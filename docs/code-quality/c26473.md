---
title: C26473
ms.date: 11/15/2017
ms.topic: conceptual
f1_keywords:
- C26473
helpviewer_keywords:
- C26473
ms.assetid: d88aaa57-0003-421f-8377-4e6a5c27f2df
ms.openlocfilehash: e1ac798e5b330ab3be122cb5a903bc6afacbe9ff
ms.sourcegitcommit: c123cc76bb2b6c5cde6f4c425ece420ac733bf70
ms.translationtype: MT
ms.contentlocale: pl-PL
ms.lasthandoff: 04/14/2020
ms.locfileid: "81320097"
---
# <a name="c26473-no_identity_cast"></a>C26473 NO_IDENTITY_CAST

"Nie rzutuj między typami wskaźnika, gdzie typ źródła i typ docelowy są takie same."

**Podstawowe wytyczne dotyczące języka C++**: Typ.1: Unikaj rzutów

Ta reguła pomaga usunąć niepotrzebne lub podejrzane rzutowania. Oczywiście, gdy typ jest konwertowany na siebie, taka konwersja jest nieskuteczna, ale fakt, że rzutowanie jest używany może wskazywać na subtelny problem projektu lub potencjał regresji, jeśli typy zmienić w przyszłości. Zawsze bezpieczniej jest używać jak najmniejszej liczby odlewów.

## <a name="remarks"></a>Uwagi

- Ta reguła jest implementowana dla rzutowania statycznego i reinterpretacji i sprawdza tylko typy wskaźników.

## <a name="example"></a>Przykład

niebezpiecznie ogólne wyszukiwanie

```cpp
gsl::span<server> servers_;

template<class T>
server* resolve_server(T tag) noexcept {
    auto p = reinterpret_cast<server*>(tag); // C26473, also 26490 NO_REINTERPRET_CAST
    return p >= &(*servers_.begin()) && p < &(*servers_.end()) ? p : nullptr;
}

void promote(server *s, int index) noexcept {
    auto s0 = resolve_server(s);
    auto s1 = resolve_server(index);
   if (s0 && s1)
        std::swap(s0, s1);
}
```

niebezpiecznie ogólne wyszukiwanie - przerobione

```cpp
// ...
server* resolve_server(server *p) noexcept {
    return p >= &(*servers_.begin()) && p < &(*servers_.end()) ? p : nullptr;
}

server* resolve_server(ptrdiff_t i) noexcept {
    return !servers_.empty() && i >= 0 && i < servers_.size() ? &servers_[i] : nullptr;
}
// ...
```

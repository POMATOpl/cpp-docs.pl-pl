---
title: C26429
ms.date: 11/15/2017
ms.topic: conceptual
f1_keywords:
- C26429
helpviewer_keywords:
- C26429
ms.assetid: 4e1c74d5-7307-436c-927b-f74ae863282c
ms.openlocfilehash: 9645ceb5b1b80365c1fcc7f59655ba4fb649a196
ms.sourcegitcommit: c123cc76bb2b6c5cde6f4c425ece420ac733bf70
ms.translationtype: MT
ms.contentlocale: pl-PL
ms.lasthandoff: 04/14/2020
ms.locfileid: "81359477"
---
# <a name="c26429-use_notnull"></a>C26429 USE_NOTNULL

"Symbol nigdy nie jest testowany pod kątem nieważności, może być oznaczony jako gsl::not_null."

**Podstawowe wytyczne języka C++**: F.23:\<Użyj> not_null T, aby wskazać, że "null" nie jest prawidłową wartością

Jest powszechną praktyką, aby użyć potwierdzeń w celu wymuszenia założeń dotyczących ważności wartości wskaźnika. Problem z potwierdzeniami polega na tym, że nie ujawniają założeń za pośrednictwem interfejsu (np. w zamian typów lub parametrów). Potwierdzenia są również trudniejsze do utrzymania i zachować synchronizację z innymi zmianami kodu. Zalecenie jest użycie gsl::not_null z biblioteki obsługi wytycznych jako znacznik zasobów, które nigdy nie powinny mieć wartość null. Reguła USE_NOTNULL pomaga zidentyfikować miejsca, które pomijają sprawdzanie wartości null i dlatego mogą być aktualizowane w celu użycia gsl::not_null.

## <a name="remarks"></a>Uwagi

- Logika reguły wymaga kodu do wyłuskinia zmiennej wskaźnika, tak aby sprawdzanie wartości null (lub wymuszanie wartości innej niż null) byłoby uzasadnione. Tak więc ostrzeżenie będzie emitowane tylko wtedy, gdy wskaźniki są wyłuskiwane i nigdy nie testowane pod kątem nullness.
  - Bieżąca implementacja obsługuje tylko zwykłe wskaźniki (lub ich aliasy) i nie wykrywa inteligentnych wskaźników, nawet jeśli gsl::not_null można również zastosować do inteligentnych wskaźników.
  - Zmienna jest oznaczona jako zaznaczona pod kątem wartości null, gdy jest używana w następujących kontekstach:
  - jako wyrażenie symbolu w warunku gałęzi, np.
  - niesąsowe operacje logiczne;
  - operacje porównania, gdzie jeden operand jest wyrażeniem stałym, które ocenia do zera.
  - Reguła nie ma pełnego śledzenia przepływu danych i może powodować nieprawidłowe wyniki w przypadkach, gdy używane są kontrole pośrednie (np. gdy zmienna pośrednia zawiera wartość null, a później używana w porównaniu).

## <a name="example"></a>Przykład

ukryte oczekiwanie

```cpp
using client_collection = gsl::span<client*>;
// ...
void keep_alive(const connection *connection)   // C26429
{
    const client_collection clients = connection->get_clients();
    for (ptrdiff_t i = 0; i < clients.size(); i++)
    {
        auto client = clients[i];               // C26429
        client->send_heartbeat();
        // ...
    }
}
```

ukryte oczekiwania – wyjaśnione przez gsl::not_null

```cpp
using client_collection = gsl::span<gsl::not_null<client*>>;
// ...
void keep_alive(gsl::not_null<const connection*> connection)
{
    const client_collection clients = connection->get_clients();
    for (ptrdiff_t i = 0; i < clients.size(); i++)
    {
        auto client = clients[i];
        client->send_heartbeat();
        // ...
    }
}
```

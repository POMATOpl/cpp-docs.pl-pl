---
title: C26441
ms.date: 11/15/2017
ms.topic: conceptual
f1_keywords:
- C26441
helpviewer_keywords:
- C26441
ms.assetid: f923c422-ed01-4644-b40b-93f15fc5bb93
ms.openlocfilehash: 0e6d609ee8b24f40aa06250515f5e60d088a2289
ms.sourcegitcommit: c123cc76bb2b6c5cde6f4c425ece420ac733bf70
ms.translationtype: MT
ms.contentlocale: pl-PL
ms.lasthandoff: 04/14/2020
ms.locfileid: "81369883"
---
# <a name="c26441-no_unnamed_guards"></a>C26441 NO_UNNAMED_GUARDS

"Obiekty straży muszą mieć nazwę."

**Podstawowe wytyczne dotyczące języka C++**: CP.44: Pamiętaj, aby nazwać swoje lock_guards i unique_locks

Standardowa biblioteka zawiera kilka przydatnych klas, które pomagają kontrolować równoczesny dostęp do zasobów. Obiekty tego typu blokują wyłączny dostęp na czas ich istnienia. Oznacza to, że każdy obiekt blokady musi być nazwany, czyli mają jasno zdefiniowany okres istnienia, który obejmuje okres, w którym operacje dostępu są wykonywane. Tak, nie można przypisać obiekt blokady do zmiennej jest błędem, który jest skutecznie wyłącza mechanizm blokowania (ponieważ zmienne tymczasowe są przejściowe). Ta reguła próbuje złapać proste przypadki takiego niezamierzone zachowanie.

## <a name="remarks"></a>Uwagi

- Śledzone są tylko standardowe typy blokad: std::scoped_lock, std::unique_lock i std::lock_quard.
  - Analizowane są tylko proste wywołania konstruktorów. Bardziej złożone wyrażenie inicjatora może prowadzić do niedokładnych wyników, ale jest to dość nietypowy scenariusz.
  - Blokady przekazywane jako argumenty do wywołań funkcji lub zwracane jako wyniki wywołań funkcji są ignorowane.
  - Blokady utworzone jako tymczasowe, ale przypisane do nazwanych odwołań w celu przedłużenia ich okresu istnienia są ignorowane.

## <a name="example"></a>Przykład

brak zmiennej o zakresie

```cpp
void print_diagnostic(gsl::string_span<> text)
{
    auto stream = get_diagnostic_stream();
    if (stream)
    {
        std::lock_guard<std::mutex>{ diagnostic_mutex_ }; // C26441
        write_line(stream, text);
        // ...
    }
}
```

brak zmiennej o zakresie - poprawiona

```cpp
void print_diagnostic(gsl::string_span<> text)
{
    auto stream = get_diagnostic_stream();
    if (stream)
    {
        std::lock_guard<std::mutex> lock{ diagnostic_mutex_ };
        write_line(stream, text);
        // ...
    }
}
```

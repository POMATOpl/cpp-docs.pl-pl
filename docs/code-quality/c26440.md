---
title: C26440
ms.date: 11/15/2017
ms.topic: conceptual
f1_keywords:
- C26440
helpviewer_keywords:
- C26440
ms.assetid: b6d2b188-35cc-4de2-878c-6f97d5a2444a
ms.openlocfilehash: d28431087b2b01c65f6dce18d21aa5cc72c8a898
ms.sourcegitcommit: c123cc76bb2b6c5cde6f4c425ece420ac733bf70
ms.translationtype: MT
ms.contentlocale: pl-PL
ms.lasthandoff: 04/14/2020
ms.locfileid: "81353796"
---
# <a name="c26440-declare_noexcept"></a>C26440 DECLARE_NOEXCEPT

"Funkcja może być zadeklarowana 'noexcept'."

**C++ Podstawowe wytyczne:** F.6: Jeśli funkcja nie może rzucić, zadeklarować go noexcept

Jeśli kod nie ma powodować żadnych wyjątków, powinny być oznaczone jako takie przy użyciu specyfikatora "noexcept". Pomogłoby to uprościć obsługę błędów po stronie kodu klienta, a także włączyć kompilator do wykonywania dodatkowych optymalizacji.

## <a name="remarks"></a>Uwagi

- Funkcja jest uważana za nierzucającą, jeśli:
  - nie ma żadnych jawnych instrukcji throw;
  - funkcja wywołuje w jego treści, jeśli istnieje, wywołać tylko funkcje, które mało prawdopodobne, aby zgłosić: constexpr lub funkcje oznaczone ze specyfikacją wyjątku, który pociąga za sobą zachowanie niezgłaszawania (obejmuje to niektóre niestandardowe specyfikacje).
- Niestandardowe i przestarzałe specyfikatory, takie jak throw() lub declspec(nothrow) nie są równoważne z "noexcept".
- Jawne specyfikatory noexcept(false) i noexcept(true) są odpowiednio przestrzegane.
- Funkcje oznaczone jako constexpr nie powinny powodować wyjątki i nie są analizowane.
- Reguła ma również zastosowanie do wyrażeń lambda.
- Logika nie uwzględnia wywołań cyklicznych jako potencjalnie nierzucając. Może się to zmienić w przyszłości.

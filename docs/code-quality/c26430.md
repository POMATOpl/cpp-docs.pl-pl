---
title: C26430
ms.date: 11/15/2017
ms.topic: conceptual
f1_keywords:
- C26430
helpviewer_keywords:
- C26430
ms.assetid: 3dca2626-8102-4eed-8ff3-73eb3d5c328c
ms.openlocfilehash: 73f69b54d7f4635be6fb67099b2864ea3882eb24
ms.sourcegitcommit: c123cc76bb2b6c5cde6f4c425ece420ac733bf70
ms.translationtype: MT
ms.contentlocale: pl-PL
ms.lasthandoff: 04/14/2020
ms.locfileid: "81316903"
---
# <a name="c26430-test_on_all_paths"></a>C26430 TEST_ON_ALL_PATHS

"Symbol nie jest testowany pod kątem nieważności na wszystkich ścieżkach."

**Podstawowe wytyczne języka C++**: F.23:\<Użyj> not_null T, aby wskazać, że "null" nie jest prawidłową wartością

Jeśli kod kiedykolwiek sprawdza nullness zmiennych wskaźnika należy to zrobić konsekwentnie i sprawdź poprawność wskaźników na wszystkich ścieżkach. Czasami zbyt agresywne sprawdzanie nieważności jest jeszcze lepsze niż możliwość ciężkiej awarii w jednej ze skomplikowanych gałęzi. W idealnym przypadku taki kod powinien być refaktoryzowany jako mniej złożony (przez dzielenie na wiele funkcji) i polegać na znacznikach, takich jak gsl::not_null (zobacz Guidelines Support Library), aby wyizolować części algorytmu, które mogą bezpiecznie zakładać prawidłowe wartości wskaźnika. Reguła TEST_ON_ALL_PATHS pomaga znaleźć miejsca, w których sprawdzanie nieważności są niespójne (dlatego założenia mogą wymagać przeglądu) lub rzeczywiste błędy, w których potencjalna wartość null może pominąć sprawdzanie wartości null w niektórych ścieżkach kodu.

## <a name="remarks"></a>Uwagi

- Ta reguła oczekuje, że kod wyłuska zmienną wskaźnika, tak aby sprawdzanie nullness (lub wymuszanie wartości innej niż null) byłoby uzasadnione. Jeśli nie ma wyłuskania, reguła jest zawieszona.
  - Bieżąca implementacja obsługuje tylko zwykłe wskaźniki (lub ich aliasy) i nie wykrywa inteligentnych wskaźników, nawet jeśli sprawdzanie wartości nullności ma zastosowanie również do inteligentnych wskaźników.
  - Zmienna jest oznaczona jako zaznaczona pod kątem wartości null, gdy jest używana w następujących kontekstach:
  - jako wyrażenie symbolu w warunku gałęzi, np.
  - niesąsowe operacje logiczne;
  - operacje porównania, gdzie jeden operand jest wyrażeniem stałym, które ocenia do zera.
  - Reguła nie ma pełnego śledzenia przepływu danych i może powodować nieprawidłowe wyniki w przypadkach, gdy używane są kontrole pośrednie (np. gdy zmienna pośrednia zawiera wartość null, a później używana w porównaniu).
  - Niejawne sprawdzanie wartości nullness są przyjmowane, gdy wartość wskaźnika jest przypisana z:
  - alokacji wykonywanej z operatorem rzucającym nowością;
  - wskaźnik uzyskany z typu oznaczonego gsl::not_null.

## <a name="example"></a>Przykład

niespójne testy ujawniają błąd logiczny

```cpp
void merge_states(const state *left, const state *right) // C26430
{
    if (*left && *right)
        converge(left, right);
    else
    {
        // ...
        if (!left && !right)                            // Logic error!
            discard(left, right);
    }
}
```

niespójne testy ujawniają błąd logiczny - poprawiony

```cpp
void merge_states(gsl::not_null<const state *> left, gsl::not_null<const state *> right)
{
    if (*left && *right)
        converge(left, right);
    else
    {
        // ...
        if (*left && *right)
            discard(left, right);
    }
}
```

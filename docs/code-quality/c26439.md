---
title: C26439
ms.date: 11/15/2017
ms.topic: conceptual
f1_keywords:
- C26439
helpviewer_keywords:
- C26439
ms.assetid: 9df2a1b0-ea94-4884-9d28-c1522ec33a1b
ms.openlocfilehash: 79d325397f98b5cca5a5f434bb4a8ef505c6d787
ms.sourcegitcommit: c123cc76bb2b6c5cde6f4c425ece420ac733bf70
ms.translationtype: MT
ms.contentlocale: pl-PL
ms.lasthandoff: 04/14/2020
ms.locfileid: "81369526"
---
# <a name="c26439-special_noexcept"></a>C26439 SPECIAL_NOEXCEPT

"Tego rodzaju funkcja nie może rzucać. Oznajmij to "noexcept".

**C++ Podstawowe wytyczne:** F.6: Jeśli funkcja nie może rzucić, zadeklarować go noexcept

Niektóre rodzaje operacji nigdy nie powinny powodować wyjątków. Ich implementacje powinny być wiarygodne i powinny obsługiwać możliwe błędy warunki bezpiecznie. Nigdy nie należy używać wyjątków, aby wskazać błąd. Ta reguła oznacza przypadki, w których takie operacje nie są wyraźnie oznaczone jako "noexcept", co oznacza, że mogą zgłaszać wyjątki i nie mogą przekazać założeń dotyczących ich niezawodności.

## <a name="remarks"></a>Uwagi

- Specjalne rodzaje operacji są następujące:
  - destruktory;
  - konstruktory domyślne;
  - przenosić konstruktory i przenosić operatory przydziałów;
  - standardowe funkcje z semantyką przenoszenia: std::move i std::swap.
- Niestandardowe i przestarzałe specyfikatory, takie jak throw() lub declspec(nothrow) nie są równoważne z "noexcept".
- Jawne specyfikatory noexcept(false) i noexcept(true) są odpowiednio przestrzegane.
- Ostrzeżenie może nadal pojawiać się dla operacji, które są oznaczone jako constexpr. Może się to zmienić w przyszłych wersjach.

---
title: Klasa przechwytywania
ms.date: 11/19/2018
f1_keywords:
- CDC
- AFXWIN/CDC
- AFXWIN/CDC::CDC
- AFXWIN/CDC::AbortDoc
- AFXWIN/CDC::AbortPath
- AFXWIN/CDC::AddMetaFileComment
- AFXWIN/CDC::AlphaBlend
- AFXWIN/CDC::AngleArc
- AFXWIN/CDC::Arc
- AFXWIN/CDC::ArcTo
- AFXWIN/CDC::Attach
- AFXWIN/CDC::BeginPath
- AFXWIN/CDC::BitBlt
- AFXWIN/CDC::Chord
- AFXWIN/CDC::CloseFigure
- AFXWIN/CDC::CreateCompatibleDC
- AFXWIN/CDC::CreateDC
- AFXWIN/CDC::CreateIC
- AFXWIN/CDC::DeleteDC
- AFXWIN/CDC::DeleteTempMap
- AFXWIN/CDC::Detach
- AFXWIN/CDC::DPtoHIMETRIC
- AFXWIN/CDC::DPtoLP
- AFXWIN/CDC::Draw3dRect
- AFXWIN/CDC::DrawDragRect
- AFXWIN/CDC::DrawEdge
- AFXWIN/CDC::DrawEscape
- AFXWIN/CDC::DrawFocusRect
- AFXWIN/CDC::DrawFrameControl
- AFXWIN/CDC::DrawIcon
- AFXWIN/CDC::DrawState
- AFXWIN/CDC::DrawText
- AFXWIN/CDC::DrawTextEx
- AFXWIN/CDC::Ellipse
- AFXWIN/CDC::EndDoc
- AFXWIN/CDC::EndPage
- AFXWIN/CDC::EndPath
- AFXWIN/CDC::EnumObjects
- AFXWIN/CDC::Escape
- AFXWIN/CDC::ExcludeClipRect
- AFXWIN/CDC::ExcludeUpdateRgn
- AFXWIN/CDC::ExtFloodFill
- AFXWIN/CDC::ExtTextOut
- AFXWIN/CDC::FillPath
- AFXWIN/CDC::FillRect
- AFXWIN/CDC::FillRgn
- AFXWIN/CDC::FillSolidRect
- AFXWIN/CDC::FlattenPath
- AFXWIN/CDC::FloodFill
- AFXWIN/CDC::FrameRect
- AFXWIN/CDC::FrameRgn
- AFXWIN/CDC::FromHandle
- AFXWIN/CDC::GetArcDirection
- AFXWIN/CDC::GetAspectRatioFilter
- AFXWIN/CDC::GetBkColor
- AFXWIN/CDC::GetBkMode
- AFXWIN/CDC::GetBoundsRect
- AFXWIN/CDC::GetBrushOrg
- AFXWIN/CDC::GetCharABCWidths
- AFXWIN/CDC::GetCharABCWidthsI
- AFXWIN/CDC::GetCharacterPlacement
- AFXWIN/CDC::GetCharWidth
- AFXWIN/CDC::GetCharWidthI
- AFXWIN/CDC::GetClipBox
- AFXWIN/CDC::GetColorAdjustment
- AFXWIN/CDC::GetCurrentBitmap
- AFXWIN/CDC::GetCurrentBrush
- AFXWIN/CDC::GetCurrentFont
- AFXWIN/CDC::GetCurrentPalette
- AFXWIN/CDC::GetCurrentPen
- AFXWIN/CDC::GetCurrentPosition
- AFXWIN/CDC::GetDCBrushColor
- AFXWIN/CDC::GetDCPenColor
- AFXWIN/CDC::GetDeviceCaps
- AFXWIN/CDC::GetFontData
- AFXWIN/CDC::GetFontLanguageInfo
- AFXWIN/CDC::GetGlyphOutline
- AFXWIN/CDC::GetGraphicsMode
- AFXWIN/CDC::GetHalftoneBrush
- AFXWIN/CDC::GetKerningPairs
- AFXWIN/CDC::GetLayout
- AFXWIN/CDC::GetMapMode
- AFXWIN/CDC::GetMiterLimit
- AFXWIN/CDC::GetNearestColor
- AFXWIN/CDC::GetOutlineTextMetrics
- AFXWIN/CDC::GetOutputCharWidth
- AFXWIN/CDC::GetOutputTabbedTextExtent
- AFXWIN/CDC::GetOutputTextExtent
- AFXWIN/CDC::GetOutputTextMetrics
- AFXWIN/CDC::GetPath
- AFXWIN/CDC::GetPixel
- AFXWIN/CDC::GetPolyFillMode
- AFXWIN/CDC::GetROP2
- AFXWIN/CDC::GetSafeHdc
- AFXWIN/CDC::GetStretchBltMode
- AFXWIN/CDC::GetTabbedTextExtent
- AFXWIN/CDC::GetTextAlign
- AFXWIN/CDC::GetTextCharacterExtra
- AFXWIN/CDC::GetTextColor
- AFXWIN/CDC::GetTextExtent
- AFXWIN/CDC::GetTextExtentExPointI
- AFXWIN/CDC::GetTextExtentPointI
- AFXWIN/CDC::GetTextFace
- AFXWIN/CDC::GetTextMetrics
- AFXWIN/CDC::GetViewportExt
- AFXWIN/CDC::GetViewportOrg
- AFXWIN/CDC::GetWindow
- AFXWIN/CDC::GetWindowExt
- AFXWIN/CDC::GetWindowOrg
- AFXWIN/CDC::GetWorldTransform
- AFXWIN/CDC::GradientFill
- AFXWIN/CDC::GrayString
- AFXWIN/CDC::HIMETRICtoDP
- AFXWIN/CDC::HIMETRICtoLP
- AFXWIN/CDC::IntersectClipRect
- AFXWIN/CDC::InvertRect
- AFXWIN/CDC::InvertRgn
- AFXWIN/CDC::IsPrinting
- AFXWIN/CDC::LineTo
- AFXWIN/CDC::LPtoDP
- AFXWIN/CDC::LPtoHIMETRIC
- AFXWIN/CDC::MaskBlt
- AFXWIN/CDC::ModifyWorldTransform
- AFXWIN/CDC::MoveTo
- AFXWIN/CDC::OffsetClipRgn
- AFXWIN/CDC::OffsetViewportOrg
- AFXWIN/CDC::OffsetWindowOrg
- AFXWIN/CDC::PaintRgn
- AFXWIN/CDC::PatBlt
- AFXWIN/CDC::Pie
- AFXWIN/CDC::PlayMetaFile
- AFXWIN/CDC::PlgBlt
- AFXWIN/CDC::PolyBezier
- AFXWIN/CDC::PolyBezierTo
- AFXWIN/CDC::PolyDraw
- AFXWIN/CDC::Polygon
- AFXWIN/CDC::Polyline
- AFXWIN/CDC::PolylineTo
- AFXWIN/CDC::PolyPolygon
- AFXWIN/CDC::PolyPolyline
- AFXWIN/CDC::PtVisible
- AFXWIN/CDC::RealizePalette
- AFXWIN/CDC::Rectangle
- AFXWIN/CDC::RectVisible
- AFXWIN/CDC::ReleaseAttribDC
- AFXWIN/CDC::ReleaseOutputDC
- AFXWIN/CDC::ResetDC
- AFXWIN/CDC::RestoreDC
- AFXWIN/CDC::RoundRect
- AFXWIN/CDC::SaveDC
- AFXWIN/CDC::ScaleViewportExt
- AFXWIN/CDC::ScaleWindowExt
- AFXWIN/CDC::ScrollDC
- AFXWIN/CDC::SelectClipPath
- AFXWIN/CDC::SelectClipRgn
- AFXWIN/CDC::SelectObject
- AFXWIN/CDC::SelectPalette
- AFXWIN/CDC::SelectStockObject
- AFXWIN/CDC::SetAbortProc
- AFXWIN/CDC::SetArcDirection
- AFXWIN/CDC::SetAttribDC
- AFXWIN/CDC::SetBkColor
- AFXWIN/CDC::SetBkMode
- AFXWIN/CDC::SetBoundsRect
- AFXWIN/CDC::SetBrushOrg
- AFXWIN/CDC::SetColorAdjustment
- AFXWIN/CDC::SetDCBrushColor
- AFXWIN/CDC::SetDCPenColor
- AFXWIN/CDC::SetGraphicsMode
- AFXWIN/CDC::SetLayout
- AFXWIN/CDC::SetMapMode
- AFXWIN/CDC::SetMapperFlags
- AFXWIN/CDC::SetMiterLimit
- AFXWIN/CDC::SetOutputDC
- AFXWIN/CDC::SetPixel
- AFXWIN/CDC::SetPixelV
- AFXWIN/CDC::SetPolyFillMode
- AFXWIN/CDC::SetROP2
- AFXWIN/CDC::SetStretchBltMode
- AFXWIN/CDC::SetTextAlign
- AFXWIN/CDC::SetTextCharacterExtra
- AFXWIN/CDC::SetTextColor
- AFXWIN/CDC::SetTextJustification
- AFXWIN/CDC::SetViewportExt
- AFXWIN/CDC::SetViewportOrg
- AFXWIN/CDC::SetWindowExt
- AFXWIN/CDC::SetWindowOrg
- AFXWIN/CDC::SetWorldTransform
- AFXWIN/CDC::StartDoc
- AFXWIN/CDC::StartPage
- AFXWIN/CDC::StretchBlt
- AFXWIN/CDC::StrokeAndFillPath
- AFXWIN/CDC::StrokePath
- AFXWIN/CDC::TabbedTextOut
- AFXWIN/CDC::TextOut
- AFXWIN/CDC::TransparentBlt
- AFXWIN/CDC::UpdateColors
- AFXWIN/CDC::WidenPath
- AFXWIN/CDC::m_hAttribDC
- AFXWIN/CDC::m_hDC
helpviewer_keywords:
- CDC [MFC], CDC
- CDC [MFC], AbortDoc
- CDC [MFC], AbortPath
- CDC [MFC], AddMetaFileComment
- CDC [MFC], AlphaBlend
- CDC [MFC], AngleArc
- CDC [MFC], Arc
- CDC [MFC], ArcTo
- CDC [MFC], Attach
- CDC [MFC], BeginPath
- CDC [MFC], BitBlt
- CDC [MFC], Chord
- CDC [MFC], CloseFigure
- CDC [MFC], CreateCompatibleDC
- CDC [MFC], CreateDC
- CDC [MFC], CreateIC
- CDC [MFC], DeleteDC
- CDC [MFC], DeleteTempMap
- CDC [MFC], Detach
- CDC [MFC], DPtoHIMETRIC
- CDC [MFC], DPtoLP
- CDC [MFC], Draw3dRect
- CDC [MFC], DrawDragRect
- CDC [MFC], DrawEdge
- CDC [MFC], DrawEscape
- CDC [MFC], DrawFocusRect
- CDC [MFC], DrawFrameControl
- CDC [MFC], DrawIcon
- CDC [MFC], DrawState
- CDC [MFC], DrawText
- CDC [MFC], DrawTextEx
- CDC [MFC], Ellipse
- CDC [MFC], EndDoc
- CDC [MFC], EndPage
- CDC [MFC], EndPath
- CDC [MFC], EnumObjects
- CDC [MFC], Escape
- CDC [MFC], ExcludeClipRect
- CDC [MFC], ExcludeUpdateRgn
- CDC [MFC], ExtFloodFill
- CDC [MFC], ExtTextOut
- CDC [MFC], FillPath
- CDC [MFC], FillRect
- CDC [MFC], FillRgn
- CDC [MFC], FillSolidRect
- CDC [MFC], FlattenPath
- CDC [MFC], FloodFill
- CDC [MFC], FrameRect
- CDC [MFC], FrameRgn
- CDC [MFC], FromHandle
- CDC [MFC], GetArcDirection
- CDC [MFC], GetAspectRatioFilter
- CDC [MFC], GetBkColor
- CDC [MFC], GetBkMode
- CDC [MFC], GetBoundsRect
- CDC [MFC], GetBrushOrg
- CDC [MFC], GetCharABCWidths
- CDC [MFC], GetCharABCWidthsI
- CDC [MFC], GetCharacterPlacement
- CDC [MFC], GetCharWidth
- CDC [MFC], GetCharWidthI
- CDC [MFC], GetClipBox
- CDC [MFC], GetColorAdjustment
- CDC [MFC], GetCurrentBitmap
- CDC [MFC], GetCurrentBrush
- CDC [MFC], GetCurrentFont
- CDC [MFC], GetCurrentPalette
- CDC [MFC], GetCurrentPen
- CDC [MFC], GetCurrentPosition
- CDC [MFC], GetDCBrushColor
- CDC [MFC], GetDCPenColor
- CDC [MFC], GetDeviceCaps
- CDC [MFC], GetFontData
- CDC [MFC], GetFontLanguageInfo
- CDC [MFC], GetGlyphOutline
- CDC [MFC], GetGraphicsMode
- CDC [MFC], GetHalftoneBrush
- CDC [MFC], GetKerningPairs
- CDC [MFC], GetLayout
- CDC [MFC], GetMapMode
- CDC [MFC], GetMiterLimit
- CDC [MFC], GetNearestColor
- CDC [MFC], GetOutlineTextMetrics
- CDC [MFC], GetOutputCharWidth
- CDC [MFC], GetOutputTabbedTextExtent
- CDC [MFC], GetOutputTextExtent
- CDC [MFC], GetOutputTextMetrics
- CDC [MFC], GetPath
- CDC [MFC], GetPixel
- CDC [MFC], GetPolyFillMode
- CDC [MFC], GetROP2
- CDC [MFC], GetSafeHdc
- CDC [MFC], GetStretchBltMode
- CDC [MFC], GetTabbedTextExtent
- CDC [MFC], GetTextAlign
- CDC [MFC], GetTextCharacterExtra
- CDC [MFC], GetTextColor
- CDC [MFC], GetTextExtent
- CDC [MFC], GetTextExtentExPointI
- CDC [MFC], GetTextExtentPointI
- CDC [MFC], GetTextFace
- CDC [MFC], GetTextMetrics
- CDC [MFC], GetViewportExt
- CDC [MFC], GetViewportOrg
- CDC [MFC], GetWindow
- CDC [MFC], GetWindowExt
- CDC [MFC], GetWindowOrg
- CDC [MFC], GetWorldTransform
- CDC [MFC], GradientFill
- CDC [MFC], GrayString
- CDC [MFC], HIMETRICtoDP
- CDC [MFC], HIMETRICtoLP
- CDC [MFC], IntersectClipRect
- CDC [MFC], InvertRect
- CDC [MFC], InvertRgn
- CDC [MFC], IsPrinting
- CDC [MFC], LineTo
- CDC [MFC], LPtoDP
- CDC [MFC], LPtoHIMETRIC
- CDC [MFC], MaskBlt
- CDC [MFC], ModifyWorldTransform
- CDC [MFC], MoveTo
- CDC [MFC], OffsetClipRgn
- CDC [MFC], OffsetViewportOrg
- CDC [MFC], OffsetWindowOrg
- CDC [MFC], PaintRgn
- CDC [MFC], PatBlt
- CDC [MFC], Pie
- CDC [MFC], PlayMetaFile
- CDC [MFC], PlgBlt
- CDC [MFC], PolyBezier
- CDC [MFC], PolyBezierTo
- CDC [MFC], PolyDraw
- CDC [MFC], Polygon
- CDC [MFC], Polyline
- CDC [MFC], PolylineTo
- CDC [MFC], PolyPolygon
- CDC [MFC], PolyPolyline
- CDC [MFC], PtVisible
- CDC [MFC], RealizePalette
- CDC [MFC], Rectangle
- CDC [MFC], RectVisible
- CDC [MFC], ReleaseAttribDC
- CDC [MFC], ReleaseOutputDC
- CDC [MFC], ResetDC
- CDC [MFC], RestoreDC
- CDC [MFC], RoundRect
- CDC [MFC], SaveDC
- CDC [MFC], ScaleViewportExt
- CDC [MFC], ScaleWindowExt
- CDC [MFC], ScrollDC
- CDC [MFC], SelectClipPath
- CDC [MFC], SelectClipRgn
- CDC [MFC], SelectObject
- CDC [MFC], SelectPalette
- CDC [MFC], SelectStockObject
- CDC [MFC], SetAbortProc
- CDC [MFC], SetArcDirection
- CDC [MFC], SetAttribDC
- CDC [MFC], SetBkColor
- CDC [MFC], SetBkMode
- CDC [MFC], SetBoundsRect
- CDC [MFC], SetBrushOrg
- CDC [MFC], SetColorAdjustment
- CDC [MFC], SetDCBrushColor
- CDC [MFC], SetDCPenColor
- CDC [MFC], SetGraphicsMode
- CDC [MFC], SetLayout
- CDC [MFC], SetMapMode
- CDC [MFC], SetMapperFlags
- CDC [MFC], SetMiterLimit
- CDC [MFC], SetOutputDC
- CDC [MFC], SetPixel
- CDC [MFC], SetPixelV
- CDC [MFC], SetPolyFillMode
- CDC [MFC], SetROP2
- CDC [MFC], SetStretchBltMode
- CDC [MFC], SetTextAlign
- CDC [MFC], SetTextCharacterExtra
- CDC [MFC], SetTextColor
- CDC [MFC], SetTextJustification
- CDC [MFC], SetViewportExt
- CDC [MFC], SetViewportOrg
- CDC [MFC], SetWindowExt
- CDC [MFC], SetWindowOrg
- CDC [MFC], SetWorldTransform
- CDC [MFC], StartDoc
- CDC [MFC], StartPage
- CDC [MFC], StretchBlt
- CDC [MFC], StrokeAndFillPath
- CDC [MFC], StrokePath
- CDC [MFC], TabbedTextOut
- CDC [MFC], TextOut
- CDC [MFC], TransparentBlt
- CDC [MFC], UpdateColors
- CDC [MFC], WidenPath
- CDC [MFC], m_hAttribDC
- CDC [MFC], m_hDC
ms.assetid: 715b3334-cb2b-4c9c-8067-02eb7c66c8b2
ms.openlocfilehash: 432d560da0ae3459ba43faed9a50b9771b0de5d1
ms.sourcegitcommit: 1f009ab0f2cc4a177f2d1353d5a38f164612bdb1
ms.translationtype: MT
ms.contentlocale: pl-PL
ms.lasthandoff: 07/27/2020
ms.locfileid: "87212556"
---
# <a name="cdc-class"></a>Klasa przechwytywania

Definiuje klasę obiektów kontekstu urządzenia.

## <a name="syntax"></a>Składnia

```
class CDC : public CObject
```

## <a name="members"></a>Elementy członkowskie

### <a name="public-constructors"></a>Konstruktory publiczne

|Nazwa|Opis|
|----------|-----------------|
|[PRZECHWYTYWANIE ZMIAN:: PRZEPRZECHWYTYWANIE](#cdc)|Konstruuje `CDC` obiekt.|

### <a name="public-methods"></a>Metody publiczne

|Nazwa|Opis|
|----------|-----------------|
|[Przechwytywanie zmian:: AbortDoc](#abortdoc)|Kończy bieżące zadanie drukowania, Wymazuje wszystko, co aplikacja została zapisywana na urządzeniu od momentu ostatniego wywołania `StartDoc` funkcji członkowskiej.|
|[Przechwytywanie zmian:: AbortPath](#abortpath)|Zamyka i odrzuca wszystkie ścieżki w kontekście urządzenia.|
|[Przechwytywanie zmian:: AddMetaFileComment](#addmetafilecomment)|Kopiuje komentarz z buforu do określonego metapliku ulepszonego formatu.|
|[Przechwytywanie zmian:: AlphaBlend](#alphablend)|Wyświetla mapy bitowe, które mają przezroczyste lub półprzezroczyste piksele.|
|[Przechwytywanie zmian:: AngleArc](#anglearc)|Rysuje segment linii i łuk i przenosi bieżącą pozycję do punktu końcowego łuku.|
|[Przechwytywanie zmian:: Arc](#arc)|Rysuje Łuk eliptyczny.|
|[Przechwytywanie zmian:: ArcTo](#arcto)|Rysuje Łuk eliptyczny. Ta funkcja jest podobna do `Arc` , z tą różnicą, że bieżące stanowisko zostało zaktualizowane.|
|[Przechwytywanie zmian:: Attach](#attach)|Dołącza kontekst urządzenia systemu Windows do tego `CDC` obiektu.|
|[Przechwytywanie zmian:: BeginPath](#beginpath)|Otwiera nawias ścieżki w kontekście urządzenia.|
|[Przechwytywanie zmian:: BitBlt](#bitblt)|Kopiuje mapę bitową z określonego kontekstu urządzenia.|
|[Przechwytywanie zmian:: skrót](#chord)|Rysuje skrót (zamkniętą figurę powiązaną z przecięciem wielokropka i segmentu linii).|
|[Przechwytywanie zmian:: CloseFigure](#closefigure)|Zamyka otwarty rysunek w ścieżce.|
|[Przechwytywanie zmian:: CreateCompatibleDC](#createcompatibledc)|Tworzy kontekst urządzenia pamięci, który jest zgodny z innym kontekstem urządzenia. Służy do przygotowywania obrazów w pamięci.|
|[Przechwytywanie zmian:: CreateDC](#createdc)|Tworzy kontekst urządzenia dla określonego urządzenia.|
|[Przechwytywanie zmian:: Tworzenie](#createic)|Tworzy kontekst informacyjny dla określonego urządzenia. Zapewnia to szybki sposób uzyskiwania informacji o urządzeniu bez tworzenia kontekstu urządzenia.|
|[Przechwytywanie zmian::D eleteDC](#deletedc)|Usuwa kontekst urządzenia systemu Windows skojarzony z tym `CDC` obiektem.|
|[Przechwytywanie zmian::D eleteTempMap](#deletetempmap)|Wywoływane przez `CWinApp` procedurę obsługi czasu bezczynności, aby usunąć wszystkie `CDC` obiekty tymczasowe utworzone przez `FromHandle` . Powoduje także odłączenie kontekstu urządzenia.|
|[Przechwytywanie zmian::D etach](#detach)|Odłącza kontekst urządzenia Windows z tego `CDC` obiektu.|
|[Przechwytywanie zmian::D PtoHIMETRIC](#dptohimetric)|Konwertuje jednostki urządzeń na jednostki HIMETRIC.|
|[Przechwytywanie zmian::D PtoLP](#dptolp)|Konwertuje jednostki urządzeń na jednostki logiczne.|
|[Przechwytywanie zmian::D raw3dRect](#draw3drect)|Rysuje trójwymiarowy prostokąt.|
|[Przechwytywanie zmian::D rawDragRect](#drawdragrect)|Wymazuje i ponownie rysuje prostokąt w miarę przeciągania.|
|[Przechwytywanie zmian::D rawEdge](#drawedge)|Rysuje krawędzie prostokąta.|
|[Przechwytywanie zmian::D rawEscape](#drawescape)|Uzyskuje dostęp do możliwości rysowania wideo, które nie są bezpośrednio dostępne za pomocą interfejsu urządzenia graficznego (GDI).|
|[Przechwytywanie zmian::D rawFocusRect](#drawfocusrect)|Rysuje prostokąt w stylu używanym do wskazywania fokusu.|
|[Przechwytywanie zmian::D rawFrameControl](#drawframecontrol)|Narysuj kontrolkę klatkę.|
|[Przechwytywanie zmian::D rawIcon](#drawicon)|Rysuje ikonę.|
|[Przechwytywanie zmian::D rawState](#drawstate)|Wyświetla obraz i stosuje efekt wizualny, aby wskazać stan.|
|[Przechwytywanie zmian::D rawText](#drawtext)|Rysuje sformatowany tekst w określonym prostokącie.|
|[Przechwytywanie zmian::D rawTextEx](#drawtextex)|Rysuje sformatowany tekst w określonym prostokącie przy użyciu dodatkowych formatów.|
|[Reprzechwytywania:: elipsa](#ellipse)|Rysuje elipsę.|
|[Przechwytywanie zmian:: EndDoc](#enddoc)|Zamyka zadanie drukowania uruchomione przez `StartDoc` funkcję członkowską.|
|[Przechwytywanie zmian:: EndPage](#endpage)|Informuje sterownik urządzenia, że strona kończy się.|
|[Przechwytywanie zmian:: EndPath](#endpath)|Zamyka nawias ścieżki i wybiera ścieżkę zdefiniowaną przez nawias w kontekście urządzenia.|
|[Przechwytywanie zmian:: EnumObjects](#enumobjects)|Wylicza pióra i pędzle dostępne w kontekście urządzenia.|
|[Przechwytywanie zmian:: Escape](#escape)|Umożliwia aplikacjom dostęp do obiektów, które nie są bezpośrednio dostępne z określonego urządzenia za pośrednictwem interfejsu GDI. Umożliwia również dostęp do funkcji systemu Windows. Wywołania ucieczki wykonywane przez aplikację są tłumaczone i wysyłane do sterownika urządzenia.|
|[Przechwytywanie zmian:: ExcludeClipRect](#excludecliprect)|Tworzy nowy region przycinania, który składa się z istniejącego regionu wycinka minus określonego prostokąta.|
|[Przechwytywanie zmian:: ExcludeUpdateRgn](#excludeupdatergn)|Uniemożliwia Rysowanie w nieprawidłowych obszarach okna przez wykluczenie zaktualizowanego regionu w oknie z obszaru wycinka.|
|[Przechwytywanie zmian:: ExtFloodFill](#extfloodfill)|Wypełnia obszar bieżącym pędzlem. Zapewnia większą elastyczność niż funkcja elementu członkowskiego funkcji [przechwytywania:: FloodFill](#floodfill) .|
|[Przechwytywanie zmian:: ExtTextOut](#exttextout)|Zapisuje ciąg znaków w obszarze prostokątnym przy użyciu aktualnie zaznaczonej czcionki.|
|[Przechwytywanie zmian:: FillPath](#fillpath)|Zamyka wszystkie otwarte figury w bieżącej ścieżce i wypełnia wnętrze ścieżki przy użyciu bieżącego pędzla i trybu wypełniania wielokątów.|
|[Przechwytywanie zmian:: FillRect](#fillrect)|Wypełnia dany prostokąt przy użyciu określonego pędzla.|
|[Przechwytywanie zmian:: FillRgn](#fillrgn)|Wypełnia określony region określonym pędzlem.|
|[Przechwytywanie zmian:: FillSolidRect](#fillsolidrect)|Wypełnia prostokąt wypełnionym kolorem.|
|[Przechwytywanie zmian:: FlattenPath](#flattenpath)|Przekształca wszystkie krzywe w ścieżce zaznaczonej w bieżącym kontekście urządzenia i włącza każdą krzywą w sekwencji wierszy.|
|[Przechwytywanie zmian:: FloodFill](#floodfill)|Wypełnia obszar bieżącym pędzlem.|
|[Przechwytywanie zmian:: FrameRect](#framerect)|Rysuje obramowanie wokół prostokąta.|
|[Przechwytywanie zmian:: FrameRgn](#framergn)|Rysuje obramowanie wokół określonego regionu przy użyciu pędzla.|
|[Przechwytywanie zmian:: FromHandle](#fromhandle)|Zwraca wskaźnik do obiektu, `CDC` gdy ma dojść do kontekstu urządzenia. Jeśli `CDC` obiekt nie jest dołączony do dojścia, `CDC` tworzony jest obiekt tymczasowy i jest on dołączony.|
|[Przechwytywanie zmian:: GetArcDirection](#getarcdirection)|Zwraca bieżący kierunek łuku dla kontekstu urządzenia.|
|[Przechwytywanie zmian:: GetAspectRatioFilter](#getaspectratiofilter)|Pobiera ustawienie dla bieżącego filtru współczynnika proporcji.|
|[Przechwytywanie zmian:: GetBkColor](#getbkcolor)|Pobiera bieżący kolor tła.|
|[Przechwytywanie zmian:: GetBkMode](#getbkmode)|Pobiera tryb tła.|
|[Przechwytywanie zmian:: GetBoundsRect](#getboundsrect)|Zwraca bieżący, skumulowany prostokąt związany z określonym kontekstem urządzenia.|
|[Przechwytywanie zmian:: GetBrushOrg](#getbrushorg)|Pobiera źródło bieżącego pędzla.|
|[Przechwytywanie zmian:: GetCharABCWidths](#getcharabcwidths)|Pobiera szerokość (w jednostkach logicznych) kolejnych znaków w danym zakresie z bieżącej czcionki.|
|[Przechwytywanie zmian:: GetCharABCWidthsI](#getcharabcwidthsi)|Pobiera szerokość (w jednostkach logicznych) kolejnych indeksów symboli w określonym zakresie od bieżącej czcionki TrueType.|
|[Przechwytywanie zmian:: GetCharacterPlacement](#getcharacterplacement)|Pobiera różne rodzaje informacji w ciągu znaków.|
|[Przechwytywanie zmian:: GetCharWidth](#getcharwidth)|Pobiera szerokość ułamków kolejnych znaków w danym zakresie z bieżącej czcionki.|
|[Przechwytywanie zmian:: GetCharWidthI](#getcharwidthi)|Pobiera szerokość, we współrzędnych logicznych, kolejnych indeksów symboli w określonym zakresie od bieżącej czcionki.|
|[Przechwytywanie zmian:: GetClipBox](#getclipbox)|Pobiera wymiary najbliżej przyległego prostokąta wokół bieżącej granicy wycinka.|
|[Przechwytywanie zmian:: GetColorAdjustment](#getcoloradjustment)|Pobiera wartości korekty koloru dla kontekstu urządzenia.|
|[Przechwytywanie zmian:: GetCurrentBitmap](#getcurrentbitmap)|Zwraca wskaźnik do aktualnie wybranego `CBitmap` obiektu.|
|[Przechwytywanie zmian:: GetCurrentBrush](#getcurrentbrush)|Zwraca wskaźnik do aktualnie wybranego `CBrush` obiektu.|
|[Przechwytywanie zmian:: GetCurrentFont](#getcurrentfont)|Zwraca wskaźnik do aktualnie wybranego `CFont` obiektu.|
|[Przechwytywanie zmian:: GetCurrentPalette](#getcurrentpalette)|Zwraca wskaźnik do aktualnie wybranego `CPalette` obiektu.|
|[Przechwytywanie zmian:: GetCurrentPen](#getcurrentpen)|Zwraca wskaźnik do aktualnie wybranego `CPen` obiektu.|
|[Przechwytywanie zmian:: GetCurrentPosition](#getcurrentposition)|Pobiera bieżącą pozycję pióra (we współrzędnych logicznych).|
|[Przechwytywanie zmian:: GetDCBrushColor](#getdcbrushcolor)|Pobiera bieżący kolor pędzla.|
|[Przechwytywanie zmian:: GetDCPenColor](#getdcpencolor)|Pobiera bieżący kolor pióra.|
|[Przechwytywanie zmian:: GetDeviceCaps](#getdevicecaps)|Pobiera określony rodzaj informacji dotyczących urządzenia, na których dostępne są dane.|
|[Przechwytywanie zmian:: GetFontData](#getfontdata)|Pobiera informacje o metryki czcionki z skalowalnego pliku czcionek. Informacje do pobrania są identyfikowane przez określenie przesunięcia do pliku czcionki oraz długości zwracanych informacji.|
|[Przechwytywanie zmian:: GetFontLanguageInfo](#getfontlanguageinfo)|Zwraca informacje dotyczące aktualnie wybranej czcionki dla określonego kontekstu wyświetlania.|
|[Przechwytywanie zmian:: GetGlyphOutline](#getglyphoutline)|Pobiera krzywą lub mapę bitową konturu dla znaku konturu w bieżącej czcionce.|
|[Przechwytywanie zmian:: getgraphicsmode](#getgraphicsmode)|Pobiera bieżący tryb grafiki dla określonego kontekstu urządzenia.|
|[Przechwytywanie zmian:: GetHalftoneBrush](#gethalftonebrush)|Pobiera Pędzel półtonów.|
|[Przechwytywanie zmian:: GetKerningPairs](#getkerningpairs)|Pobiera pary kerningu znaków dla czcionki, która jest aktualnie wybrana w określonym kontekście urządzenia.|
|[Przechwytywanie zmian:: GetLayout](#getlayout)|Pobiera układ kontekstu urządzenia (DC). Układ może być albo od lewej do prawej (ustawienie domyślne), albo od prawej do lewej (zdublowany).|
|[Przechwytywanie zmian:: GetMapMode](#getmapmode)|Pobiera bieżący tryb mapowania.|
|[Przechwytywanie zmian:: GetMiterLimit](#getmiterlimit)|Zwraca limit ścięcia dla kontekstu urządzenia.|
|[Przechwytywanie zmian:: GetNearestColor](#getnearestcolor)|Pobiera najbliższy kolor logiczny do określonego koloru logicznego, który może być reprezentowany przez dane urządzenie.|
|[Przechwytywanie zmian:: GetOutlineTextMetrics](#getoutlinetextmetrics)|Pobiera informacje o metryki czcionki dla czcionek TrueType.|
|[Przechwytywanie zmian:: GetOutputCharWidth](#getoutputcharwidth)|Pobiera szerokości pojedynczych znaków w kolejnej grupie znaków z bieżącej czcionki przy użyciu kontekstu urządzenia wyjściowego.|
|[Przechwytywanie zmian:: GetOutputTabbedTextExtent](#getoutputtabbedtextextent)|Oblicza szerokość i wysokość ciągu znaków w kontekście urządzenia wyjściowego.|
|[Przechwytywanie zmian:: GetOutputTextExtent](#getoutputtextextent)|Oblicza szerokość i wysokość wiersza tekstu w kontekście urządzenia wyjściowego przy użyciu bieżącej czcionki, aby określić wymiary.|
|[Przechwytywanie zmian:: GetOutputTextMetrics](#getoutputtextmetrics)|Pobiera metryki dla bieżącej czcionki z kontekstu urządzenia wyjściowego.|
|[Przechwytywanie zmian:: GetPath](#getpath)|Pobiera współrzędne definiujące punkty końcowe linii i punkty kontrolne krzywych znalezionych w ścieżce zaznaczonej w kontekście urządzenia.|
|[Przechwytywanie zmian:: GetPixel](#getpixel)|Pobiera wartość RGB koloru piksela w określonym punkcie.|
|[Przechwytywanie zmian:: GetPolyFillMode](#getpolyfillmode)|Pobiera bieżący tryb wypełniania wielokątów.|
|[Przechwytywanie zmian:: GetROP2](#getrop2)|Pobiera bieżący tryb rysowania.|
|[Przechwytywanie zmian:: GetSafeHdc](#getsafehdc)|Zwraca wartość funkcji [przechwytywania:: m_hDC](#m_hdc), kontekstu urządzenia wyjściowego.|
|[Przechwytywanie zmian:: GetStretchBltMode](#getstretchbltmode)|Pobiera bieżący tryb rozciągnięcia mapy bitowej.|
|[Przechwytywanie zmian:: GetTabbedTextExtent](#gettabbedtextextent)|Oblicza szerokość i wysokość ciągu znaków w kontekście urządzenia atrybutu.|
|[Przechwytywanie zmian:: TextAlign](#gettextalign)|Pobiera flagi wyrównania tekstu.|
|[Przechwytywanie zmian:: GetTextCharacterExtra](#gettextcharacterextra)|Pobiera bieżące ustawienie wielkości odstępów między znakami.|
|[Przechwytywanie zmian:: GetTextColor](#gettextcolor)|Pobiera bieżący kolor tekstu.|
|[Przechwytywanie zmian:: GetTextExtent](#gettextextent)|Oblicza szerokość i wysokość wiersza tekstu w kontekście urządzenia atrybutów przy użyciu bieżącej czcionki, aby określić wymiary.|
|[Przechwytywanie zmian:: GetTextExtentExPointI](#gettextextentexpointi)|Pobiera liczbę znaków w określonym ciągu, które mieszczą się w określonym miejscu i wypełnia tablicę w zakresie tekstu dla każdego z tych znaków.|
|[Przechwytywanie zmian:: GetTextExtentPointI](#gettextextentpointi)|Pobiera szerokość i wysokość określonej tablicy indeksów symboli.|
|[Przechwytywanie zmian:: GetTextFace](#gettextface)|Kopiuje nazwę kroju bieżącej czcionki do bufora jako ciąg zakończony znakiem null.|
|[Przechwytywanie zmian:: GetTextMetrics](#gettextmetrics)|Pobiera metryki dla bieżącej czcionki z kontekstu atrybutów urządzenia.|
|[Przechwytywanie zmian:: GetViewportExt](#getviewportext)|Pobiera zakresy x i y okienka ekranu.|
|[Przechwytywanie zmian:: GetViewportOrg](#getviewportorg)|Pobiera współrzędne x i y źródła okienka ekranu.|
|[Przechwytywanie zmian:: GetWindow](#getwindow)|Zwraca okno skojarzone z kontekstem wyświetlania urządzenia.|
|[Przechwytywanie zmian:: GetWindowExt](#getwindowext)|Pobiera zakresy x i y skojarzonego okna.|
|[Przechwytywanie zmian:: GetWindowOrg](#getwindoworg)|Pobiera współrzędne x i y pochodzenia skojarzonego okna.|
|[Przechwytywanie zmian:: GetWorldTransform](#getworldtransform)|Pobiera bieżące miejsce na przekształcenie obszaru strony.|
|[Przechwytywanie zmian:: GradientFill](#gradientfill)|Wypełnia struktury prostokątne i trójkąty przy użyciu koloru gradating.|
|[Przechwytywanie zmian:: GrayString](#graystring)|Rysuje wygaszone (wyszarzone) tekst w danej lokalizacji.|
|[Przechwytywanie zmian:: HIMETRICtoDP](#himetrictodp)|Konwertuje jednostki HIMETRIC na jednostki urządzeń.|
|[Przechwytywanie zmian:: HIMETRICtoLP](#himetrictolp)|Konwertuje jednostki HIMETRIC na jednostki logiczne.|
|[Przechwytywanie zmian:: IntersectClipRect](#intersectcliprect)|Tworzy nowy region przycinania, tworząc przecięcie bieżącego regionu i prostokąta.|
|[Przechwytywanie zmian:: InvertRect](#invertrect)|Odwraca zawartość prostokąta.|
|[Przechwytywanie zmian:: InvertRgn](#invertrgn)|Odwraca kolory w regionie.|
|[Przechwytywanie zmian:: IsPrinting](#isprinting)|Określa, czy kontekst urządzenia jest używany do drukowania.|
|[Przechwytywanie zmian:: LineTo](#lineto)|Rysuje linię od bieżącego położenia do, ale nie do punktu.|
|[Przechwytywanie zmian:: LPtoDP](#lptodp)|Konwertuje jednostki logiczne na jednostki urządzeń.|
|[Przechwytywanie zmian:: LPtoHIMETRIC](#lptohimetric)|Konwertuje jednostki logiczne na jednostki HIMETRIC.|
|[Przechwytywanie zmian:: MaskBlt](#maskblt)|Łączy dane koloru dla źródłowej i docelowej mapy bitowej przy użyciu danej maski i operacji rastrowej.|
|[Przechwytywanie zmian:: ModifyWorldTransform](#modifyworldtransform)|Zmienia światową transformację dla kontekstu urządzenia przy użyciu określonego trybu.|
|[Przechwytywanie zmian:: MoveTo](#moveto)|Przenosi bieżące położenie.|
|[Przechwytywanie zmian:: OffsetClipRgn](#offsetcliprgn)|Przenosi region przycinania danego urządzenia.|
|[Przechwytywanie zmian:: OffsetViewportOrg](#offsetviewportorg)|Modyfikuje początek okienka ekranu względem współrzędnych bieżącego źródła okienka ekranu.|
|[Przechwytywanie zmian:: OffsetWindowOrg](#offsetwindoworg)|Modyfikuje pochodzenie okna względem współrzędnych bieżącego źródła okna.|
|[Przechwytywanie zmian::P aintRgn](#paintrgn)|Wypełnia region wybranym pędzlem.|
|[Przechwytywanie zmian::P atBlt](#patblt)|Tworzy wzorzec bitowy.|
|[Przechwytywanie zmian::P IE](#pie)|Rysuje klin w kształcie koła.|
|[Przechwytywanie zmian::P layMetaFile](#playmetafile)|Odtwarza zawartość określonego metapliku na danym urządzeniu. Wersja rozszerzona programu `PlayMetaFile` wyświetla zdjęcie przechowywane w danym metapliku ulepszonego formatu. Metaplik może być odtwarzany dowolną liczbę razy.|
|[Przechwytywanie zmian::P lgBlt](#plgblt)|Wykonuje bit bloku bitowego transferu bitów danych koloru z określonego prostokąta w kontekście urządzenia źródłowego do określonego równoległobok w danym kontekście urządzenia.|
|[Przechwytywanie zmian::P olyBezier](#polybezier)|Rysuje co najmniej jedną krzywą Bzier. Bieżąca pozycja nie jest używana ani aktualizowana.|
|[Przechwytywanie zmian::P olyBezierTo](#polybezierto)|Rysuje co najmniej jedną krzywą Bzier i przenosi bieżącą pozycję do punktu końcowego ostatniej krzywej łamanej Bzier.|
|[Przechwytywanie zmian::P olyDraw](#polydraw)|Rysuje zestaw segmentów linii i krzywych Bzier. Ta funkcja aktualizuje bieżące położenie.|
|[Przechwytywanie zmian::P olygon](#polygon)|Rysuje Wielokąt składający się z dwóch lub więcej punktów (wierzchołków) połączonych przez wiersze.|
|[Przechwytywanie zmian::P olyline](#polyline)|Rysuje zestaw segmentów linii łączących określone punkty.|
|[Przechwytywanie zmian::P olylineTo](#polylineto)|Rysuje jeden lub więcej linii prostych i przenosi bieżącą pozycję do punktu końcowego ostatniego wiersza.|
|[Przechwytywanie zmian::P olyPolygon](#polypolygon)|Tworzy dwa lub więcej wielokątów, które są wypełniane przy użyciu bieżącego trybu wypełniania wielokątów. Wielokąty mogą być rozłączane lub mogą się nakładać.|
|[Przechwytywanie zmian::P olyPolyline](#polypolyline)|Rysuje wiele serii połączonych segmentów linii. Bieżąca pozycja nie jest używana ani aktualizowana przez tę funkcję.|
|[Przechwytywanie zmian::P tVisible](#ptvisible)|Określa, czy dany punkt znajduje się w obszarze przycinania.|
|[Przechwytywanie zmian:: RealizePalette](#realizepalette)|Mapuje wpisy palety w bieżącej palecie logicznej na paletę systemową.|
|[Reprzechwytywania:: Rectangle](#rectangle)|Rysuje prostokąt przy użyciu bieżącego pióra i wypełnia go przy użyciu bieżącego pędzla.|
|[Przechwytywanie zmian:: RectVisible](#rectvisible)|Określa, czy jakakolwiek część danego prostokąta leży w obszarze przycinania.|
|[Przechwytywanie zmian:: ReleaseAttribDC](#releaseattribdc)|Wersje `m_hAttribDC` , kontekst urządzenia atrybutu.|
|[Przechwytywanie zmian:: ReleaseOutputDC](#releaseoutputdc)|Wersje `m_hDC` , kontekst urządzenia wyjściowego.|
|[Przechwytywanie zmian:: ResetDC](#resetdc)|Aktualizuje `m_hAttribDC` kontekst urządzenia.|
|[Przechwytywanie zmian:: RestoreDC](#restoredc)|Przywraca kontekst urządzenia do poprzedniego stanu zapisanego za pomocą `SaveDC` .|
|[Przechwytywanie zmian:: RoundRect](#roundrect)|Rysuje prostokąt z zaokrąglonymi rogami przy użyciu bieżącego pióra i wypełniany przy użyciu bieżącego pędzla.|
|[Przechwytywanie zmian:: SaveDC](#savedc)|Zapisuje bieżący stan kontekstu urządzenia.|
|[Przechwytywanie zmian:: ScaleViewportExt](#scaleviewportext)|Modyfikuje zakres okienka ekranu względem bieżących wartości.|
|[Przechwytywanie zmian:: ScaleWindowExt](#scalewindowext)|Modyfikuje zakresy okna względem bieżących wartości.|
|[Przechwytywanie zmian:: ScrollDC](#scrolldc)|Przewija prostokąt w poziomie i w pionie.|
|[Przechwytywanie zmian:: SelectClipPath](#selectclippath)|Wybiera bieżącą ścieżkę jako region przycinania dla kontekstu urządzenia, łącząc nowy region z dowolnym istniejącym regionem przycinania przy użyciu określonego trybu.|
|[Przechwytywanie zmian:: SelectClipRgn](#selectcliprgn)|Łączy dany region z bieżącym regionem przycinania przy użyciu określonego trybu.|
|[Przechwytywanie zmian:: SelectObject](#selectobject)|Wybiera obiekt rysunku GDI, taki jak pióro.|
|[Przechwytywanie zmian:: SelectPalette](#selectpalette)|Wybiera paletę logiczną.|
|[Przechwytywanie zmian:: SelectStockObject](#selectstockobject)|Wybiera jedno ze wstępnie zdefiniowanych piór, pędzle lub czcionki dostarczone przez system Windows.|
|[Przechwytywanie zmian:: SetAbortProc](#setabortproc)|Ustawia funkcję wywołania zwrotnego, która jest wywoływana przez programistę, jeśli zadanie drukowania musi być przerwane.|
|[Przechwytywanie zmian:: SetArcDirection](#setarcdirection)|Ustawia kierunek rysowania, który ma być używany dla funkcji łuku i prostokąta.|
|[Przechwytywanie zmian:: SetAttribDC](#setattribdc)|Ustawia `m_hAttribDC` kontekst urządzenia atrybutu.|
|[Przechwytywanie zmian:: SetBkColor](#setbkcolor)|Ustawia bieżący kolor tła.|
|[Przechwytywanie zmian:: SetBkMode](#setbkmode)|Ustawia tryb tła.|
|[Przechwytywanie zmian:: SetBoundsRect](#setboundsrect)|Kontroluje akumulację informacji o prostokącie obwiedni dla określonego kontekstu urządzenia.|
|[Przechwytywanie zmian:: SetBrushOrg](#setbrushorg)|Określa początek następnego pędzla zaznaczonego w kontekście urządzenia.|
|[Przechwytywanie zmian:: SetColorAdjustment](#setcoloradjustment)|Ustawia wartości korekty koloru dla kontekstu urządzenia przy użyciu określonych wartości.|
|[Przechwytywanie zmian:: SetDCBrushColor](#setdcbrushcolor)|Ustawia bieżący kolor pędzla.|
|[Przechwytywanie zmian:: SetDCPenColor](#setdcpencolor)|Ustawia bieżący kolor pióra.|
|[Przechwytywanie zmian:: setgraphicsmode](#setgraphicsmode)|Ustawia bieżący tryb grafiki dla określonego kontekstu urządzenia.|
|[Przechwytywanie zmian:: SetLayout](#setlayout)|Zmienia układ kontekstu urządzenia (DC).|
|[Przechwytywanie zmian:: SetMapMode](#setmapmode)|Ustawia bieżący tryb mapowania.|
|[Przechwytywanie zmian:: SetMapperFlags](#setmapperflags)|Zmienia algorytm używany przez mapowanie czcionek, gdy mapuje czcionki logiczne na czcionki fizyczne.|
|[Przechwytywanie zmian:: SetMiterLimit](#setmiterlimit)|Ustawia limit długości sprzężeń ścięcia dla kontekstu urządzenia.|
|[Przechwytywanie zmian:: SetOutputDC](#setoutputdc)|Ustawia `m_hDC` kontekst urządzenia wyjściowego.|
|[Przechwytywanie zmian:: SetPixel](#setpixel)|Ustawia piksel w określonym punkcie na najbliższy przybliżenie określonego koloru.|
|[Przechwytywanie zmian:: SetPixelV](#setpixelv)|Ustawia piksel na określonych współrzędnych do najbliższego przybliżenia podanego koloru. `SetPixelV`jest szybsza niż `SetPixel` , ponieważ nie musi zwracać wartości koloru punktu w rzeczywistości.|
|[Przechwytywanie zmian:: SetPolyFillMode](#setpolyfillmode)|Ustawia tryb wypełniania wielokątów.|
|[Przechwytywanie zmian:: SetROP2](#setrop2)|Ustawia bieżący tryb rysowania.|
|[Przechwytywanie zmian:: SetStretchBltMode](#setstretchbltmode)|Ustawia tryb rozciągnięcia mapy bitowej.|
|[Przechwytywanie zmian:: TextAlign](#settextalign)|Ustawia flagi wyrównania tekstu.|
|[Przechwytywanie zmian:: SetTextCharacterExtra](#settextcharacterextra)|Ustawia liczbę odstępów między znakami.|
|[Przechwytywanie zmian:: SetTextColor](#settextcolor)|Ustawia kolor tekstu.|
|[Przechwytywanie zmian:: SetTextJustification](#settextjustification)|Dodaje miejsce do znaków podziału w ciągu.|
|[Przechwytywanie zmian:: SetViewportExt](#setviewportext)|Ustawia zakresy x i y okienka ekranu.|
|[Przechwytywanie zmian:: SetViewportOrg](#setviewportorg)|Ustawia źródło okienka ekranu.|
|[Przechwytywanie zmian:: SetWindowExt](#setwindowext)|Ustawia zakresy x i y skojarzonego okna.|
|[Przechwytywanie zmian:: SetWindowOrg](#setwindoworg)|Ustawia pochodzenie okna dla kontekstu urządzenia.|
|[Przechwytywanie zmian:: SetWorldTransform](#setworldtransform)|Ustawia bieżące miejsce na przekształcenie obszaru strony.|
|[Przechwytywanie zmian:: StartDoc](#startdoc)|Informuje o tym, że zostanie uruchomione nowe zadanie drukowania.|
|[Przechwytywanie zmian:: StartPage](#startpage)|Informuje o tym, że zostanie uruchomiona nowa strona.|
|[Przechwytywanie zmian:: StretchBlt](#stretchblt)|Przenosi mapę bitową ze źródłowego prostokąta i urządzenia do prostokąta docelowego, rozciągając lub kompresując mapę bitową, jeśli jest to konieczne, aby dopasować wymiary prostokąta docelowego.|
|[Przechwytywanie zmian:: StrokeAndFillPath](#strokeandfillpath)|Zamyka wszystkie otwarte figury w ścieżce, uderza kontur ścieżki przy użyciu bieżącego pióra i wypełnia jego wnętrze przy użyciu bieżącego pędzla.|
|[Przechwytywanie zmian:: StrokePath](#strokepath)|Renderuje określoną ścieżkę przy użyciu bieżącego pióra.|
|[Przechwytywanie zmian:: TabbedTextOut](#tabbedtextout)|Zapisuje ciąg znaków w określonej lokalizacji, rozwijając tabulatory do wartości określonych w tablicy pozycji tabulatora.|
|[Przechwytywanie zmian:: TextOut](#textout)|Zapisuje ciąg znaków w określonej lokalizacji przy użyciu aktualnie zaznaczonej czcionki.|
|[Przechwytywanie zmian:: TransparentBlt](#transparentblt)|Transferuje bitowy blok danych koloru z określonego kontekstu urządzenia źródłowego do kontekstu urządzenia docelowego, co umożliwia renderowanie określonego koloru jako przezroczystego w ramach transferu.|
|[Przechwytywanie zmian:: UpdateColors](#updatecolors)|Aktualizuje obszar klienta kontekstu urządzenia, dopasowując bieżące kolory w obszarze klienta do palety systemowej w oparciu o piksel w pikselach.|
|[Przechwytywanie zmian:: WidenPath](#widenpath)|Ponownie definiuje bieżącą ścieżkę jako obszar, który będzie rysowany w przypadku pociągnięcia ścieżki przy użyciu pióra aktualnie zaznaczonego w kontekście urządzenia.|

### <a name="public-operators"></a>Operatory publiczne

|Nazwa|Opis|
|----------|-----------------|
|[Przechwytywanie zmian:: operator używający HDC](#operator_hdc)|Pobiera uchwyt kontekstu urządzenia.|

### <a name="public-data-members"></a>Publiczne elementy członkowskie danych

|Nazwa|Opis|
|----------|-----------------|
|[Przechwytywanie zmian:: m_hAttribDC](#m_hattribdc)|Kontekst atrybutu-urządzenia używany przez ten `CDC` obiekt.|
|[Przechwytywanie zmian:: m_hDC](#m_hdc)|Kontekst urządzenia wyjściowego używany przez ten `CDC` obiekt.|

## <a name="remarks"></a>Uwagi

`CDC`Obiekt zawiera funkcje elementów członkowskich do pracy z kontekstem urządzenia, takim jak wyświetlacz lub drukarka, jak również członków do pracy z kontekstem wyświetlania skojarzonym z obszarem klienckim okna.

Wykonaj wszystkie rysowanie przez funkcje elementów członkowskich `CDC` obiektu. Klasa udostępnia funkcje członkowskie dla operacji kontekstu urządzenia, pracy z narzędziami do rysowania, wybór obiektów bezpiecznego interfejsu graficznego (GDI) i pracy z kolorami i paletami. Udostępnia również funkcje członkowskie do pobierania i ustawiania atrybutów rysowania, mapowania, pracy z okienkiem ekranu, pracy z zakresem okna, konwertowania współrzędnych, pracy z regionami, wycinków, linii rysowania i rysowania prostych kształtów, elips i wielokątów. Funkcje składowe są również udostępniane do rysowania tekstu, pracy z czcionkami, korzystania z ucieczki drukarki, przewijania i odtwarzania plików.

Aby użyć `CDC` obiektu, Konstruuj go, a następnie Wywołaj jego funkcje członkowskie, które są równoległymi funkcjami systemu Windows, które używają kontekstów urządzenia.

> [!NOTE]
> W systemie Windows 95/98 wszystkie współrzędne ekranu są ograniczone do 16 bitów. **`int`** W związku z tym przekazanie `CDC` do funkcji składowej musi należeć do zakresu od-32768 do 32767.

W przypadku określonych celów biblioteka MFC zawiera kilka klas pochodnych od `CDC` . `CPaintDC`hermetyzuje wywołania do `BeginPaint` i `EndPaint` . `CClientDC`zarządza kontekstem wyświetlania skojarzonym z obszarem klienckim okna. `CWindowDC`zarządza kontekstem wyświetlania skojarzonym z całym oknem, włącznie z jego ramką i kontrolkami. `CMetaFileDC`kojarzy kontekst urządzenia z metaplikiem.

`CDC`Program udostępnia dwie funkcje składowe, [GetLayout](#getlayout) i [SetLayout](#setlayout)w celu odwrócenia układu kontekstu urządzenia, który nie dziedziczy układu z okna. W przypadku aplikacji utworzonych dla kultur, takich jak arabski lub hebrajski, taka orientacja jest niezbędna, gdy układ znaków nie jest standardem europejskim.

`CDC`zawiera dwa konteksty urządzenia, [m_hDC](#m_hdc) i [m_hAttribDC](#m_hattribdc), które podczas tworzenia `CDC` obiektu odnoszą się do tego samego urządzenia. `CDC`kieruje wszystkie wyjściowe wywołania GDI do `m_hDC` i większość atrybutów wywołania GDI do `m_hAttribDC` . (Przykład wywołania atrybutu jest `GetTextColor` , podczas gdy `SetTextColor` jest wywołaniem wyjściowym).

Na przykład, struktura używa tych dwóch kontekstów urządzeń do implementowania `CMetaFileDC` obiektu, który wyśle dane wyjściowe do metapliku podczas odczytywania atrybutów z urządzenia fizycznego. Podgląd wydruku jest zaimplementowany w środowisku w podobny sposób. Można również użyć dwóch kontekstów urządzeń w podobny sposób w kodzie specyficznym dla aplikacji.

Istnieją przypadki, w których mogą być potrzebne informacje o metrykach tekstu zarówno `m_hDC` z `m_hAttribDC` kontekstów, jak i urządzenia. Następujące pary funkcji zapewniają tę możliwość:

|Używa m_hAttribDC|Używa m_hDC|
|-----------------------|-----------------|
|[GetTextExtent](#gettextextent)|[GetOutputTextExtent](#getoutputtextextent)|
|[GetTabbedTextExtent](#gettabbedtextextent)|[GetOutputTabbedTextExtent](#getoutputtabbedtextextent)|
|[GetTextMetrics](#gettextmetrics)|[GetOutputTextMetrics](#getoutputtextmetrics)|
|[GetCharWidth](#getcharwidth)|[GetOutputCharWidth](#getoutputcharwidth)|

Aby uzyskać więcej informacji na temat `CDC` , zobacz [konteksty urządzeń](../../mfc/device-contexts.md).

## <a name="inheritance-hierarchy"></a>Hierarchia dziedziczenia

[CObject](../../mfc/reference/cobject-class.md)

`CDC`

## <a name="requirements"></a>Wymagania

**Nagłówek:** afxwin. h

## <a name="cdcabortdoc"></a><a name="abortdoc"></a>Przechwytywanie zmian:: AbortDoc

Kończy bieżące zadanie drukowania i Wymazuje wszystko, co aplikacja została zapisywana na urządzeniu od czasu ostatniego wywołania funkcji składowej [StartDoc](#startdoc) .

```
int AbortDoc();
```

### <a name="return-value"></a>Wartość zwracana

Wartość większa lub równa 0, jeśli została wykonana pomyślnie, lub wartość ujemna, jeśli wystąpił błąd. Na poniższej liście przedstawiono typowe wartości błędów i ich znaczenie:

- SP_ERROR błąd ogólny.

- SP_OUTOFDISK zbyt mało miejsca na dysku, które jest obecnie dostępne do buforowania i nie będzie można uzyskać więcej miejsca.

- Za mało dostępnej pamięci do buforowania. SP_OUTOFMEMORY

- SP_USERABORT użytkownik zakończył zadanie za pomocą Menedżera wydruku.

### <a name="remarks"></a>Uwagi

Ta funkcja członkowska zastępuje ABORTDOC drukarki.

`AbortDoc`należy użyć, aby zakończyć następujące czynności:

- Operacje drukowania, które nie określają funkcji Abort przy użyciu [SetAbortProc](#setabortproc).

- Operacje drukowania, które nie osiągnęły jeszcze pierwszego wywołania ucieczki NEWFRAME lub NEXTBAND.

Jeśli aplikacja napotka błąd drukowania lub anulowaną operację drukowania, nie może ona próbować zakończyć operacji przy użyciu [EndDoc](#enddoc) lub `AbortDoc` funkcji członkowskich klasy `CDC` . Interfejs GDI automatycznie kończy operację przed zwróceniem wartości błędu.

Jeśli aplikacja wyświetli okno dialogowe umożliwiające użytkownikowi anulowanie operacji drukowania, musi wywołać `AbortDoc` przed zniszczeniem okna dialogowego.

Jeśli Menedżer wydruku został użyty do uruchomienia zadania drukowania, wywołanie `AbortDoc` wymazuje całe zadanie buforu — drukarka nie odbiera żadnych informacji. Jeśli Menedżer wydruku nie został użyty do uruchomienia zadania drukowania, dane mogły zostać wysłane do drukarki przed `AbortDoc` wywołaniem. W takim przypadku sterownik drukarki zresetował drukarkę (jeśli to możliwe) i zamknięto zadanie drukowania.

### <a name="example"></a>Przykład

  Zobacz przykład dla danych [przechwytywania:: StartDoc](#startdoc).

## <a name="cdcabortpath"></a><a name="abortpath"></a>Przechwytywanie zmian:: AbortPath

Zamyka i odrzuca wszystkie ścieżki w kontekście urządzenia.

```
BOOL AbortPath();
```

### <a name="return-value"></a>Wartość zwracana

Różne od zera, jeśli funkcja zakończyła się pomyślnie; w przeciwnym razie 0.

### <a name="remarks"></a>Uwagi

Jeśli w kontekście urządzenia jest otwarty nawias ścieżki, zamykany jest nawias ścieżki, a ścieżka zostanie odrzucona. Jeśli w kontekście urządzenia istnieje ścieżka zamknięty, ścieżka zostanie odrzucona.

## <a name="cdcaddmetafilecomment"></a><a name="addmetafilecomment"></a>Przechwytywanie zmian:: AddMetaFileComment

Kopiuje komentarz z buforu do określonego metapliku ulepszonego formatu.

```
BOOL AddMetaFileComment(
    UINT nDataSize,
    const BYTE* pCommentData);
```

### <a name="parameters"></a>Parametry

*nDataSize*<br/>
Określa długość buforu komentarza w bajtach.

*pCommentData*<br/>
Wskazuje bufor zawierający komentarz.

### <a name="return-value"></a>Wartość zwracana

Różne od zera, jeśli funkcja zakończyła się pomyślnie; w przeciwnym razie 0.

### <a name="remarks"></a>Uwagi

Komentarz może zawierać informacje prywatne, na przykład źródło obrazu i datę jego utworzenia. Komentarz powinien rozpoczynać się od podpisu aplikacji, po którym następuje dane. Komentarze nie powinny zawierać danych specyficznych dla pozycji. Dane specyficzne dla pozycji określają lokalizację rekordu i nie powinny być uwzględniane, ponieważ jeden metaplik może być osadzony w innym metapliku. Ta funkcja może być używana tylko z rozszerzonymi plikami.

## <a name="cdcalphablend"></a><a name="alphablend"></a>Przechwytywanie zmian:: AlphaBlend

Wywołaj tę funkcję elementu członkowskiego, aby wyświetlić mapy bitowe, które mają przezroczyste lub półprzezroczyste piksele.

```
BOOL AlphaBlend(
    int xDest,
    int yDest,
    int nDestWidth,
    int nDestHeight,
    CDC* pSrcDC,
    int xSrc,
    int ySrc,
    int nSrcWidth,
    int nSrcHeight,
    BLENDFUNCTION blend);
```

### <a name="parameters"></a>Parametry

*xDest*<br/>
Określa współrzędną x (w jednostkach logicznych) lewego górnego rogu prostokąta docelowego.

*yDest*<br/>
Określa współrzędną y (w jednostkach logicznych) lewego górnego rogu prostokąta docelowego.

*nDestWidth*<br/>
Określa szerokość (w jednostkach logicznych) prostokąta docelowego.

*nDestHeight*<br/>
Określa wysokość (w jednostkach logicznych) prostokąta docelowego.

*pSrcDC*<br/>
Wskaźnik do kontekstu urządzenia źródłowego.

*xSrc*<br/>
Określa współrzędną x (w jednostkach logicznych) lewego górnego rogu prostokąta źródłowego.

*ySrc*<br/>
Określa współrzędną y (w jednostkach logicznych) lewego górnego rogu prostokąta źródłowego.

*nSrcWidth*<br/>
Określa szerokość (w jednostkach logicznych) prostokąta źródłowego.

*nSrcHeight*<br/>
Określa wysokość (w jednostkach logicznych) prostokąta źródłowego.

*mieszania*<br/>
Określa strukturę [BLENDFUNCTION](/windows/win32/api/wingdi/ns-wingdi-blendfunction) .

### <a name="return-value"></a>Wartość zwracana

Wartość TRUE, jeśli powodzenie; w przeciwnym razie FALSE.

### <a name="remarks"></a>Uwagi

Aby uzyskać więcej informacji, zobacz [AlphaBlend](/windows/win32/api/wingdi/nf-wingdi-alphablend) w Windows SDK.

## <a name="cdcanglearc"></a><a name="anglearc"></a>Przechwytywanie zmian:: AngleArc

Rysuje segment linii i łuk.

```
BOOL AngleArc(
    int x,
    int y,
    int nRadius,
    float fStartAngle,
    float fSweepAngle);
```

### <a name="parameters"></a>Parametry

*x*<br/>
Określa logiczną współrzędną x środka okręgu.

*t*<br/>
Określa logiczną współrzędną y środka okręgu.

*nRadius*<br/>
Określa promień okręgu w jednostkach logicznych. Ta wartość musi być dodatnia.

*fStartAngle*<br/>
Określa kąt początkowy w stopniach względem osi x.

*fSweepAngle*<br/>
Określa kąt odchylenia (w stopniach) względem kąta początkowego.

### <a name="return-value"></a>Wartość zwracana

Niezerowe, jeśli pomyślne; w przeciwnym razie 0.

### <a name="remarks"></a>Uwagi

Segment linii jest rysowany od bieżącego położenia do początku łuku. Łuk jest rysowany wzdłuż obwodu koła z danym promień i wyśrodkuj. Długość łuku jest definiowana przez dany kąt rozpoczęcia i odchylenia.

`AngleArc`przenosi bieżącą pozycję do punktu końcowego łuku. Łuk rysowany przez tę funkcję może wydawać się elipsą, w zależności od bieżącego przekształcenia i trybu mapowania. Przed rysowaniem łuku ta funkcja Rysuje segment linii od bieżącego położenia do początku łuku. Łuk jest rysowany przez konstruowanie okręgu urojonego z określonym promieniem wokół określonego punktu centralnego. Punkt początkowy łuku jest określany przez zmierzenie w lewo od osi x okręgu przez liczbę stopni w kącie początkowym. Punkt końcowy jest analogiczny, mierząc w lewo od punktu początkowego o liczbę stopni w kącie odchylenia.

Jeśli kąt odchylenia jest większy niż 360 stopni, łuk jest wyczyszczony wiele razy. Ta funkcja rysuje linie przy użyciu bieżącego pióra. Rysunek nie jest wypełniony.

## <a name="cdcarc"></a><a name="arc"></a>Przechwytywanie zmian:: Arc

Rysuje Łuk eliptyczny.

```
BOOL Arc(
    int x1,
    int y1,
    int x2,
    int y2,
    int x3,
    int y3,
    int x4,
    int y4);

BOOL Arc(
    LPCRECT lpRect,
    POINT ptStart,
    POINT ptEnd);
```

### <a name="parameters"></a>Parametry

*x1*<br/>
Określa współrzędną x lewego górnego rogu prostokąta ograniczenia (w jednostkach logicznych).

*Y1*<br/>
Określa współrzędną y lewego górnego rogu prostokąta ograniczenia (w jednostkach logicznych).

*x2*<br/>
Określa współrzędną x dolnego prawego górnego rogu prostokąta granicznego (w jednostkach logicznych).

*Y2*<br/>
Określa współrzędną y prawego dolnego rogu prostokąta granicznego (w jednostkach logicznych).

*x3*<br/>
Określa współrzędną x punktu, który definiuje punkt początkowy łuku (w jednostkach logicznych). Ten punkt nie musi znajdować się dokładnie na łuku.

*Y3*<br/>
Określa współrzędną y punktu, który definiuje punkt początkowy łuku (w jednostkach logicznych). Ten punkt nie musi znajdować się dokładnie na łuku.

*X4*<br/>
Określa współrzędną x punktu, który definiuje punkt końcowy łuku (w jednostkach logicznych). Ten punkt nie musi znajdować się dokładnie na łuku.

*Y4*<br/>
Określa współrzędną y punktu, który definiuje punkt końcowy łuku (w jednostkach logicznych). Ten punkt nie musi znajdować się dokładnie na łuku.

*lpRect*<br/>
Określa prostokąt ograniczenia (w jednostkach logicznych). Można przekazać obiekt LPRECT lub [CRect](../../atl-mfc-shared/reference/crect-class.md) dla tego parametru.

*ptStart*<br/>
Określa współrzędne x i y punktu, który definiuje punkt początkowy łuku (w jednostkach logicznych). Ten punkt nie musi znajdować się dokładnie na łuku. Dla tego parametru można przekazać strukturę [punktu](/windows/win32/api/windef/ns-windef-point) lub obiekt [CPoint](../../atl-mfc-shared/reference/cpoint-class.md) .

*ptEnd*<br/>
Określa współrzędne x i y punktu, który definiuje punkt końcowy łuku (w jednostkach logicznych). Ten punkt nie musi znajdować się dokładnie na łuku. Można przekazać `POINT` strukturę lub `CPoint` obiekt dla tego parametru.

### <a name="return-value"></a>Wartość zwracana

Różne od zera, jeśli funkcja zakończyła się pomyślnie; w przeciwnym razie 0.

### <a name="remarks"></a>Uwagi

Łuk rysowany przy użyciu funkcji jest segmentem elipsy zdefiniowanej przez określony prostokąt ograniczający.

Rzeczywistym punktem początkowym łuku jest punkt, w którym promień narysowany z centrum obwiedni przez określony punkt początkowy przecina wielokropek. Faktyczny punkt końcowy łuku to punkt, w którym promień narysowany przez środek obwiedni przez określony punkt końcowy przecina wielokropek. Łuk jest rysowany w kierunku do ruchu wskazówek zegara. Ponieważ łuk nie jest rysunkiem zamkniętym, nie jest wypełniony. Szerokość i wysokość prostokąta musi być większa niż 2 jednostki i mniejsza niż 32 767 jednostek.

### <a name="example"></a>Przykład

[!code-cpp[NVC_MFCDocView#29](../../mfc/codesnippet/cpp/cdc-class_1.cpp)]

## <a name="cdcarcto"></a><a name="arcto"></a>Przechwytywanie zmian:: ArcTo

Rysuje Łuk eliptyczny.

```
BOOL ArcTo(
    int x1,
    int y1,
    int x2,
    int y2,
    int x3,
    int y3,
    int x4,
    int y4);

BOOL ArcTo(
    LPCRECT lpRect,
    POINT ptStart,
    POINT ptEnd);
```

### <a name="parameters"></a>Parametry

*x1*<br/>
Określa współrzędną x lewego górnego rogu prostokąta ograniczenia (w jednostkach logicznych).

*Y1*<br/>
Określa współrzędną y lewego górnego rogu prostokąta ograniczenia (w jednostkach logicznych).

*x2*<br/>
Określa współrzędną x dolnego prawego górnego rogu prostokąta granicznego (w jednostkach logicznych).

*Y2*<br/>
Określa współrzędną y prawego dolnego rogu prostokąta granicznego (w jednostkach logicznych).

*x3*<br/>
Określa współrzędną x punktu, który definiuje punkt początkowy łuku (w jednostkach logicznych). Ten punkt nie musi znajdować się dokładnie na łuku.

*Y3*<br/>
Określa współrzędną y punktu, który definiuje punkt początkowy łuku (w jednostkach logicznych). Ten punkt nie musi znajdować się dokładnie na łuku.

*X4*<br/>
Określa współrzędną x punktu, który definiuje punkt końcowy łuku (w jednostkach logicznych). Ten punkt nie musi znajdować się dokładnie na łuku.

*Y4*<br/>
Określa współrzędną y punktu, który definiuje punkt końcowy łuku (w jednostkach logicznych). Ten punkt nie musi znajdować się dokładnie na łuku.

*lpRect*<br/>
Określa prostokąt ograniczenia (w jednostkach logicznych). Można przekazać wskaźnik do struktury danych [Rect](/windows/win32/api/windef/ns-windef-rect) lub obiektu [CRect](../../atl-mfc-shared/reference/crect-class.md) dla tego parametru.

*ptStart*<br/>
Określa współrzędne x i y punktu, który definiuje punkt początkowy łuku (w jednostkach logicznych). Ten punkt nie musi znajdować się dokładnie na łuku. Dla tego parametru można przekazać strukturę danych [punktu](/windows/win32/api/windef/ns-windef-point) lub obiekt [CPoint](../../atl-mfc-shared/reference/cpoint-class.md) .

*ptEnd*<br/>
Określa współrzędne x i y punktu, który definiuje punkt końcowy łuku (w jednostkach logicznych). Ten punkt nie musi znajdować się dokładnie na łuku. Można przekazać `POINT` strukturę danych lub `CPoint` obiekt dla tego parametru.

### <a name="return-value"></a>Wartość zwracana

Różne od zera, jeśli funkcja zakończyła się pomyślnie; w przeciwnym razie 0.

### <a name="remarks"></a>Uwagi

Ta funkcja jest podobna do `CDC::Arc` , z tą różnicą, że bieżące stanowisko zostało zaktualizowane. Punkty ( *x1*, *Y1*) i ( *X2*, *Y2*) określają prostokąt ograniczający. Elipsa utworzona przez dany prostokąt ograniczenia definiuje krzywą łuku. Łuk rozciąga się w lewo (domyślny kierunek łuku) od punktu, w którym przecina linię promieniową od środka prostokąta, do ( *x3*, *Y3*). Łuk zostaje zakończony, gdy przecina linię promieniową od środka prostokąta obwiedni do ( *X4*, *Y4*). Jeśli punkt początkowy i punkt końcowy są takie same, zostanie narysowana pełna Elipsa.

Linia jest rysowana od bieżącego położenia do punktu początkowego łuku. Jeśli wystąpi błąd, bieżąca pozycja jest ustawiana na punkt końcowy łuku. Łuk jest rysowany przy użyciu bieżącego pióra; nie jest wypełnione.

## <a name="cdcattach"></a><a name="attach"></a>Przechwytywanie zmian:: Attach

Użyj tej funkcji elementu członkowskiego, aby dołączyć *używający HDC* do `CDC` obiektu.

```
BOOL Attach(HDC hDC);
```

### <a name="parameters"></a>Parametry

*Używający HDC*<br/>
Kontekst urządzenia systemu Windows.

### <a name="return-value"></a>Wartość zwracana

Różne od zera, jeśli funkcja zakończyła się pomyślnie; w przeciwnym razie 0.

### <a name="remarks"></a>Uwagi

*Używający HDC* jest przechowywany zarówno w `m_hDC` kontekście urządzenia wyjściowego, jak i w, kontekst `m_hAttribDC` urządzenia atrybutu.

## <a name="cdcbeginpath"></a><a name="beginpath"></a>Przechwytywanie zmian:: BeginPath

Otwiera nawias ścieżki w kontekście urządzenia.

```
BOOL BeginPath();
```

### <a name="return-value"></a>Wartość zwracana

Różne od zera, jeśli funkcja zakończyła się pomyślnie; w przeciwnym razie 0.

### <a name="remarks"></a>Uwagi

Po otwarciu nawiasu ścieżki aplikacja może rozpocząć wywoływanie funkcji rysowania GDI w celu zdefiniowania punktów, które znajdują się w ścieżce. Aplikacja może zamknąć nawias ścieżki otwierającej, wywołując `EndPath` funkcję członkowską. Gdy aplikacja wywołuje `BeginPath` wszystkie poprzednie ścieżki są odrzucane.

Zobacz [BeginPath](/windows/win32/api/wingdi/nf-wingdi-beginpath) w Windows SDK, aby uzyskać listę funkcji rysowania, które definiują punkty w ścieżce.

### <a name="example"></a>Przykład

[!code-cpp[NVC_MFCDocView#30](../../mfc/codesnippet/cpp/cdc-class_2.cpp)]

## <a name="cdcbitblt"></a><a name="bitblt"></a>Przechwytywanie zmian:: BitBlt

Kopiuje mapę bitową z kontekstu urządzenia źródłowego do tego bieżącego kontekstu urządzenia.

```
BOOL BitBlt(
    int x,
    int y,
    int nWidth,
    int nHeight,
    CDC* pSrcDC,
    int xSrc,
    int ySrc,
    DWORD dwRop);
```

### <a name="parameters"></a>Parametry

*x*<br/>
Określa logiczną współrzędną x lewego górnego rogu prostokąta docelowego.

*t*<br/>
Określa logiczną współrzędną y lewego górnego rogu prostokąta docelowego.

*nWidth*<br/>
Określa szerokość (w jednostkach logicznych) prostokąta docelowego i źródłową mapę bitową.

*nHeight*<br/>
Określa wysokość (w jednostkach logicznych) prostokąta docelowego i źródłową mapę bitową.

*pSrcDC*<br/>
Wskaźnik do `CDC` obiektu, który identyfikuje kontekst urządzenia, z którego zostanie skopiowana Mapa bitowa. Jeśli *dwRop* określa operację rastrową, która nie zawiera źródła, musi mieć wartość null.

*xSrc*<br/>
Określa logiczną współrzędną x lewego górnego rogu bitmapy źródłowej.

*ySrc*<br/>
Określa logiczną współrzędną y lewego górnego rogu bitmapy źródłowej.

*dwRop*<br/>
Określa operację rastrową, która ma być wykonana. Kody operacji rastrowych definiują sposób, w jaki interfejs GDI łączy kolory w operacjach wyjściowych, które obejmują bieżący Pędzel, możliwą źródłową mapę bitową i docelową mapę bitową. Aby uzyskać listę kodów operacji rastrowych dla *dwRop* i ich opisów, zobacz [BitBlt](/windows/win32/api/wingdi/nf-wingdi-bitblt) w Windows SDK.

Aby uzyskać pełną listę kodów operacji rastrowych, zobacz [Informacje o kodach operacji rastrowych](/windows/win32/gdi/raster-operation-codes) w Windows SDK.

### <a name="return-value"></a>Wartość zwracana

Różne od zera, jeśli funkcja zakończyła się pomyślnie; w przeciwnym razie 0.

### <a name="remarks"></a>Uwagi

Aplikacja może wyrównać obszary systemu Windows lub klienta w granicach bajtów, aby upewnić się, że `BitBlt` operacje są wykonywane w prostokątach wyrównanych do bajtów. (Ustaw CS_BYTEALIGNWINDOW lub CS_BYTEALIGNCLIENT flagi podczas rejestrowania klas okna).

`BitBlt`operacje na prostokątach wyrównanych do bajtów są znacznie szybsze niż `BitBlt` operacje w prostokątach, które nie są wyrównane do bajtu. Jeśli chcesz określić style klas, takie jak wyrównanie bajtów dla własnego kontekstu urządzenia, musisz zarejestrować klasę okna zamiast polegać na tym, aby nie polegać na klasach Microsoft Foundation. Użyj funkcji globalnej [AfxRegisterWndClass —](../../mfc/reference/application-information-and-management.md#afxregisterwndclass).

Interfejs GDI transformuje *nWidth* i *nHeight*, raz przy użyciu kontekstu urządzenia docelowego i raz przy użyciu kontekstu urządzenia źródłowego. Jeśli zakres wyników nie jest zgodny, interfejs GDI używa funkcji systemu Windows `StretchBlt` w celu kompresowania lub rozciągnięcia źródłowej mapy bitowej zgodnie z potrzebami.

Jeżeli mapy bitowe lokalizacji docelowej, źródłowej i wzorca nie mają tego samego formatu koloru, `BitBlt` funkcja konwertuje mapy bitowe źródłowe i wzorca, aby pasowały do miejsca docelowego. Kolory pierwszego planu i tła docelowej mapy bitowej są używane podczas konwersji.

Gdy `BitBlt` funkcja konwertuje czarną mapę bitową na kolor, ustawia biały bity (1) na kolor tła i czarne bity (0) na kolor pierwszego planu. Używane są kolory pierwszego planu i tła kontekstu urządzenia docelowego. Aby przekonwertować kolor na monochromatyczny, `BitBlt` Ustawia piksele pasujące do koloru tła na biały i ustawia wszystkie pozostałe piksele na czerń. `BitBlt`używa kolorów pierwszego planu i tła kontekstu urządzenia koloru do konwersji z koloru na monochromatyczny.

Należy pamiętać, że nie wszystkie konteksty urządzenia obsługują `BitBlt` . Aby sprawdzić, czy dany kontekst urządzenia obsługuje `BitBlt` , użyj `GetDeviceCaps` funkcji składowej i określ indeks RASTERCAPS.

### <a name="example"></a>Przykład

  Zobacz przykład dla danych [przechwytywania:: CreateCompatibleDC](#createcompatibledc).

## <a name="cdccdc"></a><a name="cdc"></a>PRZECHWYTYWANIE ZMIAN:: PRZEPRZECHWYTYWANIE

Konstruuje `CDC` obiekt.

```
CDC();
```

## <a name="cdcchord"></a><a name="chord"></a>Przechwytywanie zmian:: skrót

Rysuje skrót (zamkniętą figurę powiązaną z przecięciem wielokropka i segmentu linii).

```
BOOL Chord(
    int x1,
    int y1,
    int x2,
    int y2,
    int x3,
    int y3,
    int x4,
    int y4);

BOOL Chord(
    LPCRECT lpRect,
    POINT ptStart,
    POINT ptEnd);
```

### <a name="parameters"></a>Parametry

*x1*<br/>
Określa współrzędną x lewego górnego rogu prostokąta skrót (w jednostkach logicznych).

*Y1*<br/>
Określa współrzędną y lewego górnego rogu prostokąta skrót (w jednostkach logicznych).

*x2*<br/>
Określa współrzędną x dolnego prawego górnego rogu prostokąta skrót (w jednostkach logicznych).

*Y2*<br/>
Określa współrzędną y prawego dolnego rogu prostokąta skrót (w jednostkach logicznych).

*x3*<br/>
Określa współrzędną x punktu, który definiuje punkt początkowy skrót (w jednostkach logicznych).

*Y3*<br/>
Określa współrzędną y punktu, który definiuje punkt początkowy skrót (w jednostkach logicznych).

*X4*<br/>
Określa współrzędną x punktu, który definiuje punkt końcowy skrót (w jednostkach logicznych).

*Y4*<br/>
Określa współrzędną y punktu, który definiuje punkt końcowy skrót (w jednostkach logicznych).

*lpRect*<br/>
Określa prostokąt ograniczenia (w jednostkach logicznych). Można przekazać obiekt LPRECT lub [CRect](../../atl-mfc-shared/reference/crect-class.md) dla tego parametru.

*ptStart*<br/>
Określa współrzędne x i y punktu, który definiuje punkt początkowy skrót (w jednostkach logicznych). Ten punkt nie musi się dokładnie znajdować w skrót. Można przekazać `POINT` strukturę lub `CPoint` obiekt dla tego parametru.

*ptEnd*<br/>
Określa współrzędne x i y punktu, który definiuje punkt końcowy skrót (w jednostkach logicznych). Ten punkt nie musi się dokładnie znajdować w skrót. Dla tego parametru można przekazać strukturę [punktu](/windows/win32/api/windef/ns-windef-point) lub obiekt [CPoint](../../atl-mfc-shared/reference/cpoint-class.md) .

### <a name="return-value"></a>Wartość zwracana

Różne od zera, jeśli funkcja zakończyła się pomyślnie; w przeciwnym razie 0.

### <a name="remarks"></a>Uwagi

Parametry ( *x1*, *Y1*) i ( *X2*, *Y2*) określają odpowiednio górne i dolne rogi prostokąta, który jest częścią skrót. Parametry ( *x3*, *Y3*) i ( *X4*, *Y4*) określają punkty końcowe linii, która przecina elipsę. Skrót jest rysowany przy użyciu wybranego pióra i wypełniany przy użyciu wybranego pędzla.

Rysunek rysowany przez `Chord` funkcję rozciąga się do, ale nie obejmuje współrzędnej prawej i dolnej. Oznacza to, że wysokość rysunku to *Y2*  -  *Y1* , a szerokość rysunku to *X2*  -  *x1*.

### <a name="example"></a>Przykład

[!code-cpp[NVC_MFCDocView#31](../../mfc/codesnippet/cpp/cdc-class_3.cpp)]

## <a name="cdcclosefigure"></a><a name="closefigure"></a>Przechwytywanie zmian:: CloseFigure

Zamyka otwarty rysunek w ścieżce.

```
BOOL CloseFigure();
```

### <a name="return-value"></a>Wartość zwracana

Różne od zera, jeśli funkcja zakończyła się pomyślnie; w przeciwnym razie 0.

### <a name="remarks"></a>Uwagi

Funkcja zamyka rysunek, rysując linię od bieżącego położenia do pierwszego punktu rysunku (zazwyczaj punkt określony przez ostatnie wywołanie do `MoveTo` funkcji składowej) i łączy linie przy użyciu stylu sprzężenia linii. Jeśli rysunek jest zamknięty przy użyciu `LineTo` funkcji elementu członkowskiego zamiast `CloseFigure` , zakończenia są używane do tworzenia rogu zamiast sprzężenia. `CloseFigure`powinien być wywoływany tylko w przypadku, gdy w kontekście urządzenia istnieje otwarty nawias w ścieżce.

Rysunek w ścieżce jest otwarty, chyba że zostanie jawnie zamknięty przy użyciu tej funkcji. (Rysunek może być otwarty, nawet jeśli bieżący punkt i punkt początkowy rysunku są takie same). Dowolna linia lub krzywa została dodana do ścieżki po `CloseFigure` rozpoczęciu nowego rysunku.

## <a name="cdccreatecompatibledc"></a><a name="createcompatibledc"></a>Przechwytywanie zmian:: CreateCompatibleDC

Tworzy kontekst urządzenia pamięci, który jest zgodny z urządzeniem określonym przez *PDC*.

```
BOOL CreateCompatibleDC(CDC* pDC);
```

### <a name="parameters"></a>Parametry

*Domeny*<br/>
Wskaźnik do kontekstu urządzenia. Jeśli *PDC* ma wartość null, funkcja tworzy kontekst urządzenia pamięci, który jest zgodny z wyświetlaczem systemowym.

### <a name="return-value"></a>Wartość zwracana

Różne od zera, jeśli funkcja zakończyła się pomyślnie; w przeciwnym razie 0.

### <a name="remarks"></a>Uwagi

Kontekst urządzenia pamięci to blok pamięci, który reprezentuje powierzchnię wyświetlaną. Można go użyć do przygotowania obrazów w pamięci przed skopiowaniem ich do rzeczywistej powierzchni urządzenia zgodnego urządzenia.

Po utworzeniu kontekstu urządzenia pamięci, interfejs GDI automatycznie wybiera dla niego mapę bitową od 1 do 1. Funkcje wyjściowe GDI mogą być używane z kontekstem urządzenia pamięci tylko wtedy, gdy mapa bitowa została utworzona i wybrana w tym kontekście.

Ta funkcja może być używana tylko do tworzenia zgodnych kontekstów urządzeń dla urządzeń, które obsługują operacje rastrowe. Aby uzyskać informacje dotyczące transferów bitów między kontekstami urządzeń, zobacz funkcję składową funkcji [przechwytywania:: BitBlt](#bitblt) . Aby określić, czy kontekst urządzenia obsługuje operacje rastrowe, zobacz RC_BITBLT Raster w funkcji składowej `CDC::GetDeviceCaps` .

### <a name="example"></a>Przykład

[!code-cpp[NVC_MFCDocView#32](../../mfc/codesnippet/cpp/cdc-class_4.cpp)]

## <a name="cdccreatedc"></a><a name="createdc"></a>Przechwytywanie zmian:: CreateDC

Tworzy kontekst urządzenia dla określonego urządzenia.

```
BOOL CreateDC(
    LPCTSTR lpszDriverName,
    LPCTSTR lpszDeviceName,
    LPCTSTR lpszOutput,
    const void* lpInitData);
```

### <a name="parameters"></a>Parametry

*lpszDriverName*<br/>
Wskazuje ciąg zakończony znakiem null, który określa nazwę pliku (bez rozszerzenia) sterownika urządzenia (na przykład "EPSON"). Można również przekazać `CString` obiekt dla tego parametru.

*lpszDeviceName*<br/>
Wskazuje ciąg zakończony znakiem null, który określa nazwę konkretnego urządzenia, które ma być obsługiwane (na przykład "EPSON FX-80"). Parametr *lpszDeviceName* jest używany, jeśli moduł obsługuje więcej niż jedno urządzenie. Można również przekazać `CString` obiekt dla tego parametru.

*lpszOutput*<br/>
Wskazuje ciąg zakończony znakiem null, który określa nazwę pliku lub urządzenia dla fizycznego nośnika wyjściowego (plik lub port wyjściowy). Można również przekazać `CString` obiekt dla tego parametru.

*lpInitData*<br/>
Wskazuje `DEVMODE` strukturę zawierającą dane inicjowania specyficzne dla urządzenia dla sterownika urządzenia. Funkcja systemu Windows `DocumentProperties` Pobiera tę strukturę wypełnioną dla danego urządzenia. Parametr *lpInitData* musi mieć wartość null, jeśli sterownik urządzenia ma używać domyślnej inicjalizacji (jeśli istnieje) określonej przez użytkownika za pomocą panelu sterowania.

### <a name="return-value"></a>Wartość zwracana

Różne od zera, jeśli funkcja zakończyła się pomyślnie; w przeciwnym razie 0.

### <a name="remarks"></a>Uwagi

Drukuj. Plik nagłówkowy H jest wymagany w przypadku użycia struktury [DEVMODE](/windows/win32/api/wingdi/ns-wingdi-devmodea) .

Nazwy urządzeń przestrzegają następujących konwencji: kończące się średnikiem (:) jest zalecany, ale opcjonalny. System Windows paski przerwania, aby nazwa urządzenia kończąca się dwukropkiem jest zamapowana na ten sam port, który ma taką samą nazwę, bez dwukropka. Nazwy sterowników i portów nie mogą zawierać spacji wiodących ani końcowych. Funkcje wyjściowe GDI nie mogą być używane z kontekstami informacji.

## <a name="cdccreateic"></a><a name="createic"></a>Przechwytywanie zmian:: Tworzenie

Tworzy kontekst informacyjny dla określonego urządzenia.

```
BOOL CreateIC(
    LPCTSTR lpszDriverName,
    LPCTSTR lpszDeviceName,
    LPCTSTR lpszOutput,
    const void* lpInitData);
```

### <a name="parameters"></a>Parametry

*lpszDriverName*<br/>
Wskazuje ciąg zakończony znakiem null, który określa nazwę pliku (bez rozszerzenia) sterownika urządzenia (na przykład "EPSON"). Można przekazać `CString` obiekt dla tego parametru.

*lpszDeviceName*<br/>
Wskazuje ciąg zakończony znakiem null, który określa nazwę konkretnego urządzenia, które ma być obsługiwane (na przykład "EPSON FX-80"). Parametr *lpszDeviceName* jest używany, jeśli moduł obsługuje więcej niż jedno urządzenie. Można przekazać `CString` obiekt dla tego parametru.

*lpszOutput*<br/>
Wskazuje ciąg zakończony znakiem null, który określa nazwę pliku lub urządzenia dla fizycznego nośnika wyjściowego (plik lub port). Można przekazać `CString` obiekt dla tego parametru.

*lpInitData*<br/>
Wskazuje na dane inicjowania specyficzne dla urządzenia dla sterownika urządzenia. Parametr *lpInitData* musi mieć wartość null, jeśli sterownik urządzenia ma używać domyślnej inicjalizacji (jeśli istnieje) określonej przez użytkownika za pomocą panelu sterowania. Zobacz `CreateDC` , aby uzyskać informacje na temat inicjowania konkretnego urządzenia.

### <a name="return-value"></a>Wartość zwracana

Niezerowe, jeśli pomyślne; w przeciwnym razie 0.

### <a name="remarks"></a>Uwagi

Kontekst informacji zapewnia szybki sposób uzyskiwania informacji o urządzeniu bez tworzenia kontekstu urządzenia.

Nazwy urządzeń przestrzegają następujących konwencji: kończące się średnikiem (:) jest zalecany, ale opcjonalny. System Windows paski przerwania, aby nazwa urządzenia kończąca się dwukropkiem jest zamapowana na ten sam port, który ma taką samą nazwę, bez dwukropka. Nazwy sterowników i portów nie mogą zawierać spacji wiodących ani końcowych. Funkcje wyjściowe GDI nie mogą być używane z kontekstami informacji.

## <a name="cdcdeletedc"></a><a name="deletedc"></a>Przechwytywanie zmian::D eleteDC

Ogólnie rzecz biorąc nie wywołuj tej funkcji; destruktor wykona tę czynność.

```
BOOL DeleteDC();
```

### <a name="return-value"></a>Wartość zwracana

Niezerowe, jeśli funkcja została ukończona pomyślnie; w przeciwnym razie 0.

### <a name="remarks"></a>Uwagi

`DeleteDC`Funkcja członkowska usuwa konteksty urządzenia z systemem Windows, które są skojarzone z `m_hDC` w bieżącym `CDC` obiekcie. Jeśli ten `CDC` obiekt jest ostatnim aktywnym kontekstem urządzenia dla danego urządzenia, urządzenie zostanie powiadomione i zostaną wydane wszystkie zasoby dotyczące magazynu i systemu używane przez urządzenie.

Aplikacja nie powinna wywołać, `DeleteDC` Jeśli obiekty zostały wybrane do kontekstu urządzenia. Najpierw należy wybrać obiekty z kontekstu urządzenia przed jego usunięciem.

Aplikacja nie może usunąć kontekstu urządzenia, którego dojście zostało uzyskane przez wywołanie [CWnd:: GetDC —](../../mfc/reference/cwnd-class.md#getdc). Zamiast tego należy wywołać [CWnd:: ReleaseDC](../../mfc/reference/cwnd-class.md#releasedc) w celu zwolnienia kontekstu urządzenia. Klasy [CClientDC —](../../mfc/reference/cclientdc-class.md) i [CWindowDC](../../mfc/reference/cwindowdc-class.md) są dostarczane w celu oblewania tej funkcji.

`DeleteDC`Funkcja jest zazwyczaj używana do usuwania kontekstów urządzenia utworzonych za pomocą [CreateDC](#createdc), [Create](#createic)lub [CreateCompatibleDC](#createcompatibledc).

### <a name="example"></a>Przykład

  Zobacz przykład dla [CPrintDialog:: GetPrinterDC](../../mfc/reference/cprintdialog-class.md#getprinterdc).

## <a name="cdcdeletetempmap"></a><a name="deletetempmap"></a>Przechwytywanie zmian::D eleteTempMap

Wywoływana automatycznie przez `CWinApp` program obsługi czasu bezczynności, `DeleteTempMap` usuwa wszystkie `CDC` obiekty tymczasowe utworzone przez `FromHandle` , ale nie niszczy dojść kontekstu urządzenia `hDC` tymczasowo skojarzonych z `CDC` obiektami.

```
static void PASCAL DeleteTempMap();
```

## <a name="cdcdetach"></a><a name="detach"></a>Przechwytywanie zmian::D etach

Wywołaj tę funkcję, aby odłączyć `m_hDC` (kontekst urządzenia wyjściowego) od `CDC` obiektu i ustawić `m_hDC` `m_hAttribDC` wartość null.

```
HDC Detach();
```

### <a name="return-value"></a>Wartość zwracana

Kontekst urządzenia systemu Windows.

## <a name="cdcdptohimetric"></a><a name="dptohimetric"></a>Przechwytywanie zmian::D PtoHIMETRIC

Użyj tej funkcji, gdy przydajesz HIMETRIC rozmiary do OLE, konwertując piksele na HIMETRIC.

```cpp
void DPtoHIMETRIC(LPSIZE lpSize) const;
```

### <a name="parameters"></a>Parametry

*lpSize*<br/>
Wskazuje na strukturę [rozmiaru](/windows/win32/api/windef/ns-windef-size) lub obiekt [CSize](../../atl-mfc-shared/reference/csize-class.md) .

### <a name="remarks"></a>Uwagi

Jeśli tryb mapowania obiektu kontekstu urządzenia jest MM_LOENGLISH, MM_HIENGLISH, MM_LOMETRIC lub MM_HIMETRIC, konwersja jest zależna od liczby pikseli w danym cala. Jeśli tryb mapowania jest jednym z pozostałych trybów nieograniczonych (np. MM_TEXT), konwersja jest oparta na liczbie pikseli w centymetrze logicznym.

## <a name="cdcdptolp"></a><a name="dptolp"></a>Przechwytywanie zmian::D PtoLP

Konwertuje jednostki urządzeń na jednostki logiczne.

```cpp
void DPtoLP(
    LPPOINT lpPoints,
    int nCount = 1) const;

void DPtoLP(LPRECT lpRect) const;
void DPtoLP(LPSIZE lpSize) const;
```

### <a name="parameters"></a>Parametry

*lpPoints*<br/>
Wskazuje tablicę struktur [punktów](/windows/win32/api/windef/ns-windef-point) lub obiektów [CPoint](../../atl-mfc-shared/reference/cpoint-class.md) .

*nCount*<br/>
Liczba punktów w tablicy.

*lpRect*<br/>
Wskazuje strukturę [Rect](/windows/win32/api/windef/ns-windef-rect) lub obiekt [CRect](../../atl-mfc-shared/reference/crect-class.md) . Ten parametr jest używany w prostym przypadku konwertowania jednego prostokąta z punktów urządzenia do punktów logicznych.

*lpSize*<br/>
Wskazuje na strukturę [rozmiaru](/windows/win32/api/windef/ns-windef-size) lub obiekt [CSize](../../atl-mfc-shared/reference/csize-class.md) .

### <a name="remarks"></a>Uwagi

Funkcja mapuje współrzędne każdego punktu lub wymiaru rozmiaru z systemu współrzędnych urządzenia do logicznego układu współrzędnych GDI. Konwersja zależy od bieżącego trybu mapowania oraz ustawień źródeł i zakresów dla okna i okienka ekranu urządzenia.

## <a name="cdcdraw3drect"></a><a name="draw3drect"></a>Przechwytywanie zmian::D raw3dRect

Wywołaj tę funkcję elementu członkowskiego, aby narysować trójwymiarowy prostokąt.

```cpp
void Draw3dRect(
    LPCRECT lpRect,
    COLORREF clrTopLeft,
    COLORREF clrBottomRight);

void Draw3dRect(
    int x,
    int y,
    int cx,
    int cy,
    COLORREF clrTopLeft,
    COLORREF clrBottomRight);
```

### <a name="parameters"></a>Parametry

*lpRect*<br/>
Określa prostokąt ograniczenia (w jednostkach logicznych). Można przekazać wskaźnik do struktury [Rect](/windows/win32/api/windef/ns-windef-rect) lub obiektu [CRect](../../atl-mfc-shared/reference/crect-class.md) dla tego parametru.

*clrTopLeft*<br/>
Określa kolor górnej i lewej krawędzi trójwymiarowego prostokąta.

*clrBottomRight*<br/>
Określa kolor dolnej i prawej strony prostokąta trójwymiarowego.

*x*<br/>
Określa logiczną współrzędną x lewego górnego rogu prostokąta trójwymiarowego.

*t*<br/>
Określa logiczną współrzędną y lewego górnego rogu prostokąta trójwymiarowego.

*CX*<br/>
Określa szerokość trójwymiarowego prostokąta.

*cy*<br/>
Określa wysokość prostokąta trójwymiarowego.

### <a name="remarks"></a>Uwagi

Prostokąt zostanie narysowany przy użyciu górnej i lewej strony w kolorze określonym przez *clrTopLeft* oraz u dołu i prawej stronie koloru określonego przez *clrBottomRight*.

### <a name="example"></a>Przykład

[!code-cpp[NVC_MFCDocView#33](../../mfc/codesnippet/cpp/cdc-class_5.cpp)]

## <a name="cdcdrawdragrect"></a><a name="drawdragrect"></a>Przechwytywanie zmian::D rawDragRect

Wywołaj tę funkcję elementu członkowskiego wielokrotnie, aby ponownie narysować prostokąt przeciągania.

```cpp
void DrawDragRect(
    LPCRECT lpRect,
    SIZE size,
    LPCRECT lpRectLast,
    SIZE sizeLast,
    CBrush* pBrush = NULL,
    CBrush* pBrushLast = NULL);
```

### <a name="parameters"></a>Parametry

*lpRect*<br/>
Wskazuje [na strukturę](/windows/win32/api/windef/ns-windef-rect) prostokąta lub obiekt [CRect](../../atl-mfc-shared/reference/crect-class.md) , który określa współrzędne logiczne prostokąta — w tym przypadku położenie końcowe prostokąta.

*zmienia*<br/>
Określa przemieszczenie od lewego górnego rogu obramowania zewnętrznego do lewego górnego rogu obramowania wewnętrznego (czyli grubości obramowania) prostokąta.

*lpRectLast*<br/>
Wskazuje na strukturę [Rect](/windows/win32/api/windef/ns-windef-rect) lub obiekt [CRect](../../atl-mfc-shared/reference/crect-class.md) , który określa współrzędne logiczne położenia prostokąta — w tym przypadku oryginalne położenie prostokąta jest odświeżane.

*sizeLast*<br/>
Określa przemieszczenie od lewego górnego rogu obramowania zewnętrznego do lewego górnego rogu obramowania wewnętrznego (oznacza to grubość obramowania) oryginalnego prostokąta.

*pBrush*<br/>
Wskaźnik do obiektu pędzla. Ustaw wartość NULL, aby użyć domyślnego pędzla półtonów.

*pBrushLast*<br/>
Wskaźnik do ostatniego użytego obiektu pędzla. Ustaw wartość NULL, aby użyć domyślnego pędzla półtonów.

### <a name="remarks"></a>Uwagi

Wywołaj ją w pętli jako przykładową pozycję myszy, aby przedstawić wizualną opinię. Po wywołaniu `DrawDragRect` , poprzedni prostokąt zostanie wymazany i zostanie narysowany nowy. Na przykład, gdy użytkownik przeciąga prostokąt na ekranie, `DrawDragRect` usunie oryginalny prostokąt i ponownie narysuje nowy element w nowym położeniu. Domyślnie program `DrawDragRect` rysuje prostokąt przy użyciu pędzla półtonów w celu wyeliminowania migotania i utworzenia wyglądu gładkiego prostokąta.

Przy pierwszym wywołaniu `DrawDragRect` parametr *lpRectLast* powinien mieć wartość null.

## <a name="cdcdrawedge"></a><a name="drawedge"></a>Przechwytywanie zmian::D rawEdge

Wywołaj tę funkcję elementu członkowskiego, aby narysować krawędzie prostokąta określonego typu i stylu.

```
BOOL DrawEdge(
    LPRECT lpRect,
    UINT nEdge,
    UINT nFlags);
```

### <a name="parameters"></a>Parametry

*lpRect*<br/>
Wskaźnik do `RECT` struktury zawierającej współrzędne logiczne prostokąta.

*nEdge*<br/>
Określa typ krawędzi wewnętrznej i zewnętrznej do rysowania. Ten parametr musi być kombinacją jednej flagi wewnętrznej krawędzi i jednej flagi zewnętrznego obramowania. Zobacz [DrawEdge](/windows/win32/api/winuser/nf-winuser-drawedge) w Windows SDK tabeli typów parametrów.

*nFlags*<br/>
Flagi określające typ obramowania, które ma zostać narysowane. Zobacz `DrawEdge` w Windows SDK tabeli wartości parametru. W przypadku linii ukośnych flagi BF_RECT określają punkt końcowy wektora ograniczonego przez parametr prostokąta.

### <a name="return-value"></a>Wartość zwracana

Niezerowe, jeśli pomyślne; w przeciwnym razie 0.

## <a name="cdcdrawescape"></a><a name="drawescape"></a>Przechwytywanie zmian::D rawEscape

Uzyskuje dostęp do możliwości rysowania wideo, które nie są bezpośrednio dostępne za pomocą interfejsu urządzenia graficznego (GDI).

```
int DrawEscape(
    int nEscape,
    int nInputSize,
    LPCSTR lpszInputData);
```

### <a name="parameters"></a>Parametry

*nEscape*<br/>
Określa funkcję ucieczki, która ma zostać wykonana.

*nInputSize*<br/>
Określa liczbę bajtów danych wskazywanych przez parametr *lpszInputData* .

*lpszInputData*<br/>
Wskazuje strukturę wejściową wymaganą dla określonej ucieczki.

### <a name="return-value"></a>Wartość zwracana

Określa wynik funkcji. Większe niż zero, jeśli się powiedzie, z wyjątkiem QUERYESCSUPPORT rysowania ucieczki, która sprawdza tylko implementację; lub zero, jeśli Ucieczka nie jest zaimplementowana; lub mniejsze od zera w przypadku wystąpienia błędu.

### <a name="remarks"></a>Uwagi

W przypadku wywołania aplikacji `DrawEscape` dane identyfikowane przez *NInputSize* i *lpszInputData* są przesyłane bezpośrednio do określonego sterownika ekranu.

## <a name="cdcdrawfocusrect"></a><a name="drawfocusrect"></a>Przechwytywanie zmian::D rawFocusRect

Rysuje prostokąt w stylu używanym do wskazywania, że prostokąt ma fokus.

```cpp
void DrawFocusRect(LPCRECT lpRect);
```

### <a name="parameters"></a>Parametry

*lpRect*<br/>
Wskazuje strukturę [Rect](/windows/win32/api/windef/ns-windef-rect) lub obiekt [CRect](../../atl-mfc-shared/reference/crect-class.md) , który określa współrzędne logiczne prostokąta do narysowania.

### <a name="remarks"></a>Uwagi

Ponieważ jest to logiczna funkcja XOR, wywołanie tej funkcji po raz drugi z tym samym prostokątem usuwa prostokąt z ekranu. Nie można przewinąć prostokąta rysowanego przez tę funkcję. Aby przewinąć obszar zawierający prostokąt rysowany przez tę funkcję, najpierw należy wywołać, `DrawFocusRect` Aby usunąć prostokąt z ekranu, a następnie przewinąć obszar, a następnie ponownie wywołać, `DrawFocusRect` Aby narysować prostokąt w nowym położeniu.

> [!CAUTION]
> `DrawFocusRect`działa tylko w trybie MM_TEXT. W innych trybach ta funkcja nie rysuje prostokąta fokusu poprawnie, ale nie zwraca wartości błędów.

## <a name="cdcdrawframecontrol"></a><a name="drawframecontrol"></a>Przechwytywanie zmian::D rawFrameControl

Wywołaj tę funkcję elementu członkowskiego, aby narysować kontrolkę Frame o określonym typie i stylu.

```
BOOL DrawFrameControl(
    LPRECT lpRect,
    UINT nType,
    UINT nState);
```

### <a name="parameters"></a>Parametry

*lpRect*<br/>
Wskaźnik do `RECT` struktury zawierającej współrzędne logiczne prostokąta.

*Npowiadomienia*<br/>
Określa typ kontrolki ramki do narysowania. Aby uzyskać listę możliwych wartości tego parametru, zobacz parametr *uType* w [DrawFrameControl](/windows/win32/api/winuser/nf-winuser-drawframecontrol) w Windows SDK.

*nInformacje*<br/>
Określa początkowy stan kontrolki ramki. Może to być co najmniej jedna wartość opisana dla parametru *uState* w `DrawFrameControl` Windows SDK. Użyj DFCS_ADJUSTRECT wartość *nInformacje* , aby dostosować prostokąt ograniczający do wykluczenia otaczającej krawędzi przycisku push.

### <a name="return-value"></a>Wartość zwracana

Niezerowe, jeśli pomyślne; w przeciwnym razie 0.

### <a name="remarks"></a>Uwagi

W kilku przypadkach *nInformacje* zależy od parametru *npowiadomienia* . Na poniższej liście przedstawiono relacje między czterema wartościami *npowiadomienia* i *nInformacje*:

- DFC_BUTTON

  - DFCS_BUTTON3STATE przycisk z trzema Stanami

  - Pole wyboru DFCS_BUTTONCHECK

  - DFCS_BUTTONPUSH przycisku push

  - Przycisk radiowy DFCS_BUTTONRADIO

  - Obraz DFCS_BUTTONRADIOIMAGE przycisku radiowego (obraz wymaga obrazu niekwadratowego)

  - Maska DFCS_BUTTONRADIOMASK dla przycisku radiowego (Maska niekwadratowa wymaga maski)

- DFC_CAPTION

  - Przycisk DFCS_CAPTIONCLOSE Zamknij

  - Przycisk pomocy DFCS_CAPTIONHELP

  - Przycisk Maksymalizuj DFCS_CAPTIONMAX

  - Przycisk DFCS_CAPTIONMIN Minimalizuj

  - DFCS_CAPTIONRESTORE przycisk Przywróć

- DFC_MENU

  - Strzałka podmenu DFCS_MENUARROW

  - DFCS_MENUBULLET Bullet

  - Znacznik wyboru DFCS_MENUCHECK

- DFC_SCROLL

  - Pasek przewijania DFCS_SCROLLCOMBOBOX pola kombi

  - DFCS_SCROLLDOWN strzałkę w dół paska przewijania

  - DFCS_SCROLLLEFT lewej strzałki paska przewijania

  - DFCS_SCROLLRIGHT Strzałka w prawo paska przewijania

  - Uchwyt rozmiaru DFCS_SCROLLSIZEGRIP w prawym dolnym rogu okna

  - DFCS_SCROLLUP Strzałka w górę paska przewijania

### <a name="example"></a>Przykład

Ten kod rysuje uchwyt rozmiaru w prawym dolnym rogu okna. Jest ona odpowiednia dla `OnPaint` procedury obsługi okna dialogowego, które nie ma stylów i zwykle nie zawiera innych kontrolek (takich jak pasek stanu), które mogą dać uchwyt rozmiaru.

[!code-cpp[NVC_MFCDocView#34](../../mfc/codesnippet/cpp/cdc-class_6.cpp)]

## <a name="cdcdrawicon"></a><a name="drawicon"></a>Przechwytywanie zmian::D rawIcon

Rysuje ikonę na urządzeniu reprezentowanej przez bieżący `CDC` obiekt.

```
BOOL DrawIcon(
    int x,
    int y,
    HICON hIcon);

BOOL DrawIcon(
    POINT point,
    HICON hIcon);
```

### <a name="parameters"></a>Parametry

*x*<br/>
Określa logiczną współrzędną x lewego górnego rogu ikony.

*t*<br/>
Określa logiczną współrzędną y lewego górnego rogu ikony.

*hIcon*<br/>
Identyfikuje uchwyt ikony do narysowania.

*moment*<br/>
Określa logiczne współrzędne x i y lewego górnego rogu ikony. Dla tego parametru można przekazać strukturę [punktu](/windows/win32/api/windef/ns-windef-point) lub obiekt [CPoint](../../atl-mfc-shared/reference/cpoint-class.md) .

### <a name="return-value"></a>Wartość zwracana

Niezerowe, jeśli funkcja została ukończona pomyślnie; w przeciwnym razie 0.

### <a name="remarks"></a>Uwagi

Funkcja umieszcza lewym górnym rogu ikony w lokalizacji określonej przez wartości *x* i *y*. Lokalizacja jest objęta bieżącym trybem mapowania kontekstu urządzenia.

Zasób ikony musi być poprzednio załadowany przy użyciu funkcji `CWinApp::LoadIcon` , `CWinApp::LoadStandardIcon` lub `CWinApp::LoadOEMIcon` . `MM_TEXT`Przed użyciem tej funkcji należy wybrać tryb mapowania.

### <a name="example"></a>Przykład

  Zobacz przykład dla [CWnd:: isicon](../../mfc/reference/cwnd-class.md#isiconic).

## <a name="cdcdrawstate"></a><a name="drawstate"></a>Przechwytywanie zmian::D rawState

Wywołaj tę funkcję elementu członkowskiego, aby wyświetlić obraz i zastosować efekt wizualny, aby wskazać stan, taki jak stan wyłączony lub domyślny.

> [!NOTE]
> Dla wszystkich stanów *nFlag* , z wyjątkiem DSS_NORMAL, obraz jest konwertowany na monochromatyczny przed zastosowaniem efektu wizualnego.

```
BOOL DrawState(
    CPoint pt,
    CSize size,
    HBITMAP hBitmap,
    UINT nFlags,
    HBRUSH hBrush = NULL);

BOOL DrawState(
    CPoint pt,
    CSize size,
    CBitmap* pBitmap,
    UINT nFlags,
    CBrush* pBrush = NULL);

BOOL DrawState(
    CPoint pt,
    CSize size,
    HICON hIcon,
    UINT nFlags,
    HBRUSH hBrush = NULL);

BOOL DrawState(
    CPoint pt,
    CSize size,
    HICON hIcon,
    UINT nFlags,
    CBrush* pBrush = NULL);

BOOL DrawState(
    CPoint pt,
    CSize size,
    LPCTSTR lpszText,
    UINT nFlags,
    BOOL bPrefixText = TRUE,
    int nTextLen = 0,
    HBRUSH hBrush = NULL);

BOOL DrawState(
    CPoint pt,
    CSize size,
    LPCTSTR lpszText,
    UINT nFlags,
    BOOL bPrefixText = TRUE,
    int nTextLen = 0,
    CBrush* pBrush = NULL);

BOOL DrawState(
    CPoint pt,
    CSize size,
    DRAWSTATEPROC lpDrawProc,
    LPARAM lData,
    UINT nFlags,
    HBRUSH hBrush = NULL);

BOOL DrawState(
    CPoint pt,
    CSize size,
    DRAWSTATEPROC lpDrawProc,
    LPARAM lData,
    UINT nFlags,
    CBrush* pBrush = NULL);
```

### <a name="parameters"></a>Parametry

*zmiennoprzecinkow*<br/>
Określa lokalizację obrazu.

*zmienia*<br/>
Określa rozmiar obrazu.

*hBitmap*<br/>
Uchwyt do mapy bitowej.

*nFlags*<br/>
Flagi określające typ i stan obrazu. Aby uzyskać możliwe typy i Stany *nFlags* , zobacz [DrawState](/windows/win32/api/winuser/nf-winuser-drawstatew) w Windows SDK.

*hBrush*<br/>
Uchwyt do pędzla.

*pBitmap*<br/>
Wskaźnik do obiektu CBitmap.

*pBrush*<br/>
Wskaźnik do obiektu CBrush.

*hIcon*<br/>
Uchwyt do ikony.

*lpszText*<br/>
Wskaźnik do tekstu.

*bPrefixText*<br/>
Tekst, który może zawierać skrót skrótu. Parametr *lData* określa adres ciągu, a parametr *nTextLen* określa długość. Jeśli *nTextLen* jest równa 0, przyjmuje się, że ciąg jest zakończony znakiem null.

*nTextLen*<br/>
Długość ciągu tekstowego wskazywanego przez *lpszText*. Jeśli *nTextLen* jest równa 0, przyjmuje się, że ciąg jest zakończony znakiem null.

*lpDrawProc*<br/>
Wskaźnik do funkcji wywołania zwrotnego służącej do renderowania obrazu. Ten parametr jest wymagany, jeśli typ obrazu w *nFlags* jest DST_COMPLEX. Jest to opcjonalne i może mieć wartość NULL, jeśli typ obrazu to DST_TEXT. Dla wszystkich innych typów obrazów ten parametr jest ignorowany. Aby uzyskać więcej informacji na temat funkcji wywołania zwrotnego, zobacz funkcję [DrawStateProc](/windows/win32/api/winuser/nc-winuser-drawstateproc) w Windows SDK.

*lData*<br/>
Określa informacje o obrazie. Znaczenie tego parametru zależy od typu obrazu.

### <a name="return-value"></a>Wartość zwracana

Niezerowe, jeśli pomyślne; w przeciwnym razie 0.

## <a name="cdcdrawtext"></a><a name="drawtext"></a>Przechwytywanie zmian::D rawText

Wywołaj tę funkcję elementu członkowskiego, aby sformatować tekst w danym prostokącie. Aby określić dodatkowe opcje formatowania, użyj metody [przechwytywania::D rawtextex](#drawtextex).

```
virtual int DrawText(
    LPCTSTR lpszString,
    int nCount,
    LPRECT lpRect,
    UINT nFormat);

int DrawText(
    const CString& str,
    LPRECT lpRect,
    UINT nFormat);
```

### <a name="parameters"></a>Parametry

*lpszString*<br/>
Wskazuje ciąg do narysowania. Jeśli *nCount* jest-1, ciąg musi być zakończony znakiem null.

*nCount*<br/>
Określa liczbę znaków w ciągu. Jeśli *nCount* to-1, przyjmuje się, że *lpszString* jest długim wskaźnikiem do ciągu zakończonego wartością null i `DrawText` automatycznie oblicza liczbę znaków.

*lpRect*<br/>
Wskazuje strukturę [Rect](/windows/win32/api/windef/ns-windef-rect) lub obiekt [CRect](../../atl-mfc-shared/reference/crect-class.md) , który zawiera prostokąt (we współrzędnych logicznych), w którym tekst ma być sformatowany.

*str*<br/>
Obiekt [CString](../../atl-mfc-shared/reference/cstringt-class.md) , który zawiera określone znaki do narysowania.

*nFormat*<br/>
Określa metodę formatowania tekstu. Może to być dowolna kombinacja wartości opisanych dla parametru *uFormat* w [DrawText](/windows/win32/api/winuser/nf-winuser-drawtext) w Windows SDK. (Połącz przy użyciu operatora bitowego or):

> [!NOTE]
> Niektóre kombinacje flag *uFormat* mogą spowodować modyfikację przesłanego ciągu. Użycie DT_MODIFYSTRING z DT_END_ELLIPSIS lub DT_PATH_ELLIPSIS może spowodować modyfikację ciągu, powodując potwierdzenie w `CString` przesłonięciu. Wartości DT_CALCRECT, DT_EXTERNALLEADING, DT_INTERNAL, DT_NOCLIP i DT_NOPREFIX nie mogą być używane z wartością DT_TABSTOP.

### <a name="return-value"></a>Wartość zwracana

Wysokość tekstu, jeśli funkcja się powiedzie.

### <a name="remarks"></a>Uwagi

Formatuje tekst przez powiększanie kart w odpowiednie miejsca, wyrównywanie tekstu do lewej, prawej lub środka danego prostokąta, a także przerywanie tekstu do wierszy, które mieszczą się w danym prostokącie. Typ formatowania jest określany przez *nFormat*.

Ta funkcja elementu członkowskiego służy do narysowania tekstu przy użyciu wybranej czcionki, koloru tekstu i koloru tła dla kontekstu urządzenia. Jeśli format DT_NOCLIP nie jest używany, program `DrawText` przycina tekst tak, aby tekst nie był wyświetlany poza danym prostokątem. Przyjmuje się, że całe formatowanie ma wiele wierszy, chyba że zostanie określony format DT_SINGLELINE.

Jeśli wybrana czcionka jest zbyt duża dla określonego prostokąta, `DrawText` funkcja członkowska nie próbuje zastąpić mniejszej czcionki.

Jeśli flaga DT_CALCRECT jest określona, prostokąt określony przez *lpRect* zostanie zaktualizowany w celu odzwierciedlenia szerokości i wysokości wymaganej do narysowania tekstu.

Jeśli ustawiono TA_UPDATECP flagę wyrównania tekstu (zobacz element przestawny [:: TextAlign](#settextalign)), program `DrawText` wyświetli tekst zaczynający się na bieżącym miejscu, a nie na lewo od danego prostokąta. `DrawText`nie otacza tekstu po ustawieniu flagi TA_UPDATECP (oznacza to, że flaga DT_WORDBREAK nie będzie miała żadnego efektu).

Kolor tekstu może być ustawiony przez wartość [przechwytywania:: SetTextColor](#settextcolor).

## <a name="cdcdrawtextex"></a><a name="drawtextex"></a>Przechwytywanie zmian::D rawTextEx

Formatuje tekst w danym prostokącie.

```
virtual int DrawTextEx(
    LPTSTR lpszString,
    int nCount,
    LPRECT lpRect,
    UINT nFormat,
    LPDRAWTEXTPARAMS lpDTParams);

int DrawTextEx(
    const CString& str,
    LPRECT lpRect,
    UINT nFormat,
    LPDRAWTEXTPARAMS lpDTParams);
```

### <a name="parameters"></a>Parametry

*lpszString*<br/>
Wskazuje ciąg do narysowania. Jeśli *nCount* jest-1, ciąg musi być zakończony wartością null.

*nCount*<br/>
Określa liczbę znaków w ciągu. Jeśli *nCount* to-1, przyjmuje się, że *lpszString* jest długim wskaźnikiem do ciągu zakończonego wartością null i `DrawText` automatycznie oblicza liczbę znaków.

*lpRect*<br/>
Wskazuje strukturę [Rect](/windows/win32/api/windef/ns-windef-rect) lub obiekt [CRect](../../atl-mfc-shared/reference/crect-class.md) , który zawiera prostokąt (we współrzędnych logicznych), w którym tekst ma być sformatowany.

*str*<br/>
Obiekt [CString](../../atl-mfc-shared/reference/cstringt-class.md) , który zawiera określone znaki do narysowania.

*nFormat*<br/>
Określa metodę formatowania tekstu. Może to być dowolna kombinacja wartości opisanych dla parametru *uFormat* w [DrawText](/windows/win32/api/winuser/nf-winuser-drawtext) w Windows SDK. (Połącz przy **użyciu operatora bitowego or)** :

> [!NOTE]
> Niektóre kombinacje flag *uFormat* mogą spowodować modyfikację przesłanego ciągu. Użycie DT_MODIFYSTRING z DT_END_ELLIPSIS lub DT_PATH_ELLIPSIS może spowodować modyfikację ciągu, powodując potwierdzenie w `CString` przesłonięciu. Wartości DT_CALCRECT, DT_EXTERNALLEADING, DT_INTERNAL, DT_NOCLIP i DT_NOPREFIX nie mogą być używane z wartością DT_TABSTOP.

*lpDTParams*<br/>
Wskaźnik na strukturę [DRAWTEXTPARAMS](/windows/win32/api/winuser/ns-winuser-drawtextparams) , która określa dodatkowe opcje formatowania. Ten parametr może mieć wartość NULL.

### <a name="remarks"></a>Uwagi

Formatuje tekst przez powiększanie kart w odpowiednie miejsca, wyrównywanie tekstu do lewej, prawej lub środka danego prostokąta, a także przerywanie tekstu do wierszy, które mieszczą się w danym prostokącie. Typ formatowania jest określany przez *nFormat* i *lpDTParams*. Aby uzyskać więcej informacji, zobacz sekcję [przechwytywania::D rawtext](#drawtext) i [DrawTextEx](/windows/win32/api/winuser/nf-winuser-drawtextexw) w Windows SDK.

Kolor tekstu może być ustawiony przez wartość [przechwytywania:: SetTextColor](#settextcolor).

## <a name="cdcellipse"></a><a name="ellipse"></a>Reprzechwytywania:: elipsa

Rysuje elipsę.

```
BOOL Ellipse(
    int x1,
    int y1,
    int x2,
    int y2);

BOOL Ellipse(LPCRECT lpRect);
```

### <a name="parameters"></a>Parametry

*x1*<br/>
Określa logiczną współrzędną x lewego górnego rogu prostokąta obwiedni.

*Y1*<br/>
Określa logiczną współrzędną y lewego górnego rogu prostokąta obwiedni.

*x2*<br/>
Określa logiczną współrzędną x dolnego prawego dolnego rogu prostokąta obwiedni.

*Y2*<br/>
Określa logiczną współrzędną y w prawym dolnym rogu prostokąta obwiedni.

*lpRect*<br/>
Określa prostokąt powiązany z elipsą. Można również przekazać obiekt [CRect](../../atl-mfc-shared/reference/crect-class.md) dla tego parametru.

### <a name="return-value"></a>Wartość zwracana

Różne od zera, jeśli funkcja zakończyła się pomyślnie; w przeciwnym razie 0.

### <a name="remarks"></a>Uwagi

Środek wielokropka jest środkowym prostokątem obwiedni określonym przez *x1*, *Y1*, *X2*i *Y2*lub *lpRect*. Elipsa jest rysowana z bieżącym piórem, a jej wnętrze jest wypełnione bieżącym pędzlem.

Rysunek rysowany przez tę funkcję rozszerza się do, ale nie zawiera, współrzędne praw i dolny. Oznacza to, że wysokość rysunku to *Y2*  -  *Y1* , a szerokość rysunku to *X2*  -  *x1*.

Jeśli szerokość lub wysokość prostokąta ograniczenia ma wartość 0, wielokropek nie jest rysowany.

## <a name="cdcenddoc"></a><a name="enddoc"></a>Przechwytywanie zmian:: EndDoc

Zamyka zadanie drukowania uruchomione przez wywołanie funkcji składowej [StartDoc](#startdoc) .

```
int EndDoc();
```

### <a name="return-value"></a>Wartość zwracana

Większe niż lub równe 0, jeśli funkcja jest pomyślna lub wartość ujemna, jeśli wystąpił błąd.

### <a name="remarks"></a>Uwagi

Ta funkcja członkowska zastępuje drukarkę ENDDOC Escape i powinna być wywoływana natychmiast po zakończeniu zadania drukowania zakończonego powodzeniem.

Jeśli aplikacja napotka błąd drukowania lub anulowaną operację drukowania, nie może ona próbować zakończyć operacji przy użyciu `EndDoc` lub [AbortDoc](#abortdoc). Interfejs GDI automatycznie kończy operację przed zwróceniem wartości błędu.

Tej funkcji nie należy używać wewnątrz plików.

### <a name="example"></a>Przykład

  Zobacz przykład dla danych [przechwytywania:: StartDoc](#startdoc).

## <a name="cdcendpage"></a><a name="endpage"></a>Przechwytywanie zmian:: EndPage

Informuje urządzenie, że aplikacja zakończyła zapisywanie na stronie.

```
int EndPage();
```

### <a name="return-value"></a>Wartość zwracana

Większe niż lub równe 0, jeśli funkcja jest pomyślna lub wartość ujemna, jeśli wystąpił błąd.

### <a name="remarks"></a>Uwagi

Ta funkcja członkowska jest zwykle używana do kierowania sterownika urządzenia do nowej strony.

Ta funkcja członkowska zastępuje NEWFRAME drukarki. W przeciwieństwie do NEWFRAME, ta funkcja jest zawsze wywoływana po wydrukowaniu strony.

### <a name="example"></a>Przykład

  Zobacz przykład dla danych [przechwytywania:: StartDoc](#startdoc).

## <a name="cdcendpath"></a><a name="endpath"></a>Przechwytywanie zmian:: EndPath

Zamyka nawias ścieżki i wybiera ścieżkę zdefiniowaną przez nawias w kontekście urządzenia.

```
BOOL EndPath();
```

### <a name="return-value"></a>Wartość zwracana

Różne od zera, jeśli funkcja zakończyła się pomyślnie; w przeciwnym razie 0.

### <a name="example"></a>Przykład

  Zobacz przykład dla danych [przechwytywania:: BeginPath](#beginpath).

## <a name="cdcenumobjects"></a><a name="enumobjects"></a>Przechwytywanie zmian:: EnumObjects

Wylicza pióra i pędzle dostępne w kontekście urządzenia.

```
int EnumObjects(
    int nObjectType,
    int (CALLBACK* lpfn)(
    LPVOID,
    LPARAM),
    LPARAM lpData);
```

### <a name="parameters"></a>Parametry

*nObjectType*<br/>
Określa typ obiektu. Może mieć wartości OBJ_BRUSH lub OBJ_PEN.

*lpfn*<br/>
Jest adresem wystąpienia procedury funkcji wywołania zwrotnego dostarczonej przez aplikację. Zobacz sekcję "uwagi" poniżej.

*lpData*<br/>
Wskazuje dane dostarczone przez aplikację. Dane są przesyłane do funkcji wywołania zwrotnego wraz z informacjami o obiekcie.

### <a name="return-value"></a>Wartość zwracana

Określa ostatnią wartość zwracaną przez [funkcję wywołania zwrotnego](callback-functions-used-by-mfc.md#enum_objects). Jego znaczenie jest zdefiniowane przez użytkownika.

### <a name="remarks"></a>Uwagi

Dla każdego obiektu danego typu funkcja wywołania zwrotnego jest wywoływana z informacjami dla tego obiektu. System wywołuje funkcję wywołania zwrotnego do momentu, gdy nie ma więcej obiektów lub funkcja wywołania zwrotnego zwróci wartość 0.

Należy pamiętać, że nowe funkcje Microsoft Visual C++ umożliwiają użycie zwykłej funkcji jako funkcji przekazaną do `EnumObjects` . Adres przesłany do `EnumObjects` jest wskaźnikiem do funkcji wyeksportowanej z **eksportem** i konwencją wywoływania Pascal. W aplikacjach trybu ochrony nie trzeba tworzyć tej funkcji za pomocą funkcji MakeProcInstance systemu Windows ani zwalniać funkcji po użyciu z funkcją systemu Windows FreeProcInstance.

Nie trzeba również eksportować nazwy funkcji w instrukcji **exports** w pliku definicji modułu aplikacji. Zamiast tego można użyć modyfikatora funkcji **Export** , jak w

**eksport wywołania zwrotnego int** AFunction **(LPSTR**, **LPSTR);**

Aby spowodować, że kompilator emituje właściwy rekord eksportu do eksportu przez nazwę bez aliasowania. Działa to w przypadku większości potrzeb. W przypadku niektórych specjalnych przypadków, takich jak Eksportowanie funkcji przez numer porządkowy lub alias eksportu, nadal trzeba użyć instrukcji **eksports** w pliku definicji modułu.

W przypadku kompilowania programów Microsoft Foundation zwykle używane są opcje kompilatora/GA i/GEs. Opcja kompilatora/GW nie jest używana w przypadku klas Microsoft Foundation. (Jeśli używasz funkcji systemu Windows, musisz `MakeProcInstance` jawnie rzutować zwracany wskaźnik funkcji z FARPROC na typ wymagany w tym interfejsie API). Interfejsy rejestracji wywołania zwrotnego są teraz bezpieczne dla typów (należy przekazać wskaźnik funkcji, który wskazuje na właściwy rodzaj funkcji dla określonego wywołania zwrotnego).

Należy również zauważyć, że wszystkie funkcje wywołania zwrotnego muszą mieć pułapki wyjątki programu Microsoft Foundation przed powrotem do systemu Windows, ponieważ nie można zgłaszać wyjątków dla granic wywołania zwrotnego. Aby uzyskać więcej informacji o wyjątkach, zobacz [wyjątki](../../mfc/exception-handling-in-mfc.md)w artykule.

### <a name="example"></a>Przykład

[!code-cpp[NVC_MFCDocView#35](../../mfc/codesnippet/cpp/cdc-class_7.cpp)]

## <a name="cdcescape"></a><a name="escape"></a>Przechwytywanie zmian:: Escape

Ta funkcja członkowska jest praktycznie przestarzała w programowaniu Win32.

```
virtual int Escape(
    int nEscape,
    int nCount,
    LPCSTR lpszInData,
    LPVOID lpOutData);

int Escape(
    int nEscape,
    int nInputSize,
    LPCSTR lpszInputData,
    int nOutputSize,
    LPSTR lpszOutputData);
```

### <a name="parameters"></a>Parametry

*nEscape*<br/>
Określa funkcję ucieczki, która ma zostać wykonana.

Aby uzyskać pełną listę funkcji ucieczki, zobacz [Escape](/windows/win32/api/wingdi/nf-wingdi-escape) w Windows SDK.

*nCount*<br/>
Określa liczbę bajtów danych wskazywanych przez *lpszInData*.

*lpszInData*<br/>
Wskazuje strukturę danych wejściowych wymaganą dla tego wyjścia.

*lpOutData*<br/>
Wskazuje strukturę, która ma otrzymywać dane wyjściowe z tego wyjścia. Parametr *lpOutData* ma wartość null, jeśli nie są zwracane żadne dane.

*nInputSize*<br/>
Określa liczbę bajtów danych wskazywanych przez parametr *lpszInputData* .

*lpszInputData*<br/>
Wskazuje strukturę wejściową wymaganą dla określonej ucieczki.

*nOutputSize*<br/>
Określa liczbę bajtów danych wskazywanych przez parametr *lpszOutputData* .

*lpszOutputData*<br/>
Wskazuje strukturę, która otrzymuje dane wyjściowe z tego wyjścia. Ten parametr powinien mieć wartość NULL, jeśli nie zostaną zwrócone żadne dane.

### <a name="return-value"></a>Wartość zwracana

Wartość dodatnia jest zwracana, jeśli funkcja się powiedzie, z wyjątkiem QUERYESCSUPPORT ucieczki, która sprawdza tylko implementację. Jeśli Escape nie jest zaimplementowany, zwracana jest wartość zero. Wartość ujemna jest zwracana w przypadku wystąpienia błędu. Poniżej przedstawiono typowe wartości błędów:

- SP_ERROR błąd ogólny.

- SP_OUTOFDISK zbyt mało miejsca na dysku, które jest obecnie dostępne do buforowania i nie będzie można uzyskać więcej miejsca.

- Za mało dostępnej pamięci do buforowania. SP_OUTOFMEMORY

- SP_USERABORT użytkownik zakończył zadanie za pomocą Menedżera wydruku.

### <a name="remarks"></a>Uwagi

Oryginalnej drukarki ucieczki, tylko QUERYESCSUPPORT jest obsługiwana dla aplikacji Win32. Wszystkie inne wyjścia drukarki są przestarzałe i są obsługiwane tylko w celu zapewnienia zgodności z aplikacjami 16-bitowymi.

W przypadku programowania Win32 program `CDC` zapewnia teraz sześć funkcji Członkowskich, które zastępują odpowiednie wyjścia drukarki:

- [Przechwytywanie zmian:: AbortDoc](#abortdoc)

- [Przechwytywanie zmian:: EndDoc](#enddoc)

- [Przechwytywanie zmian:: EndPage](#endpage)

- [Przechwytywanie zmian:: SetAbortProc](#setabortproc)

- [Przechwytywanie zmian:: StartDoc](#startdoc)

- [Przechwytywanie zmian:: StartPage](#startpage)

Ponadto polecenie przełączenia [:: GetDeviceCaps](#getdevicecaps) obsługuje indeksy Win32, które zastępują inne wyjścia drukarki. Aby uzyskać więcej informacji, zobacz [GetDeviceCaps](/windows/win32/api/wingdi/nf-wingdi-getdevicecaps) w Windows SDK.

Ta funkcja członkowska umożliwia aplikacjom dostęp do udogodnień określonego urządzenia, które nie są bezpośrednio dostępne za pomocą interfejsu GDI.

Użyj pierwszej wersji, jeśli aplikacja używa wstępnie zdefiniowanych wartości ucieczki. Użyj drugiej wersji, jeśli aplikacja definiuje prywatne wartości ucieczki. Aby uzyskać więcej informacji na temat drugiej wersji, zobacz [ExtEscape](/windows/win32/api/wingdi/nf-wingdi-extescape) w Windows SDK.

## <a name="cdcexcludecliprect"></a><a name="excludecliprect"></a>Przechwytywanie zmian:: ExcludeClipRect

Tworzy nowy region przycinania, który składa się z istniejącego regionu wycinka minus określonego prostokąta.

```
int ExcludeClipRect(
    int x1,
    int y1,
    int x2,
    int y2);

int ExcludeClipRect(LPCRECT lpRect);
```

### <a name="parameters"></a>Parametry

*x1*<br/>
Określa logiczną współrzędną x lewego górnego rogu prostokąta.

*Y1*<br/>
Określa logiczną współrzędną y lewego górnego rogu prostokąta.

*x2*<br/>
Określa logiczną współrzędną x w prawym dolnym rogu prostokąta.

*Y2*<br/>
Określa logiczną współrzędną y w prawym dolnym rogu prostokąta.

*lpRect*<br/>
Określa prostokąt. Może również być `CRect` obiektem.

### <a name="return-value"></a>Wartość zwracana

Określa typ nowego regionu wycinka. Może to być dowolna z następujących wartości:

- COMPLEXREGION region ma nakładające się obramowania.

- Błąd: nie utworzono regionu.

- NULLREGION region jest pusty.

- SIMPLEREGION region nie ma nakładających się obramowań.

### <a name="remarks"></a>Uwagi

Szerokość prostokąta określona przez wartość bezwzględną *X2*  -  *x1*nie może przekraczać 32 767 jednostek. Ten limit dotyczy również wysokości prostokąta.

## <a name="cdcexcludeupdatergn"></a><a name="excludeupdatergn"></a>Przechwytywanie zmian:: ExcludeUpdateRgn

Uniemożliwia Rysowanie w nieprawidłowych obszarach okna przez wykluczenie zaktualizowanego regionu w oknie z obszaru wycinków skojarzonego z `CDC` obiektem.

```
int ExcludeUpdateRgn(CWnd* pWnd);
```

### <a name="parameters"></a>Parametry

*pWnd*<br/>
Wskazuje obiekt okna, którego okno jest aktualizowane.

### <a name="return-value"></a>Wartość zwracana

Typ wykluczonego regionu. Może to być jedna z następujących wartości:

- COMPLEXREGION region ma nakładające się obramowania.

- Błąd: nie utworzono regionu.

- NULLREGION region jest pusty.

- SIMPLEREGION region nie ma nakładających się obramowań.

## <a name="cdcextfloodfill"></a><a name="extfloodfill"></a>Przechwytywanie zmian:: ExtFloodFill

Wypełnia obszar wyświetlania powierzchni bieżącym pędzlem.

```
BOOL ExtFloodFill(
    int x,
    int y,
    COLORREF crColor,
    UINT nFillType);
```

### <a name="parameters"></a>Parametry

*x*<br/>
Określa logiczną współrzędną x punktu, w którym rozpoczyna się napełnianie.

*t*<br/>
Określa logiczną współrzędną y punktu, w którym rozpoczyna się napełnianie.

*crColor*<br/>
Określa kolor granicy lub obszaru, który ma zostać wypełniony. Interpretacja *crColor* zależy od wartości *nFillType*.

*nFillType*<br/>
Określa typ wypełnienia, które ma zostać wykonane. Musi mieć jedną z następujących wartości:

- FLOODFILLBORDER obszar wypełnienia jest ograniczony przez kolor określony przez *crColor*. Ten styl jest identyczny z wypełnieniem wykonanym przez `FloodFill` .

- FLOODFILLSURFACE obszar wypełnienia jest definiowany przez kolor określony przez *crColor*. Wypełnienie jest kontynuowane na zewnątrz we wszystkich kierunkach, o ile napotkany jest kolor. Ten styl jest przydatny do wypełniania obszarów z wielokolorowymi granicami.

### <a name="return-value"></a>Wartość zwracana

Niezerowe, jeśli funkcja się powiedzie; w przeciwnym razie wartość 0, jeśli nie można ukończyć wypełniania, jeśli dany punkt ma kolor graniczny określony przez *crColor* (jeśli zażądano FLOODFILLBORDER), jeśli dany punkt nie ma koloru określonego przez *crColor* (jeśli zażądano FLOODFILLSURFACE) lub jeśli punkt znajduje się poza regionem przycinania.

### <a name="remarks"></a>Uwagi

Ta funkcja członkowska zapewnia większą elastyczność niż `FloodFill` , ponieważ można określić typ wypełnienia w *nFillType*.

Jeśli *nFillType* jest ustawiona na FLOODFILLBORDER, obszar jest założono, że jest całkowicie ograniczony przez kolor określony przez *crColor*. Funkcja rozpoczyna się od punktu określonego przez *x* i *y* i wypełnia wszystkie kierunki do granicy koloru.

Jeśli *nFillType* jest ustawiona na FLOODFILLSURFACE, funkcja rozpoczyna się w punkcie określonym przez *x* i *y* i kontynuuje wszystkie kierunki, wypełniając wszystkie przylegające obszary zawierające kolor określony przez *crColor*.

Tylko konteksty urządzenia pamięci i urządzenia obsługujące obsługę technologii rastrowych `ExtFloodFill` . Aby uzyskać więcej informacji, zobacz funkcja członkowska [GetDeviceCaps](#getdevicecaps) .

## <a name="cdcexttextout"></a><a name="exttextout"></a>Przechwytywanie zmian:: ExtTextOut

Wywołaj tę funkcję elementu członkowskiego, aby napisać ciąg znaków w regionie prostokąta przy użyciu aktualnie zaznaczonej czcionki.

```
virtual BOOL ExtTextOut(
    int x,
    int y,
    UINT nOptions,
    LPCRECT lpRect,
    LPCTSTR lpszString,
    UINT nCount,
    LPINT lpDxWidths);

BOOL ExtTextOut(
    int x,
    int y,
    UINT nOptions,
    LPCRECT lpRect,
    const CString& str,
    LPINT lpDxWidths);
```

### <a name="parameters"></a>Parametry

*x*<br/>
Określa logiczną współrzędną x dla pierwszego znaku w określonym ciągu.

*t*<br/>
Określa logiczną współrzędną y górnej krawędzi komórki Character dla pierwszego znaku w określonym ciągu.

*nOptions*<br/>
Określa typ prostokąta. Ten parametr może mieć jedną z następujących wartości:

- ETO_CLIPPED określa, że tekst jest obcinany do prostokąta.

- ETO_OPAQUE określa, że bieżący kolor tła wypełnia prostokąt. (Można ustawić bieżący kolor tła i zbadać go za pomocą funkcji składowych [SetBkColor](#setbkcolor) i [GetBkColor](#getbkcolor) ).

*lpRect*<br/>
Wskazuje strukturę [Rect](/windows/win32/api/windef/ns-windef-rect) , która określa wymiary prostokąta. Ten parametr może mieć wartość NULL. Można również przekazać obiekt [CRect](../../atl-mfc-shared/reference/crect-class.md) dla tego parametru.

*lpszString*<br/>
Wskazuje określony ciąg znaków do narysowania. Można również przekazać obiekt [CString](../../atl-mfc-shared/reference/cstringt-class.md) dla tego parametru.

*nCount*<br/>
Określa liczbę znaków w ciągu.

*lpDxWidths*<br/>
Wskazuje tablicę wartości, która wskazuje odległość między źródłami sąsiadujących znaków. Na przykład jednostki logiczne *lpDxWidths*[ *i*] oddzielają źródła *znaku i komórki* znaku *i + 1* . Jeśli *lpDxWidths* ma wartość null, `ExtTextOut` używa domyślnego odstępu między znakami.

*str*<br/>
`CString`Obiekt, który zawiera określone znaki do narysowania.

### <a name="return-value"></a>Wartość zwracana

Różne od zera, jeśli funkcja zakończyła się pomyślnie; w przeciwnym razie 0.

### <a name="remarks"></a>Uwagi

Prostokątny region może być nieprzezroczysty (wypełniony bieżącym kolorem tła) i może być regionem przycinania.

Jeśli *nOptions* jest równa 0, a *lpRect* ma wartość null, funkcja zapisuje tekst w kontekście urządzenia bez używania regionu prostokątnego. Domyślnie, funkcja nie używa ani nie aktualizuje bieżącej pozycji. Jeśli aplikacja musi zaktualizować bieżącą pozycję podczas wywoływania `ExtTextOut` , aplikacja może wywołać `CDC` funkcję elementu członkowskiego TextAlign z [SetTextAlign](#settextalign) *nFlags* ustawioną na TA_UPDATECP. Gdy ta flaga jest ustawiona, system Windows ignoruje *x* i *y* po kolejnych wywołaniach `ExtTextOut` i używa zamiast tego bieżącego położenia. Gdy aplikacja używa TA_UPDATECP, aby zaktualizować bieżącą pozycję, `ExtTextOut` ustawia bieżącą pozycję do końca poprzedniego wiersza tekstu lub do pozycji określonej przez ostatni element tablicy wskazywanej przez *lpDxWidths*, w zależności od tego, która wartość jest większa.

## <a name="cdcfillpath"></a><a name="fillpath"></a>Przechwytywanie zmian:: FillPath

Zamyka wszystkie otwarte figury w bieżącej ścieżce i wypełnia wnętrze ścieżki przy użyciu bieżącego pędzla i trybu wypełniania wielokątów.

```
BOOL FillPath();
```

### <a name="return-value"></a>Wartość zwracana

Różne od zera, jeśli funkcja zakończyła się pomyślnie; w przeciwnym razie 0.

### <a name="remarks"></a>Uwagi

Po wypełnieniu jego wnętrza ścieżka jest odrzucana z kontekstu urządzenia.

## <a name="cdcfillrect"></a><a name="fillrect"></a>Przechwytywanie zmian:: FillRect

Wywołaj tę funkcję elementu członkowskiego, aby wypełnić dany prostokąt przy użyciu określonego pędzla.

```cpp
void FillRect(
    LPCRECT lpRect,
    CBrush* pBrush);
```

### <a name="parameters"></a>Parametry

*lpRect*<br/>
Wskazuje [strukturę](/windows/win32/api/windef/ns-windef-rect) prostokąta, która zawiera współrzędne logiczne prostokąta, który ma zostać wypełniony. Można również przekazać obiekt [CRect](../../atl-mfc-shared/reference/crect-class.md) dla tego parametru.

*pBrush*<br/>
Identyfikuje pędzel używany do wypełnienia prostokąta.

### <a name="remarks"></a>Uwagi

Funkcja wypełnia cały prostokąt, w tym lewe i górne obramowanie, ale nie wypełnia krawędzi prawej i dolnej.

Pędzel musi zostać utworzony przy użyciu funkcji składowych [CBrush](../../mfc/reference/cbrush-class.md) [CreateHatchBrush](../../mfc/reference/cbrush-class.md#createhatchbrush), [CreatePatternBrush](../../mfc/reference/cbrush-class.md#createpatternbrush)i [CreateSolidBrush](../../mfc/reference/cbrush-class.md#createsolidbrush)lub do pobrania przez `GetStockObject` funkcję systemu Windows.

Podczas wypełniania określonego prostokąta nie `FillRect` obejmuje prawych i dolnych krawędzi prostokąta. Interfejs GDI wypełnia prostokąt do, ale nie zawiera, prawej kolumny i dolnego wiersza, niezależnie od bieżącego trybu mapowania. `FillRect`porównuje wartości `top` `bottom` elementów członkowskich,, `left` i i z `right` określonego prostokąta. Jeśli `bottom` jest mniejsza lub równa `top` lub jeśli `right` jest mniejsza lub równa `left` , prostokąt nie jest rysowany.

`FillRect`przypomina [:: FillSolidRect](#fillsolidrect); jednak `FillRect` Pobiera pędzle i w związku z tym może służyć do wypełniania prostokąta wypełnionym kolorem, kolorem pędzla lub wzorkiem. `FillSolidRect`używa wyłącznie pełnych kolorów (wskazywanych przez parametr COLORREF). `FillRect`zwykle jest wolniejsze niż `FillSolidRect` .

## <a name="cdcfillrgn"></a><a name="fillrgn"></a>Przechwytywanie zmian:: FillRgn

Wypełnia region określony przez *pRgn* przy użyciu pędzla określonego przez *pbrush*.

```
BOOL FillRgn(
    CRgn* pRgn,
    CBrush* pBrush);
```

### <a name="parameters"></a>Parametry

*pRgn*<br/>
Wskaźnik do regionu, który ma zostać wypełniony. Współrzędne dla danego regionu są określone w jednostkach logicznych.

*pBrush*<br/>
Identyfikuje Pędzel, który będzie używany do wypełniania regionu.

### <a name="return-value"></a>Wartość zwracana

Różne od zera, jeśli funkcja zakończyła się pomyślnie; w przeciwnym razie 0.

### <a name="remarks"></a>Uwagi

Pędzel musi zostać utworzony przy użyciu `CBrush` funkcji Członkowskich,, `CreateHatchBrush` `CreatePatternBrush` `CreateSolidBrush` , lub być pobierany przez `GetStockObject` .

### <a name="example"></a>Przykład

  Zobacz przykład dla [CRgn:: CreateRoundRectRgn](../../mfc/reference/crgn-class.md#createroundrectrgn).

## <a name="cdcfillsolidrect"></a><a name="fillsolidrect"></a>Przechwytywanie zmian:: FillSolidRect

Wywołaj tę funkcję elementu członkowskiego, aby wypełnić dany prostokąt określonym kolorem kryjącym.

```cpp
void FillSolidRect(
    LPCRECT lpRect,
    COLORREF clr);

void FillSolidRect(
    int x,
    int y,
    int cx,
    int cy,
    COLORREF clr);
```

### <a name="parameters"></a>Parametry

*lpRect*<br/>
Określa prostokąt ograniczenia (w jednostkach logicznych). Można przekazać wskaźnik do struktury danych [Rect](/windows/win32/api/windef/ns-windef-rect) lub do `CRect` obiektu dla tego parametru.

*środowisko CLR* Określa kolor, który ma być używany do wypełniania prostokąta.

*x*<br/>
Określa logiczną współrzędną x lewego górnego rogu prostokąta.

*t*<br/>
Określa logiczną współrzędną y lewego górnego rogu prostokąta docelowego.

*CX*<br/>
Określa szerokość prostokąta.

*cy*<br/>
Określa wysokość prostokąta.

### <a name="remarks"></a>Uwagi

`FillSolidRect`jest bardzo podobny do [przechwytywania zmian:: FillRect](#fillrect); jednak `FillSolidRect` używa wyłącznie pełnych kolorów (wskazywanych przez parametr COLORREF), a w `FillRect` związku z tym może służyć do wypełniania prostokąta przy użyciu pełnego koloru, kolorowego pędzla lub wzorca. `FillSolidRect`zwykle jest szybsze niż `FillRect` .

> [!NOTE]
> Po wywołaniu `FillSolidRect` , kolor tła, który został wcześniej ustawiony przy użyciu [SetBkColor](#setbkcolor), jest ustawiony na kolor wskazywany przez *środowisko CLR*.

## <a name="cdcflattenpath"></a><a name="flattenpath"></a>Przechwytywanie zmian:: FlattenPath

Przekształca wszystkie krzywe w ścieżce zaznaczonej w bieżącym kontekście urządzenia i włącza każdą krzywą w sekwencji wierszy.

```
BOOL FlattenPath();
```

### <a name="return-value"></a>Wartość zwracana

Różne od zera, jeśli funkcja zakończyła się pomyślnie; w przeciwnym razie 0.

## <a name="cdcfloodfill"></a><a name="floodfill"></a>Przechwytywanie zmian:: FloodFill

Wypełnia obszar wyświetlania powierzchni bieżącym pędzlem.

```
BOOL FloodFill(
    int x,
    int y,
    COLORREF crColor);
```

### <a name="parameters"></a>Parametry

*x*<br/>
Określa logiczną współrzędną x punktu, w którym rozpoczyna się napełnianie.

*t*<br/>
Określa logiczną współrzędną y punktu, w którym rozpoczyna się napełnianie.

*crColor*<br/>
Określa kolor granicy.

### <a name="return-value"></a>Wartość zwracana

Niezerowe, jeśli funkcja się powiedzie; w przeciwnym razie zwraca wartość 0, jeśli nie można ukończyć wypełniania, dany punkt ma kolor granicy określony przez *crColor*lub punkt znajduje się poza regionem przycinania.

### <a name="remarks"></a>Uwagi

Przyjęto, że obszar jest ograniczany zgodnie z definicją *crColor*. `FloodFill`Funkcja rozpoczyna się w punkcie wskazanym przez *x* i *y* i kontynuuje wszystkie kierunki do granicy koloru.

Tylko konteksty i urządzenia pamięci, które obsługują technologię rastrową, obsługują `FloodFill` funkcję elementu członkowskiego. Informacje o możliwościach RC_BITBLT można znaleźć w `GetDeviceCaps` funkcji elementu członkowskiego.

`ExtFloodFill`Funkcja zapewnia podobną funkcję, ale większą elastyczność.

## <a name="cdcframerect"></a><a name="framerect"></a>Przechwytywanie zmian:: FrameRect

Rysuje obramowanie wokół prostokąta określonego przez *lpRect*.

```cpp
void FrameRect(
    LPCRECT lpRect,
    CBrush* pBrush);
```

### <a name="parameters"></a>Parametry

*lpRect*<br/>
Wskazuje strukturę [Rect](/windows/win32/api/windef/ns-windef-rect) lub obiekt [CRect](../../atl-mfc-shared/reference/crect-class.md) , który zawiera współrzędne logiczne lewego górnego i prawego dolnego rogu prostokąta. Można również przekazać `CRect` obiekt dla tego parametru.

*pBrush*<br/>
Identyfikuje Pędzel, który ma być używany do obsługi ramek prostokąta.

### <a name="remarks"></a>Uwagi

Funkcja używa danego pędzla do rysowania obramowania. Szerokość i wysokość obramowania są zawsze 1 jednostką logiczną.

Jeśli współrzędne prostokąta `bottom` jest mniejsze niż lub równe `top` , lub jeśli `right` jest mniejsze niż lub równe `left` , prostokąt nie jest rysowany.

Obramowanie rysowane przez `FrameRect` znajduje się w tym samym położeniu, co obramowanie rysowane przez `Rectangle` funkcję elementu członkowskiego przy użyciu tych samych współrzędnych (Jeśli `Rectangle` używa pióra o szerokości 1 jednostki logicznej). Wnętrze prostokąta nie jest wypełnione przez `FrameRect` .

## <a name="cdcframergn"></a><a name="framergn"></a>Przechwytywanie zmian:: FrameRgn

Rysuje obramowanie wokół regionu określonego przez *pRgn* przy użyciu pędzla określonego przez *pbrush*.

```
BOOL FrameRgn(
    CRgn* pRgn,
    CBrush* pBrush,
    int nWidth,
    int nHeight);
```

### <a name="parameters"></a>Parametry

*pRgn*<br/>
Wskazuje `CRgn` obiekt, który identyfikuje region, który ma być ujęty w obramowanie. Współrzędne dla danego regionu są określone w jednostkach logicznych.

*pBrush*<br/>
Wskazuje `CBrush` obiekt, który identyfikuje Pędzel, który ma być używany do rysowania obramowania.

*nWidth*<br/>
Określa szerokość obramowania w pionie pociągnięć pędzla w jednostkach urządzeń.

*nHeight*<br/>
Określa wysokość obramowania w poziomych pociągnięć pędzla w jednostkach urządzeń.

### <a name="return-value"></a>Wartość zwracana

Różne od zera, jeśli funkcja zakończyła się pomyślnie; w przeciwnym razie 0.

### <a name="example"></a>Przykład

  Zobacz przykład dla [CRgn:: CombineRgn](../../mfc/reference/crgn-class.md#combinergn).

## <a name="cdcfromhandle"></a><a name="fromhandle"></a>Przechwytywanie zmian:: FromHandle

Zwraca wskaźnik do obiektu, `CDC` gdy ma dojść do kontekstu urządzenia.

```
static CDC* PASCAL FromHandle(HDC hDC);
```

### <a name="parameters"></a>Parametry

*Używający HDC*<br/>
Zawiera dojście do kontekstu urządzenia z systemem Windows.

### <a name="return-value"></a>Wartość zwracana

Wskaźnik może być tymczasowy i nie powinien być przechowywany poza bezpośrednim użyciem.

### <a name="remarks"></a>Uwagi

Jeśli `CDC` obiekt nie jest dołączony do dojścia, `CDC` tworzony jest obiekt tymczasowy i jest on dołączony.

### <a name="example"></a>Przykład

  Zobacz przykład dla [CPrintDialog:: GetPrinterDC](../../mfc/reference/cprintdialog-class.md#getprinterdc).

## <a name="cdcgetarcdirection"></a><a name="getarcdirection"></a>Przechwytywanie zmian:: GetArcDirection

Zwraca bieżący kierunek łuku dla kontekstu urządzenia.

```
int GetArcDirection() const;
```

### <a name="return-value"></a>Wartość zwracana

Określa bieżący kierunek łuku, jeśli to się powiedzie. Poniżej znajdują się prawidłowe wartości zwracane:

- AD_COUNTERCLOCKWISE łuki i prostokąty rysowane w lewo.

- AD_CLOCKWISE łuki i prostokąty rysowane w prawo.

Jeśli wystąpi błąd, wartość zwracana wynosi zero.

### <a name="remarks"></a>Uwagi

Funkcje Arc i Rectangle wykorzystują kierunek łuku.

## <a name="cdcgetaspectratiofilter"></a><a name="getaspectratiofilter"></a>Przechwytywanie zmian:: GetAspectRatioFilter

Pobiera ustawienie dla bieżącego filtru współczynnika proporcji.

```
CSize GetAspectRatioFilter() const;
```

### <a name="return-value"></a>Wartość zwracana

`CSize`Obiekt reprezentujący współczynnik proporcji używany przez bieżący filtr współczynnika proporcji.

### <a name="remarks"></a>Uwagi

Współczynnik proporcji jest stosunkiem utworzonym przez szerokość i wysokość pikseli urządzenia. Informacje o współczynniku proporcji urządzenia są używane podczas tworzenia, zaznaczania i wyświetlania czcionek. System Windows udostępnia filtr specjalny, filtr współczynnika proporcji do wybierania czcionek przeznaczonych dla określonego współczynnika proporcji ze wszystkich dostępnych czcionek. Filtr używa współczynnika proporcji określonego przez `SetMapperFlags` funkcję elementu członkowskiego.

## <a name="cdcgetbkcolor"></a><a name="getbkcolor"></a>Przechwytywanie zmian:: GetBkColor

Zwraca bieżący kolor tła.

```
COLORREF GetBkColor() const;
```

### <a name="return-value"></a>Wartość zwracana

Wartość koloru RGB.

### <a name="remarks"></a>Uwagi

Jeśli tryb tła jest nieprzezroczysty, system używa koloru tła do wypełnienia luk w stylach linii, przerw między liniami kreskowanymi w pędzlach i tłem w postaci komórek znakowych. System używa również koloru tła podczas konwertowania map bitowych między kontekstami urządzeń kolor i Monochromatycznie.

## <a name="cdcgetbkmode"></a><a name="getbkmode"></a>Przechwytywanie zmian:: GetBkMode

Zwraca tryb tła.

```
int GetBkMode() const;
```

### <a name="return-value"></a>Wartość zwracana

Bieżący tryb tła, który może być nieprzezroczysty lub PRZEZROCZYSTy.

### <a name="remarks"></a>Uwagi

Tryb tła definiuje, czy system usuwa istniejące kolory tła na powierzchni rysowania przed rysowaniem tekstu, pędzlami kreskowanymi i dowolnym stylem pióra, który nie jest linią ciągłą.

## <a name="cdcgetboundsrect"></a><a name="getboundsrect"></a>Przechwytywanie zmian:: GetBoundsRect

Zwraca bieżący, skumulowany prostokąt związany z określonym kontekstem urządzenia.

```
UINT GetBoundsRect(
    LPRECT lpRectBounds,
    UINT flags);
```

### <a name="parameters"></a>Parametry

*lpRectBounds*<br/>
Wskazuje bufor, który będzie odbierać bieżący prostokąt ograniczenia. Prostokąt jest zwracany we współrzędnych logicznych.

*flagi*<br/>
Określa, czy prostokąt ograniczający ma być wyczyszczony po zwróceniu. Ten parametr powinien mieć wartość zero lub mieć ustawioną następujące wartości:

- DCB_RESET wymusza wyczyszczenie prostokąta powiązanego po jego zwróceniu.

### <a name="return-value"></a>Wartość zwracana

Określa bieżący stan prostokąta ograniczenia, jeśli funkcja się powiedzie. Może być kombinacją następujących wartości:

- Występuje DCB_ACCUMULATE nagromadzeniem prostokątów powiązanych.

- DCB_RESET prostokąt ograniczający jest pusty.

- Prostokąt ograniczający DCB_SET nie jest pusty.

- DCB_ENABLE powiązania kumulacji jest włączone.

- DCB_DISABLE powiązania kumulacji jest wyłączone.

## <a name="cdcgetbrushorg"></a><a name="getbrushorg"></a>Przechwytywanie zmian:: GetBrushOrg

Pobiera źródło (w jednostkach urządzeń) pędzla aktualnie zaznaczonego dla kontekstu urządzenia.

```
CPoint GetBrushOrg() const;
```

### <a name="return-value"></a>Wartość zwracana

Bieżące źródło pędzla (w jednostkach urządzeń) jako obiekt [CPoint](../../atl-mfc-shared/reference/cpoint-class.md) .

### <a name="remarks"></a>Uwagi

Początkowy początek pędzla jest równy (0, 0) obszaru klienckiego. Wartość zwracana określa ten punkt w jednostkach urządzeń względem źródła okna pulpitu.

## <a name="cdcgetcharacterplacement"></a><a name="getcharacterplacement"></a>Przechwytywanie zmian:: GetCharacterPlacement

Pobiera różne rodzaje informacji w ciągu znaków.

```
DWORD GetCharacterPlacement(
    LPCTSTR lpString,
    int nCount,
    int nMaxExtent,
    LPGCP_RESULTS lpResults,
    DWORD dwFlags) const;

DWORD GetCharacterPlacement(
    CString& str,
    int nMaxExtent,
    LPGCP_RESULTS lpResults,
    DWORD dwFlags) const;
```

### <a name="parameters"></a>Parametry

*lpString*<br/>
Wskaźnik do ciągu znaków do przetworzenia.

*nCount*<br/>
Określa długość ciągu. W przypadku wersji ANSI jest to liczba bajtów i dla funkcji Unicode jest to liczba WYRAZów. Aby uzyskać więcej informacji, zobacz [GetCharacterPlacement](/windows/win32/api/wingdi/nf-wingdi-getcharacterplacementw).

*nMaxExtent*<br/>
Określa maksymalny zakres (w jednostkach logicznych), do którego jest przetwarzany ciąg. Znaki, które w przypadku przetworzenia przekraczają ten zakres, zostaną zignorowane. Obliczenia dla wszystkich wymaganych tablic kolejności lub symboli mają zastosowanie tylko do dołączonych znaków. Ten parametr jest używany tylko wtedy, gdy wartość GCP_MAXEXTENT jest określona w parametrze *flagiDW* . Ponieważ funkcja przetwarza ciąg wejściowy, każdy znak i jego zakres są dodawane do danych wyjściowych, zakresów i innych tablic tylko wtedy, gdy całkowity zakres nie przekroczył jeszcze wartości maksymalnej. Po osiągnięciu limitu przetwarzanie zostanie zatrzymane.

*lpResults*<br/>
Wskaźnik do struktury [GCP_Results](/windows/win32/api/wingdi/ns-wingdi-gcp_resultsw) , która otrzymuje wyniki funkcji.

*flagiDW*<br/>
Określa sposób przetwarzania ciągu do wymaganych tablic. Ten parametr może mieć co najmniej jedną wartość wymienioną w sekcji *flagiDW* tematu [GetCharacterPlacement](/windows/win32/api/wingdi/nf-wingdi-getcharacterplacementw) .

*str*<br/>
Wskaźnik do obiektu [CString](../../atl-mfc-shared/reference/cstringt-class.md) do przetworzenia.

### <a name="return-value"></a>Wartość zwracana

Jeśli funkcja się powiedzie, wartość zwracana jest szerokością i wysokością ciągu w jednostkach logicznych.

Jeśli funkcja się nie powiedzie, zwracana wartość jest równa zero.

### <a name="remarks"></a>Uwagi

Ta funkcja członkowska emuluje funkcjonalność funkcji [GetCharacterPlacement](/windows/win32/api/wingdi/nf-wingdi-getcharacterplacementw), zgodnie z opisem w Windows SDK.

## <a name="cdcgetcharabcwidths"></a><a name="getcharabcwidths"></a>Przechwytywanie zmian:: GetCharABCWidths

Pobiera szerokość kolejnych znaków w określonym zakresie z bieżącej czcionki TrueType.

```
BOOL GetCharABCWidths(
    UINT nFirstChar,
    UINT nLastChar,
    LPABC lpabc) const;

BOOL GetCharABCWidths(
    UINT nFirstChar,
    UINT nLastChar,
    LPABCFLOAT lpABCF) const;
```

### <a name="parameters"></a>Parametry

*nFirstChar*<br/>
Określa pierwszy znak z zakresu znaków od bieżącej czcionki, dla którego są zwracane szerokości znaków.

*nLastChar*<br/>
Określa ostatni znak z zakresu znaków od bieżącej czcionki, dla którego są zwracane szerokości znaków.

*lpabc*<br/>
Wskazuje tablicę struktur [ABC](/windows/win32/api/wingdi/ns-wingdi-abc) , która otrzymuje szerokości znaków, gdy funkcja zwraca. Tablica musi zawierać co najmniej tyle `ABC` struktur, ile istnieją znaki w zakresie określonym przez parametry *NFirstChar* i *nLastChar* .

*lpABCF*<br/>
Wskazuje bufor dostarczony przez aplikację z tablicą struktur [ABCFLOAT](/windows/win32/api/wingdi/ns-wingdi-abcfloat) , aby otrzymywać szerokości znaków, gdy funkcja zwraca wartość. Szerokość zwracana przez tę funkcję są w formacie zmiennoprzecinkowym IEEE.

### <a name="return-value"></a>Wartość zwracana

Różne od zera, jeśli funkcja zakończyła się pomyślnie; w przeciwnym razie 0.

### <a name="remarks"></a>Uwagi

Szerokości są zwracane w jednostkach logicznych. Ta funkcja jest pomyślna tylko z czcionkami TrueType.

Rasteryzacja TrueType zapewnia odstępy między znakami "ABC" po wybraniu określonego rozmiaru punktu. Odstęp "A" to odległość, która jest dodawana do bieżącej pozycji przed umieszczeniem glifu. Odstępy "B" to szerokość czarnej części glifu. Odstępy "C" są dodawane do bieżącej pozycji w celu uwzględnienia białego znaku na prawo od symbolu. Łączna szerokość zaawansowana jest określona przez + B + C.

Gdy `GetCharABCWidths` funkcja członkowska pobiera ujemną szerokość "A" lub "C" dla znaku, ten znak zawiera niezawieszanie lub zawiesza się.

Aby przekonwertować szerokości ABC na jednostki projektowe czcionek, aplikacja powinna utworzyć czcionkę, której wysokość (jak określono w `lfHeight` składowej struktury [LOGFONT](/windows/win32/api/wingdi/ns-wingdi-logfontw) ) jest równa wartości przechowywanej w `ntmSizeEM` składowej struktury [NEWTEXTMETRIC](/windows/win32/api/wingdi/ns-wingdi-newtextmetricw) . (Wartość `ntmSizeEM` elementu członkowskiego można pobrać, wywołując funkcję [EnumFontFamilies](/windows/win32/api/wingdi/nf-wingdi-enumfontfamiliesw) systemu Windows).

Szerokości ABC znaku domyślnego są używane dla znaków, które znajdują się poza zakresem aktualnie zaznaczonej czcionki.

Aby pobrać szerokości znaków w czcionkach innych niż TrueType, aplikacje powinny używać funkcji [GetCharWidth](/windows/win32/api/wingdi/nf-wingdi-getcharwidthw) systemu Windows.

## <a name="cdcgetcharabcwidthsi"></a><a name="getcharabcwidthsi"></a>Przechwytywanie zmian:: GetCharABCWidthsI

Pobiera szerokość (w jednostkach logicznych) kolejnych indeksów symboli w określonym zakresie od bieżącej czcionki TrueType.

```
BOOL GetCharABCWidthsI(
    UINT giFirst,
    UINT cgi,
    LPWORD pgi,
    LPABC lpabc) const;
```

### <a name="parameters"></a>Parametry

*giFirst*<br/>
Określa pierwszy indeks glifów w grupie kolejnych indeksów glifów z bieżącej czcionki. Ten parametr jest używany tylko wtedy, gdy parametr *PGI* ma wartość null.

*Aplikacja*<br/>
Określa liczbę indeksów symboli.

*PGI*<br/>
Wskaźnik do tablicy zawierającej indeksy symboli. Jeśli wartość jest RÓWNa NULL, zamiast tego zostanie użyty parametr *giFirst* . Wartość parametru *CGI* określa liczbę indeksów glifów w tej tablicy.

*lpabc*<br/>
Wskaźnik do tablicy struktur [ABC](/windows/win32/api/wingdi/ns-wingdi-abc) otrzymujących szerokości znaków. Tablica musi zawierać co najmniej tyle `ABC` struktur, ile nie określono indeksów symboli określonych przez parametr *CGI* .

### <a name="return-value"></a>Wartość zwracana

Różne od zera, jeśli funkcja zakończyła się pomyślnie; w przeciwnym razie 0.

### <a name="remarks"></a>Uwagi

Ta funkcja członkowska emuluje funkcjonalność funkcji [GetCharABCWidthsI](/windows/win32/api/wingdi/nf-wingdi-getcharabcwidthsi), zgodnie z opisem w Windows SDK.

## <a name="cdcgetcharwidth"></a><a name="getcharwidth"></a>Przechwytywanie zmian:: GetCharWidth

Pobiera szerokość pojedynczych znaków w kolejnej grupie znaków z bieżącej czcionki, przy użyciu `m_hAttribDC` kontekstu urządzenia wejściowego.

```
BOOL GetCharWidth(
    UINT nFirstChar,
    UINT nLastChar,
    LPINT lpBuffer) const;

BOOL GetCharWidth(
    UINT nFirstChar,
    UINT nLastChar,
    float* lpFloatBuffer) const;
```

### <a name="parameters"></a>Parametry

*nFirstChar*<br/>
Określa pierwszy znak w kolejnej grupie znaków w bieżącej czcionce.

*nLastChar*<br/>
Określa ostatni znak w kolejnej grupie znaków w bieżącej czcionce.

*lpBuffer*<br/>
Wskazuje bufor, który będzie otrzymywał wartości szerokości dla kolejnej grupy znaków w bieżącej czcionce.

*lpFloatBuffer*<br/>
Wskazuje bufor, w którym mają zostać odebrane szerokości znaków. Zwrócone szerokości są w 32-bitowej liczbie zmiennoprzecinkowej IEEE. (Szerokość jest mierzona wzdłuż linii bazowej znaków).

### <a name="return-value"></a>Wartość zwracana

Różne od zera, jeśli funkcja zakończyła się pomyślnie; w przeciwnym razie 0.

### <a name="remarks"></a>Uwagi

Na przykład jeśli *nFirstChar* identyfikuje literę "a", a *nLastChar* identyfikuje literę "z", funkcja pobiera szerokości wszystkich małych liter.

Funkcja przechowuje wartości w buforze wskazywanym przez *lpBuffer*. Ten bufor musi być wystarczająco duży, aby pomieścić wszystkie szerokości. Oznacza to, że w podanym przykładzie musi znajdować się co najmniej 26 wpisów.

Jeśli znak w kolejnej grupie znaków nie istnieje w określonej czcionce, zostanie przypisana wartość szerokości znaku domyślnego.

## <a name="cdcgetcharwidthi"></a><a name="getcharwidthi"></a>Przechwytywanie zmian:: GetCharWidthI

Pobiera szerokość, we współrzędnych logicznych, kolejnych indeksów symboli w określonym zakresie od bieżącej czcionki.

```
BOOL GetCharWidthI(
    UINT giFirst,
    UINT cgi,
    LPWORD pgi,
    LPINT lpBuffer) const;
```

### <a name="parameters"></a>Parametry

*giFirst*<br/>
Określa pierwszy indeks glifów w grupie kolejnych indeksów glifów z bieżącej czcionki. Ten parametr jest używany tylko wtedy, gdy parametr *PGI* ma wartość null.

*Aplikacja*<br/>
Określa liczbę indeksów symboli.

*PGI*<br/>
Wskaźnik do tablicy zawierającej indeksy symboli. Jeśli wartość jest RÓWNa NULL, zamiast tego zostanie użyty parametr *giFirst* . Wartość parametru *CGI* określa liczbę indeksów glifów w tej tablicy.

*lpBuffer*<br/>
Wskaźnik do buforu, który odbiera szerokość.

### <a name="return-value"></a>Wartość zwracana

Różne od zera, jeśli funkcja zakończyła się pomyślnie; w przeciwnym razie 0.

### <a name="remarks"></a>Uwagi

Ta funkcja członkowska emuluje funkcjonalność funkcji [GetCharWidthI](/windows/win32/api/wingdi/nf-wingdi-getcharwidthi), zgodnie z opisem w Windows SDK.

## <a name="cdcgetclipbox"></a><a name="getclipbox"></a>Przechwytywanie zmian:: GetClipBox

Pobiera wymiary najbliżej przyległego prostokąta wokół bieżącej granicy wycinka.

```
virtual int GetClipBox(LPRECT lpRect) const;
```

### <a name="parameters"></a>Parametry

*lpRect*<br/>
Wskazuje strukturę [Rect](/windows/win32/api/windef/ns-windef-rect) lub obiekt [CRect](../../atl-mfc-shared/reference/crect-class.md) , który ma otrzymywać wymiary prostokąta.

### <a name="return-value"></a>Wartość zwracana

Typ regionu wycinka. Może to być dowolna z następujących wartości:

- Region przycinania COMPLEXREGION ma nakładające się obramowania.

- Nieprawidłowy kontekst urządzenia błędu.

- Region wycinka NULLREGION jest pusty.

- Region wycinka SIMPLEREGION nie ma nakładających się obramowań.

### <a name="remarks"></a>Uwagi

Wymiary są kopiowane do buforu wskazywanym przez *lpRect*.

## <a name="cdcgetcoloradjustment"></a><a name="getcoloradjustment"></a>Przechwytywanie zmian:: GetColorAdjustment

Pobiera wartości korekty koloru dla kontekstu urządzenia.

```
BOOL GetColorAdjustment(LPCOLORADJUSTMENT lpColorAdjust) const;
```

### <a name="parameters"></a>Parametry

*lpColorAdjust*<br/>
Wskazuje strukturę danych [COLORADJUSTMENT](/windows/win32/api/wingdi/ns-wingdi-coloradjustment) , aby otrzymać wartości korekty koloru.

### <a name="return-value"></a>Wartość zwracana

Różne od zera, jeśli funkcja zakończyła się pomyślnie; w przeciwnym razie 0.

## <a name="cdcgetcurrentbitmap"></a><a name="getcurrentbitmap"></a>Przechwytywanie zmian:: GetCurrentBitmap

Zwraca wskaźnik do aktualnie wybranego `CBitmap` obiektu.

```
CBitmap* GetCurrentBitmap() const;
```

### <a name="return-value"></a>Wartość zwracana

Wskaźnik do `CBitmap` obiektu, jeśli się powiedzie; w przeciwnym razie wartość null.

### <a name="remarks"></a>Uwagi

Ta funkcja członkowska może zwracać obiekty tymczasowe.

## <a name="cdcgetcurrentbrush"></a><a name="getcurrentbrush"></a>Przechwytywanie zmian:: GetCurrentBrush

Zwraca wskaźnik do aktualnie wybranego `CBrush` obiektu.

```
CBrush* GetCurrentBrush() const;
```

### <a name="return-value"></a>Wartość zwracana

Wskaźnik do `CBrush` obiektu, jeśli się powiedzie; w przeciwnym razie wartość null.

### <a name="remarks"></a>Uwagi

Ta funkcja członkowska może zwracać obiekty tymczasowe.

## <a name="cdcgetcurrentfont"></a><a name="getcurrentfont"></a>Przechwytywanie zmian:: GetCurrentFont

Zwraca wskaźnik do aktualnie wybranego `CFont` obiektu.

```
CFont* GetCurrentFont() const;
```

### <a name="return-value"></a>Wartość zwracana

Wskaźnik do `CFont` obiektu, jeśli się powiedzie; w przeciwnym razie wartość null.

### <a name="remarks"></a>Uwagi

Ta funkcja członkowska może zwracać obiekty tymczasowe.

## <a name="cdcgetcurrentpalette"></a><a name="getcurrentpalette"></a>Przechwytywanie zmian:: GetCurrentPalette

Zwraca wskaźnik do aktualnie wybranego `CPalette` obiektu.

```
CPalette* GetCurrentPalette() const;
```

### <a name="return-value"></a>Wartość zwracana

Wskaźnik do `CPalette` obiektu, jeśli się powiedzie; w przeciwnym razie wartość null.

### <a name="remarks"></a>Uwagi

Ta funkcja członkowska może zwracać obiekty tymczasowe.

## <a name="cdcgetcurrentpen"></a><a name="getcurrentpen"></a>Przechwytywanie zmian:: GetCurrentPen

Zwraca wskaźnik do aktualnie wybranego `CPen` obiektu.

```
CPen* GetCurrentPen() const;
```

### <a name="return-value"></a>Wartość zwracana

Wskaźnik do `CPen` obiektu, jeśli się powiedzie; w przeciwnym razie wartość null.

### <a name="remarks"></a>Uwagi

Ta funkcja członkowska może zwracać obiekty tymczasowe.

## <a name="cdcgetcurrentposition"></a><a name="getcurrentposition"></a>Przechwytywanie zmian:: GetCurrentPosition

Pobiera bieżącą pozycję (we współrzędnych logicznych).

```
CPoint GetCurrentPosition() const;
```

### <a name="return-value"></a>Wartość zwracana

Bieżąca pozycja jako `CPoint` obiekt.

### <a name="remarks"></a>Uwagi

Bieżącą pozycję można ustawić za pomocą `MoveTo` funkcji składowej.

## <a name="cdcgetdcbrushcolor"></a><a name="getdcbrushcolor"></a>Przechwytywanie zmian:: GetDCBrushColor

Pobiera bieżący kolor pędzla.

```
COLORREF GetDCBrushColor() const;
```

### <a name="return-value"></a>Wartość zwracana

Jeśli funkcja się powiedzie, wartość zwracana jest wartością [COLORREF](/windows/win32/gdi/colorref) bieżącego koloru pędzla.

Jeśli funkcja się nie powiedzie, wartość zwracana jest CLR_INVALID.

### <a name="remarks"></a>Uwagi

Ta funkcja członkowska emuluje funkcjonalność funkcji [GetDCBrushColor](/windows/win32/api/wingdi/nf-wingdi-getdcbrushcolor), zgodnie z opisem w Windows SDK.

## <a name="cdcgetdcpencolor"></a><a name="getdcpencolor"></a>Przechwytywanie zmian:: GetDCPenColor

Pobiera bieżący kolor pióra.

```
COLORREF GetDCPenColor() const;
```

### <a name="return-value"></a>Wartość zwracana

Jeśli funkcja się powiedzie, wartość zwracana jest wartością [COLORREF](/windows/win32/gdi/colorref) dla bieżącego koloru pióra.

Jeśli funkcja się nie powiedzie, wartość zwracana jest CLR_INVALID.

### <a name="remarks"></a>Uwagi

Ta funkcja członkowska wykorzystuje funkcję Win32 [GetDCPenColor](/windows/win32/api/wingdi/nf-wingdi-getdcpencolor), zgodnie z opisem w Windows SDK.

## <a name="cdcgetdevicecaps"></a><a name="getdevicecaps"></a>Przechwytywanie zmian:: GetDeviceCaps

Pobiera szeroki zakres informacji o urządzeniu wyświetlanym.

```
int GetDeviceCaps(int nIndex) const;
```

### <a name="parameters"></a>Parametry

*nIndex*<br/>
Określa typ danych do zwrócenia. Aby uzyskać listę wartości, zobacz [GetDeviceCaps](/windows/win32/api/wingdi/nf-wingdi-getdevicecaps) w Windows SDK.

### <a name="return-value"></a>Wartość zwracana

Wartość żądanej możliwości, jeśli funkcja się powiedzie.

### <a name="example"></a>Przykład

  Zobacz przykład dla [CPrintDialog:: GetDefaults](../../mfc/reference/cprintdialog-class.md#getdefaults).

## <a name="cdcgetfontdata"></a><a name="getfontdata"></a>Przechwytywanie zmian:: GetFontData

Pobiera informacje o metryki czcionki z skalowalnego pliku czcionek.

```
DWORD GetFontData(
    DWORD dwTable,
    DWORD dwOffset,
    LPVOID lpData,
    DWORD cbData) const;
```

### <a name="parameters"></a>Parametry

*dwTable*<br/>
Określa nazwę tabeli metryk, która ma zostać zwrócona. Ten parametr może być jedną z tabel metryk opisanych w specyfikacji plików czcionek TrueType opublikowanej przez firmę Microsoft Corporation. Jeśli ten parametr ma wartość 0, informacje są pobierane, zaczynając od początku pliku czcionki.

*dwOffset*<br/>
Określa przesunięcie od początku tabeli, w której ma zostać rozpoczęte pobieranie informacji. Jeśli ten parametr ma wartość 0, informacje są pobierane, zaczynając od początku tabeli określonej przez parametr *dwTable* . Jeśli ta wartość jest większa lub równa rozmiarowi tabeli, `GetFontData` zwraca wartość 0.

*lpData*<br/>
Wskazuje bufor, który otrzyma informacje o czcionce. Jeśli ta wartość jest RÓWNa NULL, funkcja zwraca rozmiar buforu wymagany dla danych czcionki określonych w parametrze *dwTable* .

*cbData*<br/>
Określa długość (w bajtach) informacji do pobrania. Jeśli ten parametr ma wartość 0, `GetFontData` zwraca rozmiar danych określonych w parametrze *dwTable* .

### <a name="return-value"></a>Wartość zwracana

Określa liczbę bajtów zwracanych w buforze wskazywanym przez *lpData* , jeśli funkcja się powiedzie; w przeciwnym razie-1.

### <a name="remarks"></a>Uwagi

Informacje do pobrania są identyfikowane przez określenie przesunięcia do pliku czcionki oraz długości zwracanych informacji.

Aplikacja może czasami używać `GetFontData` funkcji członkowskiej, aby zapisać czcionkę TrueType z dokumentem. W tym celu aplikacja określa, czy czcionka może być osadzona, a następnie pobiera cały plik z czcionką, określając wartość 0 dla parametrów *dwTable*, *dwOffset*i *cbData* .

Aplikacje mogą określić, czy czcionka może być osadzona, sprawdzając `otmfsType` element członkowski struktury [OUTLINETEXTMETRIC](/windows/win32/api/wingdi/ns-wingdi-outlinetextmetricw) . Jeśli bit 1 `otmfsType` jest ustawiony, osadzanie nie jest dozwolone dla czcionki. Jeśli bit 1 jest wyczyszczony, czcionka może być osadzony. Jeśli ustawiono bit 2, osadzanie jest tylko do odczytu.

Jeśli aplikacja próbuje użyć tej funkcji do pobrania informacji dla czcionki innej niż TrueType, `GetFontData` funkcja członkowska zwróci wartość-1.

## <a name="cdcgetfontlanguageinfo"></a><a name="getfontlanguageinfo"></a>Przechwytywanie zmian:: GetFontLanguageInfo

Zwraca informacje dotyczące aktualnie wybranej czcionki dla określonego kontekstu wyświetlania.

```
DWORD GetFontLanguageInfo() const;
```

### <a name="return-value"></a>Wartość zwracana

Wartość zwracana identyfikuje charakterystykę aktualnie zaznaczonej czcionki. Aby uzyskać pełną listę możliwych wartości, zobacz [GetFontLanguageInfo](/windows/win32/api/wingdi/nf-wingdi-getfontlanguageinfo).

### <a name="remarks"></a>Uwagi

Ta funkcja członkowska emuluje funkcjonalność funkcji [GetFontLanguageInfo](/windows/win32/api/wingdi/nf-wingdi-getfontlanguageinfo), zgodnie z opisem w Windows SDK.

## <a name="cdcgetglyphoutline"></a><a name="getglyphoutline"></a>Przechwytywanie zmian:: GetGlyphOutline

Pobiera krzywą lub mapę bitową konturu dla znaku konturu w bieżącej czcionce.

```
DWORD GetGlyphOutline(
    UINT nChar,
    UINT nFormat,
    LPGLYPHMETRICS lpgm,
    DWORD cbBuffer,
    LPVOID lpBuffer,
    const MAT2* lpmat2) const;
```

### <a name="parameters"></a>Parametry

*nChar*<br/>
Określa znak, dla którego mają zostać zwrócone informacje.

*nFormat*<br/>
Określa format, w którym funkcja ma zwracać informacje. Może to być jedna z następujących wartości lub 0:

|Wartość|Znaczenie|
|-----------|-------------|
|GGO_BITMAP|Zwraca mapę bitową symboli. Gdy funkcja zwraca, bufor wskazywany przez *lpBuffer* zawiera 1-bitową mapę bitową na piksel, której wiersze zaczynają się na granicach DoubleWord.|
|GGO_NATIVE|Zwraca punkty danych krzywej w formacie natywnym rasteryzatora, przy użyciu jednostek urządzenia. Gdy ta wartość jest określona, wszystkie przekształcenia określone w *lpmat2* są ignorowane.|

Gdy wartość *nFormat* jest równa 0, funkcja wypełnia strukturę [GLYPHMETRICS](/windows/win32/api/wingdi/ns-wingdi-glyphmetrics) , ale nie zwraca danych z konturu symbolu.

*lpgm*<br/>
Wskazuje na strukturę GLYPHMETRICS, która opisuje położenie glifu w komórce znaku.

*cbBuffer*<br/>
Określa rozmiar buforu, do którego funkcja kopiuje informacje o znakach konspektu. Jeśli wartość jest równa 0, a parametr *nFormat* jest wartością GGO_BITMAP lub GGO_NATIVE, funkcja zwraca wymagany rozmiar buforu.

*lpBuffer*<br/>
Wskazuje bufor, do którego funkcja kopiuje informacje o znakach konspektu. Jeśli *nFormat* określa wartość GGO_NATIVE, informacje są kopiowane w postaci struktur TTPOLYGONHEADER i TTPOLYCURVE. Jeśli ta wartość jest RÓWNa NULL, a *nFormat* jest wartością GGO_BITMAP lub GGO_NATIVE, funkcja zwraca wymagany rozmiar buforu.

*lpmat2*<br/>
Wskazuje na strukturę [MAT2](/windows/win32/api/wingdi/ns-wingdi-mat2) , która zawiera macierz transformacji dla znaku. Ten parametr nie może mieć wartości NULL, nawet jeśli wartość GGO_NATIVE została określona dla *nFormat*.

### <a name="return-value"></a>Wartość zwracana

Rozmiar (w bajtach) bufora wymaganego dla pobranych informacji, jeśli *cbBuffer* jest równa 0 lub *lpBuffer* ma wartość null. W przeciwnym razie jest to wartość dodatnia, jeśli funkcja się powiedzie lub-1, jeśli wystąpi błąd.

### <a name="remarks"></a>Uwagi

Aplikacja może obrócić znaki pobrane w formacie mapy bitowej, określając tablicę transformacji 2 na 2 w strukturze wskazywanej przez *lpmat2*.

Konspekt symboli jest zwracany jako seria rozkładów. Każde kontury jest definiowane przez strukturę [TTPOLYGONHEADER](/windows/win32/api/wingdi/ns-wingdi-ttpolygonheader) , a następnie tyle, ile `TTPOLYCURVE` struktur jest wymaganych do opisywania. Wszystkie punkty są zwracane jako struktury [POINTFX](/windows/win32/api/wingdi/ns-wingdi-pointfx) i reprezentują położenia bezwzględne, a nie przenoszone. Punkt początkowy przyznany przez `pfxStart` element członkowski struktury [TTPOLYGONHEADER](/windows/win32/api/wingdi/ns-wingdi-ttpolygonheader) jest punktem, w którym rozpoczyna się konspekt konturu. Następujące struktury [TTPOLYCURVE](/windows/win32/api/wingdi/ns-wingdi-ttpolycurve) mogą być rekordami łamaną lub rekordami krzywej łamanej. Rekordy linii łamanej są serią punktów; linie rysowane między punktami opisują kontur znaku. Rekordy krzywej łamanej reprezentują krzywe kwadratowe używane przez TrueType (czyli kwadraty b-krzywe).

## <a name="cdcgetgraphicsmode"></a><a name="getgraphicsmode"></a>Przechwytywanie zmian:: getgraphicsmode

Pobiera bieżący tryb grafiki dla określonego kontekstu urządzenia.

```
int GetGraphicsMode() const;
```

### <a name="return-value"></a>Wartość zwracana

Zwraca bieżący tryb grafiki po powodzeniu. Aby zapoznać się z listą wartości, które ta metoda może zwrócić, zobacz [Getgraphicsmode](/windows/win32/api/wingdi/nf-wingdi-getgraphicsmode).

Zwraca wartość 0 w przypadku niepowodzenia.

Aby uzyskać rozszerzone informacje o błędzie, wywołaj [wartość GetLastError](/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror).

### <a name="remarks"></a>Uwagi

Ta metoda [otacza funkcję interfejsu](/windows/win32/api/wingdi/nf-wingdi-getgraphicsmode)GDI systemu Windows.

## <a name="cdcgethalftonebrush"></a><a name="gethalftonebrush"></a>Przechwytywanie zmian:: GetHalftoneBrush

Wywołaj tę funkcję elementu członkowskiego, aby pobrać pędzel półtonowy.

```
static CBrush* PASCAL GetHalftoneBrush();
```

### <a name="return-value"></a>Wartość zwracana

Wskaźnik do `CBrush` obiektu, jeśli się powiedzie; w przeciwnym razie wartość null.

### <a name="remarks"></a>Uwagi

Pędzel półtonów pokazuje piksele, które są kolorami z pierwszego planu i tła, aby utworzyć wzorzec. Poniżej znajduje się przykładowy wzorzec utworzony przez pędzel półtonów.

![Szczegóły pociągnięcia piórem](../../mfc/reference/media/vc318s1.gif "Szczegóły pociągnięcia piórem")

## <a name="cdcgetkerningpairs"></a><a name="getkerningpairs"></a>Przechwytywanie zmian:: GetKerningPairs

Pobiera pary kerningu znaków dla czcionki, która jest aktualnie wybrana w określonym kontekście urządzenia.

```
int GetKerningPairs(
    int nPairs,
    LPKERNINGPAIR lpkrnpair) const;
```

### <a name="parameters"></a>Parametry

*nPairs*<br/>
Określa liczbę struktur [KERNINGPAIR](/windows/win32/api/wingdi/ns-wingdi-kerningpair) wskazanych przez *lpkrnpair*. Funkcja nie będzie kopiować większej liczby par kerningu niż określona przez *nPairs*.

*lpkrnpair*<br/>
Wskazuje tablicę `KERNINGPAIR` struktur, które odbierają pary kerningu, gdy funkcja zwraca wartość. Tablica musi zawierać co najmniej tyle struktur, jak określono przez *nPairs*. Jeśli ten parametr ma wartość NULL, funkcja zwraca łączną liczbę par kerningu dla czcionki.

### <a name="return-value"></a>Wartość zwracana

Określa liczbę par kerningu lub łączną liczbę par kerningu w czcionce, jeśli funkcja się powiedzie. Jeśli funkcja nie powiedzie się lub nie ma par kerningu dla czcionki, zwracana jest wartość zero.

## <a name="cdcgetlayout"></a><a name="getlayout"></a>Przechwytywanie zmian:: GetLayout

Wywołaj tę funkcję elementu członkowskiego, aby określić układ tekstu i grafiki dla kontekstu urządzenia, takiego jak drukarka lub metaplik.

```
DWORD GetLayout() const;
```

### <a name="return-value"></a>Wartość zwracana

Jeśli to się powiedzie, flagi układu dla bieżącego kontekstu urządzenia. W przeciwnym razie GDI_ERROR. Aby uzyskać rozszerzone informacje o błędzie, wywołaj [wartość GetLastError](/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror). Aby uzyskać listę flag układu, zobacz przechwytywanie [:: SetLayout](#setlayout).

### <a name="remarks"></a>Uwagi

Domyślny układ to od lewej do prawej.

## <a name="cdcgetmapmode"></a><a name="getmapmode"></a>Przechwytywanie zmian:: GetMapMode

Pobiera bieżący tryb mapowania.

```
int GetMapMode() const;
```

### <a name="return-value"></a>Wartość zwracana

Tryb mapowania.

### <a name="remarks"></a>Uwagi

Aby uzyskać opis trybów mapowania, zobacz `SetMapMode` funkcja członkowska.

> [!NOTE]
> Jeśli wywołasz metodę [SetLayout](#setlayout) w celu zmiany układu DC na układ od prawej do lewej, program `SetLayout` automatycznie zmieni tryb mapowania na MM_ISOTROPIC. W związku z tym każde kolejne wywołanie zwróci `GetMapMode` MM_ISOTROPIC.

## <a name="cdcgetmiterlimit"></a><a name="getmiterlimit"></a>Przechwytywanie zmian:: GetMiterLimit

Zwraca limit ścięcia dla kontekstu urządzenia.

```
float GetMiterLimit() const;
```

### <a name="return-value"></a>Wartość zwracana

Różne od zera, jeśli funkcja zakończyła się pomyślnie; w przeciwnym razie 0.

### <a name="remarks"></a>Uwagi

Próg ścięcia jest używany podczas rysowania linii geometrycznych mających sprzężenia ścięcia.

## <a name="cdcgetnearestcolor"></a><a name="getnearestcolor"></a>Przechwytywanie zmian:: GetNearestColor

Zwraca pełny kolor, który najlepiej pasuje do określonego koloru logicznego.

```
COLORREF GetNearestColor(COLORREF crColor) const;
```

### <a name="parameters"></a>Parametry

*crColor*<br/>
Określa kolor, który ma zostać dopasowany.

### <a name="return-value"></a>Wartość zwracana

Wartość koloru RGB (czerwony, zielony, niebieski), która definiuje pełny kolor zbliżony do wartości *crColor* , którą urządzenie może reprezentować.

### <a name="remarks"></a>Uwagi

Określone urządzenie musi mieć możliwość reprezentowania tego koloru.

## <a name="cdcgetoutlinetextmetrics"></a><a name="getoutlinetextmetrics"></a>Przechwytywanie zmian:: GetOutlineTextMetrics

Pobiera informacje o metrykach czcionek TrueType.

```
UINT GetOutlineTextMetrics(
    UINT cbData,
    LPOUTLINETEXTMETRIC lpotm) const;
```

### <a name="parameters"></a>Parametry

*lpotm*<br/>
Wskazuje tablicę struktur [OUTLINETEXTMETRIC](/windows/win32/api/wingdi/ns-wingdi-outlinetextmetricw) . Jeśli ten parametr ma wartość NULL, funkcja zwraca rozmiar buforu wymagany dla pobranych danych metryki.

*cbData*<br/>
Określa rozmiar bufora, do którego zwracane są informacje w bajtach.

*lpotm*<br/>
Wskazuje `OUTLINETEXTMETRIC` strukturę. Jeśli ten parametr ma wartość NULL, funkcja zwraca rozmiar buforu wymagany dla pobranych informacji o metryki.

### <a name="return-value"></a>Wartość zwracana

Różne od zera, jeśli funkcja zakończyła się pomyślnie; w przeciwnym razie 0.

### <a name="remarks"></a>Uwagi

Struktura [OUTLINETEXTMETRIC](/windows/win32/api/wingdi/ns-wingdi-outlinetextmetricw) zawiera większość informacji o metrykach czcionki dostarczonych w formacie TrueType, w tym strukturę [TEXTMETRIC](/windows/win32/api/wingdi/ns-wingdi-textmetricw) . Ostatnie cztery składowe `OUTLINETEXTMETRIC` struktury są wskaźnikami do ciągów. Aplikacje powinny przydzielić miejsce dla tych ciągów oprócz miejsca wymaganego dla innych elementów członkowskich. Ponieważ nie ma limitu narzuconego przez system do rozmiaru ciągów, Najprostszą metodą alokacji pamięci jest pobranie wymaganego rozmiaru przez określenie wartości NULL dla *lpotm* w pierwszym wywołaniu `GetOutlineTextMetrics` funkcji.

## <a name="cdcgetoutputcharwidth"></a><a name="getoutputcharwidth"></a>Przechwytywanie zmian:: GetOutputCharWidth

Używa kontekstu urządzenia wyjściowego, `m_hDC` i pobiera szerokości pojedynczych znaków w kolejnej grupie znaków z bieżącej czcionki.

```
BOOL GetOutputCharWidth(
    UINT nFirstChar,
    UINT nLastChar,
    LPINT lpBuffer) const;
```

### <a name="parameters"></a>Parametry

*nFirstChar*<br/>
Określa pierwszy znak w kolejnej grupie znaków w bieżącej czcionce.

*nLastChar*<br/>
Określa ostatni znak w kolejnej grupie znaków w bieżącej czcionce.

*lpBuffer*<br/>
Wskazuje bufor, który będzie otrzymywał wartości szerokości dla kolejnej grupy znaków w bieżącej czcionce.

### <a name="return-value"></a>Wartość zwracana

Różne od zera, jeśli funkcja zakończyła się pomyślnie; w przeciwnym razie 0.

### <a name="remarks"></a>Uwagi

Na przykład jeśli *nFirstChar* identyfikuje literę "a", a *nLastChar* identyfikuje literę "z", funkcja pobiera szerokości wszystkich małych liter.

Funkcja przechowuje wartości w buforze wskazywanym przez *lpBuffer*. Ten bufor musi być wystarczająco duży, aby pomieścić wszystkie szerokości; oznacza to, że w podanym przykładzie musi znajdować się co najmniej 26 wpisów.

Jeśli znak w kolejnej grupie znaków nie istnieje w określonej czcionce, zostanie przypisana wartość szerokości znaku domyślnego.

## <a name="cdcgetoutputtabbedtextextent"></a><a name="getoutputtabbedtextextent"></a>Przechwytywanie zmian:: GetOutputTabbedTextExtent

Wywołaj tę funkcję elementu członkowskiego, aby obliczyć szerokość i wysokość ciągu znaków przy użyciu [m_hDC](#m_hdc), kontekstu urządzenia wyjściowego.

```
CSize GetOutputTabbedTextExtent(
    LPCTSTR lpszString,
    int nCount,
    int nTabPositions,
    LPINT lpnTabStopPositions) const;

CSize GetOutputTabbedTextExtent(
    const CString& str,
    int nTabPositions,
    LPINT lpnTabStopPositions) const;
```

### <a name="parameters"></a>Parametry

*lpszString*<br/>
Wskazuje ciąg znaków, który ma być mierzony. Można również przekazać obiekt [CString](../../atl-mfc-shared/reference/cstringt-class.md) dla tego parametru.

*nCount*<br/>
Określa [Długość ciągu](/windows/win32/gdi/specifying-length-of-text-output-string) wskazywanego przez *lpszString*.

*nTabPositions*<br/>
Określa liczbę pozycji tabulatora w tablicy wskazywanej przez *lpnTabStopPositions*.

*lpnTabStopPositions*<br/>
Wskazuje tablicę liczb całkowitych zawierających pozycje tabulatora w jednostkach logicznych. Tabulatory muszą być sortowane w kolejności rosnącej; najmniejsza wartość x powinna być pierwszym elementem w tablicy. Karty wstecz są niedozwolone.

*str*<br/>
`CString`Obiekt, który zawiera określone znaki, które mają być mierzone.

### <a name="return-value"></a>Wartość zwracana

Wymiary ciągu (w jednostkach logicznych) w obiekcie [CSize](../../atl-mfc-shared/reference/csize-class.md) .

### <a name="remarks"></a>Uwagi

Jeśli ciąg zawiera jeden lub więcej znaków tabulacji, Szerokość ciągu jest określana na podstawie tabulatorów określonych przez *lpnTabStopPositions*. Funkcja używa aktualnie wybranej czcionki do obliczenia wymiarów ciągu.

Bieżący region wycinka nie przesuwa szerokości i wysokości zwracanej przez `GetOutputTabbedTextExtent` funkcję.

Ponieważ niektóre urządzenia nie umieszczają znaków w zwykłych tablicach komórek (oznacza to, że znaki te są kerningowe), suma zakresów znaków w ciągu może nie być równa zakresowi ciągu.

Jeśli *nTabPositions* jest równa 0, a *lpnTabStopPositions* ma wartość null, karty są rozwinięte do ośmiu średniej szerokości znaków. Jeśli *nTabPositions* ma wartość 1, tabulator zostanie oddzielony o odległość określoną przez pierwszą wartość w tablicy, do której *lpnTabStopPositions* punkty. Jeśli *lpnTabStopPositions* wskazuje więcej niż pojedynczą wartość, tabulator jest ustawiany dla każdej wartości w tablicy, do numeru określonego przez *nTabPositions*.

## <a name="cdcgetoutputtextextent"></a><a name="getoutputtextextent"></a>Przechwytywanie zmian:: GetOutputTextExtent

Wywołaj tę funkcję elementu członkowskiego, aby użyć kontekstu urządzenia wyjściowego, [m_hDC](#m_hdc)i obliczyć szerokość i wysokość wiersza tekstu przy użyciu bieżącej czcionki.

```
CSize GetOutputTextExtent(
    LPCTSTR lpszString,
    int nCount) const;

CSize GetOutputTextExtent(const CString& str) const;
```

### <a name="parameters"></a>Parametry

*lpszString*<br/>
Wskazuje ciąg znaków. Można również przekazać obiekt [CString](../../atl-mfc-shared/reference/cstringt-class.md) dla tego parametru.

*nCount*<br/>
Określa [Długość ciągu](/windows/win32/gdi/specifying-length-of-text-output-string) wskazywanego przez *lpszString*.

*str*<br/>
`CString`Obiekt, który zawiera określone znaki, które mają być mierzone.

### <a name="return-value"></a>Wartość zwracana

Wymiary ciągu (w jednostkach logicznych) zwrócone w obiekcie [CSize](../../atl-mfc-shared/reference/csize-class.md) .

### <a name="remarks"></a>Uwagi

Bieżący region wycinka nie ma wpływu na szerokość i wysokość zwracaną przez `GetOutputTextExtent` .

Ponieważ niektóre urządzenia nie umieszczają znaków w zwykłych tablicach komórek (to oznacza, że przestają się kerningiem), suma zakresów znaków w ciągu może nie być równa zakresowi ciągu.

## <a name="cdcgetoutputtextmetrics"></a><a name="getoutputtextmetrics"></a>Przechwytywanie zmian:: GetOutputTextMetrics

Pobiera metryki dla bieżącej czcionki przy użyciu `m_hDC` , kontekstu urządzenia wyjściowego.

```
BOOL GetOutputTextMetrics(LPTEXTMETRIC lpMetrics) const;
```

### <a name="parameters"></a>Parametry

*lpMetrics*<br/>
Wskazuje strukturę [TEXTMETRIC](/windows/win32/api/wingdi/ns-wingdi-textmetricw) , która otrzymuje metryki.

### <a name="return-value"></a>Wartość zwracana

Różne od zera, jeśli funkcja zakończyła się pomyślnie; w przeciwnym razie 0.

## <a name="cdcgetpath"></a><a name="getpath"></a>Przechwytywanie zmian:: GetPath

Pobiera współrzędne definiujące punkty końcowe linii i punkty kontrolne krzywych znalezionych w ścieżce zaznaczonej w kontekście urządzenia.

```
int GetPath(
    LPPOINT lpPoints,
    LPBYTE lpTypes,
    int nCount) const;
```

### <a name="parameters"></a>Parametry

*lpPoints*<br/>
Wskazuje tablicę struktur danych [punktu](/windows/win32/api/windef/ns-windef-point) lub `CPoint` obiektów, w których umieszczane są punkty końcowe linii i punktów kontrolnych krzywej.

*lpTypes*<br/>
Wskazuje tablicę bajtów, w której są umieszczane typy wierzchołków. Wartości są jedną z następujących:

- PT_MOVETO określa, że odpowiadający punkt w *lpPoints* zaczyna rozłączać.

- PT_LINETO określa, że poprzedni punkt i odpowiadający mu punkt w *lpPoints* są punktami końcowymi wiersza.

- PT_BEZIERTO określa, że odpowiadający punkt w *lpPoints* jest punktem kontrolnym lub punktem końcowym krzywej Bzier.

Typy PT_BEZIERTO zawsze występują w zestawach trzech. Punkt w ścieżce bezpośrednio poprzedzający je definiuje punkt początkowy dla krzywej Bzier. Pierwsze dwa punkty PT_BEZIERTO są punktami kontrolnymi, a trzeci punkt PT_BEZIERTO jest punktem końcowym (jeśli jest sztywno zakodowany).

   Typ PT_LINETO lub PT_BEZIERTO może być połączony z następującą flagą (za pomocą operatora bitowego **lub**), aby wskazać, że odpowiadający punkt jest ostatnim punktem na rysunku i że rysunek powinien być zamknięty:

- PT_CLOSEFIGURE określa, że rysunek jest automatycznie zamykany po narysowaniu odpowiedniego wiersza lub krzywej. Rysunek jest zamykany przez rysowanie linii z punktu końcowego linii lub łuku do punktu odpowiadającego ostatniemu PT_MOVETO.

*nCount*<br/>
Określa łączną liczbę struktur danych [punktu](/windows/win32/api/windef/ns-windef-point) , które mogą być umieszczone w tablicy *lpPoints* . Ta wartość musi być taka sama jak liczba bajtów, które mogą być umieszczone w tablicy *lpTypes* .

### <a name="return-value"></a>Wartość zwracana

Jeśli parametr *nCount* ma wartość różną od zera, liczba wyliczonych punktów. Jeśli *nCount* jest równa 0, łączną liczbę punktów w ścieżce (i `GetPath` zapisuje nic do buforów). Jeśli *nCount* jest różna od zera i jest mniejsza niż liczba punktów w ścieżce, zwracana wartość to-1.

### <a name="remarks"></a>Uwagi

Kontekst urządzenia musi zawierać ścieżkę zamkniętą. Punkty ścieżki są zwracane we współrzędnych logicznych. Punkty są przechowywane w ścieżce we współrzędnych urządzenia, dlatego `GetPath` zmieniają punkty ze współrzędnych urządzenia na współrzędne logiczne przy użyciu odwrotności bieżącego przekształcenia. `FlattenPath`Funkcja członkowska może być wywoływana wcześniej `GetPath` , aby przekonwertować wszystkie krzywe w ścieżce na segmenty linii.

### <a name="example"></a>Przykład

  Zobacz przykład dla danych [przechwytywania:: BeginPath](#beginpath).

## <a name="cdcgetpixel"></a><a name="getpixel"></a>Przechwytywanie zmian:: GetPixel

Pobiera wartość RGB koloru piksela w punkcie określonym przez *x* i *y*.

```
COLORREF GetPixel(
    int x,
    int y) const;

COLORREF GetPixel(POINT point) const;
```

### <a name="parameters"></a>Parametry

*x*<br/>
Określa logiczną współrzędną x punktu, który ma zostać zbadany.

*t*<br/>
Określa logiczną współrzędną y punktu, który ma zostać zbadany.

*moment*<br/>
Określa współrzędne x i y punktu, który ma zostać zbadany.

### <a name="return-value"></a>Wartość zwracana

Dla każdej wersji funkcji kolor RGB jest kolorem danego punktu. Ma wartość-1, jeśli współrzędne nie określają punktu w regionie przycinania.

### <a name="remarks"></a>Uwagi

Punkt musi znajdować się w regionie przycinania. Jeśli punkt nie znajduje się w regionie przycinania, funkcja nie ma żadnego efektu i zwróci wartość-1.

Nie wszystkie urządzenia obsługują `GetPixel` funkcję. Aby uzyskać więcej informacji, zobacz RC_BITBLT rastrową w ramach funkcji składowej [GetDeviceCaps](#getdevicecaps) .

`GetPixel`Funkcja członkowska ma dwa formularze. Pierwszy pobiera dwie wartości współrzędnych; Druga pobiera strukturę [punktu](/windows/win32/api/windef/ns-windef-point) lub obiekt [CPoint](../../atl-mfc-shared/reference/cpoint-class.md) .

## <a name="cdcgetpolyfillmode"></a><a name="getpolyfillmode"></a>Przechwytywanie zmian:: GetPolyFillMode

Pobiera bieżący tryb wypełniania wielokątów.

```
int GetPolyFillMode() const;
```

### <a name="return-value"></a>Wartość zwracana

Bieżący tryb wypełniania wielokątów, ALTERNATYWny lub UZWOJENIe, jeśli funkcja się powiedzie.

### <a name="remarks"></a>Uwagi

Zobacz `SetPolyFillMode` funkcję członkowską, aby uzyskać opis trybów wypełniania wielokątów.

## <a name="cdcgetrop2"></a><a name="getrop2"></a>Przechwytywanie zmian:: GetROP2

Pobiera bieżący tryb rysowania.

```
int GetROP2() const;
```

### <a name="return-value"></a>Wartość zwracana

Tryb rysowania. Aby zapoznać się z listą wartości trybu rysowania, zobacz `SetROP2` funkcja członkowska.

### <a name="remarks"></a>Uwagi

Tryb rysowania określa, w jaki sposób kolory pióra i wnętrza wypełnionych obiektów są połączone z kolorem znajdującym się już na powierzchni ekranu.

## <a name="cdcgetsafehdc"></a><a name="getsafehdc"></a>Przechwytywanie zmian:: GetSafeHdc

Wywołaj tę funkcję elementu członkowskiego, aby uzyskać [m_hDC](#m_hdc), kontekst urządzenia wyjściowego.

```
HDC GetSafeHdc() const;
```

### <a name="return-value"></a>Wartość zwracana

Dojście kontekstu urządzenia.

### <a name="remarks"></a>Uwagi

Ta funkcja członkowska działa również ze wskaźnikami o wartości null.

## <a name="cdcgetstretchbltmode"></a><a name="getstretchbltmode"></a>Przechwytywanie zmian:: GetStretchBltMode

Pobiera bieżący tryb rozciągnięcia mapy bitowej.

```
int GetStretchBltMode() const;
```

### <a name="return-value"></a>Wartość zwracana

Wartość zwracana określa bieżący tryb rozciągnięcia mapy bitowej — STRETCH_ANDSCANS, STRETCH_DELETESCANS lub STRETCH_ORSCANS — Jeśli funkcja się powiedzie.

### <a name="remarks"></a>Uwagi

Tryb rozciągnięcia mapy bitowej definiuje, jak informacje są usuwane z bitmap, które są rozciągane lub kompresowane przez `StretchBlt` funkcję członkowską.

Tryby STRETCH_ANDSCANS i STRETCH_ORSCANS są zwykle używane do zachowywania pikseli pierwszego planu w przypadku monochromatycznych map bitowych. Tryb STRETCH_DELETESCANS jest zazwyczaj używany do zachowywania koloru w bitmapach kolorowych.

## <a name="cdcgettabbedtextextent"></a><a name="gettabbedtextextent"></a>Przechwytywanie zmian:: GetTabbedTextExtent

Wywołaj tę funkcję elementu członkowskiego, aby obliczyć szerokość i wysokość ciągu znaków przy użyciu [m_hAttribDC](#m_hattribdc), kontekst urządzenia atrybutu.

```
CSize GetTabbedTextExtent(
    LPCTSTR lpszString,
    int nCount,
    int nTabPositions,
    LPINT lpnTabStopPositions) const;

CSize GetTabbedTextExtent(
    const CString& str,
    int nTabPositions,
    LPINT lpnTabStopPositions) const;
```

### <a name="parameters"></a>Parametry

*lpszString*<br/>
Wskazuje ciąg znaków. Można również przekazać obiekt [CString](../../atl-mfc-shared/reference/cstringt-class.md) dla tego parametru.

*nCount*<br/>
Określa [Długość ciągu](/windows/win32/gdi/specifying-length-of-text-output-string) wskazywanego przez *lpszString*.

*nTabPositions*<br/>
Określa liczbę pozycji tabulatora w tablicy wskazywanej przez *lpnTabStopPositions*.

*lpnTabStopPositions*<br/>
Wskazuje tablicę liczb całkowitych zawierających pozycje tabulatora w jednostkach logicznych. Tabulatory muszą być sortowane w kolejności rosnącej; najmniejsza wartość x powinna być pierwszym elementem w tablicy. Karty wstecz są niedozwolone.

*str*<br/>
`CString`Obiekt, który zawiera określone znaki do narysowania.

### <a name="return-value"></a>Wartość zwracana

Wymiary ciągu (w jednostkach logicznych) w obiekcie [CSize](../../atl-mfc-shared/reference/csize-class.md) .

### <a name="remarks"></a>Uwagi

Jeśli ciąg zawiera jeden lub więcej znaków tabulacji, Szerokość ciągu jest określana na podstawie tabulatorów określonych przez *lpnTabStopPositions*. Funkcja używa aktualnie wybranej czcionki do obliczenia wymiarów ciągu.

Bieżący region wycinka nie przesuwa szerokości i wysokości zwracanej przez `GetTabbedTextExtent` funkcję.

Ponieważ niektóre urządzenia nie umieszczają znaków w zwykłych tablicach komórek (oznacza to, że znaki te są kerningowe), suma zakresów znaków w ciągu może nie być równa zakresowi ciągu.

Jeśli *nTabPositions* jest 0, a *lpnTabStopPositions* ma wartość null, karty są rozwinięte do ośmiu razy średniej szerokości znaków. Jeśli *nTabPositions* ma wartość 1, tabulator zostanie oddzielony o odległość określoną przez pierwszą wartość w tablicy, do której *lpnTabStopPositions* punkty. Jeśli *lpnTabStopPositions* wskazuje więcej niż pojedynczą wartość, tabulator jest ustawiany dla każdej wartości w tablicy, do numeru określonego przez *nTabPositions*.

## <a name="cdcgettextalign"></a><a name="gettextalign"></a>Przechwytywanie zmian:: TextAlign

Pobiera stan flag wyrównania tekstu dla kontekstu urządzenia.

```
UINT GetTextAlign() const;
```

### <a name="return-value"></a>Wartość zwracana

Stan flag wyrównania tekstu. Wartość zwracana to co najmniej jedna z następujących wartości:

- TA_BASELINE określa wyrównanie osi x i linię bazową wybranej czcionki w prostokącie obwiedni.

- TA_BOTTOM określa wyrównanie osi x i dolnego prostokąta ograniczenia.

- TA_CENTER określa wyrównanie osi y i środka prostokąta ograniczenia.

- TA_LEFT określa wyrównanie osi y i lewej krawędzi prostokąta granicznego.

- TA_NOUPDATECP określa, że bieżąca pozycja nie jest aktualizowana.

- TA_RIGHT określa wyrównanie osi y i po prawej stronie prostokąta obwiedni.

- TA_TOP określa wyrównanie osi x i górnego prostokąta ograniczenia.

- TA_UPDATECP określa, czy bieżące położenie zostało zaktualizowane.

### <a name="remarks"></a>Uwagi

Flagi wyrównania tekstu określają sposób, w `TextOut` jaki `ExtTextOut` funkcje elementów członkowskich są wyrównane do ciągu tekstowego w odniesieniu do punktu początkowego ciągu. Flagi wyrównania tekstu nie muszą mieć flag jednobitowe i mogą być równe 0. Aby sprawdzić, czy flaga jest ustawiona, aplikacja powinna wykonać następujące czynności:

1. Zastosuj operator bitowy OR do flagi i powiązane z nią flagi, pogrupowane w następujący sposób:

   - TA_LEFT, TA_CENTER i TA_RIGHT

   - TA_BASELINE, TA_BOTTOM i TA_TOP

   - TA_NOUPDATECP i TA_UPDATECP

1. Zastosuj operator koniunkcji bitowe do wyniku i wartość zwracaną `GetTextAlign` .

1. Przetestuj ten wynik i flagę.

## <a name="cdcgettextcharacterextra"></a><a name="gettextcharacterextra"></a>Przechwytywanie zmian:: GetTextCharacterExtra

Pobiera bieżące ustawienie wielkości odstępów między znakami.

```
int GetTextCharacterExtra() const;
```

### <a name="return-value"></a>Wartość zwracana

Wielkość odstępów między znakami.

### <a name="remarks"></a>Uwagi

Interfejs GDI dodaje te odstępy do każdego znaku, w tym znaki łamania, gdy zapisuje wiersz tekstu do kontekstu urządzenia.

Wartość domyślna dla wielkości odstępów między znakami wynosi 0.

## <a name="cdcgettextcolor"></a><a name="gettextcolor"></a>Przechwytywanie zmian:: GetTextColor

Pobiera bieżący kolor tekstu.

```
COLORREF GetTextColor() const;
```

### <a name="return-value"></a>Wartość zwracana

Bieżący kolor tekstu jako wartość koloru RGB.

### <a name="remarks"></a>Uwagi

Kolor tekstu jest kolorem pierwszego planu znaków rysowanych za pomocą funkcji tekstowych danych wyjściowych GDI [TextOut](#textout), [ExtTextOut](#exttextout)i [TabbedTextOut](#tabbedtextout).

## <a name="cdcgettextextent"></a><a name="gettextextent"></a>Przechwytywanie zmian:: GetTextExtent

Wywołaj tę funkcję elementu członkowskiego, aby obliczyć szerokość i wysokość wiersza tekstu przy użyciu bieżącej czcionki, aby określić wymiary.

```
CSize GetTextExtent(
    LPCTSTR lpszString,
    int nCount) const;

CSize GetTextExtent(const CString& str) const;
```

### <a name="parameters"></a>Parametry

*lpszString*<br/>
Wskazuje ciąg znaków. Można również przekazać obiekt [CString](../../atl-mfc-shared/reference/cstringt-class.md) dla tego parametru.

*nCount*<br/>
Określa liczbę znaków w ciągu.

*str*<br/>
`CString`Obiekt, który zawiera określone znaki.

### <a name="return-value"></a>Wartość zwracana

Wymiary ciągu (w jednostkach logicznych) w obiekcie [CSize](../../atl-mfc-shared/reference/csize-class.md) .

### <a name="remarks"></a>Uwagi

Informacje są pobierane z [m_hAttribDC](#m_hattribdc), kontekstu atrybutu urządzenia.

Domyślnie, zakłada, że `GetTextExtent` tekst, dla którego pobierany jest wymiar, jest ustawiany wzdłuż linii poziomej (oznacza to, że ucieczka to 0). Jeśli utworzysz czcionkę określającą zerową wartość ucieczki, musisz jawnie skonwertować kąt tekstu, aby uzyskać wymiary ciągu.

Bieżący region wycinka nie ma wpływu na szerokość i wysokość zwracaną przez `GetTextExtent` .

Ponieważ niektóre urządzenia nie umieszczają znaków w zwykłych tablicach komórek (to oznacza, że przestają się kerningiem), suma zakresów znaków w ciągu może nie być równa zakresowi ciągu.

## <a name="cdcgettextextentexpointi"></a><a name="gettextextentexpointi"></a>Przechwytywanie zmian:: GetTextExtentExPointI

Pobiera liczbę znaków w określonym ciągu, które mieszczą się w określonym miejscu i wypełnia tablicę w zakresie tekstu dla każdego z tych znaków.

```
BOOL GetTextExtentExPointI(
    LPWORD pgiIn,
    int cgi,
    int nMaxExtent,
    LPINT lpnFit,
    LPINT alpDx,
    LPSIZE lpSize) const;
```

### <a name="parameters"></a>Parametry

*pgiIn*<br/>
Wskaźnik do tablicy indeksów symboli, dla których mają zostać pobrane zakresy.

*Aplikacja*<br/>
Określa liczbę symboli w tablicy wskazywanych przez *pgiIn*.

*nMaxExtent*<br/>
Określa maksymalną dozwoloną Szerokość (w jednostkach logicznych) sformatowanego ciągu.

*lpnFit*<br/>
Wskaźnik do liczby całkowitej, która otrzymuje liczbę znaków, które zmieszczą się w miejscu określonym przez *nMaxExtent*. Gdy *lpnFit* ma wartość null, *nMaxExtent* jest ignorowany.

*alpDx*<br/>
Wskaźnik do tablicy liczb całkowitych, który odbiera częściowe zakresy symboli. Każdy element w tablicy zapewnia odległość, w jednostkach logicznych, między początkiem tablicy indeksów symboli a jednym z glifów, które pasują do miejsca określonego przez *nMaxExtent*. Mimo że ta tablica powinna zawierać co najmniej tyle elementów jako indeksów symboli określonych przez *CGI*, funkcja wypełnia tablicę zakresami tylko dla tylu indeksów symboli, które są określone przez *lpnFit*. Jeśli *lpnDx* ma wartość null, funkcja nie oblicza częściowych szerokości ciągu.

*lpSize*<br/>
Wskaźnik do struktury [rozmiaru](/windows/win32/api/windef/ns-windef-size) , który odbiera Wymiary tablicy indeksów symboli w jednostkach logicznych. Ta wartość nie może być RÓWNa NULL.

### <a name="return-value"></a>Wartość zwracana

Różne od zera, jeśli funkcja zakończyła się pomyślnie; w przeciwnym razie 0.

### <a name="remarks"></a>Uwagi

Ta funkcja członkowska emuluje funkcjonalność funkcji [GetTextExtentExPointI](/windows/win32/api/wingdi/nf-wingdi-gettextextentexpointi), zgodnie z opisem w Windows SDK.

## <a name="cdcgettextextentpointi"></a><a name="gettextextentpointi"></a>Przechwytywanie zmian:: GetTextExtentPointI

Pobiera szerokość i wysokość określonej tablicy indeksów symboli.

```
BOOL GetTextExtentPointI(
    LPWORD pgiIn,
    int cgi,
    LPSIZE lpSize) const;
```

### <a name="parameters"></a>Parametry

*pgiIn*<br/>
Wskaźnik do tablicy indeksów symboli, dla których mają zostać pobrane zakresy.

*Aplikacja*<br/>
Określa liczbę symboli w tablicy wskazywanych przez *pgiIn*.

*lpSize*<br/>
Wskaźnik do struktury [rozmiaru](/windows/win32/api/windef/ns-windef-size) , który odbiera Wymiary tablicy indeksów symboli w jednostkach logicznych. Ta wartość nie może być RÓWNa NULL.

### <a name="return-value"></a>Wartość zwracana

Różne od zera, jeśli funkcja zakończyła się pomyślnie; w przeciwnym razie 0.

### <a name="remarks"></a>Uwagi

Ta funkcja członkowska emuluje funkcjonalność funkcji [GetTextExtentPointI](/windows/win32/api/wingdi/nf-wingdi-gettextextentpointi), zgodnie z opisem w Windows SDK.

## <a name="cdcgettextface"></a><a name="gettextface"></a>Przechwytywanie zmian:: GetTextFace

Wywołaj tę funkcję elementu członkowskiego, aby skopiować nazwę kroju bieżącej czcionki do buforu.

```
int GetTextFace(
    int nCount,
    LPTSTR lpszFacename) const;

int GetTextFace(CString& rString) const;
```

### <a name="parameters"></a>Parametry

*nCount*<br/>
Określa rozmiar buforu (w bajtach). Jeśli nazwa kroju jest dłuższa niż liczba bajtów określona przez ten parametr, nazwa zostanie obcięta.

*lpszFacename*<br/>
Wskazuje bufor dla nazwy kroju.

*rString*<br/>
Odwołanie do obiektu [CString](../../atl-mfc-shared/reference/cstringt-class.md) .

### <a name="return-value"></a>Wartość zwracana

Liczba bajtów skopiowanych do buforu bez uwzględniania kończącego znaku null. Jeśli wystąpi błąd, wartość jest równa 0.

### <a name="remarks"></a>Uwagi

Nazwa kroju jest kopiowana jako ciąg zakończony znakiem null.

## <a name="cdcgettextmetrics"></a><a name="gettextmetrics"></a>Przechwytywanie zmian:: GetTextMetrics

Pobiera metryki dla bieżącej czcionki przy użyciu kontekstu urządzenia atrybutu.

```
BOOL GetTextMetrics(LPTEXTMETRIC lpMetrics) const;
```

### <a name="parameters"></a>Parametry

*lpMetrics*<br/>
Wskazuje strukturę [TEXTMETRIC](/windows/win32/api/wingdi/ns-wingdi-textmetricw) , która otrzymuje metryki.

### <a name="return-value"></a>Wartość zwracana

Różne od zera, jeśli funkcja zakończyła się pomyślnie; w przeciwnym razie 0.

## <a name="cdcgetviewportext"></a><a name="getviewportext"></a>Przechwytywanie zmian:: GetViewportExt

Pobiera zakresy x i y okienka ekranu kontekstu urządzenia.

```
CSize GetViewportExt() const;
```

### <a name="return-value"></a>Wartość zwracana

Zakresy x i y (w jednostkach urządzeń) jako `CSize` obiekt.

## <a name="cdcgetviewportorg"></a><a name="getviewportorg"></a>Przechwytywanie zmian:: GetViewportOrg

Pobiera współrzędne x i y źródła okienka ekranu skojarzonego z kontekstem urządzenia.

```
CPoint GetViewportOrg() const;
```

### <a name="return-value"></a>Wartość zwracana

Początek okienka ekranu (współrzędne urządzenia) jako `CPoint` obiekt.

## <a name="cdcgetwindow"></a><a name="getwindow"></a>Przechwytywanie zmian:: GetWindow

Zwraca okno skojarzone z kontekstem wyświetlania urządzenia.

```
CWnd* GetWindow() const;
```

### <a name="return-value"></a>Wartość zwracana

Wskaźnik do `CWnd` obiektu, jeśli się powiedzie; w przeciwnym razie wartość null.

### <a name="remarks"></a>Uwagi

Jest to funkcja zaawansowana. Na przykład ta funkcja członkowska może nie zwracać okna widoku podczas drukowania lub w podglądzie wydruku. Zawsze zwraca okno skojarzone z danymi wyjściowymi. Funkcje wyjściowe korzystające z danego kontrolera domeny są rysowane w tym oknie.

## <a name="cdcgetwindowext"></a><a name="getwindowext"></a>Przechwytywanie zmian:: GetWindowExt

Pobiera zakresy x i y okna skojarzonego z kontekstem urządzenia.

```
CSize GetWindowExt() const;
```

### <a name="return-value"></a>Wartość zwracana

Zakresy x i y (w jednostkach logicznych) jako `CSize` obiekt.

## <a name="cdcgetwindoworg"></a><a name="getwindoworg"></a>Przechwytywanie zmian:: GetWindowOrg

Pobiera współrzędne x i y źródła okna skojarzonego z kontekstem urządzenia.

```
CPoint GetWindowOrg() const;
```

### <a name="return-value"></a>Wartość zwracana

Początek okna (współrzędne logiczne) jako `CPoint` obiekt.

## <a name="cdcgetworldtransform"></a><a name="getworldtransform"></a>Przechwytywanie zmian:: GetWorldTransform

Pobiera bieżące miejsce na przekształcenie obszaru strony.

```
BOOL GetWorldTransform(XFORM& rXform) const;
```

### <a name="parameters"></a>Parametry

*rXform*<br/>
Odwołanie do struktury [Xform](/windows/win32/api/wingdi/ns-wingdi-xform) , która otrzymuje bieżącą przestrzeń na przekształceniu na stronę.

### <a name="return-value"></a>Wartość zwracana

Zwraca wartość różną od zera.

Zwraca wartość 0 w przypadku niepowodzenia.

Aby uzyskać rozszerzone informacje o błędzie, wywołaj [wartość GetLastError](/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror).

### <a name="remarks"></a>Uwagi

Ta metoda otacza funkcję [GetWorldTransform](/windows/win32/api/wingdi/nf-wingdi-getworldtransform)systemu Windows.

## <a name="cdcgradientfill"></a><a name="gradientfill"></a>Przechwytywanie zmian:: GradientFill

Wywołaj tę funkcję elementu członkowskiego, aby wypełnić struktury prostokątów i trójkątów kolorem, który płynnie zanika od jednej strony do drugiego.

```
BOOL GradientFill(
    TRIVERTEX* pVertices,
    ULONG nVertices,
    void* pMesh,
    ULONG nMeshElements,
    DWORD dwMode);
```

### <a name="parameters"></a>Parametry

*pVertices*<br/>
Wskaźnik do tablicy struktur [TRIVERTEX](/windows/win32/api/wingdi/ns-wingdi-trivertex) , które definiują trójkątny wierzchołek.

*nVertices*<br/>
Liczba wierzchołków.

*pMesh*<br/>
Tablica struktur [GRADIENT_TRIANGLE](/windows/win32/api/wingdi/ns-wingdi-gradient_triangle) w trybie trójkąta lub tablica struktur [GRADIENT_RECT](/windows/win32/api/wingdi/ns-wingdi-gradient_rect) w trybie prostokąta.

*nMeshElements*<br/>
Liczba elementów (trójkątów lub prostokątów) w *pMesh*.

*dwMode*<br/>
Określa tryb wypełnienia gradientu. Aby uzyskać listę możliwych wartości, zobacz [GradientFill](/windows/win32/api/wingdi/nf-wingdi-gradientfill) w Windows SDK.

### <a name="return-value"></a>Wartość zwracana

Wartość TRUE, jeśli powodzenie; w przeciwnym razie FALSE.

### <a name="remarks"></a>Uwagi

Aby uzyskać więcej informacji, zobacz `GradientFill` w Windows SDK.

## <a name="cdcgraystring"></a><a name="graystring"></a>Przechwytywanie zmian:: GrayString

Rysuje wygaszone (szare) tekst w danej lokalizacji przez zapisanie tekstu w mapie bitowej pamięci, przyciemnienie mapy bitowej, a następnie skopiowanie mapy bitowej do ekranu.

```
virtual BOOL GrayString(
    CBrush* pBrush,
    BOOL (CALLBACK* lpfnOutput)(
    HDC,
    LPARAM,
    int),
    LPARAM lpData,
    int nCount,
    int x,
    int y,
    int nWidth,
    int nHeight);
```

### <a name="parameters"></a>Parametry

*pBrush*<br/>
Identyfikuje Pędzel, który ma być używany na potrzeby przygaszania (szare).

*lpfnOutput*<br/>
Określa adres procedury dla funkcji wywołania zwrotnego dostarczonej przez aplikację, która będzie rysować ciąg. Aby uzyskać więcej informacji, zobacz Opis `OutputFunc` [funkcji wywołania zwrotnego](callback-functions-used-by-mfc.md#graystring)systemu Windows. Jeśli ten parametr ma wartość NULL, system używa funkcji systemu Windows `TextOut` do narysowania ciągu, a *lpData* przyjmuje się długi wskaźnik do ciągu znaków, który ma zostać wyprowadzony.

*lpData*<br/>
Określa daleko wskaźnik do danych, które mają być przekazywane do funkcji Output. Jeśli *lpfnOutput* ma wartość null, *lpData* musi być długim wskaźnikiem do ciągu, który ma zostać wyprowadzony.

*nCount*<br/>
Określa liczbę znaków, które mają być wyprowadzane. Jeśli ten parametr ma wartość 0, `GrayString` oblicza długość ciągu (przy założeniu, że *lpData* jest wskaźnikiem do ciągu). Jeśli *nCount* to 1, a funkcja wskazywana przez *lpfnOutput* zwraca wartość 0, obraz jest pokazywany, ale nie jest wyszarzony.

*x*<br/>
Określa logiczną współrzędną x pozycji początkowej prostokąta otaczającego ciąg.

*t*<br/>
Określa logiczną współrzędną y pozycji początkowej prostokąta otaczającego ciąg.

*nWidth*<br/>
Określa szerokość (w jednostkach logicznych) prostokąta otaczającego ciąg. Jeśli *nWidth* ma wartość 0, `GrayString` oblicza szerokość obszaru, przy założeniu, że *lpData* jest wskaźnikiem do ciągu.

*nHeight*<br/>
Określa wysokość (w jednostkach logicznych) prostokąta otaczającego ciąg. Jeśli *nHeight* ma wartość 0, `GrayString` oblicza wysokość obszaru, przy założeniu, że *lpData* jest wskaźnikiem do ciągu.

### <a name="return-value"></a>Wartość zwracana

Wartość różna od zera, jeśli ciąg jest rysowany lub 0, jeśli funkcja `TextOut` lub funkcja wyjściowa dostarczona przez aplikację zwróciła wartość 0 lub w przypadku niewystarczającej ilości pamięci do utworzenia mapy bitowej pamięci dla funkcji DIMM.

### <a name="remarks"></a>Uwagi

Funkcja przyciemnia tekst bez względu na wybrany pędzel i tło. `GrayString`Funkcja członkowska używa aktualnie zaznaczonej czcionki. Przed użyciem tej funkcji należy wybrać tryb mapowania MM_TEXT.

Aplikacja może rysować wyszarzone (wyszarzone) ciągi na urządzeniach, które obsługują jednolity szary kolor bez wywoływania `GrayString` funkcji składowej. Kolor systemu COLOR_GRAYTEXT jest kolorem systemu Solid-szarego używanego do rysowania wyłączonego tekstu. Aplikacja może wywołać `GetSysColor` funkcję systemu Windows w celu pobrania wartości koloru COLOR_GRAYTEXT. Jeśli kolor jest inny niż 0 (czarny), aplikacja może wywołać `SetTextColor` funkcję elementu członkowskiego, aby ustawić kolor tekstu na wartość koloru, a następnie narysować ciąg bezpośrednio. Jeśli pobrany kolor jest czarny, aplikacja musi wywołać, `GrayString` Aby zagasić (szaro) tekst.

Jeśli *lpfnOutput* ma wartość null, interfejs GDI używa funkcji [TextOut](/windows/win32/api/wingdi/nf-wingdi-textoutw) systemu Windows, a *lpData* przyjmuje się, że jest to daleko wskaźnik do znaku, który ma zostać wyprowadzony. Jeśli znaki przeznaczone do wyprowadzania nie mogą być obsługiwane przez `TextOut` funkcję członkowską (na przykład ciąg jest przechowywany jako mapa bitowa), aplikacja musi dostarczyć własną funkcję wyjściową.

Należy również zauważyć, że wszystkie funkcje wywołania zwrotnego muszą mieć pułapki wyjątki programu Microsoft Foundation przed powrotem do systemu Windows, ponieważ nie można zgłaszać wyjątków dla granic wywołania zwrotnego. Aby uzyskać więcej informacji o wyjątkach, zobacz [wyjątki](../../mfc/exception-handling-in-mfc.md)w artykule.

Funkcja wywołania zwrotnego przeniesiona do `GrayString` musi używać **`__stdcall`** konwencji wywoływania i musi zostać wyeksportowana z **`__declspec`** .

Gdy struktura jest w trybie Podgląd, wywołanie `GrayString` funkcji składowej jest tłumaczone na `TextOut` wywołanie, a funkcja wywołania zwrotnego nie jest wywoływana.

## <a name="cdchimetrictodp"></a><a name="himetrictodp"></a>Przechwytywanie zmian:: HIMETRICtoDP

Użyj tej funkcji, gdy konwertujesz rozmiary HIMETRIC z OLE na piksele.

```cpp
void HIMETRICtoDP(LPSIZE lpSize) const;
```

### <a name="parameters"></a>Parametry

*lpSize*<br/>
Wskazuje na strukturę [rozmiaru](/windows/win32/api/windef/ns-windef-size) lub obiekt [CSize](../../atl-mfc-shared/reference/csize-class.md) .

### <a name="remarks"></a>Uwagi

Jeśli tryb mapowania obiektu kontekstu urządzenia jest MM_LOENGLISH, MM_HIENGLISH, MM_LOMETRIC lub MM_HIMETRIC, konwersja jest zależna od liczby pikseli w danym cala. Jeśli tryb mapowania jest jednym z pozostałych trybów nieograniczonych (np. MM_TEXT), konwersja jest oparta na liczbie pikseli w centymetrze logicznym.

## <a name="cdchimetrictolp"></a><a name="himetrictolp"></a>Przechwytywanie zmian:: HIMETRICtoLP

Wywołaj tę funkcję, aby przekonwertować jednostki HIMETRIC na jednostki logiczne.

```cpp
void HIMETRICtoLP(LPSIZE lpSize) const;
```

### <a name="parameters"></a>Parametry

*lpSize*<br/>
Wskazuje na strukturę [rozmiaru](/windows/win32/api/windef/ns-windef-size) lub obiekt [CSize](../../atl-mfc-shared/reference/csize-class.md) .

### <a name="remarks"></a>Uwagi

Użyj tej funkcji, Jeśli otrzymujesz rozmiary HIMETRIC z OLE i chcesz je przekonwertować do trybu naturalnego mapowania aplikacji.

Konwersja jest realizowana przez pierwsze przekonwertowanie jednostek HIMETRIC na piksele, a następnie przekonwertowanie tych jednostek na jednostki logiczne przy użyciu bieżących jednostek mapowania kontekstu urządzenia. Należy zauważyć, że zakresy okna i okienka ekranu urządzenia wpłyną na wynik.

## <a name="cdcintersectcliprect"></a><a name="intersectcliprect"></a>Przechwytywanie zmian:: IntersectClipRect

Tworzy nowy region przycinania, tworząc przecięcie bieżącego regionu i prostokąt określony przez *x1*, *Y1*, *X2*i *Y2*.

```
int IntersectClipRect(
    int x1,
    int y1,
    int x2,
    int y2);

int IntersectClipRect(LPCRECT lpRect);
```

### <a name="parameters"></a>Parametry

*x1*<br/>
Określa logiczną współrzędną x lewego górnego rogu prostokąta.

*Y1*<br/>
Określa logiczną współrzędną y lewego górnego rogu prostokąta.

*x2*<br/>
Określa logiczną współrzędną x w prawym dolnym rogu prostokąta.

*Y2*<br/>
Określa logiczną współrzędną y w prawym dolnym rogu prostokąta.

*lpRect*<br/>
Określa prostokąt. Można przekazać `CRect` obiekt lub wskaźnik do `RECT` struktury dla tego parametru.

### <a name="return-value"></a>Wartość zwracana

Typ nowego regionu wycinka. Może to być jedna z następujących wartości:

- Nowy region wycinków COMPLEXREGION ma nakładające się obramowania.

- Nieprawidłowy kontekst urządzenia błędu.

- Nowy region wycinka NULLREGION jest pusty.

- Nowy region wycinka SIMPLEREGION nie ma nakładających się obramowań.

### <a name="remarks"></a>Uwagi

Interfejs GDI przenosi wszystkie kolejne dane wyjściowe w celu dopasowania ich do nowej granicy. Szerokość i wysokość nie mogą przekraczać 32 767.

## <a name="cdcinvertrect"></a><a name="invertrect"></a>Przechwytywanie zmian:: InvertRect

Odwraca zawartość danego prostokąta.

```cpp
void InvertRect(LPCRECT lpRect);
```

### <a name="parameters"></a>Parametry

*lpRect*<br/>
Wskazuje element `RECT` , który zawiera współrzędne logiczne prostokąta do odwrócenia. Można również przekazać `CRect` obiekt dla tego parametru.

### <a name="remarks"></a>Uwagi

Inversion to wartość logiczna nie działa i przerzuca bity każdego piksela. W przypadku ekranów monochromatycznych funkcja ta sprawia, że białe piksele są białe i czarne. W przypadku wyświetlania kolorów Inwersja zależy od tego, jak kolory są generowane na potrzeby wyświetlania. `InvertRect`Dwukrotne wywołanie z tym samym prostokątem przywraca poprzednie kolory.

Jeśli prostokąt jest pusty, nic nie jest rysowane.

### <a name="example"></a>Przykład

[!code-cpp[NVC_MFCDocView#36](../../mfc/codesnippet/cpp/cdc-class_8.cpp)]

## <a name="cdcinvertrgn"></a><a name="invertrgn"></a>Przechwytywanie zmian:: InvertRgn

Odwraca kolory w regionie określonym przez *pRgn*.

```
BOOL InvertRgn(CRgn* pRgn);
```

### <a name="parameters"></a>Parametry

*pRgn*<br/>
Określa region, który ma zostać odwrócony. Współrzędne dla regionu są określone w jednostkach logicznych.

### <a name="return-value"></a>Wartość zwracana

Różne od zera, jeśli funkcja zakończyła się pomyślnie; w przeciwnym razie 0.

### <a name="remarks"></a>Uwagi

W przypadku ekranów monochromatycznych funkcja ta sprawia, że białe piksele są białe i czarne. W przypadku wyświetlania kolorów Inwersja zależy od tego, jak kolory są generowane na potrzeby wyświetlania.

## <a name="cdcisprinting"></a><a name="isprinting"></a>Przechwytywanie zmian:: IsPrinting

Określa, czy kontekst urządzenia jest używany do drukowania.

```
BOOL IsPrinting() const;
```

### <a name="return-value"></a>Wartość zwracana

Niezerowe, jeśli `CDC` obiekt jest kontrolerem domeny; w przeciwnym razie 0.

## <a name="cdclineto"></a><a name="lineto"></a>Przechwytywanie zmian:: LineTo

Rysuje linię od bieżącego położenia do, ale nie z uwzględnieniem, punkt określony przez *x* i *y* (lub *punkt*).

```
BOOL LineTo(
    int x,
    int y);

BOOL LineTo(POINT point);
```

### <a name="parameters"></a>Parametry

*x*<br/>
Określa logiczną współrzędną x punktu końcowego dla wiersza.

*t*<br/>
Określa logiczną współrzędną y punktu końcowego dla wiersza.

*moment*<br/>
Określa punkt końcowy wiersza. Można przekazać `POINT` strukturę lub `CPoint` obiekt dla tego parametru.

### <a name="return-value"></a>Wartość zwracana

Niezerowe, jeśli wiersz jest rysowany; w przeciwnym razie 0.

### <a name="remarks"></a>Uwagi

Linia jest rysowana z wybranym piórem. Bieżąca pozycja jest ustawiona na *x*, *y* lub na *punkt*.

### <a name="example"></a>Przykład

  Zobacz przykład dla [CRect:: Centerpoint](../../atl-mfc-shared/reference/crect-class.md#centerpoint).

## <a name="cdclptodp"></a><a name="lptodp"></a>Przechwytywanie zmian:: LPtoDP

Konwertuje jednostki logiczne na jednostki urządzeń.

```cpp
void LPtoDP(
    LPPOINT lpPoints,
    int nCount = 1) const;

void LPtoDP(LPRECT lpRect) const;
void LPtoDP(LPSIZE lpSize) const;
```

### <a name="parameters"></a>Parametry

*lpPoints*<br/>
Wskazuje tablicę punktów. Każdy punkt w tablicy jest strukturą [punktu](/windows/win32/api/windef/ns-windef-point) lub obiektem [CPoint](../../atl-mfc-shared/reference/cpoint-class.md) .

*nCount*<br/>
Liczba punktów w tablicy.

*lpRect*<br/>
Wskazuje strukturę [Rect](/windows/win32/api/windef/ns-windef-rect) lub obiekt [CRect](../../atl-mfc-shared/reference/crect-class.md) . Ten parametr jest używany w przypadku typowego przypadku mapowania prostokąta od wartości logicznej do jednostek urządzeń.

*lpSize*<br/>
Wskazuje na strukturę [rozmiaru](/windows/win32/api/windef/ns-windef-size) lub obiekt [CSize](../../atl-mfc-shared/reference/csize-class.md) .

### <a name="remarks"></a>Uwagi

Funkcja mapuje współrzędne każdego punktu lub wymiary rozmiaru od logicznego układu współrzędnych GDI do układu współrzędnych urządzenia. Konwersja zależy od bieżącego trybu mapowania oraz ustawień źródeł i zakresów okna i okienka ekranu urządzenia.

Współrzędne x i y punktów to 2-bajtowe liczby całkowite ze znakiem z zakresu od-32 768 do 32 767. W przypadku, gdy tryb mapowania spowoduje, że wartości przekraczają te limity, system ustawi odpowiednio wartości-32 768 i 32 767.

## <a name="cdclptohimetric"></a><a name="lptohimetric"></a>Przechwytywanie zmian:: LPtoHIMETRIC

Wywołaj tę funkcję, aby przekonwertować jednostki logiczne na jednostki HIMETRIC.

```cpp
void LPtoHIMETRIC(LPSIZE lpSize) const;
```

### <a name="parameters"></a>Parametry

*lpSize*<br/>
Wskazuje `SIZE` strukturę lub `CSize` obiekt.

### <a name="remarks"></a>Uwagi

Użyj tej funkcji, gdy przydajesz rozmiary HIMETRIC do OLE, konwertując z trybu naturalnego mapowania aplikacji. Należy zauważyć, że zakresy okna i okienka ekranu urządzenia wpłyną na wynik.

Konwersja jest realizowana przez pierwsze przekonwertowanie jednostek logicznych na piksele przy użyciu jednostek bieżącego mapowania kontekstu urządzenia, a następnie przekonwertowanie tych jednostek na jednostki HIMETRIC.

## <a name="cdcm_hattribdc"></a><a name="m_hattribdc"></a>Przechwytywanie zmian:: m_hAttribDC

Kontekst urządzenia atrybutu dla tego `CDC` obiektu.

```
HDC m_hAttribDC;
```

### <a name="remarks"></a>Uwagi

Domyślnie ten kontekst urządzenia jest równy `m_hDC` . Ogólnie rzecz biorąc, `CDC` wywołania GDI, które żądają informacji z kontekstu urządzenia, są kierowane do `m_hAttribDC` . Zobacz opis klasy [przechwytywania](../../mfc/reference/cdc-class.md) , aby uzyskać więcej informacji na temat korzystania z tych dwóch kontekstów urządzeń.

## <a name="cdcm_hdc"></a><a name="m_hdc"></a>Przechwytywanie zmian:: m_hDC

Kontekst urządzenia wyjściowego dla tego `CDC` obiektu.

```
HDC m_hDC;
```

### <a name="remarks"></a>Uwagi

Domyślnie `m_hDC` jest równe `m_hAttribDC` , inne kontekstu urządzenia opakowane przez `CDC` . Ogólnie rzecz biorąc, `CDC` wywołania GDI, które tworzą dane wyjściowe, przejdą do `m_hDC` kontekstu urządzenia. Można inicjować `m_hDC` i `m_hAttribDC` wskazywać różne urządzenia. Zobacz opis klasy [przechwytywania](../../mfc/reference/cdc-class.md) , aby uzyskać więcej informacji na temat korzystania z tych dwóch kontekstów urządzeń.

## <a name="cdcmaskblt"></a><a name="maskblt"></a>Przechwytywanie zmian:: MaskBlt

Łączy dane koloru dla źródłowej i docelowej mapy bitowej przy użyciu danej maski i operacji rastrowej.

```
BOOL MaskBlt(
    int x,
    int y,
    int nWidth,
    int nHeight,
    CDC* pSrcDC,
    int xSrc,
    int ySrc,
    CBitmap& maskBitmap,
    int xMask,
    int yMask,
    DWORD dwRop);
```

### <a name="parameters"></a>Parametry

*x*<br/>
Określa logiczną współrzędną x lewego górnego rogu prostokąta docelowego.

*t*<br/>
Określa logiczną współrzędną y lewego górnego rogu prostokąta docelowego.

*nWidth*<br/>
Określa szerokość (w jednostkach logicznych) prostokąta docelowego i źródłową mapę bitową.

*nHeight*<br/>
Określa wysokość (w jednostkach logicznych) prostokąta docelowego i źródłową mapę bitową.

*pSrcDC*<br/>
Określa kontekst urządzenia, z którego ma zostać skopiowana Mapa bitowa. Musi mieć wartość zero, jeśli parametr *dwRop* określa operację rastrową, która nie zawiera źródła.

*xSrc*<br/>
Określa logiczną współrzędną x lewego górnego rogu bitmapy źródłowej.

*ySrc*<br/>
Określa logiczną współrzędną y lewego górnego rogu bitmapy źródłowej.

*maskBitmap*<br/>
Identyfikuje mapę bitową mapy monochromatyczną połączoną z mapą bitowej koloru w kontekście urządzenia źródłowego.

*xMask*<br/>
Określa przesunięcie pikseli w poziomie dla mapy bitowej określonej przez parametr *maskBitmap* .

*yMask*<br/>
Określa przesunięcie pikseli w pionie dla mapy bitowej określonej przez parametr *maskBitmap* .

*dwRop*<br/>
Określa zarówno kod operacji typu Trzyelementowy, jak i w tle, którego funkcja używa do kontrolowania kombinacji danych źródłowych i docelowych. Kod operacji rastrowej w tle jest przechowywany w wysokim bajcie wysokiego wyrazu tej wartości. kod operacji rastrowych na pierwszym planie jest przechowywany w niskim bajcie wysokiego wyrazu tej wartości. Dolny wyraz tej wartości jest ignorowany i powinien mieć wartość zero. Makro MAKEROP4 tworzy takie kombinacje kodów operacji rastrowych na pierwszym planie i w tle. Zobacz sekcję Uwagi, aby zapoznać się z omówieniem pierwszego planu i tła w kontekście tej funkcji. Zobacz `BitBlt` funkcję członkowską, aby uzyskać listę typowych kodów operacji rastrowych.

### <a name="return-value"></a>Wartość zwracana

Różne od zera, jeśli funkcja zakończyła się pomyślnie; w przeciwnym razie 0.

### <a name="remarks"></a>Uwagi

Wartość 1 w masce określona przez *maskBitmap* wskazuje, że w tej lokalizacji należy zastosować kod operacji rastrowej na pierwszym planie określony przez *dwRop* . Wartość 0 w masce wskazuje, że w tej lokalizacji należy zastosować kod operacji rastrowej w tle określony przez *dwRop* . Jeśli operacje rastrowe wymagają źródła, prostokąt maski musi pokrywać się z prostokątem źródłowym. Jeśli tak nie jest, funkcja zakończy się niepowodzeniem. Jeśli operacje rastrowe nie wymagają źródła, prostokąt maski musi obejmować prostokąt docelowy. Jeśli tak nie jest, funkcja zakończy się niepowodzeniem.

Jeśli przekształcenie rotacji lub ścinania jest stosowane dla kontekstu urządzenia źródłowego, gdy ta funkcja jest wywoływana, wystąpi błąd. Jednak inne typy transformacji są dozwolone.

Jeśli formaty koloru źródłowej, wzorcowej i docelowej mapy bitowej różnią się od siebie, ta funkcja konwertuje wzorzec lub format źródła lub oba, aby dopasować format docelowy. Jeśli mapa bitowa nie jest mapą bitową, wystąpi błąd. Gdy jest rejestrowany ulepszony metaplik, wystąpi błąd (a funkcja zwraca wartość 0), jeśli kontekst urządzenia źródłowego zidentyfikuje kontekst urządzenia z ulepszonym metaplikiem. Nie wszystkie urządzenia obsługują `MaskBlt` . Aplikacja powinna wywołać `GetDeviceCaps` , aby określić, czy urządzenie obsługuje tę funkcję. Jeśli nie podano mapy bitowej maski, ta funkcja zachowuje się dokładnie tak samo `BitBlt` , jak przy użyciu kodu operacji rastrowej na pierwszym planie. Przesunięcie pikseli w mapie bitowej maski mapy do punktu (0, 0) w mapie bitowej kontekstu urządzenia źródłowego. Jest to przydatne w przypadkach, w których mapa bitowa maski zawiera zestaw masek; Aplikacja może łatwo zastosować dowolne z nich do zadania maskowania blitting przez dostosowanie przesunięć pikseli i rozmiarów prostokątów wysyłanych do `MaskBlt` .

## <a name="cdcmodifyworldtransform"></a><a name="modifyworldtransform"></a>Przechwytywanie zmian:: ModifyWorldTransform

Zmienia światową transformację dla kontekstu urządzenia przy użyciu określonego trybu.

```
BOOL ModifyWorldTransform(
    const XFORM& rXform,
    DWORD iMode);
```

### <a name="parameters"></a>Parametry

*rXform*<br/>
Odwołanie do struktury [Xform](/windows/win32/api/wingdi/ns-wingdi-xform) używanej do modyfikowania transformacji światowej dla danego kontekstu urządzenia.

*iMode*<br/>
Określa, jak dane transformacji modyfikują bieżącą transformację światową. Aby zapoznać się z listą wartości, które może wykonać ten parametr, zobacz [ModifyWorldTransform](/windows/win32/api/wingdi/nf-wingdi-modifyworldtransform).

### <a name="return-value"></a>Wartość zwracana

Zwraca wartość różną od zera.

Zwraca wartość 0 w przypadku niepowodzenia.

Aby uzyskać rozszerzone informacje o błędzie, wywołaj [wartość GetLastError](/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror).

### <a name="remarks"></a>Uwagi

Ta metoda otacza funkcję [ModifyWorldTransform](/windows/win32/api/wingdi/nf-wingdi-modifyworldtransform)systemu Windows.

## <a name="cdcmoveto"></a><a name="moveto"></a>Przechwytywanie zmian:: MoveTo

Przenosi bieżącą pozycję do punktu określonego przez *x* i *y* (lub przez *punkt*).

```
CPoint MoveTo(
    int x,
    int y);

CPoint MoveTo(POINT point);
```

### <a name="parameters"></a>Parametry

*x*<br/>
Określa logiczną współrzędną x nowej pozycji.

*t*<br/>
Określa logiczną współrzędną y nowej pozycji.

*moment*<br/>
Określa nową pozycję. Można przekazać `POINT` strukturę lub `CPoint` obiekt dla tego parametru.

### <a name="return-value"></a>Wartość zwracana

Współrzędne x i y powyższej pozycji jako `CPoint` obiekt.

### <a name="example"></a>Przykład

  Zobacz przykład dla [CRect:: Centerpoint](../../atl-mfc-shared/reference/crect-class.md#centerpoint).

## <a name="cdcoffsetcliprgn"></a><a name="offsetcliprgn"></a>Przechwytywanie zmian:: OffsetClipRgn

Przenosi region przycinania kontekstu urządzenia o określone przesunięcia.

```
int OffsetClipRgn(
    int x,
    int y);

int OffsetClipRgn(SIZE size);
```

### <a name="parameters"></a>Parametry

*x*<br/>
Określa liczbę jednostek logicznych do przeniesienia w lewo lub w prawo.

*t*<br/>
Określa liczbę jednostek logicznych, które mają zostać przesunięte w górę lub w dół.

*zmienia*<br/>
Określa kwotę do przesunięcia.

### <a name="return-value"></a>Wartość zwracana

Typ nowego regionu. Może to być jedna z następujących wartości:

- Region przycinania COMPLEXREGION ma nakładające się obramowania.

- Nieprawidłowy kontekst urządzenia błędu.

- Region wycinka NULLREGION jest pusty.

- Region wycinka SIMPLEREGION nie ma nakładających się obramowań.

### <a name="remarks"></a>Uwagi

Funkcja przenosi jednostki *x* regionu wzdłuż osi x i *y* wzdłuż osi y.

## <a name="cdcoffsetviewportorg"></a><a name="offsetviewportorg"></a>Przechwytywanie zmian:: OffsetViewportOrg

Modyfikuje współrzędne pochodzenia wziernika względem współrzędnych bieżącego źródła okienka ekranu.

```
virtual CPoint OffsetViewportOrg(
    int nWidth,
    int nHeight);
```

### <a name="parameters"></a>Parametry

*nWidth*<br/>
Określa liczbę jednostek urządzeń, które mają zostać dodane do współrzędnych x bieżącego źródła.

*nHeight*<br/>
Określa liczbę jednostek urządzeń, które mają zostać dodane do współrzędnych y bieżącego źródła.

### <a name="return-value"></a>Wartość zwracana

Poprzednie miejsce początkowe okienka ekranu (we współrzędnych urządzenia) jako `CPoint` obiekt.

## <a name="cdcoffsetwindoworg"></a><a name="offsetwindoworg"></a>Przechwytywanie zmian:: OffsetWindowOrg

Modyfikuje współrzędne pochodzenie okna względem współrzędnych bieżącego źródła okna.

```
CPoint OffsetWindowOrg(
    int nWidth,
    int nHeight);
```

### <a name="parameters"></a>Parametry

*nWidth*<br/>
Określa liczbę jednostek logicznych, które mają zostać dodane do współrzędnych x bieżącego źródła.

*nHeight*<br/>
Określa liczbę jednostek logicznych, które mają zostać dodane do współrzędnych y bieżącego źródła.

### <a name="return-value"></a>Wartość zwracana

Poprzednie pochodzenie okna (we współrzędnych logicznych) jako `CPoint` obiekt.

## <a name="cdcoperator-hdc"></a><a name="operator_hdc"></a>Przechwytywanie zmian:: operator używający HDC

Użyj tego operatora, aby pobrać uchwyt kontekstu urządzenia dla `CDC` obiektu.

```
operator HDC() const;
```

### <a name="return-value"></a>Wartość zwracana

Jeśli to się powiedzie, uchwyt obiektu kontekstu urządzenia; w przeciwnym razie wartość NULL.

### <a name="remarks"></a>Uwagi

Możesz użyć uchwytu, aby bezpośrednio wywołać interfejsy API systemu Windows.

## <a name="cdcpaintrgn"></a><a name="paintrgn"></a>Przechwytywanie zmian::P aintRgn

Wypełnia region określony przez *pRgn* przy użyciu bieżącego pędzla.

```
BOOL PaintRgn(CRgn* pRgn);
```

### <a name="parameters"></a>Parametry

*pRgn*<br/>
Określa region, który ma zostać wypełniony. Współrzędne dla danego regionu są określone w jednostkach logicznych.

### <a name="return-value"></a>Wartość zwracana

Różne od zera, jeśli funkcja zakończyła się pomyślnie; w przeciwnym razie 0.

## <a name="cdcpatblt"></a><a name="patblt"></a>Przechwytywanie zmian::P atBlt

Tworzy na urządzeniu wzorzec bitowy.

```
BOOL PatBlt(
    int x,
    int y,
    int nWidth,
    int nHeight,
    DWORD dwRop);
```

### <a name="parameters"></a>Parametry

*x*<br/>
Określa logiczną współrzędną x lewego górnego rogu prostokąta, który ma otrzymać wzorzec.

*t*<br/>
Określa logiczną współrzędną y lewego górnego rogu prostokąta, który ma otrzymać wzorzec.

*nWidth*<br/>
Określa szerokość (w jednostkach logicznych) prostokąta, który ma otrzymać wzorzec.

*nHeight*<br/>
Określa wysokość (w jednostkach logicznych) prostokąta, który ma otrzymać wzorzec.

*dwRop*<br/>
Określa kod operacji rastrowej. Kody operacji rastrowych (ROPs) definiują sposób, w jaki interfejs GDI łączy kolory w operacjach wyjściowych, które obejmują bieżący Pędzel, możliwą źródłową mapę bitową i docelową mapę bitową. Ten parametr może mieć jedną z następujących wartości:

- PATCOPY kopiuje wzorzec do docelowej mapy bitowej.

- PATINVERT łączy docelową mapę bitową ze wzorcem przy użyciu operatora Boolean XOR.

- DSTINVERT odwraca docelową mapę bitową.

- CZERNI powoduje, że wszystkie dane wyjściowe są czarne.

- WHITENESS włącza wszystkie białe dane wyjściowe.

### <a name="return-value"></a>Wartość zwracana

Różne od zera, jeśli funkcja zakończyła się pomyślnie; w przeciwnym razie 0.

### <a name="remarks"></a>Uwagi

Wzorzec jest kombinacją wybranego pędzla i wzorca znajdującego się już na urządzeniu. Kod operacji rastrowej określony przez *dwRop* definiuje sposób łączenia wzorców. Operacje rastrowe wymienione dla tej funkcji są ograniczonym podzbiorem pełnych kodów operacji Trzyelementowy (256). w szczególności nie można użyć kodu operacji rastrowej, który odwołuje się do źródła.

Nie wszystkie konteksty urządzenia obsługują `PatBlt` funkcję. Aby określić, czy kontekst urządzenia obsługuje `PatBlt` , wywołaj `GetDeviceCaps` funkcję elementu członkowskiego z indeksem RASTERCAPS i sprawdź wartość zwracaną flagi RC_BITBLT.

## <a name="cdcpie"></a><a name="pie"></a>Przechwytywanie zmian::P IE

Rysuje klin w kształcie koła, rysując Łuk eliptyczny, którego środkowe i dwa punkty końcowe są sprzężone liniami.

```
BOOL Pie(
    int x1,
    int y1,
    int x2,
    int y2,
    int x3,
    int y3,
    int x4,
    int y4);

BOOL Pie(
    LPCRECT lpRect,
    POINT ptStart,
    POINT ptEnd);
```

### <a name="parameters"></a>Parametry

*x1*<br/>
Określa współrzędną x lewego górnego rogu prostokąta ograniczenia (w jednostkach logicznych).

*Y1*<br/>
Określa współrzędną y lewego górnego rogu prostokąta ograniczenia (w jednostkach logicznych).

*x2*<br/>
Określa współrzędną x dolnego prawego górnego rogu prostokąta granicznego (w jednostkach logicznych).

*Y2*<br/>
Określa współrzędną y prawego dolnego rogu prostokąta granicznego (w jednostkach logicznych).

*x3*<br/>
Określa współrzędną x punktu początkowego łuku (w jednostkach logicznych). Ten punkt nie musi znajdować się dokładnie na łuku.

*Y3*<br/>
Określa współrzędną y punktu początkowego łuku (w jednostkach logicznych). Ten punkt nie musi znajdować się dokładnie na łuku.

*X4*<br/>
Określa współrzędną x punktu końcowego łuku (w jednostkach logicznych). Ten punkt nie musi znajdować się dokładnie na łuku.

*Y4*<br/>
Określa współrzędną y punktu końcowego łuku (w jednostkach logicznych). Ten punkt nie musi znajdować się dokładnie na łuku.

*lpRect*<br/>
Określa prostokąt ograniczający. Można przekazać `CRect` obiekt lub wskaźnik do `RECT` struktury dla tego parametru.

*ptStart*<br/>
Określa punkt początkowy łuku. Ten punkt nie musi znajdować się dokładnie na łuku. Dla tego parametru można przekazać strukturę [punktu](/windows/win32/api/windef/ns-windef-point) lub obiekt [CPoint](../../atl-mfc-shared/reference/cpoint-class.md) .

*ptEnd*<br/>
Określa punkt końcowy łuku. Ten punkt nie musi znajdować się dokładnie na łuku. Można przekazać `POINT` strukturę lub `CPoint` obiekt dla tego parametru.

### <a name="return-value"></a>Wartość zwracana

Różne od zera, jeśli funkcja zakończyła się pomyślnie; w przeciwnym razie 0.

### <a name="remarks"></a>Uwagi

Środek łuku jest środkowym prostokątem obwiedni określonym przez *x1*, *Y1*, *X2*i *Y2* (lub przez *lpRect*). Punkty początkowe i końcowe łuku są określone przez *x3*, *Y3*, *X4*i *Y4* (lub przez *ptStart* i *ptEnd*).

Łuk jest rysowany z wybranym piórem, poruszając się w kierunku do ruchu wskazówek zegara. Dwa dodatkowe linie są rysowane z każdego punktu końcowego do środka łuku. Obszar w kształcie koła jest wypełniany bieżącym pędzlem. Jeśli *x3* jest *równe X4* i *Y3* równa się *Y4*, wynik jest elipsą z pojedynczym wierszem od środka elipsy do punktu ( *x3*, *Y3*) lub ( *X4*, *Y4*).

Rysunek rysowany przez tę funkcję rozszerza się do programu, ale nie obejmuje współrzędnych prawej i dolnej. Oznacza to, że wysokość rysunku to *Y2*  -  *Y1* , a szerokość rysunku to *X2*  -  *x1*. Szerokość i wysokość prostokąta ograniczenia musi być większa niż 2 jednostki i mniejsza niż 32 767 jednostek.

### <a name="example"></a>Przykład

[!code-cpp[NVC_MFCDocView#37](../../mfc/codesnippet/cpp/cdc-class_9.cpp)]

## <a name="cdcplaymetafile"></a><a name="playmetafile"></a>Przechwytywanie zmian::P layMetaFile

Odtwarza zawartość określonego metapliku w kontekście urządzenia.

```
BOOL PlayMetaFile(HMETAFILE hMF);

BOOL PlayMetaFile(
    HENHMETAFILE hEnhMetaFile,
    LPCRECT lpBounds);
```

### <a name="parameters"></a>Parametry

*hMF*<br/>
Identyfikuje metaplik, który ma być odtwarzany.

*hEnhMetaFile*<br/>
Identyfikuje rozszerzony metaplik.

*lpBounds*<br/>
Wskazuje na `RECT` strukturę lub `CRect` obiekt, który zawiera współrzędne prostokąta ograniczenia używany do wyświetlania obrazu. Współrzędne są określone w jednostkach logicznych.

### <a name="return-value"></a>Wartość zwracana

Różne od zera, jeśli funkcja zakończyła się pomyślnie; w przeciwnym razie 0.

### <a name="remarks"></a>Uwagi

Metaplik może być odtwarzany dowolną liczbę razy.

W drugiej wersji programu `PlayMetaFile` jest wyświetlany obraz zapisany w formacie metapliku rozszerzonego. Gdy aplikacja wywołuje drugą wersję programu `PlayMetaFile` , system Windows używa ramki obrazu w nagłówku ulepszonego metapliku do mapowania obrazu na prostokąt wskazywany przez parametr *lpBounds* . (Ten obraz może zostać przechylić lub obrócony przez ustawienie transformacji światowej na urządzeniu wyjściowym przed wywołaniem `PlayMetaFile` ). Na obrazie znajdują się punkty wzdłuż brzegów prostokąta. Obraz ulepszonego metapliku można przycinać przez zdefiniowanie obszaru przycinania na urządzeniu wyjściowym przed rozpoczęciem tworzenia rozszerzonego metapliku.

Jeśli rozszerzony metaplik zawiera opcjonalną paletę, aplikacja może uzyskać spójne kolory przez skonfigurowanie palety kolorów na urządzeniu wyjściowym przed wywołaniem drugiej wersji programu `PlayMetaFile` . Aby pobrać opcjonalną paletę, użyj `GetEnhMetaFilePaletteEntries` funkcji systemu Windows. Ulepszony metaplik może być osadzony w nowo utworzonym metapliku, przez wywołanie drugiej wersji `PlayMetaFile` i odtwarzanie źródła rozszerzonego metapliku w kontekście urządzenia dla nowego, ulepszonego metapliku.

Stany kontekstu urządzenia wyjściowego są zachowywane przez tę funkcję. Wszystkie obiekty utworzone, ale nie usunięte w rozszerzonym metapliku są usuwane przez tę funkcję. Aby zatrzymać tę funkcję, aplikacja może wywołać `CancelDC` funkcję systemu Windows z innego wątku, aby zakończyć operację. W takim przypadku funkcja zwraca wartość zero.

## <a name="cdcplgblt"></a><a name="plgblt"></a>Przechwytywanie zmian::P lgBlt

Wykonuje bit bloku bitowego transferu bitów danych koloru z określonego prostokąta w kontekście urządzenia źródłowego do określonego równoległobok w danym kontekście urządzenia.

```
BOOL PlgBlt(
    LPPOINT lpPoint,
    CDC* pSrcDC,
    int xSrc,
    int ySrc,
    int nWidth,
    int nHeight,
    CBitmap& maskBitmap,
    int xMask,
    int yMask);
```

### <a name="parameters"></a>Parametry

*lpPoint*<br/>
Wskazuje tablicę trzech punktów w przestrzeni logicznej, która identyfikuje trzy rogi przerównoległobok docelowego. Lewy górny róg prostokąta źródłowego jest mapowany do pierwszego punktu w tej tablicy, prawego górnego rogu do drugiego punktu w tej tablicy oraz lewego dolnego rogu do trzeciego punktu. Prawy dolny róg prostokąta źródłowego jest mapowany do niejawnego czwartego punktu w równoległobok.

*pSrcDC*<br/>
Identyfikuje kontekst urządzenia źródłowego.

*xSrc*<br/>
Określa współrzędną x (w jednostkach logicznych) lewego górnego rogu prostokąta źródłowego.

*ySrc*<br/>
Określa współrzędną y (w jednostkach logicznych) lewego górnego rogu prostokąta źródłowego.

*nWidth*<br/>
Określa szerokość (w jednostkach logicznych) prostokąta źródłowego.

*nHeight*<br/>
Określa wysokość (w jednostkach logicznych) prostokąta źródłowego.

*maskBitmap*<br/>
Określa opcjonalną mapę bitową monochromatyczny, która jest używana do maskowania kolorów prostokąta źródłowego.

*xMask*<br/>
Określa współrzędną x lewego górnego rogu mapy bitowej monochromatycznej.

*yMask*<br/>
Określa współrzędną y lewego górnego rogu mapy bitowej monochromatycznia.

### <a name="return-value"></a>Wartość zwracana

Różne od zera, jeśli funkcja zakończyła się pomyślnie; w przeciwnym razie 0.

### <a name="remarks"></a>Uwagi

Jeśli dany uchwyt maski bitowej identyfikuje poprawną mapę bitową monochromatyczny, funkcja używa tej mapy bitowej do maskowania bitów danych koloru z prostokąta źródłowego.

Czwarty wierzchołek równoległobok (D) jest definiowany przez traktowanie pierwszych trzech punktów (A, B i C) jako wektorów i obliczeniowych D = B + C-A.

Jeśli Maska bitów istnieje, wartość 1 w masce wskazuje, że kolor piksela źródłowego ma być kopiowany do miejsca docelowego. Wartość 0 w masce wskazuje, że kolor piksela docelowego nie jest zmieniany.

Jeśli prostokąt maski jest mniejszy niż prostokąty źródłowe i docelowe, funkcja replikuje wzorzec maski.

Skalowanie, translacja i przekształcenia odbicia są dozwolone w kontekście urządzenia źródłowego; Jednakże przekształcenia rotacji i ścinania nie są. Jeśli mapa bitowa nie jest mapą bitową, wystąpi błąd. Tryb rozciągania dla kontekstu urządzenia docelowego służy do określania sposobu rozciągania lub kompresowania pikseli, jeśli jest to konieczne. Gdy jest rejestrowany ulepszony metaplik, występuje błąd, jeśli kontekst urządzenia źródłowego identyfikuje kontekst urządzenia z ulepszonym metaplikiem.

Współrzędne miejsca przeznaczenia są przekształcane zgodnie z kontekstem urządzenia docelowego; współrzędne źródła są przekształcane zgodnie z kontekstem urządzenia źródłowego. Jeśli transformacja źródłowa ma rotację lub ścinanie, zwracany jest błąd. Jeśli prostokąty docelowe i źródłowe nie mają tego samego formatu koloru, program `PlgBlt` konwertuje prostokąt źródłowy w celu dopasowania go do docelowego prostokąta. Nie wszystkie urządzenia obsługują `PlgBlt` . Aby uzyskać więcej informacji, zobacz opis możliwości RC_BITBLT rastrowej w `CDC::GetDeviceCaps` funkcji składowej.

Jeśli konteksty urządzenia źródłowego i docelowego reprezentują niezgodne urządzenia, program `PlgBlt` zwraca błąd.

## <a name="cdcpolybezier"></a><a name="polybezier"></a>Przechwytywanie zmian::P olyBezier

Rysuje co najmniej jedną krzywą Bzier.

```
BOOL PolyBezier(
    const POINT* lpPoints,
    int nCount);
```

### <a name="parameters"></a>Parametry

*lpPoints*<br/>
Wskazuje tablicę struktur danych [punktu](/windows/win32/api/windef/ns-windef-point) , które zawierają punkty końcowe i punkty kontrolne krzywej łamanej.

*nCount*<br/>
Określa liczbę punktów w tablicy *lpPoints* . Ta wartość musi być dłuższa niż trzy razy większa niż liczba krzywych składanych, ponieważ każda krzywa Bzier wymaga dwóch punktów kontrolnych i punktu końcowego, a początkowa krzywa składana wymaga dodatkowego punktu początkowego.

### <a name="return-value"></a>Wartość zwracana

Różne od zera, jeśli funkcja zakończyła się pomyślnie; w przeciwnym razie 0.

### <a name="remarks"></a>Uwagi

Ta funkcja rysuje krzywe Bzier sześciennych za pomocą punktów końcowych i punktów kontrolnych określonych przez parametr *lpPoints* . Pierwsza krzywa składana jest rysowana od pierwszego punktu do czwartego punktu przy użyciu drugiego i trzeciego punktu jako punktów kontrolnych. Każda kolejna krzywa składana w sekwencji wymaga dokładnie trzech kolejnych punktów: punkt końcowy poprzedniej krzywej łamanej jest używany jako punkt początkowy, następne dwa punkty w sekwencji są punktami kontrolnymi, a trzeci jest punktem końcowym.

Bieżąca pozycja nie jest używana ani aktualizowana przez `PolyBezier` funkcję. Rysunek nie jest wypełniony. Ta funkcja rysuje linie przy użyciu bieżącego pióra.

## <a name="cdcpolybezierto"></a><a name="polybezierto"></a>Przechwytywanie zmian::P olyBezierTo

Rysuje co najmniej jedną krzywą Bzier.

```
BOOL PolyBezierTo(
    const POINT* lpPoints,
    int nCount);
```

### <a name="parameters"></a>Parametry

*lpPoints*<br/>
Wskazuje tablicę struktur danych [punktu](/windows/win32/api/windef/ns-windef-point) , które zawierają punkty końcowe i punkty kontrolne.

*nCount*<br/>
Określa liczbę punktów w tablicy *lpPoints* . Ta wartość musi być trzy razy większa niż liczba krzywych składanych, ponieważ każda krzywa Bzier wymaga dwóch punktów kontrolnych i punktu końcowego.

### <a name="return-value"></a>Wartość zwracana

Różne od zera, jeśli funkcja zakończyła się pomyślnie; w przeciwnym razie 0.

### <a name="remarks"></a>Uwagi

Ta funkcja rysuje krzywe Bzier sześciennych przy użyciu punktów kontrolnych określonych przez parametr *lpPoints* . Pierwsza krzywa składana jest od bieżącego położenia do trzeciego punktu przy użyciu pierwszych dwóch punktów jako punktów kontrolnych. Dla każdej kolejnej krzywej łamanej funkcja wymaga dokładnie trzech kolejnych punktów i używa punktu końcowego poprzedniej krzywej łamanej jako punktu początkowego dla następnego. `PolyBezierTo`przenosi bieżącą pozycję do punktu końcowego ostatniej krzywej łamanej Bzier. Rysunek nie jest wypełniony. Ta funkcja rysuje linie przy użyciu bieżącego pióra.

### <a name="example"></a>Przykład

  Zobacz przykład dla danych [przechwytywania:: BeginPath](#beginpath).

## <a name="cdcpolydraw"></a><a name="polydraw"></a>Przechwytywanie zmian::P olyDraw

Rysuje zestaw segmentów linii i krzywych Bzier.

```
BOOL PolyDraw(
    const POINT* lpPoints,
    const BYTE* lpTypes,
    int nCount);
```

### <a name="parameters"></a>Parametry

*lpPoints*<br/>
Wskazuje tablicę struktur danych [punktu](/windows/win32/api/windef/ns-windef-point) , która zawiera punkty końcowe dla każdego segmentu linii oraz punkty końcowe i punkty kontroli dla każdej krzywej łamanej Bzier.

*lpTypes*<br/>
Wskazuje tablicę, która określa, jak jest używany każdy punkt w tablicy *lpPoints* . Może to być jedna z następujących wartości:

- PT_MOVETO określa, że ten punkt uruchamia rozłączenie. Ten punkt stanie się nowym bieżącym położeniem.

- PT_LINETO określa, że linia ma zostać narysowana z bieżącego położenia do tego punktu, a następnie stanie się nową bieżącą pozycją.

- PT_BEZIERTO określa, że ten punkt jest punktem kontrolnym lub punktem końcowym dla krzywej łamanej Bzier.

Typy PT_BEZIERTO zawsze występują w zestawach trzech. Bieżąca pozycja definiuje punkt początkowy dla krzywej Bzier. Pierwsze dwa punkty PT_BEZIERTO są punktami kontrolnymi, a trzeci punkt PT_BEZIERTO jest punktem końcowym. Punkt końcowy stanie się nowym bieżącym położeniem. Jeśli nie ma trzech kolejnych punktów PT_BEZIERTO, wystąpi błąd.

   Typ PT_LINETO lub PT_BEZIERTO może być połączony z następującą stałą przy użyciu operatora bitowego lub do wskazywania, że odpowiadający punkt jest ostatnim punktem na rysunku, a rysunek jest zamknięty:

- PT_CLOSEFIGURE określa, że rysunek jest automatycznie zamykany po zakończeniu PT_LINETO lub PT_BEZIERTO typu dla tego punktu. Wiersz jest rysowany od tego punktu do najnowszej PT_MOVETO lub `MoveTo` punktu.

   Ta flaga jest połączona z typem PT_LINETO dla wiersza lub z typem PT_BEZIERTO punktu końcowego dla krzywej łamanej Bzier przy **użyciu operatora bitowego or.** Bieżąca pozycja jest ustawiana na punkt końcowy wiersza zamykającego.

*nCount*<br/>
Określa łączną liczbę punktów w tablicy *lpPoints* , tak samo jak liczba bajtów w tablicy *lpTypes* .

### <a name="return-value"></a>Wartość zwracana

Różne od zera, jeśli funkcja zakończyła się pomyślnie; w przeciwnym razie 0.

### <a name="remarks"></a>Uwagi

Ta funkcja może służyć do rysowania rozłączonych cyfr zamiast kolejnych wywołań do `CDC::MoveTo` , `CDC::LineTo` i `CDC::PolyBezierTo` funkcji Członkowskich. Linie i krzywki są rysowane przy użyciu bieżącego pióra, a cyfry nie są wypełnione. Jeśli istnieje aktywna ścieżka `CDC::BeginPath` , wywołując funkcję członkowską, `PolyDraw` dodaje do ścieżki. Punkty zawarte w tablicy *lpPoints* i w *lpTypes* wskazują, czy każdy punkt jest częścią `CDC::MoveTo` , a, czy `CDC::LineTo` `CDC::BezierTo` operacji. Możliwe jest również zamknięcie cyfr. Ta funkcja aktualizuje bieżące położenie.

### <a name="example"></a>Przykład

  Zobacz przykład dla danych [przechwytywania:: BeginPath](#beginpath).

## <a name="cdcpolygon"></a><a name="polygon"></a>Przechwytywanie zmian::P olygon

Rysuje Wielokąt składający się z dwóch lub więcej punktów (wierzchołków) połączonych przez linie przy użyciu bieżącego pióra.

```
BOOL Polygon(
    LPPOINT lpPoints,
    int nCount);
```

### <a name="parameters"></a>Parametry

*lpPoints*<br/>
Wskazuje tablicę punktów, która określa wierzchołki wielokąta. Każdy punkt w tablicy jest `POINT` strukturą lub `CPoint` obiektem.

*nCount*<br/>
Określa liczbę wierzchołków w tablicy.

### <a name="return-value"></a>Wartość zwracana

Różne od zera, jeśli funkcja zakończyła się pomyślnie; w przeciwnym razie 0.

### <a name="remarks"></a>Uwagi

System automatycznie zamknie Wielokąt, w razie potrzeby, rysując linię od ostatniego wierzchołka do pierwszego.

Bieżący tryb wypełniania wielokątów można pobrać lub ustawić przy użyciu `GetPolyFillMode` funkcji i `SetPolyFillMode` .

### <a name="example"></a>Przykład

[!code-cpp[NVC_MFCDocView#38](../../mfc/codesnippet/cpp/cdc-class_10.cpp)]

## <a name="cdcpolyline"></a><a name="polyline"></a>Przechwytywanie zmian::P olyline

Rysuje zestaw segmentów linii łączących punkty określone przez *lpPoints*.

```
BOOL Polyline(
    LPPOINT lpPoints,
    int nCount);
```

### <a name="parameters"></a>Parametry

*lpPoints*<br/>
Wskazuje tablicę `POINT` struktur lub `CPoint` obiektów, które mają być połączone.

*nCount*<br/>
Określa liczbę punktów w tablicy. Ta wartość musi być równa co najmniej 2.

### <a name="return-value"></a>Wartość zwracana

Różne od zera, jeśli funkcja zakończyła się pomyślnie; w przeciwnym razie 0.

### <a name="remarks"></a>Uwagi

Linie są rysowane od pierwszego punktu za pośrednictwem kolejnych punktów przy użyciu bieżącego pióra. W przeciwieństwie do `LineTo` funkcji składowej, `Polyline` Funkcja nie używa ani nie aktualizuje bieżącej pozycji.

Aby uzyskać więcej informacji, zobacz [łamaną](/windows/win32/api/wingdi/nf-wingdi-polyline) w Windows SDK.

## <a name="cdcpolylineto"></a><a name="polylineto"></a>Przechwytywanie zmian::P olylineTo

Rysuje jeden lub więcej linii prostych.

```
BOOL PolylineTo(
    const POINT* lpPoints,
    int nCount);
```

### <a name="parameters"></a>Parametry

*lpPoints*<br/>
Wskazuje tablicę struktur danych [punktu](/windows/win32/api/windef/ns-windef-point) , które zawierają wierzchołki wiersza.

*nCount*<br/>
Określa liczbę punktów w tablicy.

### <a name="return-value"></a>Wartość zwracana

Różne od zera, jeśli funkcja zakończyła się pomyślnie; w przeciwnym razie 0.

### <a name="remarks"></a>Uwagi

Linia jest rysowana od bieżącego położenia do pierwszego punktu określonego przez parametr *lpPoints* za pomocą bieżącego pióra. Dla każdego dodatkowego wiersza funkcja rysuje od punktu końcowego poprzedniego wiersza do następnego punktu określonego przez *lpPoints*. `PolylineTo`przenosi bieżącą pozycję do punktu końcowego ostatniego wiersza. Jeśli segmenty linii rysowane przez tę funkcję tworzą figurę zamkniętą, rysunek nie zostanie wypełniony.

## <a name="cdcpolypolygon"></a><a name="polypolygon"></a>Przechwytywanie zmian::P olyPolygon

Tworzy dwa lub więcej wielokątów, które są wypełniane przy użyciu bieżącego trybu wypełniania wielokątów.

```
BOOL PolyPolygon(
    LPPOINT lpPoints,
    LPINT lpPolyCounts,
    int nCount);
```

### <a name="parameters"></a>Parametry

*lpPoints*<br/>
Wskazuje tablicę `POINT` struktur lub `CPoint` obiektów, które definiują wierzchołki wielokątów.

*lpPolyCounts*<br/>
Wskazuje tablicę liczb całkowitych, z których każdy określa liczbę punktów w jednym z wielokątów w tablicy *lpPoints* .

*nCount*<br/>
Liczba wpisów w tablicy *lpPolyCounts* . Ta liczba określa liczbę wielokątów do narysowania. Ta wartość musi być równa co najmniej 2.

### <a name="return-value"></a>Wartość zwracana

Różne od zera, jeśli funkcja zakończyła się pomyślnie; w przeciwnym razie 0.

### <a name="remarks"></a>Uwagi

Wielokąty mogą być rozłączane lub nakładane.

Każdy Wielokąt określony w wywołaniu `PolyPolygon` funkcji musi być zamknięty. W przeciwieństwie do wielokątów utworzonych przez `Polygon` funkcję składową, wielokąty utworzone przez `PolyPolygon` nie są zamykane automatycznie.

Funkcja tworzy dwa lub więcej wielokątów. Aby utworzyć pojedynczy Wielokąt, aplikacja powinna używać `Polygon` funkcji składowej.

Bieżący tryb wypełniania wielokątów można pobrać lub ustawić przy użyciu `GetPolyFillMode` funkcji i `SetPolyFillMode` .

## <a name="cdcpolypolyline"></a><a name="polypolyline"></a>Przechwytywanie zmian::P olyPolyline

Rysuje wiele serii połączonych segmentów linii.

```
BOOL PolyPolyline(
    const POINT* lpPoints,
    const DWORD* lpPolyPoints,
    int nCount);
```

### <a name="parameters"></a>Parametry

*lpPoints*<br/>
Wskazuje tablicę struktur, które zawierają wierzchołki linii łamanej. Linie łamane są określane po kolei.

*lpPolyPoints*<br/>
Wskazuje tablicę zmiennych określającą liczbę punktów w tablicy *lpPoints* dla odpowiedniego wielokąta. Każdy wpis musi być większy lub równy 2.

*nCount*<br/>
Określa łączną liczbę liczników w tablicy *lpPolyPoints* .

### <a name="return-value"></a>Wartość zwracana

Różne od zera, jeśli funkcja zakończyła się pomyślnie; w przeciwnym razie 0.

### <a name="remarks"></a>Uwagi

Segmenty linii są rysowane przy użyciu bieżącego pióra. Liczby utworzone przez segmenty nie są wypełnione. Bieżąca pozycja nie jest używana ani aktualizowana przez tę funkcję.

## <a name="cdcptvisible"></a><a name="ptvisible"></a>Przechwytywanie zmian::P tVisible

Określa, czy dany punkt znajduje się w obszarze przycinania kontekstu urządzenia.

```
virtual BOOL PtVisible(
    int x,
    int y) const;

BOOL PtVisible(POINT point) const;
```

### <a name="parameters"></a>Parametry

*x*<br/>
Określa logiczną współrzędną x punktu.

*t*<br/>
Określa logiczną współrzędną y punktu.

*moment*<br/>
Określa punkt do ewidencjonowania współrzędnych logicznych. Można przekazać `POINT` strukturę lub `CPoint` obiekt dla tego parametru.

### <a name="return-value"></a>Wartość zwracana

Różne od zera, jeśli określony punkt znajduje się w obszarze przycinania; w przeciwnym razie 0.

## <a name="cdcqueryabort"></a><a name="queryabort"></a>Przechwytywanie zmian:: QueryAbort

Wywołuje funkcję Abort zainstalowaną przez funkcję członkowską [SetAbortProc](#setabortproc) dla aplikacji drukującej i wysyła zapytanie o to, czy drukowanie ma zostać zakończone.

```
BOOL QueryAbort() const;
```

### <a name="return-value"></a>Wartość zwracana

Wartość zwracana jest różna od zera, Jeśli drukowanie powinno być kontynuowane, lub jeśli nie ma procedury Abort. Wartość 0 oznacza, że zadanie drukowania powinno zostać zakończone. Wartość zwracana jest dostarczana przez funkcję Abort.

## <a name="cdcrealizepalette"></a><a name="realizepalette"></a>Przechwytywanie zmian:: RealizePalette

Mapuje wpisy z bieżącej palety logicznej na paletę systemową.

```
UINT RealizePalette();
```

### <a name="return-value"></a>Wartość zwracana

Wskazuje liczbę wpisów w palecie logicznej mapowanych na różne wpisy w palecie systemowej. Przedstawia liczbę wpisów, które ta funkcja jest ponownie mapowana, aby uwzględnić zmiany w palecie systemu od momentu ostatniego zrealizowania palety logicznej.

### <a name="remarks"></a>Uwagi

Logiczna paleta kolorów działa jako bufor między aplikacjami intensywnie wykorzystującymi kolory i systemem, co pozwala aplikacji na używanie dowolnej liczby kolorów, bez zakłócania wyświetlania własnych kolorów lub kolorów wyświetlanych przez inne okna.

Gdy okno ma fokus wprowadzania danych i wywołań `RealizePalette` , system Windows zapewnia, że okno będzie wyświetlało wszystkie żądane kolory, do wartości maksymalnej dostępnej jednocześnie na ekranie. W systemie Windows wyświetlane są również kolory, które nie znajdują się w palecie okna, dopasowując je do dostępnych kolorów.

Ponadto system Windows dopasowuje kolory wymagane przez nieaktywne okna, które wywołują funkcję jak najbliżej dostępnych kolorów. Znacznie zmniejsza to niepożądane zmiany w kolorze wyświetlanym w nieaktywnym systemie Windows.

## <a name="cdcrectangle"></a><a name="rectangle"></a>Reprzechwytywania:: Rectangle

Rysuje prostokąt przy użyciu bieżącego pióra.

```
BOOL Rectangle(
    int x1,
    int y1,
    int x2,
    int y2);

BOOL Rectangle(LPCRECT lpRect);
```

### <a name="parameters"></a>Parametry

*x1*<br/>
Określa współrzędną x lewego górnego rogu prostokąta (w jednostkach logicznych).

*Y1*<br/>
Określa współrzędną y lewego górnego rogu prostokąta (w jednostkach logicznych).

*x2*<br/>
Określa współrzędną x w prawym dolnym rogu prostokąta (w jednostkach logicznych).

*Y2*<br/>
Określa współrzędną y prawego dolnego rogu prostokąta (w jednostkach logicznych).

*lpRect*<br/>
Określa prostokąt w jednostkach logicznych. Można przekazać `CRect` obiekt lub wskaźnik do `RECT` struktury dla tego parametru.

### <a name="return-value"></a>Wartość zwracana

Różne od zera, jeśli funkcja zakończyła się pomyślnie; w przeciwnym razie 0.

### <a name="remarks"></a>Uwagi

Wnętrze prostokąta jest wypełniane przy użyciu bieżącego pędzla.

Prostokąt rozciąga się do, ale nie obejmuje współrzędnych prawej i dolnej. Oznacza to, że wysokość prostokąta to *Y2*  -  *Y1* , a szerokość prostokąta to *X2*  -  *x1*. Szerokość i wysokość prostokąta musi być większa niż 2 jednostki i mniejsza niż 32 767 jednostek.

### <a name="example"></a>Przykład

[!code-cpp[NVC_MFCDocView#39](../../mfc/codesnippet/cpp/cdc-class_11.cpp)]

## <a name="cdcrectvisible"></a><a name="rectvisible"></a>Przechwytywanie zmian:: RectVisible

Określa, czy jakakolwiek część danego prostokąta znajduje się w obszarze przycinania kontekstu wyświetlania.

```
virtual BOOL RectVisible(LPCRECT lpRect) const;
```

### <a name="parameters"></a>Parametry

*lpRect*<br/>
Wskazuje `RECT` strukturę lub `CRect` obiekt, który zawiera współrzędne logiczne określonego prostokąta.

### <a name="return-value"></a>Wartość zwracana

Różne od zera, jeśli jakakolwiek część danego prostokąta leży w obszarze przycinania. w przeciwnym razie 0.

## <a name="cdcreleaseattribdc"></a><a name="releaseattribdc"></a>Przechwytywanie zmian:: ReleaseAttribDC

Wywołaj tę funkcję elementu członkowskiego, aby ustawić `m_hAttribDC` wartość null.

```
virtual void ReleaseAttribDC();
```

### <a name="remarks"></a>Uwagi

Nie powoduje to wystąpienia tego problemu `Detach` . Tylko kontekst urządzenia wyjściowego jest dołączony do `CDC` obiektu i tylko może zostać odłączony.

## <a name="cdcreleaseoutputdc"></a><a name="releaseoutputdc"></a>Przechwytywanie zmian:: ReleaseOutputDC

Wywołaj tę funkcję elementu członkowskiego, aby ustawić `m_hDC` element członkowski na wartość null.

```
virtual void ReleaseOutputDC();
```

### <a name="remarks"></a>Uwagi

Ta funkcja członkowska nie może być wywoływana, gdy kontekst urządzenia wyjściowego jest dołączony do `CDC` obiektu. Użyj `Detach` funkcji elementu członkowskiego, aby odłączyć kontekst urządzenia wyjściowego.

## <a name="cdcresetdc"></a><a name="resetdc"></a>Przechwytywanie zmian:: ResetDC

Wywołaj tę funkcję elementu członkowskiego, aby zaktualizować kontekst urządzenia opakowany przez `CDC` obiekt.

```
BOOL ResetDC(const DEVMODE* lpDevMode);
```

### <a name="parameters"></a>Parametry

*lpDevMode*<br/>
Wskaźnik do struktury systemu Windows `DEVMODE` .

### <a name="return-value"></a>Wartość zwracana

Różne od zera, jeśli funkcja zakończyła się pomyślnie; w przeciwnym razie 0.

### <a name="remarks"></a>Uwagi

Kontekst urządzenia jest aktualizowany z informacji określonych w strukturze systemu Windows `DEVMODE` . Ta funkcja członkowska resetuje tylko kontekst urządzenia atrybutu.

Aplikacja zwykle będzie używać `ResetDC` funkcji członkowskiej, gdy okno przetwarza `WM_DEVMODECHANGE` komunikat. Można również użyć tej funkcji elementu członkowskiego, aby zmienić orientację papieru lub zasobniki papieru podczas drukowania dokumentu.

Nie można użyć tej funkcji elementu członkowskiego, aby zmienić nazwę sterownika, nazwę urządzenia lub port wyjściowy. Gdy użytkownik zmieni połączenie z portem lub nazwę urządzenia, należy usunąć oryginalny kontekst urządzenia i utworzyć nowy kontekst urządzenia przy użyciu nowych informacji.

Przed wywołaniem tej funkcji elementu członkowskiego należy upewnić się, że wybrano wszystkie obiekty (inne niż obiekty podstawowe), które zostały wybrane w kontekście urządzenia.

## <a name="cdcrestoredc"></a><a name="restoredc"></a>Przechwytywanie zmian:: RestoreDC

Przywraca kontekst urządzenia do poprzedniego stanu identyfikowanego przez *nSavedDC*.

```
virtual BOOL RestoreDC(int nSavedDC);
```

### <a name="parameters"></a>Parametry

*nSavedDC*<br/>
Określa kontekst urządzenia, który ma zostać przywrócony. Może to być wartość zwrócona przez poprzednie `SaveDC` wywołanie funkcji. Jeśli *nSavedDC* ma wartość-1, ostatnio zapisany kontekst urządzenia zostanie przywrócony.

### <a name="return-value"></a>Wartość zwracana

Różne od zera, jeśli określony kontekst został przywrócony; w przeciwnym razie 0.

### <a name="remarks"></a>Uwagi

`RestoreDC`przywraca kontekst urządzenia przez usuwanie informacji o stanie poza stos utworzony przez wcześniejsze wywołania `SaveDC` funkcji składowej.

Stos może zawierać informacje o stanie dla kilku kontekstów urządzeń. Jeśli kontekst określony przez *nSavedDC* nie znajduje się na szczycie stosu, `RestoreDC` usuwa wszystkie informacje o stanie między kontekstem urządzenia określonym przez *nSavedDC* i górną część stosu. Usunięte informacje zostaną utracone.

## <a name="cdcroundrect"></a><a name="roundrect"></a>Przechwytywanie zmian:: RoundRect

Rysuje prostokąt z zaokrąglonymi rogami przy użyciu bieżącego pióra.

```
BOOL RoundRect(
    int x1,
    int y1,
    int x2,
    int y2,
    int x3,
    int y3);

BOOL RoundRect(
    LPCRECT lpRect,
    POINT point);
```

### <a name="parameters"></a>Parametry

*x1*<br/>
Określa współrzędną x lewego górnego rogu prostokąta (w jednostkach logicznych).

*Y1*<br/>
Określa współrzędną y lewego górnego rogu prostokąta (w jednostkach logicznych).

*x2*<br/>
Określa współrzędną x w prawym dolnym rogu prostokąta (w jednostkach logicznych).

*Y2*<br/>
Określa współrzędną y prawego dolnego rogu prostokąta (w jednostkach logicznych).

*x3*<br/>
Określa szerokość elipsy używanej do rysowania zaokrąglonych rogów (w jednostkach logicznych).

*Y3*<br/>
Określa wysokość elipsy używanej do rysowania zaokrąglonych rogów (w jednostkach logicznych).

*lpRect*<br/>
Określa prostokąt ograniczenia w jednostkach logicznych. Można przekazać `CRect` obiekt lub wskaźnik do `RECT` struktury dla tego parametru.

*moment*<br/>
Współrzędna x *punktu* Określa szerokość wielokropka, aby narysować Zaokrąglone rogi (w jednostkach logicznych). Współrzędna y *punktu* określa wysokość elipsy do rysowania zaokrąglonych rogów (w jednostkach logicznych). Można przekazać `POINT` strukturę lub `CPoint` obiekt dla tego parametru.

### <a name="return-value"></a>Wartość zwracana

Różne od zera, jeśli funkcja zakończyła się pomyślnie; w przeciwnym razie 0.

### <a name="remarks"></a>Uwagi

Wnętrze prostokąta jest wypełniane przy użyciu bieżącego pędzla.

Rysunek, który rysuje ta funkcja, rozciąga się do, ale nie obejmuje współrzędnych prawej i dolnej. Oznacza to, że wysokość rysunku to *Y2*  -  *Y1* , a szerokość rysunku to *X2*  -  *x1*. Wysokość i szerokość prostokąta ograniczenia musi być większa niż 2 jednostki i mniejsza niż 32 767 jednostek.

### <a name="example"></a>Przykład

[!code-cpp[NVC_MFCDocView#40](../../mfc/codesnippet/cpp/cdc-class_12.cpp)]

## <a name="cdcsavedc"></a><a name="savedc"></a>Przechwytywanie zmian:: SaveDC

Zapisuje bieżący stan kontekstu urządzenia przez kopiowanie informacji o stanie (takich jak region przycinania, wybrane obiekty i tryb mapowania) do stosu kontekstu obsługiwanego przez system Windows.

```
virtual int SaveDC();
```

### <a name="return-value"></a>Wartość zwracana

Liczba całkowita identyfikująca zapisany kontekst urządzenia. Jeśli wystąpi błąd, wartość jest równa 0. Ta wartość zwracana może być używana do przywracania kontekstu urządzenia przez wywołanie `RestoreDC` .

### <a name="remarks"></a>Uwagi

Zapisany kontekst urządzenia można później przywrócić za pomocą polecenia `RestoreDC` .

`SaveDC`można użyć dowolnej liczby razy, aby zapisać dowolną liczbę stanów kontekstu urządzenia.

## <a name="cdcscaleviewportext"></a><a name="scaleviewportext"></a>Przechwytywanie zmian:: ScaleViewportExt

Modyfikuje zakresy okienka ekranu względem bieżących wartości.

```
virtual CSize ScaleViewportExt(
    int xNum,
    int xDenom,
    int yNum,
    int yDenom);
```

### <a name="parameters"></a>Parametry

*xNum*<br/>
Określa liczbę, przez którą ma zostać pomnożony bieżący zakres x.

*xDenom*<br/>
Określa liczbę, przez którą ma zostać podzielony wynik mnożenia bieżącego zakresu x przez wartość parametru *xNum* .

*yNum*<br/>
Określa liczbę, przez którą ma zostać pomnożony bieżący zakres y.

*yDenom*<br/>
Określa liczbę, przez którą ma zostać podzielony wynik mnożenia bieżącego zakresu y przez wartość parametru *yNum* .

### <a name="return-value"></a>Wartość zwracana

Poprzednie zakresy okienka ekranu (w jednostkach urządzeń) jako `CSize` obiekt.

### <a name="remarks"></a>Uwagi

Formuły są zapisywane w następujący sposób:

`xNewVE = ( xOldVE * xNum ) / xDenom`

`yNewVE = ( yOldVE * yNum ) / yDenom`

Nowe zakresy okienka ekranu są obliczane przez pomnożenie bieżącego zakresu przez dany licznik, a następnie dzielenie przez dany mianownik.

## <a name="cdcscalewindowext"></a><a name="scalewindowext"></a>Przechwytywanie zmian:: ScaleWindowExt

Modyfikuje zakresy okna względem bieżących wartości.

```
virtual CSize ScaleWindowExt(
    int xNum,
    int xDenom,
    int yNum,
    int yDenom);
```

### <a name="parameters"></a>Parametry

*xNum*<br/>
Określa liczbę, przez którą ma zostać pomnożony bieżący zakres x.

*xDenom*<br/>
Określa liczbę, przez którą ma zostać podzielony wynik mnożenia bieżącego zakresu x przez wartość parametru *xNum* .

*yNum*<br/>
Określa liczbę, przez którą ma zostać pomnożony bieżący zakres y.

*yDenom*<br/>
Określa liczbę, przez którą ma zostać podzielony wynik mnożenia bieżącego zakresu y przez wartość parametru *yNum* .

### <a name="return-value"></a>Wartość zwracana

Poprzednie zakresy okna (w jednostkach logicznych) jako `CSize` obiekt.

### <a name="remarks"></a>Uwagi

Formuły są zapisywane w następujący sposób:

`xNewWE = ( xOldWE * xNum ) / xDenom`

`yNewWE = ( yOldWE * yNum ) / yDenom`

Nowe zakresy okna są obliczane przez pomnożenie bieżącego zakresu przez dany licznik, a następnie dzielenie przez dany mianownik.

## <a name="cdcscrolldc"></a><a name="scrolldc"></a>Przechwytywanie zmian:: ScrollDC

Przewija prostokąt w poziomie i w pionie.

```
BOOL ScrollDC(
    int dx,
    int dy,
    LPCRECT lpRectScroll,
    LPCRECT lpRectClip,
    CRgn* pRgnUpdate,
    LPRECT lpRectUpdate);
```

### <a name="parameters"></a>Parametry

*DX*<br/>
Określa liczbę jednostek przewijania w poziomie.

*dy*<br/>
Określa liczbę pionowych jednostek przewijania.

*lpRectScroll*<br/>
Wskazuje `RECT` strukturę lub `CRect` obiekt, który zawiera współrzędne prostokąta przewijania.

*lpRectClip*<br/>
Wskazuje `RECT` strukturę lub `CRect` obiekt, który zawiera współrzędne prostokąta wycinka. Gdy ten prostokąt jest mniejszy niż pierwotny, wskazany przez *lpRectScroll*, przewijanie odbywa się tylko w mniejszym prostokącie.

*pRgnUpdate*<br/>
Identyfikuje region nieobjęty przez proces przewijania. `ScrollDC`Funkcja definiuje ten region; nie jest to prostokąt.

*lpRectUpdate*<br/>
Wskazuje `RECT` strukturę lub `CRect` obiekt, który otrzymuje współrzędne prostokąta, który jest powiązany z regionem aktualizacji przewijania. Jest to największy prostokątny obszar, który wymaga ponownego rysowania. Wartości w strukturze lub obiekcie, gdy funkcja zwraca wartość, jest w koordynuje klienta, niezależnie od trybu mapowania dla danego kontekstu urządzenia.

### <a name="return-value"></a>Wartość zwracana

Niezerowe, jeśli przewijanie jest wykonywane; w przeciwnym razie 0.

### <a name="remarks"></a>Uwagi

Jeśli *lpRectUpdate* ma wartość null, system Windows nie obliczy prostokąta aktualizacji. Jeśli zarówno *pRgnUpdate* , jak i *lpRectUpdate* mają wartość null, system Windows nie obliczy regionu aktualizacji. Jeśli *pRgnUpdate* nie ma wartości null, system Windows zakłada, że zawiera prawidłowy wskaźnik do regionu niekrytego przez proces przewijania (zdefiniowany przez `ScrollDC` funkcję członkowską). Region aktualizacji zwrócony w *lpRectUpdate* można przesłać do, jeśli jest to `CWnd::InvalidateRgn` wymagane.

Aplikacja powinna używać `ScrollWindow` funkcji składowej klasy, `CWnd` gdy jest to konieczne, aby przewinąć cały obszar klienta okna. W przeciwnym razie należy użyć `ScrollDC` .

## <a name="cdcselectclippath"></a><a name="selectclippath"></a>Przechwytywanie zmian:: SelectClipPath

Wybiera bieżącą ścieżkę jako region przycinania dla kontekstu urządzenia, łącząc nowy region z dowolnym istniejącym regionem przycinania przy użyciu określonego trybu.

```
BOOL SelectClipPath(int nMode);
```

### <a name="parameters"></a>Parametry

*nMode*<br/>
Określa sposób używania ścieżki. Dozwolone są następujące wartości:

- RGN_AND nowy region przycinania obejmuje część wspólną (nakładające się obszary) bieżącego regionu przycinania i bieżącą ścieżkę.

- RGN_COPY nowy region wycinka jest bieżącą ścieżką.

- RGN_DIFF nowy region przycinania obejmuje obszary bieżącego obszaru wycinków, a ich bieżąca ścieżka jest wykluczona.

- RGN_OR nowy region przycinania obejmuje Unię (połączone obszary) bieżącego regionu przycinania i bieżącą ścieżkę.

- RGN_XOR nowy region przycinania obejmuje Unię bieżącego obszaru wycinków i bieżącą ścieżkę, ale bez nakładających się obszarów.

### <a name="return-value"></a>Wartość zwracana

Różne od zera, jeśli funkcja zakończyła się pomyślnie; w przeciwnym razie 0.

### <a name="remarks"></a>Uwagi

Określony kontekst urządzenia musi zawierać ścieżkę zamkniętą.

## <a name="cdcselectcliprgn"></a><a name="selectcliprgn"></a>Przechwytywanie zmian:: SelectClipRgn

Wybiera dany region jako bieżący region wycinka dla kontekstu urządzenia.

```
int SelectClipRgn(CRgn* pRgn);

int SelectClipRgn(
    CRgn* pRgn,
    int nMode);
```

### <a name="parameters"></a>Parametry

*pRgn*<br/>
Określa region, który ma zostać wybrany.

- W przypadku pierwszej wersji tej funkcji, jeśli ta wartość jest RÓWNa NULL, cały obszar klienta jest zaznaczony, a dane wyjściowe są nadal przycinane do okna.

- W przypadku drugiej wersji tej funkcji dojście może mieć wartość NULL tylko wtedy, gdy jest określony tryb RGN_COPY.

*nMode*<br/>
Określa operację, która ma zostać wykonana. Musi to być jedna z następujących wartości:

- RGN_AND nowy region przycinania łączy nakładające się obszary bieżącego regionu przycinania oraz region identyfikowany przez *pRgn*.

- RGN_COPY nowy region wycinka jest kopią regionu identyfikowanego przez *pRgn*. Jest to funkcja taka sama jak w przypadku pierwszej wersji programu `SelectClipRgn` . Jeśli region identyfikowany przez *pRgn* ma wartość null, nowy region przycinania będzie domyślnym regionem przycinania (regionem o wartości null).

- RGN_DIFF nowy region przycinania łączy obszary bieżącego obszaru przycinania z tymi obszarami, które są wykluczone z regionu identyfikowanego przez *pRgn*.

- RGN_OR nowy region przycinania łączy bieżący region przycinania i region identyfikowany przez *pRgn*.

- RGN_XOR nowy region przycinania łączy bieżący region przycinania i region identyfikowany przez *pRgn* , ale wyklucza wszystkie nakładające się obszary.

### <a name="return-value"></a>Wartość zwracana

Typ regionu. Może to być dowolna z następujących wartości:

- Nowy region wycinków COMPLEXREGION ma nakładające się obramowania.

- Nieprawidłowy kontekst lub region urządzenia błędu.

- Nowy region wycinka NULLREGION jest pusty.

- Nowy region wycinka SIMPLEREGION nie ma nakładających się obramowań.

### <a name="remarks"></a>Uwagi

Używana jest tylko kopia wybranego regionu. Sam region można wybrać dla dowolnej liczby innych kontekstów urządzenia lub można go usunąć.

Funkcja zakłada, że współrzędne dla danego regionu są określone w jednostkach urządzeń. Niektóre urządzenia drukarek obsługują tekst danych wyjściowych o wyższej rozdzielczości niż dane wyjściowe grafiki, aby zachować dokładność potrzebną dla metryk tekstu Express. Te urządzenia zgłaszają jednostki urządzeń w wyższej rozdzielczości, czyli w jednostkach tekstowych. Te urządzenia następnie skalują współrzędne dla grafiki, tak aby kilka zgłoszonych jednostek urządzenia mapować tylko na 1 jednostkę graficzną. Zawsze należy wywoływać `SelectClipRgn` funkcję przy użyciu jednostek tekstowych.

Aplikacje, które muszą mieć Skalowanie obiektów graficznych w interfejsie GDI, można użyć do określenia współczynnika skalowania przy użyciu wyjścia drukarki GETSCALINGFACTOR. Ten współczynnik skalowania ma wpływ na przycinanie. Jeśli region jest używany do wycinania grafiki, interfejs GDI dzieli współrzędne przez współczynnik skalowania. Jeśli region jest używany do wycinania tekstu, interfejs GDI nie ma żadnego dopasowania skalowania. Współczynnik skalowania równy 1 powoduje, że współrzędne mają być podzielone przez 2; współczynnik skalowania równy 2 powoduje, że współrzędne mają być podzielone przez 4; i tak dalej.

## <a name="cdcselectobject"></a><a name="selectobject"></a>Przechwytywanie zmian:: SelectObject

Wybiera obiekt w kontekście urządzenia.

```
CPen* SelectObject(CPen* pPen);
CBrush* SelectObject(CBrush* pBrush);
virtual CFont* SelectObject(CFont* pFont);
CBitmap* SelectObject(CBitmap* pBitmap);
int SelectObject(CRgn* pRgn);
CGdiObject* SelectObject(CGdiObject* pObject);
```

### <a name="parameters"></a>Parametry

*pPen*<br/>
Wskaźnik do obiektu [CPen](../../mfc/reference/cpen-class.md) , który ma zostać wybrany.

*pBrush*<br/>
Wskaźnik do obiektu [CBrush](../../mfc/reference/cbrush-class.md) , który ma zostać wybrany.

*pFont*<br/>
Wskaźnik do obiektu [CFont](../../mfc/reference/cfont-class.md) , który ma zostać wybrany.

*pBitmap*<br/>
Wskaźnik do obiektu [CBitmap](../../mfc/reference/cbitmap-class.md) , który ma zostać wybrany.

*pRgn*<br/>
Wskaźnik do obiektu [CRgn](../../mfc/reference/crgn-class.md) , który ma zostać wybrany.

*pObject*<br/>
Wskaźnik do obiektu [CGdiObject](../../mfc/reference/cgdiobject-class.md) , który ma zostać wybrany.

### <a name="return-value"></a>Wartość zwracana

Wskaźnik do zastępowanego obiektu. Jest to wskaźnik do obiektu jednej z klas pochodnych `CGdiObject` , takich jak `CPen` , w zależności od używanej wersji funkcji. Wartość zwracana ma wartość NULL, jeśli wystąpi błąd. Ta funkcja może zwrócić wskaźnik do obiektu tymczasowego. Ten obiekt tymczasowy jest prawidłowy tylko podczas przetwarzania jednego komunikatu systemu Windows. Aby uzyskać więcej informacji, zobacz `CGdiObject::FromHandle`.

Wersja funkcji składowej, która przyjmuje parametr regionu, wykonuje to samo zadanie co `SelectClipRgn` funkcja członkowska. Wartość zwracana może być jedną z następujących wartości:

- Nowy region wycinków COMPLEXREGION ma nakładające się obramowania.

- Nieprawidłowy kontekst lub region urządzenia błędu.

- Nowy region wycinka NULLREGION jest pusty.

- Nowy region wycinka SIMPLEREGION nie ma nakładających się obramowań.

### <a name="remarks"></a>Uwagi

Klasa `CDC` oferuje pięć wersji wyspecjalizowanych dla określonych rodzajów obiektów GDI, w tym piór, pędzle, czcionki, mapy bitowe i regiony. Nowo wybrany obiekt zastępuje poprzedni obiekt tego samego typu. Na przykład jeśli *pObject* ogólnej wersji `SelectObject` punktów do obiektu [CPen](../../mfc/reference/cpen-class.md) , funkcja zastępuje bieżące pióro piórem określonym przez *pObject*.

Aplikacja może wybrać mapę bitową do kontekstów urządzenia pamięci tylko i tylko jeden kontekst urządzenia pamięci jednocześnie. Format mapy bitowej musi być monochromatyczny lub zgodny z kontekstem urządzenia; Jeśli nie, `SelectObject` zwraca błąd.

W przypadku systemu Windows 3,1 i nowszych `SelectObject` Funkcja zwraca tę samą wartość, niezależnie od tego, czy jest używana w metapliku, czy nie. W poprzednich wersjach systemu Windows program `SelectObject` zwrócił wartość różną od zera dla sukcesu i 0 w przypadku niepowodzenia, gdy została użyta w metapliku.

## <a name="cdcselectpalette"></a><a name="selectpalette"></a>Przechwytywanie zmian:: SelectPalette

Wybiera paletę logiczną, która jest określona przez *pPalette* jako obiekt wybranego palety kontekstu urządzenia.

```
CPalette* SelectPalette(
    CPalette* pPalette,
    BOOL bForceBackground);
```

### <a name="parameters"></a>Parametry

*pPalette*<br/>
Określa paletę logiczną, która ma zostać wybrana. Ta paleta musi już być utworzona za pomocą `CPalette` funkcji elementu [CreatePalette](../../mfc/reference/cpalette-class.md#createpalette)Członkowskiego.

*bForceBackground*<br/>
Określa, czy w przypadku palety logicznej wymuszona jest paleta w tle. Jeśli *bForceBackground* jest różna od zera, wybrana paleta jest zawsze paletą tła, bez względu na to, czy okno ma fokus wprowadzania. Jeśli *bForceBackground* ma wartość 0, a kontekst urządzenia jest dołączony do okna, paleta logiczna jest paletą pierwszego planu, gdy okno ma fokus wprowadzania.

### <a name="return-value"></a>Wartość zwracana

Wskaźnik do `CPalette` obiektu identyfikującego paletę logiczną zastąpioną przez paletę określoną przez *pPalette*. Jeśli wystąpi błąd, ma on wartość NULL.

### <a name="remarks"></a>Uwagi

Nowa paleta jest obiektem palety używanym przez interfejs GDI do sterowania kolorami wyświetlanymi w kontekście urządzenia i zastępuje poprzednią paletę.

Aplikacja może wybrać paletę logiczną w więcej niż jednym kontekście urządzenia. Jednak zmiany w palecie logicznej będą miały wpływ na wszystkie konteksty urządzenia, dla których została wybrana. Jeśli aplikacja wybierze paletę w więcej niż jednym kontekście urządzenia, wszystkie konteksty urządzenia muszą należeć do tego samego urządzenia fizycznego.

## <a name="cdcselectstockobject"></a><a name="selectstockobject"></a>Przechwytywanie zmian:: SelectStockObject

Wybiera obiekt [CGdiObject](../../mfc/reference/cgdiobject-class.md) , który odnosi się do jednego ze wstępnie zdefiniowanych piór, pędzli lub czcionki.

```
virtual CGdiObject* SelectStockObject(int nIndex);
```

### <a name="parameters"></a>Parametry

*nIndex*<br/>
Określa rodzaj żądanego obiektu giełdowego. Może to być jedna z następujących wartości:

- BLACK_BRUSH czarnym pędzlem.

- DKGRAY_BRUSH ciemnego szarego pędzla.

- GRAY_BRUSH szarego pędzla.

- HOLLOW_BRUSH pustego pędzla.

- LTGRAY_BRUSH jasnoszary pędzel.

- NULL_BRUSH pędzla o wartości null.

- WHITE_BRUSH biały pędzel.

- BLACK_PEN czarnego pióra.

- NULL_PEN pióro o wartości null.

- WHITE_PEN białe pióro.

- ANSI_FIXED_FONT stała czcionka systemu ANSI.

- ANSI_VAR_FONT czcionkę systemową zmiennej ANSI.

- DEVICE_DEFAULT_FONT czcionkę zależną od urządzenia.

- OEM_FIXED_FONT stałej czcionki zależnej od producenta OEM.

- SYSTEM_FONT czcionki systemowej. Domyślnie system Windows używa czcionki systemowej do rysowania menu, kontrolek okna dialogowego i innego tekstu. Najlepszym rozwiązaniem jest jednak, aby nie polegać na SYSTEM_FONT w celu uzyskania czcionki używanej przez okna dialogowe i system Windows. Zamiast tego należy użyć `SystemParametersInfo` funkcji z parametrem SPI_GETNONCLIENTMETRICS, aby pobrać bieżącą czcionkę. `SystemParametersInfo`uwzględnia bieżący motyw i zawiera informacje o czcionkach dla podpisów, menu i okien dialogowych komunikatów.

- SYSTEM_FIXED_FONT czcionki systemu o stałej szerokości używanej w systemie Windows przed wersją 3,0. Ten obiekt jest dostępny w celu zapewnienia zgodności z wcześniejszymi wersjami systemu Windows.

- DEFAULT_PALETTE domyślna paleta kolorów. Ta paleta zawiera 20 kolorów statycznych w palecie systemowej.

### <a name="return-value"></a>Wartość zwracana

Wskaźnik do `CGdiObject` obiektu, który został zastąpiony, jeśli funkcja się powiedzie. Rzeczywisty obiekt wskazywany jest obiektem [CPen](../../mfc/reference/cpen-class.md), [CBrush](../../mfc/reference/cbrush-class.md)lub [CFont](../../mfc/reference/cfont-class.md) . Jeśli wywołanie zakończyło się niepowodzeniem, zwracana wartość ma wartość NULL.

## <a name="cdcsetabortproc"></a><a name="setabortproc"></a>Przechwytywanie zmian:: SetAbortProc

Instaluje procedurę Abort dla zadania drukowania.

```
int SetAbortProc(BOOL (CALLBACK* lpfn)(HDC, int));
```

### <a name="parameters"></a>Parametry

*lpfn*<br/>
Wskaźnik do funkcji Abort, która ma zostać zainstalowana jako Procedura przerywania. Aby uzyskać więcej informacji na temat funkcji wywołania zwrotnego, zobacz [Funkcja wywołania zwrotnego dla funkcji przechwytywania:: SetAbortProc](callback-functions-used-by-mfc.md#setabortproc).

### <a name="return-value"></a>Wartość zwracana

Określa wynik `SetAbortProc` funkcji. Niektóre z poniższych wartości są bardziej prawdopodobne niż inne, ale wszystkie są możliwe.

- SP_ERROR błąd ogólny.

- SP_OUTOFDISK zbyt mało miejsca na dysku, które jest obecnie dostępne do buforowania i nie będzie można uzyskać więcej miejsca.

- Za mało dostępnej pamięci do buforowania. SP_OUTOFMEMORY

- SP_USERABORT użytkownik zakończył zadanie za pomocą Menedżera wydruku.

### <a name="remarks"></a>Uwagi

Jeśli aplikacja umożliwia anulowanie zadania drukowania podczas buforowania, należy ustawić funkcję Abort przed rozpoczęciem zadania drukowania przy użyciu funkcji składowej [StartDoc](#startdoc) . Menedżer wydruku wywołuje funkcję Abort podczas buforowania, aby umożliwić aplikacji anulowanie zadania drukowania lub przetworzenie warunków braku miejsca na dysku. Jeśli funkcja Abort nie zostanie ustawiona, zadanie drukowania zakończy się niepowodzeniem, jeśli nie ma wystarczającej ilości miejsca na dysku do buforowania.

Należy zauważyć, że funkcje Microsoft Visual C++ upraszczają tworzenie funkcji wywołania zwrotnego przesłanej do `SetAbortProc` . Adres przesłany do `EnumObjects` funkcji składowej jest wskaźnikiem do funkcji wyeksportowanej z `__declspec(dllexport)` i z **`__stdcall`** konwencją wywoływania.

Nie trzeba również eksportować nazwy funkcji w instrukcji **exports** w pliku definicji modułu aplikacji. Zamiast tego można użyć modyfikatora funkcji **Export** , jak w

`BOOL CALLBACK EXPORT AFunction( HDC, int );`

Aby spowodować, że kompilator emituje właściwy rekord eksportu do eksportu przez nazwę bez aliasowania. Działa to w przypadku większości potrzeb. W przypadku niektórych specjalnych przypadków, takich jak Eksportowanie funkcji przez numer porządkowy lub alias eksportu, nadal trzeba użyć instrukcji **eksports** w pliku definicji modułu.

Interfejsy rejestracji wywołania zwrotnego są teraz bezpieczne dla typów (należy przekazać wskaźnik funkcji, który wskazuje na właściwy rodzaj funkcji dla określonego wywołania zwrotnego).

Należy również zauważyć, że wszystkie funkcje wywołania zwrotnego muszą mieć pułapki wyjątki programu Microsoft Foundation przed powrotem do systemu Windows, ponieważ nie można zgłaszać wyjątków dla granic wywołania zwrotnego. Aby uzyskać więcej informacji o wyjątkach, zobacz [wyjątki](../../mfc/exception-handling-in-mfc.md)w artykule.

## <a name="cdcsetarcdirection"></a><a name="setarcdirection"></a>Przechwytywanie zmian:: SetArcDirection

Ustawia kierunek rysowania, który ma być używany dla funkcji łuku i prostokąta.

```
int SetArcDirection(int nArcDirection);
```

### <a name="parameters"></a>Parametry

*nArcDirection*<br/>
Określa nowy kierunek łuku. Ten parametr może mieć jedną z następujących wartości:

- AD_COUNTERCLOCKWISE obrazki rysowane w lewo.

- AD_CLOCKWISE obrazki narysowane zgodnie z ruchem wskazówek zegara.

### <a name="return-value"></a>Wartość zwracana

Określa stary kierunek łuku, jeśli to się powiedzie; w przeciwnym razie 0.

### <a name="remarks"></a>Uwagi

Domyślny kierunek jest w lewo. `SetArcDirection`Funkcja określa kierunek rysowania następujących funkcji:

|Arc|Kołowy|
|---------|---------|
|`ArcTo`|`Rectangle`|
|`Chord`|`RoundRect`|
|`Ellipse`||

## <a name="cdcsetattribdc"></a><a name="setattribdc"></a>Przechwytywanie zmian:: SetAttribDC

Wywołaj tę funkcję, aby ustawić kontekst urządzenia atrybutu `m_hAttribDC` .

```
virtual void SetAttribDC(HDC hDC);
```

### <a name="parameters"></a>Parametry

*Używający HDC*<br/>
Kontekst urządzenia systemu Windows.

### <a name="remarks"></a>Uwagi

Ta funkcja członkowska nie dołącza kontekstu urządzenia do `CDC` obiektu. Tylko kontekst urządzenia wyjściowego jest dołączony do `CDC` obiektu.

## <a name="cdcsetbkcolor"></a><a name="setbkcolor"></a>Przechwytywanie zmian:: SetBkColor

Ustawia bieżący kolor tła na określony kolor.

```
virtual COLORREF SetBkColor(COLORREF crColor);
```

### <a name="parameters"></a>Parametry

*crColor*<br/>
Określa nowy kolor tła.

### <a name="return-value"></a>Wartość zwracana

Poprzedni kolor tła jako wartość koloru RGB. Jeśli wystąpi błąd, zwracana wartość to 0x80000000.

### <a name="remarks"></a>Uwagi

Jeśli tryb tła jest nieprzezroczysty, system używa koloru tła do wypełnienia luk w stylach linii, przerw między liniami kreskowanymi w pędzlach i tłem w postaci komórek znakowych. System używa również koloru tła podczas konwertowania map bitowych między kontekstami urządzeń kolor i Monochromatycznie.

Jeśli urządzenie nie może wyświetlić określonego koloru, system ustawi kolor tła na najbliższy kolor fizyczny.

## <a name="cdcsetbkmode"></a><a name="setbkmode"></a>Przechwytywanie zmian:: SetBkMode

Ustawia tryb tła.

```
int SetBkMode(int nBkMode);
```

### <a name="parameters"></a>Parametry

*nBkMode*<br/>
Określa tryb, który ma być ustawiony. Ten parametr może mieć jedną z następujących wartości:

- Tło nieprzezroczyste jest wypełniane bieżącym kolorem tła przed narysowaniem tekstu, pędzlem lub piórem. Jest to domyślny tryb tła.

- PRZEZROCZYSTe tło nie jest zmieniane przed rysowaniem.

### <a name="return-value"></a>Wartość zwracana

Poprzedni tryb w tle.

### <a name="remarks"></a>Uwagi

Tryb tła definiuje, czy system usuwa istniejące kolory tła na powierzchni rysowania przed rysowaniem tekstu, pędzlami kreskowanymi i dowolnym stylem pióra, który nie jest linią ciągłą.

### <a name="example"></a>Przykład

  Zobacz przykład dla [CWnd:: OnCtlColor](../../mfc/reference/cwnd-class.md#onctlcolor).

## <a name="cdcsetboundsrect"></a><a name="setboundsrect"></a>Przechwytywanie zmian:: SetBoundsRect

Kontroluje akumulację informacji o prostokącie obwiedni dla określonego kontekstu urządzenia.

```
UINT SetBoundsRect(
    LPCRECT lpRectBounds,
    UINT flags);
```

### <a name="parameters"></a>Parametry

*lpRectBounds*<br/>
Wskazuje `RECT` strukturę lub `CRect` obiekt, który jest używany do ustawiania prostokąta ograniczenia. Wymiary prostokątów są wyrażane we współrzędnych logicznych. Ten parametr może mieć wartość NULL.

*flagi*<br/>
Określa, w jaki sposób nowy prostokąt będzie połączony z prostokątem skumulowanym. Ten parametr może być kombinacją następujących wartości:

- DCB_ACCUMULATE dodać prostokąt określony przez *lpRectBounds* do obwiedni prostokąta (przy użyciu operacji z prostokątem).

- DCB_DISABLE wyłączyć akumulację powiązań.

- DCB_ENABLE włączyć akumulacji powiązań. (Ustawienie domyślne akumulacji powiązań jest wyłączone).

### <a name="return-value"></a>Wartość zwracana

Bieżący stan prostokąta ograniczenia, jeśli funkcja się powiedzie. Podobnie jak *flagi*, wartość zwracana może być kombinacją wartości **DCB_** :

- DCB_ACCUMULATE prostokąt ograniczający nie jest pusty. Ta wartość będzie zawsze ustawiona.

- Kumulacja powiązań DCB_DISABLE jest wyłączona.

- DCB_ENABLE powiązania są włączone.

### <a name="remarks"></a>Uwagi

System Windows może zachować prostokąt związany z wszystkimi operacjami rysowania. Ten prostokąt może być badany i resetowany przez aplikację. Granice rysowania są przydatne do unieważniania pamięci podręcznych map bitowych.

## <a name="cdcsetbrushorg"></a><a name="setbrushorg"></a>Przechwytywanie zmian:: SetBrushOrg

Określa źródło, które zostanie przypisane do następnego pędzla, który aplikacja wybierze w kontekście urządzenia.

```
CPoint SetBrushOrg(
    int x,
    int y);

CPoint SetBrushOrg(POINT point);
```

### <a name="parameters"></a>Parametry

*x*<br/>
Określa współrzędną x (w jednostkach urządzeń) nowego źródła. Ta wartość musi należeć do zakresu 0-7.

*t*<br/>
Określa współrzędną y (w jednostkach urządzeń) nowego źródła. Ta wartość musi należeć do zakresu 0-7.

*moment*<br/>
Określa współrzędne x i y nowego źródła. Każda wartość musi należeć do zakresu 0-7. Można przekazać `POINT` strukturę lub `CPoint` obiekt dla tego parametru.

### <a name="return-value"></a>Wartość zwracana

Poprzednia pochodzenie pędzla w jednostkach urządzeń.

### <a name="remarks"></a>Uwagi

Domyślne współrzędne dla pochodzenia pędzla to (0, 0). Aby zmienić źródło pędzla, wywołaj `UnrealizeObject` funkcję dla `CBrush` obiektu, wywołaj `SetBrushOrg` , a następnie Wywołaj `SelectObject` funkcję elementu członkowskiego, aby wybrać Pędzel do kontekstu urządzenia.

Nie należy używać `SetBrushOrg` z obiektami podstawowymi `CBrush` .

## <a name="cdcsetcoloradjustment"></a><a name="setcoloradjustment"></a>Przechwytywanie zmian:: SetColorAdjustment

Ustawia wartości korekty koloru dla kontekstu urządzenia przy użyciu określonych wartości.

```
BOOL SetColorAdjustment(const COLORADJUSTMENT* lpColorAdjust);
```

### <a name="parameters"></a>Parametry

*lpColorAdjust*<br/>
Wskazuje strukturę danych [COLORADJUSTMENT](/windows/win32/api/wingdi/ns-wingdi-coloradjustment) zawierającą wartości korekty koloru.

### <a name="return-value"></a>Wartość zwracana

Niezerowe, jeśli pomyślne; w przeciwnym razie 0.

### <a name="remarks"></a>Uwagi

Wartości dopasowywania koloru są używane do dostosowywania koloru wejścia źródłowej mapy bitowej dla wywołań `CDC::StretchBlt` funkcji elementu członkowskiego, gdy jest ustawiony tryb półtonów.

## <a name="cdcsetdcbrushcolor"></a><a name="setdcbrushcolor"></a>Przechwytywanie zmian:: SetDCBrushColor

Ustawia kolor bieżącego pędzla kontekstu urządzenia (DC) na określoną wartość koloru.

```
COLORREF SetDCBrushColor(COLORREF crColor);
```

### <a name="parameters"></a>Parametry

*crColor*<br/>
Określa nowy kolor pędzla.

### <a name="return-value"></a>Wartość zwracana

Jeśli funkcja się powiedzie, wartość zwracana określa poprzedni kolor pędzla kontrolera domeny jako wartość COLORREF.

Jeśli funkcja się nie powiedzie, wartość zwracana jest CLR_INVALID.

### <a name="remarks"></a>Uwagi

Ta metoda emuluje funkcjonalność funkcji [SetDCBrushColor](/windows/win32/api/wingdi/nf-wingdi-setdcbrushcolor), zgodnie z opisem w Windows SDK.

## <a name="cdcsetdcpencolor"></a><a name="setdcpencolor"></a>Przechwytywanie zmian:: SetDCPenColor

Ustawia kolor bieżącego kontekstu urządzenia (DC) na określoną wartość koloru.

```
COLORREF SetDCPenColor(COLORREF crColor);
```

### <a name="parameters"></a>Parametry

*crColor*<br/>
Określa nowy kolor pióra.

### <a name="return-value"></a>Wartość zwracana

Różne od zera, jeśli funkcja zakończyła się pomyślnie; w przeciwnym razie 0.

### <a name="remarks"></a>Uwagi

Ta funkcja członkowska wykorzystuje funkcję Win32 [SetDCPenColor](/windows/win32/api/wingdi/nf-wingdi-setdcpencolor), zgodnie z opisem w Windows SDK.

## <a name="cdcsetgraphicsmode"></a><a name="setgraphicsmode"></a>Przechwytywanie zmian:: setgraphicsmode

Ustawia tryb grafiki dla określonego kontekstu urządzenia.

```
int SetGraphicsMode(int iMode);
```

### <a name="parameters"></a>Parametry

*iMode*<br/>
Określa tryb grafiki. Aby zapoznać się z listą wartości, które może wykonać ten parametr, zobacz [Setgraphicsmode](/windows/win32/api/wingdi/nf-wingdi-setgraphicsmode).

### <a name="return-value"></a>Wartość zwracana

Zwraca stary tryb grafiki po powodzeniu.

Zwraca wartość 0 w przypadku niepowodzenia. Aby uzyskać rozszerzone informacje o błędzie, wywołaj [wartość GetLastError](/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror).

### <a name="remarks"></a>Uwagi

Ta metoda [otacza funkcję interfejsu](/windows/win32/api/wingdi/nf-wingdi-setgraphicsmode)GDI systemu Windows.

## <a name="cdcsetlayout"></a><a name="setlayout"></a>Przechwytywanie zmian:: SetLayout

Wywołaj tę funkcję elementu członkowskiego, aby zmienić układ tekstu i grafiki dla kontekstu urządzenia na od prawej do lewej, standardowy układ dla kultur, takich jak arabski i hebrajski.

```
DWORD SetLayout(DWORD dwLayout);
```

### <a name="parameters"></a>Parametry

*dwLayout*<br/>
Układ kontekstu urządzenia i flagi kontrolki mapy bitowej. Może to być kombinacja następujących wartości.

|Wartość|Znaczenie|
|-----------|-------------|
|LAYOUT_BITMAPORIENTATIONPRESERVED|Wyłącza wszystkie odbicie wywołań do [przechwytywania:: BitBlt](#bitblt) i [przechwytywania:: StretchBlt](#stretchblt).|
|LAYOUT_RTL|Ustawia domyślny układ poziomy na od prawej do lewej.|
|LAYOUT_LTR|Ustawia domyślny układ na od lewej do prawej.|

### <a name="return-value"></a>Wartość zwracana

W przypadku powodzenia, poprzedni układ kontekstu urządzenia.

W przypadku niepowodzenia GDI_ERROR. Aby uzyskać rozszerzone informacje o błędzie, wywołaj [wartość GetLastError](/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror).

### <a name="remarks"></a>Uwagi

Zwykle nie można wywoływać `SetLayout` okna. Zamiast tego możesz sterować układem od prawej do lewej w oknie, ustawiając [Style okna rozszerzonego](../../mfc/reference/styles-used-by-mfc.md#extended-window-styles) , takie jak WS_EX_RTLREADING. Kontekst urządzenia, taki jak drukarka lub metaplik, nie dziedziczy tego układu. Jedynym sposobem ustawienia kontekstu urządzenia dla układu od prawej do lewej jest wywołanie metody `SetLayout` .

Jeśli wywołasz metodę **SetLayout (LAYOUT_RTL** ), program `SetLayout` automatycznie zmieni tryb mapowania na MM_ISOTROPIC. W związku z tym kolejne wywołanie do [GetMapMode](#getmapmode) będzie zwracać MM_ISOTROPIC, a nie MM_TEXT.

W niektórych przypadkach, na przykład z wieloma mapami bitowymi, możesz chcieć zachować układ od lewej do prawej. W takich przypadkach renderuje obraz przez wywołanie metody `BitBlt` lub `StretchBlt` , a następnie ustawienie flagi kontrolki mapy bitowej dla *dwLayout* na LAYOUT_BITMAPORIENTATIONPRESERVED.

Po zmianie układu przy użyciu flagi LAYOUT_RTL flagi zwykle określające prawo lub lewo są odwracane. Aby uniknąć nieporozumień, można zdefiniować alternatywne nazwy dla standardowych flag. Aby uzyskać listę sugerowanych nazw flag alternatywnych, zobacz [SetLayout](/windows/win32/api/wingdi/nf-wingdi-setlayout) w Windows SDK.

## <a name="cdcsetmapmode"></a><a name="setmapmode"></a>Przechwytywanie zmian:: SetMapMode

Ustawia tryb mapowania.

```
virtual int SetMapMode(int nMapMode);
```

### <a name="parameters"></a>Parametry

*nMapMode*<br/>
Określa nowy tryb mapowania. Może to być jedna z następujących wartości:

- Jednostki logiczne MM_ANISOTROPIC są konwertowane na dowolną liczbę jednostek z arbitralnie skalowanymi osiami. Ustawienie trybu mapowania na MM_ANISOTROPIC nie powoduje zmiany ustawień bieżącego okna lub okienka ekranu. Aby zmienić jednostki, orientację i skalowanie, wywołaj funkcje składowe [SetWindowExt](#setwindowext) i [SetViewportExt](#setviewportext) .

- MM_HIENGLISH każda jednostka logiczna jest konwertowana na 0,001 cala. Dodatnia x to prawo; dodatnia wartość y jest nieaktualna.

- MM_HIMETRIC każda jednostka logiczna jest konwertowana na 0,01 milimetrów. Dodatnia x to prawo; dodatnia wartość y jest nieaktualna.

- Jednostki logiczne MM_ISOTROPIC są konwertowane na dowolną liczbę jednostek, które są równej skali osi; oznacza to, że 1 jednostka wzdłuż osi x jest równa 1 jednostka wzdłuż osi y. Użyj `SetWindowExt` funkcji i, `SetViewportExt` Aby określić wymagane jednostki i orientację osi. Interfejs GDI wprowadza odpowiednie korekty, aby zapewnić, że jednostki x i y pozostają w tym samym rozmiarze.

- MM_LOENGLISH każda jednostka logiczna jest konwertowana na 0,01 cala. Dodatnia x to prawo; dodatnia wartość y jest nieaktualna.

- MM_LOMETRIC każda jednostka logiczna jest konwertowana na 0,1 milimetrów. Dodatnia x to prawo; dodatnia wartość y jest nieaktualna.

- MM_TEXT każda jednostka logiczna jest konwertowana na 1 piksel urządzenia. Dodatnia x to prawo; dodatni y nie działa.

- MM_TWIPS każda jednostka logiczna jest konwertowana na 1/20 punktu. (Ponieważ punkt jest 1/72 cala, twip ma 1/1440 cm). Dodatnia x to prawo; dodatnia wartość y jest nieaktualna.

### <a name="return-value"></a>Wartość zwracana

Poprzedni tryb mapowania.

### <a name="remarks"></a>Uwagi

Tryb mapowania definiuje jednostkę miary służącą do konwertowania jednostek logicznych na jednostki urządzeń; definiuje również orientację osi x i y urządzenia. Interfejs GDI używa trybu mapowania, aby przekonwertować współrzędne logiczne do odpowiednich współrzędnych urządzenia. Tryb MM_TEXT umożliwia aplikacjom działanie w pikselach urządzeń, gdzie 1 jednostka jest równa 1 piksel. Rozmiar fizyczny piksela różni się od urządzenia do urządzenia.

Tryby MM_HIENGLISH, MM_HIMETRIC, MM_LOENGLISH, MM_LOMETRIC i MM_TWIPS są przydatne w przypadku aplikacji, które muszą rysować w fizycznie znaczących jednostkach (takich jak cale lub milimetry). Tryb MM_ISOTROPIC zapewnia współczynnik proporcji 1:1, który jest przydatny, gdy ważne jest zachowanie dokładnego kształtu obrazu. Tryb MM_ANISOTROPIC umożliwia niezależne dostosowanie współrzędnych x i y.

> [!NOTE]
> Jeśli wywołasz polecenie [SetLayout](#setlayout) by zmienić kontroler domeny (kontekst urządzenia) na układ od prawej do lewej, program `SetLayout` automatycznie zmieni tryb mapowania na MM_ISOTROPIC.

### <a name="example"></a>Przykład

  Zobacz przykład dla [CView:: OnPrepareDC](../../mfc/reference/cview-class.md#onpreparedc).

## <a name="cdcsetmapperflags"></a><a name="setmapperflags"></a>Przechwytywanie zmian:: SetMapperFlags

Zmienia metodę używaną przez funkcję mapowania czcionek podczas konwertowania logicznej czcionki na czcionkę fizyczną.

```
DWORD SetMapperFlags(DWORD dwFlag);
```

### <a name="parameters"></a>Parametry

*dwFlag*<br/>
Określa, czy Maper czcionek próbuje dopasować wysokość i Szerokość obrazu czcionki do urządzenia. Gdy ta wartość jest ASPECT_FILTERING, mapowanie wybiera tylko czcionki, których proporcje x-proporcje i y są dokładnie zgodne z tymi określonymi urządzeniami.

### <a name="return-value"></a>Wartość zwracana

Poprzednia wartość flagi mapowania czcionek.

### <a name="remarks"></a>Uwagi

Aplikacja może użyć, `SetMapperFlags` Aby spowodować, że Maper czcionek podejmie próbę wybrania tylko czcionki fizycznej, która dokładnie pasuje do współczynnika proporcji określonego urządzenia.

Aplikacja używająca tylko czcionek rastrowych może użyć `SetMapperFlags` funkcji, aby upewnić się, że czcionka wybrana przez mapowanie czcionek jest atrakcyjna i czytelna na określonym urządzeniu. Aplikacje korzystające z czcionek skalowalnych (TrueType) zwykle nie są używane `SetMapperFlags` .

Jeśli żadna czcionka fizyczna nie ma współczynnika proporcji odpowiadającego specyfikacji w czcionce logicznej, interfejs GDI wybiera nowy współczynnik proporcji i wybiera czcionkę zgodną z tym nowym wskaźnikiem proporcji.

## <a name="cdcsetmiterlimit"></a><a name="setmiterlimit"></a>Przechwytywanie zmian:: SetMiterLimit

Ustawia limit długości sprzężeń ścięcia dla kontekstu urządzenia.

```
BOOL SetMiterLimit(float fMiterLimit);
```

### <a name="parameters"></a>Parametry

*fMiterLimit*<br/>
Określa nowy limit ścięcia dla kontekstu urządzenia.

### <a name="return-value"></a>Wartość zwracana

Różne od zera, jeśli funkcja zakończyła się pomyślnie; w przeciwnym razie 0.

### <a name="remarks"></a>Uwagi

Długość ścięcia jest definiowana jako odległość od przecięcia ścian linii w obrębie wewnątrz sprzężenia z przecięciem do przecięcia ścian linii na zewnątrz sprzężenia. Próg ścięcia jest maksymalnym dozwolonym stosunkiem długości ścięcia do szerokości linii. Domyślny limit ścięcia to 10,0.

## <a name="cdcsetoutputdc"></a><a name="setoutputdc"></a>Przechwytywanie zmian:: SetOutputDC

Wywołaj tę funkcję elementu członkowskiego, aby ustawić kontekst urządzenia wyjściowego `m_hDC` .

```
virtual void SetOutputDC(HDC hDC);
```

### <a name="parameters"></a>Parametry

*Używający HDC*<br/>
Kontekst urządzenia systemu Windows.

### <a name="remarks"></a>Uwagi

Ta funkcja członkowska może zostać wywołana tylko wtedy, gdy kontekst urządzenia nie został dołączony do `CDC` obiektu. Ta funkcja elementu członkowskiego ustawia, `m_hDC` ale nie dołącza kontekstu urządzenia do `CDC` obiektu.

## <a name="cdcsetpixel"></a><a name="setpixel"></a>Przechwytywanie zmian:: SetPixel

Ustawia piksel w punkcie określonym do najbliższego przybliżenia koloru określonego przez *crColor*.

```
COLORREF SetPixel(
    int x,
    int y,
    COLORREF crColor);

COLORREF SetPixel(
    POINT point,
    COLORREF crColor);
```

### <a name="parameters"></a>Parametry

*x*<br/>
Określa logiczną współrzędną x punktu, który ma zostać ustawiony.

*t*<br/>
Określa logiczną współrzędną y punktu, który ma zostać ustawiony.

*crColor*<br/>
Wartość RGB COLORREF, która określa kolor używany do malowania punktu. Aby uzyskać opis tej wartości, zobacz [COLORREF](/windows/win32/gdi/colorref) w Windows SDK.

*moment*<br/>
Określa logiczne współrzędne x i y punktu, który ma zostać ustawiony. Można przekazać `POINT` strukturę lub `CPoint` obiekt dla tego parametru.

### <a name="return-value"></a>Wartość zwracana

Wartość RGB dla koloru, w którym punkt jest rzeczywiście malowany. Ta wartość może się różnić od określonego przez *crColor* , jeśli jest używane przybliżenie tego koloru. Jeśli funkcja nie powiedzie się (Jeśli punkt znajduje się poza obszarem przycinania), zwracana wartość to-1.

### <a name="remarks"></a>Uwagi

Punkt musi znajdować się w regionie przycinania. Jeśli punkt nie znajduje się w regionie przycinania, funkcja nic nie robi.

Nie wszystkie urządzenia obsługują `SetPixel` funkcję. Aby określić, czy urządzenie obsługuje `SetPixel` , wywołaj `GetDeviceCaps` funkcję członkowską z indeksem RASTERCAPS i sprawdź wartość zwracaną flagi RC_BITBLT.

## <a name="cdcsetpixelv"></a><a name="setpixelv"></a>Przechwytywanie zmian:: SetPixelV

Ustawia piksel na określonych współrzędnych do najbliższego przybliżenia podanego koloru.

```
BOOL SetPixelV(
    int x,
    int y,
    COLORREF crColor);

BOOL SetPixelV(
    POINT point,
    COLORREF crColor);
```

### <a name="parameters"></a>Parametry

*x*<br/>
Określa współrzędną x (w jednostkach logicznych) punktu, który ma zostać ustawiony.

*t*<br/>
Określa współrzędną y (w jednostkach logicznych) punktu, który ma zostać ustawiony.

*crColor*<br/>
Określa kolor, który ma być używany do malowania punktu.

*moment*<br/>
Określa logiczne współrzędne x i y punktu, który ma zostać ustawiony. Dla tego parametru można przekazać strukturę danych [punktu](/windows/win32/api/windef/ns-windef-point) lub obiekt [CPoint](../../atl-mfc-shared/reference/cpoint-class.md) .

### <a name="return-value"></a>Wartość zwracana

Różne od zera, jeśli funkcja zakończyła się pomyślnie; w przeciwnym razie 0.

### <a name="remarks"></a>Uwagi

Punkt musi znajdować się zarówno w regionie przycinania, jak i widocznej części powierzchni urządzenia. Nie wszystkie urządzenia obsługują funkcję członkowską. Aby uzyskać więcej informacji, zobacz możliwości RC_BITBLT w `CDC::GetDeviceCaps` funkcji składowej. `SetPixelV`jest szybsza niż `SetPixel` , ponieważ nie musi zwracać wartości koloru punktu w rzeczywistości.

## <a name="cdcsetpolyfillmode"></a><a name="setpolyfillmode"></a>Przechwytywanie zmian:: SetPolyFillMode

Ustawia tryb wypełniania wielokątów.

```
int SetPolyFillMode(int nPolyFillMode);
```

### <a name="parameters"></a>Parametry

*nPolyFillMode*<br/>
Określa nowy tryb wypełniania. Ta wartość może być ALTERNATYWą lub ZAMKNIĘCIEm. Domyślny tryb ustawiany w systemie Windows jest ALTERNATYWą.

### <a name="return-value"></a>Wartość zwracana

Poprzedni tryb wypełniania, jeśli powodzenie; w przeciwnym razie 0.

### <a name="remarks"></a>Uwagi

Gdy tryb wypełniania wielokątów jest ALTERNATYWny, system wypełnia obszar między nieparzystymi i parzystymi krawędziami w każdym wierszu skanowania. Oznacza to, że system wypełnia obszar między pierwszą i drugą stroną, między trzecią i czwartą stroną itd. Ten tryb jest domyślny.

Gdy tryb wypełniania wielokątów jest ZAWIJAny, system używa kierunku, w którym rysowany jest rysunek, aby określić, czy ma zostać wypełniony obszar. Każdy segment linii w wielokąta jest rysowany w trybie w prawo lub w lewo. Za każdym razem, gdy linia urojona rysowana od obszaru zamkniętego do zewnątrz przechodzą przez segment linii w prawo, liczba jest zwiększana. Gdy linia przechodzi przez segment linii w lewo, licznik jest zmniejszany. Obszar jest wypełniany, jeśli liczba jest różna od zera, gdy linia osiągnie się poza rysunkiem.

## <a name="cdcsetrop2"></a><a name="setrop2"></a>Przechwytywanie zmian:: SetROP2

Ustawia bieżący tryb rysowania.

```
int SetROP2(int nDrawMode);
```

### <a name="parameters"></a>Parametry

*nDrawMode*<br/>
Określa nowy tryb rysowania. Może to być dowolna z następujących wartości:

- Piksele R2_BLACK są zawsze czarne.

- Piksele R2_WHITE są zawsze białe.

- R2_NOP piksel pozostaje niezmieniony.

- R2_NOT piksel jest odwrotnością koloru ekranu.

- Piksel R2_COPYPEN jest kolorem pióra.

- R2_NOTCOPYPEN piksel jest odwrotnością koloru pióra.

- R2_MERGEPENNOT Pixel to kombinacja koloru pióra i odwrotności koloru ekranu (ostatni piksel = (nie piksel ekranu) ani pióra).

- Piksel R2_MASKPENNOT jest kombinacją kolorów wspólnych dla pióra i odwrotności ekranu (ostatni piksel = (nie piksel ekranu) i pióro).

- Piksel R2_MERGENOTPEN jest kombinacją koloru ekranu i odwrotności koloru pióra (ostatni piksel = (nie pióro) lub piksel ekranu).

- Piksel R2_MASKNOTPEN jest kombinacją kolorów wspólnych dla ekranu i odwrotności pióra (ostatni piksel = (nie pióro) i piksel ekranu).

- Piksel R2_MERGEPEN to kombinacja koloru pióra i koloru ekranu (ostatni piksel = piksel lub ekran).

- R2_NOTMERGEPEN piksel jest odwrotnością R2_MERGEPEN koloru (ostatni piksel = nie (piksel lub ekran)).

- R2_MASKPEN Pixel to kombinacja kolorów wspólnych dla pióra i ekranu (ostatni piksel = piksel i ekran).

- R2_NOTMASKPEN piksel jest odwrotnością R2_MASKPEN koloru (ostatni piksel = nie (piksel i ekran)).

- R2_XORPEN Pixel to kombinacja kolorów, które są w piórie lub na ekranie, ale nie w obu warstwach (piksel — ostatni obraz ekranu).

- R2_NOTXORPEN piksel jest odwrotnością R2_XORPEN koloru (ostatni piksel = NOT).

### <a name="return-value"></a>Wartość zwracana

Poprzedni tryb rysowania.

Może być dowolną z wartości podanej w Windows SDK.

### <a name="remarks"></a>Uwagi

Tryb rysowania określa, w jaki sposób kolory pióra i wnętrza wypełnionych obiektów są połączone z kolorem znajdującym się już na powierzchni ekranu.

Tryb rysowania dotyczy tylko urządzeń rastrowych; nie dotyczy to urządzeń wektorowych. Tryby rysowania to binarne kody operacji rastrowych reprezentujące wszystkie możliwe kombinacje logiczne dwóch zmiennych, przy użyciu operatorów binarnych i,, i XOR (wyłączne lub), a nie operacji jednoargumentowej.

## <a name="cdcsetstretchbltmode"></a><a name="setstretchbltmode"></a>Przechwytywanie zmian:: SetStretchBltMode

Ustawia tryb rozciągnięcia mapy bitowej dla `StretchBlt` funkcji członkowskiej.

```
int SetStretchBltMode(int nStretchMode);
```

### <a name="parameters"></a>Parametry

*nStretchMode*<br/>
Określa tryb rozciągania. Może to być dowolna z następujących wartości:

|Wartość|Opis|
|-----------|-----------------|
|BLACKONWHITE|Wykonuje wartość logiczną i operację przy użyciu wartości koloru dla usuniętych i istniejących pikseli. Jeśli mapa bitowa jest mapą bitową, ten tryb zachowuje czerń pikseli przy kosztach białych pikseli.|
|COLORONCOLOR|Usuwa piksele. Ten tryb usuwa wszystkie wyeliminowane wiersze pikseli bez próby zachowania informacji.|
|PÓŁCIENI|Mapuje piksele z prostokąta źródłowego do bloków pikseli w prostokącie docelowym. Średni kolor bloku docelowego pikseli przybliżony kolor pikseli źródłowych.|
||Po ustawieniu trybu rozciągania PÓŁTONów aplikacja musi wywołać funkcję Win32 [SetBrushOrgEx](/windows/win32/api/wingdi/nf-wingdi-setbrushorgex) , aby ustawić źródło pędzla. Jeśli to się nie powiedzie, nastąpi niezgodność pędzla.|
|STRETCH_ANDSCANS|**Windows 95/98**: taki sam jak BLACKONWHITE|
|STRETCH_DELETESCANS|**Windows 95/98**: taki sam jak COLORONCOLOR|
|STRETCH_HALFTONE|**Windows 95/98**: taki sam jak półtony.|
|STRETCH_ORSCANS|**Windows 95/98**: taki sam jak WHITEONBLACK|
|WHITEONBLACK|Wykonuje wartość logiczną lub operacji przy użyciu wartości koloru dla usuniętych i istniejących pikseli. Jeśli mapa bitowa jest mapą bitową, ten tryb zachowuje białe piksele na kosztach czarnych pikseli.|

### <a name="return-value"></a>Wartość zwracana

Poprzedni tryb rozciągania. Może być STRETCH_ANDSCANS, STRETCH_DELETESCANS lub STRETCH_ORSCANS.

### <a name="remarks"></a>Uwagi

Tryb rozciągnięcia mapy bitowej definiuje, jak informacje są usuwane z bitmap, które są kompresowane przy użyciu funkcji.

Tryby BLACKONWHITE (STRETCH_ANDSCANS) i WHITEONBLACK (STRETCH_ORSCANS) są zwykle używane do zachowywania pikseli pierwszego planu w przypadku monochromatycznych map bitowych. Tryb COLORONCOLOR (STRETCH_DELETESCANS) jest zazwyczaj używany do zachowywania koloru w bitmapach kolorowych.

Tryb PÓŁTONów wymaga więcej przetwarzania obrazu źródłowego niż pozostałe trzy tryby; jest to wolniejsze niż inne, ale tworzy obrazy o wyższej jakości. Należy również zauważyć, że `SetBrushOrgEx` należy wywołać po ustawieniu trybu półtonów, aby uniknąć nieodpowiedniego wyrównania pędzla.

Dodatkowe tryby rozciągania mogą być również dostępne w zależności od możliwości sterownika urządzenia.

## <a name="cdcsettextalign"></a><a name="settextalign"></a>Przechwytywanie zmian:: TextAlign

Ustawia flagi wyrównania tekstu.

```
UINT SetTextAlign(UINT nFlags);
```

### <a name="parameters"></a>Parametry

*nFlags*<br/>
Określa flagi wyrównania tekstu. Flagi określają relację między punktem a prostokątem, który jest powiązany z tekstem. Punkt może być bieżącą pozycją lub współrzędnymi określonymi przez funkcję Text-Output. Prostokąt, który jest powiązany z tekstem, jest definiowany przez sąsiednie komórki znaków w ciągu tekstowym. Parametr *nFlags* może mieć jedną lub więcej flag z następujących trzech kategorii. Wybierz tylko jedną flagę z każdej kategorii. Pierwsza kategoria ma wpływ na wyrównanie tekstu w kierunku x:

- TA_CENTER wyrównuje punkt z poziomą środka prostokąta obwiedni.

- TA_LEFT wyrównuje punkt z lewej strony prostokąta obwiedni. Jest to ustawienie domyślne.

- TA_RIGHT wyrównuje punkt z prawą krawędzią prostokąta obwiedni.

Druga kategoria ma wpływ na wyrównanie tekstu w kierunku y:

- TA_BASELINE wyrównuje punkt z linią bazową wybranej czcionki.

- TA_BOTTOM wyrównuje punkt z dolną krawędzią prostokąta ograniczenia.

- TA_TOP wyrównuje punkt z górną częścią prostokąta obwiedni. Jest to ustawienie domyślne.

Trzecia kategoria określa, czy bieżące położenie jest aktualizowane po zapisaniu tekstu:

- TA_NOUPDATECP nie aktualizuje bieżącej pozycji po każdym wywołaniu funkcji Text-Output. Jest to ustawienie domyślne.

- TA_UPDATECP aktualizuje bieżące położenie x po każdym wywołaniu funkcji Text-Output. Nowa pozycja znajduje się po prawej stronie prostokąta granicy tekstu. Gdy ta flaga jest ustawiona, współrzędne określone w wywołaniach `TextOut` funkcji składowej są ignorowane.

### <a name="return-value"></a>Wartość zwracana

Poprzednie ustawienie wyrównania tekstu, jeśli zostało wykonane pomyślnie. Niski priorytet zawiera ustawienie poziomy, a w polu High-Order bajt znajduje się ustawienie pionowe. w przeciwnym razie 0.

### <a name="remarks"></a>Uwagi

`TextOut`Funkcje i `ExtTextOut` używają tych flag podczas pozycjonowania ciągu tekstowego na ekranie lub urządzeniu. Flagi określają relację między określonym punktem a prostokątem, który jest powiązany z tekstem. Współrzędne tego punktu są przenoszone jako parametry do `TextOut` funkcji składowej. Prostokąt, który jest powiązany z tekstem, jest tworzony przez sąsiednie komórki znaków w ciągu tekstowym.

## <a name="cdcsettextcharacterextra"></a><a name="settextcharacterextra"></a>Przechwytywanie zmian:: SetTextCharacterExtra

Ustawia liczbę odstępów między znakami.

```
int SetTextCharacterExtra(int nCharExtra);
```

### <a name="parameters"></a>Parametry

*nCharExtra*<br/>
Określa ilość dodatkowego miejsca (w jednostkach logicznych), która ma zostać dodana do każdego znaku. Jeśli bieżącym trybem mapowania nie jest `MM_TEXT` , *nCharExtra* jest przekształcony i zaokrąglany do najbliższego piksela.

### <a name="return-value"></a>Wartość zwracana

Kwota poprzedniego odstępu między znakami.

### <a name="remarks"></a>Uwagi

Interfejs GDI dodaje te odstępy do każdego znaku, w tym znaki łamania, gdy zapisuje wiersz tekstu do kontekstu urządzenia. Wartość domyślna dla wielkości odstępów między znakami wynosi 0.

## <a name="cdcsettextcolor"></a><a name="settextcolor"></a>Przechwytywanie zmian:: SetTextColor

Ustawia kolor tekstu na określony kolor.

```
virtual COLORREF SetTextColor(COLORREF crColor);
```

### <a name="parameters"></a>Parametry

*crColor*<br/>
Określa kolor tekstu jako wartość koloru RGB.

### <a name="return-value"></a>Wartość zwracana

Wartość RGB dla poprzedniego koloru tekstu.

### <a name="remarks"></a>Uwagi

System użyje tego koloru tekstu podczas zapisywania tekstu w tym kontekście urządzenia, a także podczas konwertowania map bitowych między kontekstami kolorów a kolorami monochromatycznymi.

Jeśli urządzenie nie może reprezentować określonego koloru, system ustawi kolor tekstu na najbliższy kolor fizyczny. Kolor tła znaku jest określany przez `SetBkColor` i `SetBkMode` funkcje składowe.

### <a name="example"></a>Przykład

  Zobacz przykład dla [CWnd:: OnCtlColor](../../mfc/reference/cwnd-class.md#onctlcolor).

## <a name="cdcsettextjustification"></a><a name="settextjustification"></a>Przechwytywanie zmian:: SetTextJustification

Dodaje miejsce do znaków podziału w ciągu.

```
int SetTextJustification(
    int nBreakExtra,
    int nBreakCount);
```

### <a name="parameters"></a>Parametry

*nBreakExtra*<br/>
Określa łączne dodatkowe miejsce, które ma zostać dodane do wiersza tekstu (w jednostkach logicznych). Jeśli bieżącym trybem mapowania nie jest `MM_TEXT` , wartość określona przez ten parametr jest konwertowana na bieżący tryb mapowania i zaokrąglana do najbliższej jednostki urządzenia.

*nBreakCount*<br/>
Określa liczbę znaków przerwy w wierszu.

### <a name="return-value"></a>Wartość zwracana

Jeden, jeśli funkcja się powiedzie; w przeciwnym razie 0.

### <a name="remarks"></a>Uwagi

Aplikacja może używać `GetTextMetrics` funkcji elementów członkowskich do pobierania znaku podziału czcionki.

Po `SetTextJustification` wywołaniu funkcji elementu członkowskiego wywołanie funkcji Text-Output (na przykład `TextOut` ) dystrybuuje określone dodatkowe miejsce równomiernie między określoną liczbą znaków przerwania. Znak podziału jest zwykle znakiem spacji (ASCII 32), ale może być zdefiniowany przez czcionkę jako inny znak.

Funkcja członkowska `GetTextExtent` jest zwykle używana z `SetTextJustification` . `GetTextExtent`oblicza szerokość danego wiersza przed wyrównaniem. Aplikacja może określić, ile miejsca należy określić w parametrze *nBreakExtra* przez odjęcie wartości zwróconej przez wartość `GetTextExtent` z zakresu od szerokości ciągu po wyrównaniu.

`SetTextJustification`Funkcja może służyć do wyrównania linii zawierającej wiele przebiegów w różnych czcionkach. W tym przypadku wiersz musi być utworzony jako fragmentaryczny przez wyrównanie i zapisanie każdego przebiegu oddzielnie.

Ponieważ błędy zaokrągleń mogą wystąpić podczas wyrównania, system utrzymuje uruchomiony termin błędu, który definiuje bieżący błąd. Podczas wyrównywania linii zawierającej wiele uruchomień program `GetTextExtent` automatycznie używa tego warunku błędu, gdy oblicza zakres następnego uruchomienia. Pozwala to funkcji Text-Output na mieszanie błędu w nowym przebiegu.

Po wyrównaniu każdego wiersza ten okres błędu musi zostać wyczyszczony, aby zapobiec jego włączeniu do następnego wiersza. Termin może zostać wyczyszczony przez `SetTextJustification` wywołanie *nBreakExtra* o wartości 0.

## <a name="cdcsetviewportext"></a><a name="setviewportext"></a>Przechwytywanie zmian:: SetViewportExt

Ustawia zakresy x i y okienka ekranu kontekstu urządzenia.

```
virtual CSize SetViewportExt(
    int cx,
    int cy);

CSize SetViewportExt(SIZE size);
```

### <a name="parameters"></a>Parametry

*CX*<br/>
Określa zakres x zakresu okienka ekranu (w jednostkach urządzenia).

*cy*<br/>
Określa zakres y okienka ekranu (w jednostkach urządzenia).

*zmienia*<br/>
Określa zakres x i y okienka ekranu (w jednostkach urządzenia).

### <a name="return-value"></a>Wartość zwracana

Poprzednie zakresy okienka ekranu jako obiekt [CSize](../../atl-mfc-shared/reference/csize-class.md) . Gdy wystąpi błąd, współrzędne x i y zwracanego `CSize` obiektu są ustawione na 0.

### <a name="remarks"></a>Uwagi

Okienko ekranu, wraz z oknem kontekstu urządzenia, definiuje sposób, w jaki punkty mapy GDI w układzie współrzędnych logicznych wskazują punkty w układzie współrzędnych rzeczywistego urządzenia. Inaczej mówiąc, określają sposób, w jaki interfejs GDI konwertuje współrzędne logiczne na współrzędne urządzeń.

Gdy ustawione są następujące tryby mapowania, wywołania do `SetWindowExt` i `SetViewportExt` są ignorowane:

|MM_HIENGLISH|MM_LOMETRIC|
|-------------------|------------------|
|MM_HIMETRIC|MM_TEXT|
|MM_LOENGLISH|MM_TWIPS|

Gdy tryb MM_ISOTROPIC jest ustawiony, aplikacja musi wywołać `SetWindowExt` funkcję członkowską przed wywołaniem `SetViewportExt` .

### <a name="example"></a>Przykład

  Zobacz przykład dla [CView:: OnPrepareDC](../../mfc/reference/cview-class.md#onpreparedc).

## <a name="cdcsetviewportorg"></a><a name="setviewportorg"></a>Przechwytywanie zmian:: SetViewportOrg

Ustawia źródło okienka ekranu kontekstu urządzenia.

```
virtual CPoint SetViewportOrg(
    int x,
    int y);

CPoint SetViewportOrg(POINT point);
```

### <a name="parameters"></a>Parametry

*x*<br/>
Określa współrzędną x (w jednostkach urządzeń) pochodzenia okienka ekranu. Wartość musi należeć do zakresu układu współrzędnych urządzenia.

*t*<br/>
Określa współrzędną y (w jednostkach urządzeń) pochodzenia okienka ekranu. Wartość musi należeć do zakresu układu współrzędnych urządzenia.

*moment*<br/>
Określa początek okienka ekranu. Wartości muszą mieścić się w zakresie układu współrzędnych urządzenia. Można przekazać `POINT` strukturę lub `CPoint` obiekt dla tego parametru.

### <a name="return-value"></a>Wartość zwracana

Poprzednia część okienka ekranu (we współrzędnych urządzenia) jako `CPoint` obiekt.

### <a name="remarks"></a>Uwagi

Okienko ekranu, wraz z oknem kontekstu urządzenia, definiuje sposób, w jaki punkty mapy GDI w układzie współrzędnych logicznych wskazują punkty w układzie współrzędnych rzeczywistego urządzenia. Inaczej mówiąc, określają sposób, w jaki interfejs GDI konwertuje współrzędne logiczne na współrzędne urządzeń.

Źródło okienka ekranu oznacza punkt w układzie współrzędnych urządzenia, do którego interfejs GDI mapuje Źródło okna, punkt w logicznym układzie współrzędnych określony przez `SetWindowOrg` funkcję członkowską. Interfejs GDI mapuje wszystkie inne punkty, wykonując ten sam proces, który jest wymagany do zamapowania pochodzenie okna do źródła okienka ekranu. Na przykład wszystkie punkty w okręgu wokół punktu w pochodzeniu okna będą znajdować się w okręgu wokół punktu w pochodzeniu okienka ekranu. Podobnie wszystkie punkty w wierszu, który przechodzi przez pochodzenie okna, będą znajdować się w wierszu, który przechodzi przez źródło okienka ekranu.

### <a name="example"></a>Przykład

  Zobacz przykład dla [CView:: OnPrepareDC](../../mfc/reference/cview-class.md#onpreparedc).

## <a name="cdcsetwindowext"></a><a name="setwindowext"></a>Przechwytywanie zmian:: SetWindowExt

Ustawia zakresy x i y okna skojarzonego z kontekstem urządzenia.

```
virtual CSize SetWindowExt(
    int cx,
    int cy);

CSize SetWindowExt(SIZE size);
```

### <a name="parameters"></a>Parametry

*CX*<br/>
Określa zakres x (w jednostkach logicznych) okna.

*cy*<br/>
Określa zakres y (w jednostkach logicznych) okna.

*zmienia*<br/>
Określa zakresy x i y (w jednostkach logicznych) okna.

### <a name="return-value"></a>Wartość zwracana

Poprzednie zakresy okna (w jednostkach logicznych) jako `CSize` obiekt. Jeśli wystąpi błąd, współrzędne x i y zwracanego `CSize` obiektu są ustawione na 0.

### <a name="remarks"></a>Uwagi

Okno, a także okienko ekranu kontekstu urządzenia definiuje sposób, w jaki punkty mapy GDI w układzie współrzędnych logicznych wskazują punkty w układzie współrzędnych urządzenia.

Po ustawieniu następujących trybów mapowania wywołania `SetWindowExt` i `SetViewportExt` funkcje są ignorowane:

- MM_HIENGLISH

- MM_HIMETRIC

- MM_LOENGLISH

- MM_LOMETRIC

- MM_TEXT

- MM_TWIPS

Gdy tryb MM_ISOTROPIC jest ustawiony, aplikacja musi wywołać `SetWindowExt` funkcję członkowską przed wywołaniem `SetViewportExt` .

### <a name="example"></a>Przykład

  Zobacz przykład dla [CView:: OnPrepareDC](../../mfc/reference/cview-class.md#onpreparedc).

## <a name="cdcsetwindoworg"></a><a name="setwindoworg"></a>Przechwytywanie zmian:: SetWindowOrg

Ustawia pochodzenie okna dla kontekstu urządzenia.

```
CPoint SetWindowOrg(
    int x,
    int y);

CPoint SetWindowOrg(POINT point);
```

### <a name="parameters"></a>Parametry

*x*<br/>
Określa logiczną współrzędną x nowego źródła okna.

*t*<br/>
Określa logiczną współrzędną y nowego źródła okna.

*moment*<br/>
Określa współrzędne logiczne nowego źródła okna. Można przekazać `POINT` strukturę lub `CPoint` obiekt dla tego parametru.

### <a name="return-value"></a>Wartość zwracana

Poprzednie Źródło okna jako `CPoint` obiekt.

### <a name="remarks"></a>Uwagi

Okno, a także okienko ekranu kontekstu urządzenia definiuje sposób, w jaki punkty mapy GDI w układzie współrzędnych logicznych wskazują punkty w układzie współrzędnych urządzenia.

Początek okna oznacza punkt w logicznym układzie współrzędnych, z którego interfejs GDI mapuje Źródło okienka ekranu, punkt w układzie współrzędnych urządzenia określony przez `SetWindowOrg` funkcję. Interfejs GDI mapuje wszystkie inne punkty, wykonując ten sam proces, który jest wymagany do zamapowania pochodzenie okna do źródła okienka ekranu. Na przykład wszystkie punkty w okręgu wokół punktu w pochodzeniu okna będą znajdować się w okręgu wokół punktu w pochodzeniu okienka ekranu. Podobnie wszystkie punkty w wierszu, który przechodzi przez pochodzenie okna, będą znajdować się w wierszu, który przechodzi przez źródło okienka ekranu.

## <a name="cdcsetworldtransform"></a><a name="setworldtransform"></a>Przechwytywanie zmian:: SetWorldTransform

Ustawia dwuwymiarową transformację liniową między obszarem światowym i obszarem strony dla określonego kontekstu urządzenia. To przekształcenie może służyć do skalowania, obracania, ścinania lub tłumaczenia grafiki wyjściowej.

```
BOOL SetWorldTransform(const XFORM& rXform);
```

### <a name="parameters"></a>Parametry

*rXform*<br/>
Odwołanie do struktury [Xform](/windows/win32/api/wingdi/ns-wingdi-xform) zawierającej dane transformacji.

### <a name="return-value"></a>Wartość zwracana

Zwraca wartość różną od zera.

Zwraca wartość 0 w przypadku niepowodzenia.

Aby uzyskać rozszerzone informacje o błędzie, wywołaj [wartość GetLastError](/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror).

### <a name="remarks"></a>Uwagi

Ta metoda otacza funkcję [SetWorldTransform](/windows/win32/api/wingdi/nf-wingdi-setworldtransform)systemu Windows.

## <a name="cdcstartdoc"></a><a name="startdoc"></a>Przechwytywanie zmian:: StartDoc

Informuje o tym, że zostanie uruchomione nowe zadanie drukowania, a wszystkie kolejne `StartPage` i `EndPage` wywołania powinny być buforowane w ramach tego samego zadania do momentu `EndDoc` wystąpienia wywołania.

```
int StartDoc(LPDOCINFO lpDocInfo);
int StartDoc(LPCTSTR lpszDocName);
```

### <a name="parameters"></a>Parametry

*lpDocInfo*<br/>
Wskazuje strukturę [DOCINFO](/windows/win32/api/wingdi/ns-wingdi-docinfow) zawierającą nazwę pliku dokumentu i nazwę pliku wyjściowego.

*lpszDocName*<br/>
Wskaźnik na ciąg zawierający nazwę pliku dokumentu.

### <a name="return-value"></a>Wartość zwracana

Jeśli funkcja się powiedzie, wartość zwracana jest większa od zera. Ta wartość jest identyfikatorem zadania drukowania dla dokumentu.

Jeśli funkcja się nie powiedzie, wartość zwracana jest mniejsza lub równa zero.

### <a name="remarks"></a>Uwagi

Gwarantuje to, że dokumenty z więcej niż jedną stroną nie zostaną odplatane innymi zadaniami.

W przypadku systemu Windows w wersji 3,1 lub nowszej ta funkcja zastępuje STARTDOC drukarki. Użycie tej funkcji zapewnia, że dokumenty zawierające więcej niż jedną stronę nie są odłączone do innych zadań drukowania.

`StartDoc`nie należy używać wewnątrz plików.

### <a name="example"></a>Przykład

Ten fragment kodu pobiera drukarkę domyślną, otwiera zadanie drukowania i buforuje jedną stronę z opcją "Hello, World!" na nim. Ponieważ tekst drukowany przez ten kod nie jest skalowany w jednostkach logicznych drukarki, tekst wyjściowy może znajdować się w postaci małych liter, w wyniku których wynik nie jest czytelny. `SetMapMode` `SetViewportOrg` `SetWindowExt` Aby naprawić skalowanie, można użyć funkcji skalowania do przechwytywania, takich jak,, i.

[!code-cpp[NVC_MFCDocView#41](../../mfc/codesnippet/cpp/cdc-class_13.cpp)]

## <a name="cdcstartpage"></a><a name="startpage"></a>Przechwytywanie zmian:: StartPage

Wywołaj tę funkcję elementu członkowskiego, aby przygotować sterownik drukarki do odbierania danych.

```
int StartPage();
```

### <a name="return-value"></a>Wartość zwracana

Większe niż lub równe 0, jeśli funkcja jest pomyślna lub wartość ujemna, jeśli wystąpił błąd.

### <a name="remarks"></a>Uwagi

`StartPage`zastępuje NEWFRAME i BANDINFO ucieczki.

Aby zapoznać się z omówieniem sekwencji wywołań drukowania, zobacz funkcja członkowska [StartDoc](#startdoc) .

System wyłącza `ResetDC` funkcję członkowską między wywołaniami do `StartPage` i `EndPage` .

### <a name="example"></a>Przykład

  Zobacz przykład dla danych [przechwytywania:: StartDoc](#startdoc).

## <a name="cdcstretchblt"></a><a name="stretchblt"></a>Przechwytywanie zmian:: StretchBlt

Kopiuje mapę bitową z prostokąta źródłowego do prostokąta docelowego, w razie potrzeby rozciągając ją lub zmniejszając, aby dopasować ją do wymiarów prostokąta docelowego.

```
BOOL StretchBlt(
    int x,
    int y,
    int nWidth,
    int nHeight,
    CDC* pSrcDC,
    int xSrc,
    int ySrc,
    int nSrcWidth,
    int nSrcHeight,
    DWORD dwRop);
```

### <a name="parameters"></a>Parametry

*x*<br/>
Określa współrzędną x (w jednostkach logicznych) lewego górnego rogu prostokąta docelowego.

*t*<br/>
Określa współrzędną y (w jednostkach logicznych) lewego górnego rogu prostokąta docelowego.

*nWidth*<br/>
Określa szerokość (w jednostkach logicznych) prostokąta docelowego.

*nHeight*<br/>
Określa wysokość (w jednostkach logicznych) prostokąta docelowego.

*pSrcDC*<br/>
Określa kontekst urządzenia źródłowego.

*xSrc*<br/>
Określa współrzędną x (w jednostkach logicznych) lewego górnego rogu prostokąta źródłowego.

*ySrc*<br/>
Określa współrzędną y (w jednostkach logicznych) lewego górnego rogu prostokąta źródłowego.

*nSrcWidth*<br/>
Określa szerokość (w jednostkach logicznych) prostokąta źródłowego.

*nSrcHeight*<br/>
Określa wysokość (w jednostkach logicznych) prostokąta źródłowego.

*dwRop*<br/>
Określa operację rastrową, która ma być wykonana. Kody operacji rastrowych definiują, jak interfejs GDI łączy kolory w operacjach wyjściowych, które obejmują aktualny pędzel, możliwą źródłową mapę bitową i docelową mapę bitową. Ten parametr może przybierać jedną z następujących wartości:

- CZERNI powoduje, że wszystkie dane wyjściowe są czarne.

- DSTINVERT odwraca docelową mapę bitową.

- MERGECOPY łączy wzorzec i źródłową mapę bitową przy użyciu operatora logicznego i.

- MERGEPAINT łączy odwróconą źródłową mapę bitową z docelową mapą bitową przy użyciu operatora logicznego OR.

- NOTSRCCOPY kopiuje odwróconą źródłową mapę bitową do miejsca docelowego.

- NOTSRCERASE odwraca wynik łączenia mapy bitowej lokalizacji docelowej i źródłowej przy użyciu operatora logicznego OR.

- PATCOPY kopiuje wzorzec do docelowej mapy bitowej.

- PATINVERT łączy docelową mapę bitową ze wzorcem przy użyciu operatora Boolean XOR.

- PATPAINT łączy odwróconą źródłową mapę bitową ze wzorcem przy użyciu operatora logicznego OR. Łączy wynik tej operacji z docelową mapą bitową za pomocą operatora logicznego OR.

- SRCAND łączy piksele docelowej i źródłowej mapy bitowej przy użyciu operatora logicznego i.

- SRCCOPY kopiuje źródłową mapę bitową do docelowej mapy bitowej.

- SRCERASE odwraca docelową mapę bitową i łączy wynik ze źródłową mapą bitową za pomocą operatora Boolean i.

- SRCINVERT łączy piksele docelowej i źródłowej mapy bitowej przy użyciu operatora Boolean XOR.

- SRCPAINT łączy piksele docelowej i źródłowej mapy bitowej przy użyciu operatora logicznego OR.

- WHITENESS włącza wszystkie białe dane wyjściowe.

### <a name="return-value"></a>Wartość zwracana

Różne od zera, jeśli mapa bitowa jest rysowana; w przeciwnym razie 0.

### <a name="remarks"></a>Uwagi

Funkcja używa trybu rozciągania kontekstu urządzenia docelowego (ustawionego przez `SetStretchBltMode` ) w celu określenia sposobu rozciągnięcia lub skompresowania mapy bitowej.

`StretchBlt`Funkcja przenosi mapę bitową z urządzenia źródłowego podaną przez *pSrcDC* do urządzenia docelowego reprezentowanego przez obiekt kontekstu urządzenia, którego funkcja członkowska jest wywoływana. Parametry *xSrc*, *ySrc*, *nSrcWidth*i *nSrcHeight* definiują lewy górny róg i wymiary prostokąta źródłowego. Parametry *x*, *y*, *nWidth*i *nHeight* dają lewy górny róg i wymiary prostokąta docelowego. Operacja rastrowa określona przez *dwRop* definiuje sposób łączenia źródłowej mapy bitowej i bitów znajdujących się już na urządzeniu docelowym.

`StretchBlt`Funkcja tworzy obraz lustrzany mapy bitowej, jeśli znaki parametrów *NSrcWidth* i *NWidth* lub *nSrcHeight* i *nHeight* różnią się. Jeśli *nSrcWidth* i *nWidth* mają różne znaki, funkcja tworzy obraz lustrzany mapy bitowej wzdłuż osi x. Jeśli *nSrcHeight* i *nHeight* mają różne znaki, funkcja tworzy obraz lustrzany mapy bitowej wzdłuż osi y.

`StretchBlt`Funkcja rozciąga lub kompresuje źródłową mapę bitową w pamięci, a następnie kopiuje wynik do miejsca docelowego. Jeśli deseń ma być połączony z wynikiem, nie jest łączony, dopóki rozciągnięta źródłowa mapa bitowa nie zostanie skopiowana do miejsca docelowego. Jeśli jest używany pędzel, jest to wybrany pędzel w kontekście urządzenia docelowego. Współrzędne miejsca przeznaczenia są przekształcane zgodnie z kontekstem urządzenia docelowego; współrzędne źródła są przekształcane zgodnie z kontekstem urządzenia źródłowego.

Jeśli mapy bitowe lokalizacji docelowej, źródłowej i wzorca nie mają tego samego formatu koloru, program `StretchBlt` konwertuje mapy bitowe źródła i wzorca, aby pasowały do docelowych map bitowych. Kolory pierwszego planu i tła kontekstu urządzenia docelowego są używane do konwersji.

Jeśli `StretchBlt` program musi przekonwertować czarną mapę bitową na kolor, ustawia biały bity (1) na kolor tła i czarne bity (0) na kolor pierwszego planu. Aby przekonwertować kolor na monochromatyczny, ustawia piksele, które odpowiadają kolorowi tła, na biały (1), a wszystkie inne piksele ustawia na czarny (0). Używane są kolory pierwszego planu i tła kontekstu urządzenia z kolorem.

Nie wszystkie urządzenia obsługują `StretchBlt` funkcję. Aby określić, czy urządzenie obsługuje `StretchBlt` , wywołaj `GetDeviceCaps` funkcję członkowską z indeksem RASTERCAPS i sprawdź wartość zwracaną flagi RC_STRETCHBLT.

## <a name="cdcstrokeandfillpath"></a><a name="strokeandfillpath"></a>Przechwytywanie zmian:: StrokeAndFillPath

Zamyka wszystkie otwarte figury w ścieżce, rysuje kontur ścieżki przy użyciu bieżącego pióra i wypełnia jego wnętrze przy użyciu bieżącego pędzla.

```
BOOL StrokeAndFillPath();
```

### <a name="return-value"></a>Wartość zwracana

Różne od zera, jeśli funkcja zakończyła się pomyślnie; w przeciwnym razie 0.

### <a name="remarks"></a>Uwagi

Kontekst urządzenia musi zawierać ścieżkę zamkniętą. `StrokeAndFillPath`Funkcja członkowska ma ten sam skutek, co zamknięcie wszystkich otwartych figur w ścieżce i obrysowywanie i wypełnianie ścieżki oddzielnie, z tą różnicą, że wypełniony region nie nakłada się na pociągnięcie regionu, nawet jeśli pióro jest szerokie.

## <a name="cdcstrokepath"></a><a name="strokepath"></a>Przechwytywanie zmian:: StrokePath

Renderuje określoną ścieżkę przy użyciu bieżącego pióra.

```
BOOL StrokePath();
```

### <a name="return-value"></a>Wartość zwracana

Różne od zera, jeśli funkcja zakończyła się pomyślnie; w przeciwnym razie 0.

### <a name="remarks"></a>Uwagi

Kontekst urządzenia musi zawierać ścieżkę zamkniętą.

## <a name="cdctabbedtextout"></a><a name="tabbedtextout"></a>Przechwytywanie zmian:: TabbedTextOut

Wywołaj tę funkcję elementu członkowskiego, aby napisać ciąg znaków w określonej lokalizacji, rozwijając tabulatory do wartości określonych w tablicy pozycji tabulatora.

```
virtual CSize TabbedTextOut(
    int x,
    int y,
    LPCTSTR lpszString,
    int nCount,
    int nTabPositions,
    LPINT lpnTabStopPositions,
    int nTabOrigin);

CSize TabbedTextOut(
    int x,
    int y,
    const CString& str,
    int nTabPositions,
    LPINT lpnTabStopPositions,
    int nTabOrigin);
```

### <a name="parameters"></a>Parametry

*x*<br/>
Określa logiczną współrzędną x punktu początkowego ciągu.

*t*<br/>
Określa logiczną współrzędną y punktu początkowego ciągu.

*lpszString*<br/>
Wskazuje ciąg znaków do rysowania. Można przekazać wskaźnik do tablicy znaków lub obiektu [CString](../../atl-mfc-shared/reference/cstringt-class.md) dla tego parametru.

*nCount*<br/>
Określa [Długość ciągu](/windows/win32/gdi/specifying-length-of-text-output-string) wskazywanego przez *lpszString*.

*nTabPositions*<br/>
Określa liczbę wartości w tablicy pozycji tabulatora.

*lpnTabStopPositions*<br/>
Wskazuje tablicę zawierającą pozycje tabulatora (w jednostkach logicznych). Tabulatory muszą być sortowane w kolejności rosnącej; najmniejsza wartość x powinna być pierwszym elementem w tablicy.

*nTabOrigin*<br/>
Określa współrzędną x pozycji początkowej, z której są rozwijane karty (w jednostkach logicznych).

*str*<br/>
`CString`Obiekt, który zawiera określone znaki.

### <a name="return-value"></a>Wartość zwracana

Wymiary ciągu (w jednostkach logicznych) jako `CSize` obiekt.

### <a name="remarks"></a>Uwagi

Tekst jest zapisywana w aktualnie zaznaczonej czcionce. Jeśli *nTabPositions* jest 0, a *lpnTabStopPositions* ma wartość null, karty są rozwinięte do ośmiu razy średniej szerokości znaków.

Jeśli *nTabPositions* ma wartość 1, tabulatory są oddzielone o odległość określoną przez pierwszą wartość w tablicy *lpnTabStopPositions* . Jeśli tablica *lpnTabStopPositions* zawiera więcej niż jedną wartość, tabulator jest ustawiany dla każdej wartości w tablicy, do numeru określonego przez *nTabPositions*. Parametr *nTabOrigin* umożliwia aplikacji `TabbedTextOut` kilkakrotne wywołanie funkcji dla pojedynczego wiersza. Jeśli aplikacja wywołuje funkcję więcej niż raz z *nTabOrigin* ustawioną na tę samą wartość za każdym razem, funkcja rozszerza wszystkie karty względem położenia określonego przez *nTabOrigin*.

Domyślnie, funkcja nie używa ani nie aktualizuje bieżącej pozycji. Jeśli aplikacja musi zaktualizować bieżącą pozycję, gdy wywołuje funkcję, aplikacja może wywołać funkcję elementu członkowskiego [TextAlign](#settextalign) z *nFlags* ustawioną na TA_UPDATECP. Gdy ta flaga jest ustawiona, system Windows ignoruje parametry *x* i *y* podczas kolejnych wywołań do `TabbedTextOut` , przy użyciu bieżącej pozycji.

## <a name="cdctextout"></a><a name="textout"></a>Przechwytywanie zmian:: TextOut

Zapisuje ciąg znaków w określonej lokalizacji przy użyciu aktualnie wybranej czcionki.

```
virtual BOOL TextOut(
    int x,
    int y,
    LPCTSTR lpszString,
    int nCount);

BOOL TextOut(
    int x,
    int y,
    const CString& str);
```

### <a name="parameters"></a>Parametry

*x*<br/>
Określa logiczną współrzędną x punktu początkowego tekstu.

*t*<br/>
Określa logiczną współrzędną y punktu początkowego tekstu.

*lpszString*<br/>
Wskazuje ciąg znaków do rysowania.

*nCount*<br/>
Określa liczbę znaków w ciągu.

*str*<br/>
`CString`Obiekt, który zawiera znaki do narysowania.

### <a name="return-value"></a>Wartość zwracana

Różne od zera, jeśli funkcja zakończyła się pomyślnie; w przeciwnym razie 0.

### <a name="remarks"></a>Uwagi

Początki znaków są w lewym górnym rogu komórki znaków. Domyślnie, funkcja nie używa ani nie aktualizuje bieżącej pozycji.

Jeśli aplikacja musi zaktualizować bieżącą pozycję podczas wywoływania `TextOut` , aplikacja może wywołać `SetTextAlign` funkcję członkowską z *nFlags* ustawioną na TA_UPDATECP. Gdy ta flaga jest ustawiona, system Windows ignoruje parametry *x* i *y* podczas kolejnych wywołań do `TextOut` , przy użyciu bieżącej pozycji.

### <a name="example"></a>Przykład

  Zobacz przykład dla danych [przechwytywania:: BeginPath](#beginpath).

## <a name="cdctransparentblt"></a><a name="transparentblt"></a>Przechwytywanie zmian:: TransparentBlt

Wywołaj tę funkcję elementu członkowskiego, aby przesłać blok bitowy danych koloru, który odnosi się do prostokąta pikseli z określonego kontekstu urządzenia źródłowego do kontekstu urządzenia docelowego.

```
BOOL TransparentBlt(
    int xDest,
    int yDest,
    int nDestWidth,
    int nDestHeight,
    CDC* pSrcDC,
    int xSrc,
    int ySrc,
    int nSrcWidth,
    int nSrcHeight,
    UINT clrTransparent);
```

### <a name="parameters"></a>Parametry

*xDest*<br/>
Określa współrzędną x (w jednostkach logicznych) lewego górnego rogu prostokąta docelowego.

*yDest*<br/>
Określa współrzędną y (w jednostkach logicznych) lewego górnego rogu prostokąta docelowego.

*nDestWidth*<br/>
Określa szerokość (w jednostkach logicznych) prostokąta docelowego.

*nDestHeight*<br/>
Określa wysokość (w jednostkach logicznych) prostokąta docelowego.

*pSrcDC*<br/>
Wskaźnik do kontekstu urządzenia źródłowego.

*xSrc*<br/>
Określa współrzędną x (w jednostkach logicznych) prostokąta źródłowego.

*ySrc*<br/>
Określa współrzędną y (w jednostkach logicznych) prostokąta źródłowego.

*nSrcWidth*<br/>
Określa szerokość (w jednostkach logicznych) prostokąta źródłowego.

*nSrcHeight*<br/>
Określa wysokość (w jednostkach logicznych) prostokąta źródłowego.

*clrTransparent*<br/>
Kolor RGB w źródłowej mapie bitowej ma być traktowany jako przezroczysty.

### <a name="return-value"></a>Wartość zwracana

Wartość TRUE, jeśli powodzenie; w przeciwnym razie FALSE.

### <a name="remarks"></a>Uwagi

`TransparentBlt`umożliwia przezroczystość; oznacza to, że kolor RGB wskazywany przez *clrTransparent* jest renderowany jako przezroczysty dla transferu.

Aby uzyskać więcej informacji, zobacz [TransparentBlt](/windows/win32/api/wingdi/nf-wingdi-transparentblt) w Windows SDK.

## <a name="cdcupdatecolors"></a><a name="updatecolors"></a>Przechwytywanie zmian:: UpdateColors

Aktualizuje obszar klienta kontekstu urządzenia, dopasowując bieżące kolory w obszarze klienta do palety systemowej w oparciu o piksel w pikselach.

```cpp
void UpdateColors();
```

### <a name="remarks"></a>Uwagi

Nieaktywne okno z rzeczywistą paletą logiczną może wywołać `UpdateColors` jako alternatywę w celu przerysowania jej obszaru klienckiego w przypadku zmiany palety systemowej.

Aby uzyskać więcej informacji o korzystaniu z palet kolorów, zobacz [UpdateColors](/windows/win32/api/wingdi/nf-wingdi-updatecolors) w Windows SDK.

`UpdateColors`Funkcja członkowska zwykle aktualizuje obszar klienta szybciej niż w przypadku przerysowania obszaru. Ponieważ jednak funkcja wykonuje translację koloru na podstawie koloru każdego piksela przed zmianą palety systemowej, każde wywołanie tej funkcji spowoduje utratę pewnej dokładności koloru.

## <a name="cdcwidenpath"></a><a name="widenpath"></a>Przechwytywanie zmian:: WidenPath

Ponownie definiuje bieżącą ścieżkę jako obszar, który będzie rysowany w przypadku pociągnięcia ścieżki przy użyciu pióra aktualnie zaznaczonego w kontekście urządzenia.

```
BOOL WidenPath();
```

### <a name="return-value"></a>Wartość zwracana

Różne od zera, jeśli funkcja zakończyła się pomyślnie; w przeciwnym razie 0.

### <a name="remarks"></a>Uwagi

Ta funkcja jest pomyślna tylko wtedy, gdy bieżące pióro jest piórem geometrycznym utworzonym przez drugą wersję `CreatePen` funkcji składowej lub Jeśli pióro jest tworzone przy użyciu pierwszej wersji `CreatePen` i ma szerokość, w jednostkach urządzeń o wartości większej niż 1. Kontekst urządzenia musi zawierać ścieżkę zamkniętą. Wszystkie krzywe Bzier w ścieżce są konwertowane na sekwencje linii prostych przybliżania poszerzonych krzywych. W związku z tym żadna krzywa Bzier nie pozostanie w ścieżce po `WidenPath` wywołaniu.

## <a name="see-also"></a>Zobacz także

[Klasa CObject](../../mfc/reference/cobject-class.md)<br/>
[Wykres hierarchii](../../mfc/hierarchy-chart.md)<br/>
[Klasa CPaintDC](../../mfc/reference/cpaintdc-class.md)<br/>
[Klasa CWindowDC](../../mfc/reference/cwindowdc-class.md)<br/>
[Klasa CClientDC —](../../mfc/reference/cclientdc-class.md)<br/>
[Klasa CMetaFileDC](../../mfc/reference/cmetafiledc-class.md)

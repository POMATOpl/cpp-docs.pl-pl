---
title: Klasa CDC
ms.date: 11/19/2018
f1_keywords:
- CDC
- AFXWIN/CDC
- AFXWIN/CDC::CDC
- AFXWIN/CDC::AbortDoc
- AFXWIN/CDC::AbortPath
- AFXWIN/CDC::AddMetaFileComment
- AFXWIN/CDC::AlphaBlend
- AFXWIN/CDC::AngleArc
- AFXWIN/CDC::Arc
- AFXWIN/CDC::ArcTo
- AFXWIN/CDC::Attach
- AFXWIN/CDC::BeginPath
- AFXWIN/CDC::BitBlt
- AFXWIN/CDC::Chord
- AFXWIN/CDC::CloseFigure
- AFXWIN/CDC::CreateCompatibleDC
- AFXWIN/CDC::CreateDC
- AFXWIN/CDC::CreateIC
- AFXWIN/CDC::DeleteDC
- AFXWIN/CDC::DeleteTempMap
- AFXWIN/CDC::Detach
- AFXWIN/CDC::DPtoHIMETRIC
- AFXWIN/CDC::DPtoLP
- AFXWIN/CDC::Draw3dRect
- AFXWIN/CDC::DrawDragRect
- AFXWIN/CDC::DrawEdge
- AFXWIN/CDC::DrawEscape
- AFXWIN/CDC::DrawFocusRect
- AFXWIN/CDC::DrawFrameControl
- AFXWIN/CDC::DrawIcon
- AFXWIN/CDC::DrawState
- AFXWIN/CDC::DrawText
- AFXWIN/CDC::DrawTextEx
- AFXWIN/CDC::Ellipse
- AFXWIN/CDC::EndDoc
- AFXWIN/CDC::EndPage
- AFXWIN/CDC::EndPath
- AFXWIN/CDC::EnumObjects
- AFXWIN/CDC::Escape
- AFXWIN/CDC::ExcludeClipRect
- AFXWIN/CDC::ExcludeUpdateRgn
- AFXWIN/CDC::ExtFloodFill
- AFXWIN/CDC::ExtTextOut
- AFXWIN/CDC::FillPath
- AFXWIN/CDC::FillRect
- AFXWIN/CDC::FillRgn
- AFXWIN/CDC::FillSolidRect
- AFXWIN/CDC::FlattenPath
- AFXWIN/CDC::FloodFill
- AFXWIN/CDC::FrameRect
- AFXWIN/CDC::FrameRgn
- AFXWIN/CDC::FromHandle
- AFXWIN/CDC::GetArcDirection
- AFXWIN/CDC::GetAspectRatioFilter
- AFXWIN/CDC::GetBkColor
- AFXWIN/CDC::GetBkMode
- AFXWIN/CDC::GetBoundsRect
- AFXWIN/CDC::GetBrushOrg
- AFXWIN/CDC::GetCharABCWidths
- AFXWIN/CDC::GetCharABCWidthsI
- AFXWIN/CDC::GetCharacterPlacement
- AFXWIN/CDC::GetCharWidth
- AFXWIN/CDC::GetCharWidthI
- AFXWIN/CDC::GetClipBox
- AFXWIN/CDC::GetColorAdjustment
- AFXWIN/CDC::GetCurrentBitmap
- AFXWIN/CDC::GetCurrentBrush
- AFXWIN/CDC::GetCurrentFont
- AFXWIN/CDC::GetCurrentPalette
- AFXWIN/CDC::GetCurrentPen
- AFXWIN/CDC::GetCurrentPosition
- AFXWIN/CDC::GetDCBrushColor
- AFXWIN/CDC::GetDCPenColor
- AFXWIN/CDC::GetDeviceCaps
- AFXWIN/CDC::GetFontData
- AFXWIN/CDC::GetFontLanguageInfo
- AFXWIN/CDC::GetGlyphOutline
- AFXWIN/CDC::GetGraphicsMode
- AFXWIN/CDC::GetHalftoneBrush
- AFXWIN/CDC::GetKerningPairs
- AFXWIN/CDC::GetLayout
- AFXWIN/CDC::GetMapMode
- AFXWIN/CDC::GetMiterLimit
- AFXWIN/CDC::GetNearestColor
- AFXWIN/CDC::GetOutlineTextMetrics
- AFXWIN/CDC::GetOutputCharWidth
- AFXWIN/CDC::GetOutputTabbedTextExtent
- AFXWIN/CDC::GetOutputTextExtent
- AFXWIN/CDC::GetOutputTextMetrics
- AFXWIN/CDC::GetPath
- AFXWIN/CDC::GetPixel
- AFXWIN/CDC::GetPolyFillMode
- AFXWIN/CDC::GetROP2
- AFXWIN/CDC::GetSafeHdc
- AFXWIN/CDC::GetStretchBltMode
- AFXWIN/CDC::GetTabbedTextExtent
- AFXWIN/CDC::GetTextAlign
- AFXWIN/CDC::GetTextCharacterExtra
- AFXWIN/CDC::GetTextColor
- AFXWIN/CDC::GetTextExtent
- AFXWIN/CDC::GetTextExtentExPointI
- AFXWIN/CDC::GetTextExtentPointI
- AFXWIN/CDC::GetTextFace
- AFXWIN/CDC::GetTextMetrics
- AFXWIN/CDC::GetViewportExt
- AFXWIN/CDC::GetViewportOrg
- AFXWIN/CDC::GetWindow
- AFXWIN/CDC::GetWindowExt
- AFXWIN/CDC::GetWindowOrg
- AFXWIN/CDC::GetWorldTransform
- AFXWIN/CDC::GradientFill
- AFXWIN/CDC::GrayString
- AFXWIN/CDC::HIMETRICtoDP
- AFXWIN/CDC::HIMETRICtoLP
- AFXWIN/CDC::IntersectClipRect
- AFXWIN/CDC::InvertRect
- AFXWIN/CDC::InvertRgn
- AFXWIN/CDC::IsPrinting
- AFXWIN/CDC::LineTo
- AFXWIN/CDC::LPtoDP
- AFXWIN/CDC::LPtoHIMETRIC
- AFXWIN/CDC::MaskBlt
- AFXWIN/CDC::ModifyWorldTransform
- AFXWIN/CDC::MoveTo
- AFXWIN/CDC::OffsetClipRgn
- AFXWIN/CDC::OffsetViewportOrg
- AFXWIN/CDC::OffsetWindowOrg
- AFXWIN/CDC::PaintRgn
- AFXWIN/CDC::PatBlt
- AFXWIN/CDC::Pie
- AFXWIN/CDC::PlayMetaFile
- AFXWIN/CDC::PlgBlt
- AFXWIN/CDC::PolyBezier
- AFXWIN/CDC::PolyBezierTo
- AFXWIN/CDC::PolyDraw
- AFXWIN/CDC::Polygon
- AFXWIN/CDC::Polyline
- AFXWIN/CDC::PolylineTo
- AFXWIN/CDC::PolyPolygon
- AFXWIN/CDC::PolyPolyline
- AFXWIN/CDC::PtVisible
- AFXWIN/CDC::RealizePalette
- AFXWIN/CDC::Rectangle
- AFXWIN/CDC::RectVisible
- AFXWIN/CDC::ReleaseAttribDC
- AFXWIN/CDC::ReleaseOutputDC
- AFXWIN/CDC::ResetDC
- AFXWIN/CDC::RestoreDC
- AFXWIN/CDC::RoundRect
- AFXWIN/CDC::SaveDC
- AFXWIN/CDC::ScaleViewportExt
- AFXWIN/CDC::ScaleWindowExt
- AFXWIN/CDC::ScrollDC
- AFXWIN/CDC::SelectClipPath
- AFXWIN/CDC::SelectClipRgn
- AFXWIN/CDC::SelectObject
- AFXWIN/CDC::SelectPalette
- AFXWIN/CDC::SelectStockObject
- AFXWIN/CDC::SetAbortProc
- AFXWIN/CDC::SetArcDirection
- AFXWIN/CDC::SetAttribDC
- AFXWIN/CDC::SetBkColor
- AFXWIN/CDC::SetBkMode
- AFXWIN/CDC::SetBoundsRect
- AFXWIN/CDC::SetBrushOrg
- AFXWIN/CDC::SetColorAdjustment
- AFXWIN/CDC::SetDCBrushColor
- AFXWIN/CDC::SetDCPenColor
- AFXWIN/CDC::SetGraphicsMode
- AFXWIN/CDC::SetLayout
- AFXWIN/CDC::SetMapMode
- AFXWIN/CDC::SetMapperFlags
- AFXWIN/CDC::SetMiterLimit
- AFXWIN/CDC::SetOutputDC
- AFXWIN/CDC::SetPixel
- AFXWIN/CDC::SetPixelV
- AFXWIN/CDC::SetPolyFillMode
- AFXWIN/CDC::SetROP2
- AFXWIN/CDC::SetStretchBltMode
- AFXWIN/CDC::SetTextAlign
- AFXWIN/CDC::SetTextCharacterExtra
- AFXWIN/CDC::SetTextColor
- AFXWIN/CDC::SetTextJustification
- AFXWIN/CDC::SetViewportExt
- AFXWIN/CDC::SetViewportOrg
- AFXWIN/CDC::SetWindowExt
- AFXWIN/CDC::SetWindowOrg
- AFXWIN/CDC::SetWorldTransform
- AFXWIN/CDC::StartDoc
- AFXWIN/CDC::StartPage
- AFXWIN/CDC::StretchBlt
- AFXWIN/CDC::StrokeAndFillPath
- AFXWIN/CDC::StrokePath
- AFXWIN/CDC::TabbedTextOut
- AFXWIN/CDC::TextOut
- AFXWIN/CDC::TransparentBlt
- AFXWIN/CDC::UpdateColors
- AFXWIN/CDC::WidenPath
- AFXWIN/CDC::m_hAttribDC
- AFXWIN/CDC::m_hDC
helpviewer_keywords:
- CDC [MFC], CDC
- CDC [MFC], AbortDoc
- CDC [MFC], AbortPath
- CDC [MFC], AddMetaFileComment
- CDC [MFC], AlphaBlend
- CDC [MFC], AngleArc
- CDC [MFC], Arc
- CDC [MFC], ArcTo
- CDC [MFC], Attach
- CDC [MFC], BeginPath
- CDC [MFC], BitBlt
- CDC [MFC], Chord
- CDC [MFC], CloseFigure
- CDC [MFC], CreateCompatibleDC
- CDC [MFC], CreateDC
- CDC [MFC], CreateIC
- CDC [MFC], DeleteDC
- CDC [MFC], DeleteTempMap
- CDC [MFC], Detach
- CDC [MFC], DPtoHIMETRIC
- CDC [MFC], DPtoLP
- CDC [MFC], Draw3dRect
- CDC [MFC], DrawDragRect
- CDC [MFC], DrawEdge
- CDC [MFC], DrawEscape
- CDC [MFC], DrawFocusRect
- CDC [MFC], DrawFrameControl
- CDC [MFC], DrawIcon
- CDC [MFC], DrawState
- CDC [MFC], DrawText
- CDC [MFC], DrawTextEx
- CDC [MFC], Ellipse
- CDC [MFC], EndDoc
- CDC [MFC], EndPage
- CDC [MFC], EndPath
- CDC [MFC], EnumObjects
- CDC [MFC], Escape
- CDC [MFC], ExcludeClipRect
- CDC [MFC], ExcludeUpdateRgn
- CDC [MFC], ExtFloodFill
- CDC [MFC], ExtTextOut
- CDC [MFC], FillPath
- CDC [MFC], FillRect
- CDC [MFC], FillRgn
- CDC [MFC], FillSolidRect
- CDC [MFC], FlattenPath
- CDC [MFC], FloodFill
- CDC [MFC], FrameRect
- CDC [MFC], FrameRgn
- CDC [MFC], FromHandle
- CDC [MFC], GetArcDirection
- CDC [MFC], GetAspectRatioFilter
- CDC [MFC], GetBkColor
- CDC [MFC], GetBkMode
- CDC [MFC], GetBoundsRect
- CDC [MFC], GetBrushOrg
- CDC [MFC], GetCharABCWidths
- CDC [MFC], GetCharABCWidthsI
- CDC [MFC], GetCharacterPlacement
- CDC [MFC], GetCharWidth
- CDC [MFC], GetCharWidthI
- CDC [MFC], GetClipBox
- CDC [MFC], GetColorAdjustment
- CDC [MFC], GetCurrentBitmap
- CDC [MFC], GetCurrentBrush
- CDC [MFC], GetCurrentFont
- CDC [MFC], GetCurrentPalette
- CDC [MFC], GetCurrentPen
- CDC [MFC], GetCurrentPosition
- CDC [MFC], GetDCBrushColor
- CDC [MFC], GetDCPenColor
- CDC [MFC], GetDeviceCaps
- CDC [MFC], GetFontData
- CDC [MFC], GetFontLanguageInfo
- CDC [MFC], GetGlyphOutline
- CDC [MFC], GetGraphicsMode
- CDC [MFC], GetHalftoneBrush
- CDC [MFC], GetKerningPairs
- CDC [MFC], GetLayout
- CDC [MFC], GetMapMode
- CDC [MFC], GetMiterLimit
- CDC [MFC], GetNearestColor
- CDC [MFC], GetOutlineTextMetrics
- CDC [MFC], GetOutputCharWidth
- CDC [MFC], GetOutputTabbedTextExtent
- CDC [MFC], GetOutputTextExtent
- CDC [MFC], GetOutputTextMetrics
- CDC [MFC], GetPath
- CDC [MFC], GetPixel
- CDC [MFC], GetPolyFillMode
- CDC [MFC], GetROP2
- CDC [MFC], GetSafeHdc
- CDC [MFC], GetStretchBltMode
- CDC [MFC], GetTabbedTextExtent
- CDC [MFC], GetTextAlign
- CDC [MFC], GetTextCharacterExtra
- CDC [MFC], GetTextColor
- CDC [MFC], GetTextExtent
- CDC [MFC], GetTextExtentExPointI
- CDC [MFC], GetTextExtentPointI
- CDC [MFC], GetTextFace
- CDC [MFC], GetTextMetrics
- CDC [MFC], GetViewportExt
- CDC [MFC], GetViewportOrg
- CDC [MFC], GetWindow
- CDC [MFC], GetWindowExt
- CDC [MFC], GetWindowOrg
- CDC [MFC], GetWorldTransform
- CDC [MFC], GradientFill
- CDC [MFC], GrayString
- CDC [MFC], HIMETRICtoDP
- CDC [MFC], HIMETRICtoLP
- CDC [MFC], IntersectClipRect
- CDC [MFC], InvertRect
- CDC [MFC], InvertRgn
- CDC [MFC], IsPrinting
- CDC [MFC], LineTo
- CDC [MFC], LPtoDP
- CDC [MFC], LPtoHIMETRIC
- CDC [MFC], MaskBlt
- CDC [MFC], ModifyWorldTransform
- CDC [MFC], MoveTo
- CDC [MFC], OffsetClipRgn
- CDC [MFC], OffsetViewportOrg
- CDC [MFC], OffsetWindowOrg
- CDC [MFC], PaintRgn
- CDC [MFC], PatBlt
- CDC [MFC], Pie
- CDC [MFC], PlayMetaFile
- CDC [MFC], PlgBlt
- CDC [MFC], PolyBezier
- CDC [MFC], PolyBezierTo
- CDC [MFC], PolyDraw
- CDC [MFC], Polygon
- CDC [MFC], Polyline
- CDC [MFC], PolylineTo
- CDC [MFC], PolyPolygon
- CDC [MFC], PolyPolyline
- CDC [MFC], PtVisible
- CDC [MFC], RealizePalette
- CDC [MFC], Rectangle
- CDC [MFC], RectVisible
- CDC [MFC], ReleaseAttribDC
- CDC [MFC], ReleaseOutputDC
- CDC [MFC], ResetDC
- CDC [MFC], RestoreDC
- CDC [MFC], RoundRect
- CDC [MFC], SaveDC
- CDC [MFC], ScaleViewportExt
- CDC [MFC], ScaleWindowExt
- CDC [MFC], ScrollDC
- CDC [MFC], SelectClipPath
- CDC [MFC], SelectClipRgn
- CDC [MFC], SelectObject
- CDC [MFC], SelectPalette
- CDC [MFC], SelectStockObject
- CDC [MFC], SetAbortProc
- CDC [MFC], SetArcDirection
- CDC [MFC], SetAttribDC
- CDC [MFC], SetBkColor
- CDC [MFC], SetBkMode
- CDC [MFC], SetBoundsRect
- CDC [MFC], SetBrushOrg
- CDC [MFC], SetColorAdjustment
- CDC [MFC], SetDCBrushColor
- CDC [MFC], SetDCPenColor
- CDC [MFC], SetGraphicsMode
- CDC [MFC], SetLayout
- CDC [MFC], SetMapMode
- CDC [MFC], SetMapperFlags
- CDC [MFC], SetMiterLimit
- CDC [MFC], SetOutputDC
- CDC [MFC], SetPixel
- CDC [MFC], SetPixelV
- CDC [MFC], SetPolyFillMode
- CDC [MFC], SetROP2
- CDC [MFC], SetStretchBltMode
- CDC [MFC], SetTextAlign
- CDC [MFC], SetTextCharacterExtra
- CDC [MFC], SetTextColor
- CDC [MFC], SetTextJustification
- CDC [MFC], SetViewportExt
- CDC [MFC], SetViewportOrg
- CDC [MFC], SetWindowExt
- CDC [MFC], SetWindowOrg
- CDC [MFC], SetWorldTransform
- CDC [MFC], StartDoc
- CDC [MFC], StartPage
- CDC [MFC], StretchBlt
- CDC [MFC], StrokeAndFillPath
- CDC [MFC], StrokePath
- CDC [MFC], TabbedTextOut
- CDC [MFC], TextOut
- CDC [MFC], TransparentBlt
- CDC [MFC], UpdateColors
- CDC [MFC], WidenPath
- CDC [MFC], m_hAttribDC
- CDC [MFC], m_hDC
ms.assetid: 715b3334-cb2b-4c9c-8067-02eb7c66c8b2
ms.openlocfilehash: 2ff6cd6e0817f74c7688fc573d4b98f70704f96c
ms.sourcegitcommit: da32511dd5baebe27451c0458a95f345144bd439
ms.translationtype: MT
ms.contentlocale: pl-PL
ms.lasthandoff: 05/07/2019
ms.locfileid: "65222576"
---
# <a name="cdc-class"></a>Klasa CDC

Definiuje klasę obiektów kontekstu urządzenia.

## <a name="syntax"></a>Składnia

```
class CDC : public CObject
```

## <a name="members"></a>Elementy członkowskie

### <a name="public-constructors"></a>Konstruktory publiczne

|Nazwa|Opis|
|----------|-----------------|
|[CDC::CDC](#cdc)|Konstruuje `CDC` obiektu.|

### <a name="public-methods"></a>Metody publiczne

|Nazwa|Opis|
|----------|-----------------|
|[CDC::AbortDoc](#abortdoc)|Kończy działanie bieżącego zadania drukowania, wszystkie elementy aplikacji zapisane na urządzeniu od czasu ostatniego wywołania wymazywania `StartDoc` funkcja elementu członkowskiego.|
|[CDC::AbortPath](#abortpath)|Zamyka i odrzuca wszystkie ścieżki w kontekście urządzenia.|
|[CDC::AddMetaFileComment](#addmetafilecomment)|Kopiuje komentarz z buforu w określonym metaplik rozszerzony format.|
|[CDC::AlphaBlend](#alphablend)|Wyświetla mapy bitowe, które mają przezroczyste lub półprzezroczystych pikseli.|
|[CDC::AngleArc](#anglearc)|Rysuje segment linii i łuk i przenosi bieżącej pozycji do punktu końcowego łuku.|
|[CDC::ARC](#arc)|Rysuje łuk eliptyczny.|
|[CDC::ArcTo](#arcto)|Rysuje łuk eliptyczny. Ta funkcja jest podobny do `Arc`, z tą różnicą, że bieżące położenie jest aktualizowana.|
|[CDC::Attach](#attach)|Dołącza kontekstu urządzenia Windows to `CDC` obiektu.|
|[CDC::BeginPath](#beginpath)|Zostanie otwarty nawias ścieżki w kontekście urządzenia.|
|[CDC::BitBlt](#bitblt)|Kopiuje mapę bitową z kontekstu określonego urządzenia.|
|[CDC::Chord](#chord)|Rysuje skrót (figurę zamkniętą ograniczany przez przecięcie elipsę i segment linii).|
|[CDC::CloseFigure](#closefigure)|Zamyka figurę otwartą. w ścieżce.|
|[CDC::CreateCompatibleDC](#createcompatibledc)|Tworzy kontekst urządzenia pamięci, która jest zgodna z innego kontekstu urządzenia. Służy do przygotowania obrazów w pamięci.|
|[CDC::CreateDC](#createdc)|Tworzy kontekst urządzenia dla określonego urządzenia.|
|[CDC::CreateIC](#createic)|Tworzy kontekst informacje dla określonego urządzenia. Zapewnia to szybki sposób, aby uzyskać informacje o urządzeniu bez tworzenia kontekstu urządzenia.|
|[CDC::DeleteDC](#deletedc)|Usuwa kontekst urządzenia Windows, które są skojarzone z tym `CDC` obiektu.|
|[CDC::DeleteTempMap](#deletetempmap)|Wywoływane przez `CWinApp` obsługi czasu bezczynności można usunąć wszystkie tymczasowe `CDC` obiekt utworzony przez `FromHandle`. Odłącza także kontekst urządzenia.|
|[CDC::Detach](#detach)|Odłącza kontekstu urządzenia Windows z tego `CDC` obiektu.|
|[CDC::DPtoHIMETRIC](#dptohimetric)|Konwertuje jednostki urządzenia na jednostkach HIMETRIC.|
|[CDC::DPtoLP](#dptolp)|Konwertuje jednostek logicznych jednostek urządzenia.|
|[CDC::Draw3dRect](#draw3drect)|Rysuje prostokąt trójwymiarowej.|
|[CDC::DrawDragRect](#drawdragrect)|Usuwa z nich i ponownie rysuje prostokąt, jak zostanie przesunięte.|
|[CDC::DrawEdge](#drawedge)|Rysuje krawędzi prostokąta.|
|[CDC::DrawEscape](#drawescape)|Uzyskuje dostęp do rysowania możliwości wyświetlania wideo, które nie są bezpośrednio dostępne za pośrednictwem graficzny interfejs urządzenia (GDI).|
|[CDC::DrawFocusRect](#drawfocusrect)|Rysuje prostokąt w stylu używany do wskazania fokus.|
|[CDC::DrawFrameControl](#drawframecontrol)|Rysowanie formantu ramki.|
|[CDC::DrawIcon](#drawicon)|Rysuje ikony.|
|[CDC::DrawState](#drawstate)|Wyświetla obraz, a następnie stosuje efekt wizualny do wskazywania stanu.|
|[CDC::DrawText](#drawtext)|Rysuje sformatowanego tekstu w prostokącie określonego.|
|[CDC::DrawTextEx](#drawtextex)|Rysuje sformatowanego tekstu w prostokącie określonego w dodatkowych formatach.|
|[CDC::Ellipse](#ellipse)|Rysuje elipsę.|
|[CDC::EndDoc](#enddoc)|Kończy pracę, zadanie drukowania `StartDoc` funkcja elementu członkowskiego.|
|[CDC::EndPage](#endpage)|Informuje o sterownik urządzenia, który kończy się strony.|
|[CDC::EndPath](#endpath)|Zamyka nawiasu ścieżki i wybiera ścieżkę zdefiniowaną przez nawias do kontekstu urządzenia.|
|[CDC::EnumObjects](#enumobjects)|Wylicza pióra i pędzle dostępne w kontekście urządzenia.|
|[CDC::Escape](#escape)|Zezwala aplikacjom na dostęp do urządzeń, które nie są bezpośrednio dostępne z określonego urządzenia za pomocą GDI. Umożliwia również dostęp do funkcji ucieczki Windows. Specjalna wywołania przez aplikację są przetłumaczone i wysyłane do sterownika urządzenia.|
|[CDC::ExcludeClipRect](#excludecliprect)|Tworzy nowy region wycinek, który składa się z istniejącym regionem wycinka pomniejszoną o określony prostokąt.|
|[CDC::ExcludeUpdateRgn](#excludeupdatergn)|Zapobiega rysowania w obszarach nieprawidłowy okna przez wykluczenie zaktualizowano region, w oknie z obszaru przycinania.|
|[CDC::ExtFloodFill](#extfloodfill)|Wypełnia obszar pędzlem bieżącego. Zapewnia większą elastyczność niż [CDC::FloodFill](#floodfill) funkcja elementu członkowskiego.|
|[CDC::ExtTextOut](#exttextout)|Zapisuje ciąg znaków w ramach prostokątny obszar za pomocą aktualnie wybranej czcionki.|
|[CDC::FillPath](#fillpath)|Zamyka żadnych otwartych figur w bieżącej ścieżce i wypełnia wewnątrz ścieżki przy użyciu aktualny Pędzel i tryb wypełnianie wielokąta.|
|[CDC::FillRect](#fillrect)|Wypełnia danego prostokąt przy użyciu określonych pędzla.|
|[CDC::FillRgn](#fillrgn)|Wypełnia określonym regionie przy użyciu określonego pędzla.|
|[CDC::FillSolidRect](#fillsolidrect)|Wypełnia prostokąt jednolitym kolorem.|
|[CDC::FlattenPath](#flattenpath)|Przekształca wszelkie krzywych w ścieżce zaznaczone w bieżącym kontekście urządzenia i każdej krzywej jest przekształcany sekwencja wierszy.|
|[CDC::FloodFill](#floodfill)|Wypełnia obszar pędzlem bieżącego.|
|[CDC::FrameRect](#framerect)|Rysuje obramowanie wokół prostokąta.|
|[CDC::FrameRgn](#framergn)|Rysuje obramowanie wokół określonego regionu używanie pędzla.|
|[CDC::FromHandle](#fromhandle)|Zwraca wskaźnik do `CDC` obiektu, kiedy podane dojście do kontekstu urządzenia. Jeśli `CDC` obiektu nie jest dołączony do uchwyt tymczasowego `CDC` obiekt zostanie utworzony i dołączony.|
|[CDC::GetArcDirection](#getarcdirection)|Zwraca bieżący kierunek łuk kontekstu urządzenia.|
|[CDC::GetAspectRatioFilter](#getaspectratiofilter)|Pobiera ustawienie dla bieżącego filtru współczynnik proporcji.|
|[CDC::GetBkColor](#getbkcolor)|Pobiera bieżący kolor tła.|
|[CDC::GetBkMode](#getbkmode)|Pobiera tryb tła.|
|[CDC::GetBoundsRect](#getboundsrect)|Zwraca bieżący prostokąt otaczający zebranych dla kontekstu określonego urządzenia.|
|[CDC::GetBrushOrg](#getbrushorg)|Pobiera źródło aktualny pędzel.|
|[CDC::GetCharABCWidths](#getcharabcwidths)|Pobiera szerokości, w jednostkach logicznych, kolejnych znaków w danym zakresie z bieżącej czcionki.|
|[CDC::GetCharABCWidthsI](#getcharabcwidthsi)|Pobiera szerokości, w jednostkach logicznych, indeksów kolejnych symbol w określonym zakresie z bieżącej czcionki TrueType.|
|[CDC::GetCharacterPlacement](#getcharacterplacement)|Pobiera różne rodzaje informacji dla ciągu znaków.|
|[CDC::GetCharWidth](#getcharwidth)|Pobiera szerokości ułamkowe kolejnych znaków w danym zakresie z bieżącej czcionki.|
|[CDC::GetCharWidthI](#getcharwidthi)|Pobiera szerokości w logiczne współrzędne wskaźniki kolejnych symbol w określonym zakresie z bieżącej czcionki.|
|[CDC::GetClipBox](#getclipbox)|Pobiera wymiary tightest otaczający prostokąt wokół granicy bieżącego wycinka.|
|[CDC::GetColorAdjustment](#getcoloradjustment)|Pobiera wartości dostosowanie kolorów dla kontekstu urządzenia.|
|[CDC::GetCurrentBitmap](#getcurrentbitmap)|Zwraca wskaźnik do aktualnie wybranego `CBitmap` obiektu.|
|[CDC::GetCurrentBrush](#getcurrentbrush)|Zwraca wskaźnik do aktualnie wybranego `CBrush` obiektu.|
|[CDC::GetCurrentFont](#getcurrentfont)|Zwraca wskaźnik do aktualnie wybranego `CFont` obiektu.|
|[CDC::GetCurrentPalette](#getcurrentpalette)|Zwraca wskaźnik do aktualnie wybranego `CPalette` obiektu.|
|[CDC::GetCurrentPen](#getcurrentpen)|Zwraca wskaźnik do aktualnie wybranego `CPen` obiektu.|
|[CDC::GetCurrentPosition](#getcurrentposition)|Pobiera bieżącą pozycję pióra (we współrzędnych logicznych).|
|[CDC::GetDCBrushColor](#getdcbrushcolor)|Pobiera bieżący kolor pędzla.|
|[CDC::GetDCPenColor](#getdcpencolor)|Pobiera bieżący kolor pióra.|
|[CDC::GetDeviceCaps](#getdevicecaps)|Pobiera określony rodzaj informacji specyficznych dla urządzenia na temat możliwości danego urządzenia.|
|[CDC::GetFontData](#getfontdata)|Pobiera informacje dotyczące pomiaru czcionki z plikiem czcionek skalowalnych. Informacje należy pobrać, jest identyfikowany przez określanie przesunięcia do pliku czcionki i długość danych do zwrócenia.|
|[CDC::GetFontLanguageInfo](#getfontlanguageinfo)|Zwraca informacje o aktualnie wybranej czcionki dla kontekstu określonego ekranu.|
|[CDC::GetGlyphOutline](#getglyphoutline)|Pobiera krzywej konspektu lub mapy bitowej dla znaku konturu w bieżącej czcionki.|
|[CDC::GetGraphicsMode](#getgraphicsmode)|Pobiera bieżący tryb graficznych dla kontekstu określonego urządzenia.|
|[CDC::GetHalftoneBrush](#gethalftonebrush)|Pobiera pędzel półtonów.|
|[CDC::GetKerningPairs](#getkerningpairs)|Pobiera znak kerning pary czcionka, która jest aktualnie wybrany w kontekście określonego urządzenia.|
|[CDC::GetLayout](#getlayout)|Pobiera układ kontekstu urządzenia (DC). Układ może być typu od lewej do prawej (ustawienie domyślne) lub od prawej do lewej (dublowaniu).|
|[CDC::GetMapMode](#getmapmode)|Pobiera bieżący tryb mapowania.|
|[CDC::GetMiterLimit](#getmiterlimit)|Zwraca limit skosu do kontekstu urządzenia.|
|[CDC::GetNearestColor](#getnearestcolor)|Pobiera najbliższy kolor logicznej określony kolor logiczne, reprezentujące dla danego urządzenia.|
|[CDC::GetOutlineTextMetrics](#getoutlinetextmetrics)|Pobiera informacje dotyczące pomiaru czcionki dla czcionki TrueType.|
|[CDC::GetOutputCharWidth](#getoutputcharwidth)|Pobiera szerokość poszczególnych znaków w grupie następujących po sobie znaków z bieżącą czcionkę przy użyciu kontekstu urządzenia dane wyjściowe.|
|[CDC::GetOutputTabbedTextExtent](#getoutputtabbedtextextent)|Oblicza szerokością i wysokością ciągu znaków na dane wyjściowe kontekstu urządzenia.|
|[CDC::GetOutputTextExtent](#getoutputtextextent)|Oblicza, szerokość i wysokość wiersza tekstu w kontekście urządzenia wyjściowego przy użyciu bieżącej czcionki, aby określić wymiary.|
|[CDC::GetOutputTextMetrics](#getoutputtextmetrics)|Pobiera metryki dla bieżącej czcionki z danych wyjściowych kontekstu urządzenia.|
|[CDC::GetPath](#getpath)|Pobiera współrzędne Definiowanie punktów końcowych wierszy i punkty kontrolne krzywych odnaleziona w ścieżce, który wybrano w kontekście urządzenia.|
|[CDC::GetPixel](#getpixel)|Pobiera wartość koloru RGB piksel w określonym momencie.|
|[CDC::GetPolyFillMode](#getpolyfillmode)|Pobiera bieżący tryb wypełnianie wielokąta.|
|[CDC::GetROP2](#getrop2)|Pobiera bieżący tryb rysowania.|
|[CDC::GetSafeHdc](#getsafehdc)|Zwraca [CDC::m_hDC](#m_hdc), dane wyjściowe kontekstu urządzenia.|
|[CDC::GetStretchBltMode](#getstretchbltmode)|Pobiera bieżący tryb rozciąganie mapy bitowej.|
|[CDC::GetTabbedTextExtent](#gettabbedtextextent)|Oblicza szerokością i wysokością ciągu znaków na atrybut kontekstu urządzenia.|
|[CDC::GetTextAlign](#gettextalign)|Pobranie flagi wyrównania tekstu.|
|[CDC::GetTextCharacterExtra](#gettextcharacterextra)|Pobiera bieżące ustawienie wielkości intercharacter odstępów.|
|[CDC::GetTextColor](#gettextcolor)|Pobiera bieżący kolor tekstu.|
|[CDC::GetTextExtent](#gettextextent)|Oblicza, szerokość i wysokość wiersza tekstu w kontekście urządzenia atrybutu przy użyciu bieżącej czcionki, aby określić wymiary.|
|[CDC::GetTextExtentExPointI](#gettextextentexpointi)|Pobiera liczbę znaków w określonym ciągu, który zmieści się w określonej przestrzeni i wypełnia tablicę w zakresie tekst dla każdego z tych znaków.|
|[CDC::GetTextExtentPointI](#gettextextentpointi)|Pobiera szerokość i wysokość określonej tablicy indeksów symboli.|
|[CDC::GetTextFace](#gettextface)|Kopiuje nazwę krój czcionki bieżącego do buforu jako ciąg znaków zakończony znakiem null.|
|[CDC::GetTextMetrics](#gettextmetrics)|Pobiera metryki dla bieżącej czcionki z atrybutu kontekstu urządzenia.|
|[CDC::GetViewportExt](#getviewportext)|Pobiera zakresów x i y okienka ekranu.|
|[CDC::GetViewportOrg](#getviewportorg)|Pobiera współrzędnych x i y punktu początkowego okienka ekranu.|
|[CDC::GetWindow](#getwindow)|Zwraca okno skojarzonego z kontekstem urządzenia wyświetlaną.|
|[CDC::GetWindowExt](#getwindowext)|Pobiera zakresów x i y odpowiedniego okna.|
|[CDC::GetWindowOrg](#getwindoworg)|Pobiera współrzędnych x i y pochodzenia odpowiedniego okna.|
|[CDC::GetWorldTransform](#getworldtransform)|Pobiera bieżący przestrzeni świata transformację miejsce na stronie.|
|[CDC::GradientFill](#gradientfill)|Wypełnia struktury prostokąt, trójkąt gradating kolorem.|
|[CDC::GrayString](#graystring)|Rysuje wyszarzony (wygaszone) tekst w podanej lokalizacji.|
|[CDC::HIMETRICtoDP](#himetrictodp)|Konwertuje jednostkach HIMETRIC jednostek urządzenia.|
|[CDC::HIMETRICtoLP](#himetrictolp)|Konwertuje jednostkach HIMETRIC jednostki logiczne.|
|[CDC::IntersectClipRect](#intersectcliprect)|Tworzy nowy obszar przycinania, stanowiące część wspólną bieżący region i prostokąt.|
|[CDC::InvertRect](#invertrect)|Odwraca zawartość prostokąta.|
|[CDC::InvertRgn](#invertrgn)|Odwraca kolory w regionie.|
|[CDC::IsPrinting](#isprinting)|Określa, czy kontekst urządzenia jest używana do drukowania.|
|[CDC::LineTo](#lineto)|Rysuje linię z bieżącej pozycji do, ale nie tym, punkt.|
|[CDC::LPtoDP](#lptodp)|Konwertuje jednostek logicznych jednostek urządzenia.|
|[CDC::LPtoHIMETRIC](#lptohimetric)|Konwertuje jednostek logicznych na jednostkach HIMETRIC.|
|[CDC::MaskBlt](#maskblt)|Łączy dane koloru dla map bitowych źródłowych i docelowych przy użyciu danego maski i operacja rastrowa.|
|[CDC::ModifyWorldTransform](#modifyworldtransform)|Zmienia transformacji świata dla kontekstu urządzenia za pomocą określonego trybu.|
|[CDC::MoveTo](#moveto)|Przenosi bieżącej pozycji.|
|[CDC::OffsetClipRgn](#offsetcliprgn)|Przenosi obszaru przycinania danego urządzenia.|
|[CDC::OffsetViewportOrg](#offsetviewportorg)|Modyfikuje pochodzenia okienka ekranu względem współrzędnych pochodzenia bieżącego okienka ekranu.|
|[CDC::OffsetWindowOrg](#offsetwindoworg)|Modyfikuje źródła okna względem współrzędnych pochodzenia bieżącego okna.|
|[CDC::PaintRgn](#paintrgn)|Wstawia region wybrany pędzel.|
|[CDC::PatBlt](#patblt)|Tworzy wzorca bitowego.|
|[CDC::Pie](#pie)|Rysuje klina ukształtowane koła.|
|[CDC::PlayMetaFile](#playmetafile)|Odtwarza zawartość określonego meta pliku na danym urządzeniu. Rozbudowaną wersją `PlayMetaFile` Wyświetla obraz przechowywany w danym metaplik rozszerzony format. Metaplik mogą być odtwarzane dowolną liczbę razy.|
|[CDC::PlgBlt](#plgblt)|Wykonuje transfer blok bitowy bity danych kolor prostokąta określonego w kontekście urządzenia źródłowego w określonym równoległobok w kontekście danego urządzenia.|
|[CDC::PolyBezier](#polybezier)|Rysuje krzywe Bzier jeden lub więcej. Bieżącej pozycji nie jest używany ani aktualizowane.|
|[CDC::PolyBezierTo](#polybezierto)|Rysuje krzywe Bzier co najmniej jeden, a następnie przenosi bieżącej pozycji do punktu końcowego z krzywymi składanymi Bzier ostatni.|
|[CDC::PolyDraw](#polydraw)|Rysuje zestaw segmenty linii i krzywe Bzier. Ta funkcja aktualizuje bieżącej pozycji.|
|[CDC::Polygon](#polygon)|Rysuje wielokąt składający się z dwóch lub więcej punktów (wierzchołków) połączone liniami.|
|[CDC::Polyline](#polyline)|Rysuje zbiór segmenty linii łączenia z określonym punkty.|
|[CDC::PolylineTo](#polylineto)|Pobiera jeden lub więcej wierszy proste i przenosi bieżącej pozycji do punktu końcowego ostatniego wiersza.|
|[CDC::PolyPolygon](#polypolygon)|Tworzy co najmniej dwóch wielokątów są wypełniane przy użyciu bieżącego trybu wypełnianie wielokąta. Wielokąty mogą być rozłączne lub mogą się nakładać.|
|[CDC::PolyPolyline](#polypolyline)|Rysuje wielu serii segmenty linii połączonej. Bieżącej pozycji nie jest używany ani aktualizowane przez tę funkcję.|
|[CDC::PtVisible](#ptvisible)|Określa, czy dany punkt znajduje się wewnątrz obszaru przycinania.|
|[CDC::RealizePalette](#realizepalette)|Wpisy palety mapy w bieżącej palecie logiczne do palety systemu.|
|[CDC::Rectangle](#rectangle)|Rysuje prostokąt przy użyciu bieżącego pióra i wypełnia je przy użyciu bieżącego pędzla.|
|[CDC::RectVisible](#rectvisible)|Określa, czy jakichkolwiek pracach związanych z danym prostokąta znajduje się w obrębie obszaru przycinania.|
|[CDC::ReleaseAttribDC](#releaseattribdc)|Wersje `m_hAttribDC`, atrybut kontekstu urządzenia.|
|[CDC::ReleaseOutputDC](#releaseoutputdc)|Wersje `m_hDC`, dane wyjściowe kontekstu urządzenia.|
|[CDC::ResetDC](#resetdc)|Aktualizacje `m_hAttribDC` kontekstu urządzenia.|
|[CDC::RestoreDC](#restoredc)|Przywraca poprzedni stan zapisany z kontekstu urządzenia `SaveDC`.|
|[CDC::RoundRect](#roundrect)|Rysuje prostokąt z zaokrąglonymi rogami przy użyciu bieżącego pióra i wypełnione przy użyciu bieżącego pędzla.|
|[CDC::SaveDC](#savedc)|Zapisuje bieżący stan kontekstu urządzenia.|
|[CDC::ScaleViewportExt](#scaleviewportext)|Modyfikuje zakres okienka ekranu względem bieżących wartości.|
|[CDC::ScaleWindowExt](#scalewindowext)|Modyfikuje zakresów okna względem bieżących wartości.|
|[CDC::ScrollDC](#scrolldc)|Przewija prostokąt bitów w poziomie i w pionie.|
|[CDC::SelectClipPath](#selectclippath)|Wybiera bieżącą ścieżkę jako obszar przycinania kontekstu urządzenia, łącząc nowego regionu z dowolnego istniejącego obszaru przycinania za pomocą określonego trybu.|
|[CDC::SelectClipRgn](#selectcliprgn)|Łączy danego regionu z bieżącego obszaru przycinania za pomocą określonego trybu.|
|[CDC::SelectObject](#selectobject)|Wybiera obiekt rysowania interfejsu GDI, takich jak pióra.|
|[CDC::SelectPalette](#selectpalette)|Wybiera palety logiczne.|
|[CDC::SelectStockObject](#selectstockobject)|Wybiera jeden z wstępnie zdefiniowanych standardowych pióra, Pędzle lub czcionki zapewniane przez Windows.|
|[CDC::SETABORTPROC](#setabortproc)|Ustawia podany programisty funkcję wywołania zwrotnego wywołująca Windows, jeśli musi zostać przerwana zadania drukowania.|
|[CDC::SetArcDirection](#setarcdirection)|Określa kierunek rysowania, które ma być używany dla funkcji łuk i prostokąt.|
|[CDC::SetAttribDC](#setattribdc)|Zestawy `m_hAttribDC`, atrybut kontekstu urządzenia.|
|[CDC::SetBkColor](#setbkcolor)|Ustawia bieżący kolor tła.|
|[CDC::SetBkMode](#setbkmode)|Ustawia tryb tła.|
|[CDC::SetBoundsRect](#setboundsrect)|Steruje gromadzenie informacji blokujących prostokąt dla kontekstu określonego urządzenia.|
|[CDC::SetBrushOrg](#setbrushorg)|Określa punkt początkowy następnego pędzel wybrane do kontekstu urządzenia.|
|[CDC::SetColorAdjustment](#setcoloradjustment)|Ustawia wartości dostosowanie kolorów dla kontekstu urządzenia przy użyciu określonych wartości.|
|[CDC::SetDCBrushColor](#setdcbrushcolor)|Ustawia bieżący kolor pędzla.|
|[CDC::SetDCPenColor](#setdcpencolor)|Ustawia bieżący kolor pióra.|
|[CDC::SetGraphicsMode](#setgraphicsmode)|Ustawia bieżący tryb graficznych dla kontekstu określonego urządzenia.|
|[CDC::SetLayout](#setlayout)|Zmienia układ kontekstu urządzenia (DC).|
|[CDC::SetMapMode](#setmapmode)|Ustawia bieżący tryb mapowania.|
|[CDC::SetMapperFlags](#setmapperflags)|Zmienia algorytm mapowanie czcionek, gdy jest on mapowany logiczne czcionki fizycznych czcionki.|
|[CDC::SetMiterLimit](#setmiterlimit)|Ustawia limit długości skosu sprzężenia dla kontekstu urządzenia.|
|[CDC::SetOutputDC](#setoutputdc)|Zestawy `m_hDC`, dane wyjściowe kontekstu urządzenia.|
|[CDC::SetPixel](#setpixel)|Ustawia piksel w punkcie określonym najbliższego zbliżenia określonego koloru.|
|[CDC::SetPixelV](#setpixelv)|Ustawia piksela na określonych współrzędnych najbliższego zbliżenia określonego koloru. `SetPixelV` jest szybsza niż `SetPixel` ponieważ musi zwracać wartość koloru punktu, w rzeczywistości rysowane.|
|[CDC::SetPolyFillMode](#setpolyfillmode)|Ustawia tryb wypełnianie wielokąta.|
|[CDC::SetROP2](#setrop2)|Ustawia bieżący tryb rysowania.|
|[CDC::SetStretchBltMode](#setstretchbltmode)|Ustawia tryb rozciąganie mapy bitowej.|
|[CDC::SetTextAlign](#settextalign)|Ustawia flagi wyrównania tekstu.|
|[CDC::SetTextCharacterExtra](#settextcharacterextra)|Ustawia intercharacter odstępu.|
|[CDC::SetTextColor](#settextcolor)|Ustawia kolor tekstu.|
|[CDC::SetTextJustification](#settextjustification)|Dodaje miejsce znaki końca ciągu.|
|[CDC::SetViewportExt](#setviewportext)|Ustawia zakresów x i y okienka ekranu.|
|[CDC::SetViewportOrg](#setviewportorg)|Ustawia źródło okienka ekranu.|
|[CDC::SetWindowExt](#setwindowext)|Ustawia zakresów x i y odpowiedniego okna.|
|[CDC::SetWindowOrg](#setwindoworg)|Ustawia okno pochodzenia kontekstu urządzenia.|
|[CDC::SetWorldTransform](#setworldtransform)|Ustawia transformację miejsce na stronie bieżącej przestrzeni świata.|
|[CDC::StartDoc](#startdoc)|Informuje o sterownik urządzenia, który rozpoczyna nowe zadanie drukowania.|
|[CDC::StartPage](#startpage)|Informuje o sterownik urządzenia, który rozpocznie się nowa strona.|
|[CDC::StretchBlt](#stretchblt)|Przenosi mapę bitową z prostokąta źródłowego i urządzenia do prostokąta docelowego, rozciągając ją lub zmniejszając mapy bitowej, jeśli to konieczne dopasować ją do wymiarów prostokąta docelowego.|
|[CDC::StrokeAndFillPath](#strokeandfillpath)|Zamyka wszystkie otwartych figur w ścieżce, może kontynuować działalność konspektu ścieżki przy użyciu bieżącego pióra i wypełnia jego wewnętrznych przy użyciu aktualny pędzel.|
|[CDC::StrokePath](#strokepath)|Renderuje określonej ścieżki przy użyciu bieżącego pióra.|
|[CDC::TabbedTextOut](#tabbedtextout)|Zapisuje ciąg znaków w określonej lokalizacji, rozwijając karty wartościom określonym w tablicy pozycji tabulatora.|
|[CDC::TextOut](#textout)|Zapisuje ciąg znaków w określonej lokalizacji przy użyciu aktualnie wybranej czcionki.|
|[CDC::TransparentBlt](#transparentblt)|Przesyła blok bitowy dane koloru z kontekstem urządzenia źródłowego określonego do kontekstu urządzenia docelowego, renderowanie określonego koloru w transferu.|
|[CDC::UpdateColors](#updatecolors)|Aktualizacje obszaru klienta, kontekstu urządzenia, porównując bieżącą kolorów w obszar klienta do palety system na podstawie poszczególne piksele.|
|[CDC::WidenPath](#widenpath)|Ponownie bieżącą ścieżkę jako obszar, który będzie malowane, jeśli zostały malowania ścieżki, za pomocą pióra, aktualnie wybrany do kontekstu urządzenia.|

### <a name="public-operators"></a>Operatory publiczne

|Nazwa|Opis|
|----------|-----------------|
|[CDC::operator elementu HDC](#operator_hdc)|Pobiera uchwyt kontekstu urządzenia.|

### <a name="public-data-members"></a>Publiczne elementy członkowskie danych

|Nazwa|Opis|
|----------|-----------------|
|[CDC::m_hAttribDC](#m_hattribdc)|Kontekst atrybutu urządzeń używanych przez to `CDC` obiektu.|
|[CDC::m_hDC](#m_hdc)|Kontekst urządzenia wyjściowego, używany przez to `CDC` obiektu.|

## <a name="remarks"></a>Uwagi

`CDC` Obiektu dostarcza funkcji elementów członkowskich do pracy z kontekstu urządzenia, np. wyświetlania lub drukarki, jak również elementy członkowskie do pracy z kontekstem wyświetlania skojarzonych z obszaru klienckiego okna.

Wykonaj wszystkie rysunku przez element członkowski funkcji `CDC` obiektu. Klasa dostarcza funkcji elementów członkowskich dla operacji kontekstu urządzenia, Praca z narzędzi, wybór obiektu interface (GDI) urządzenia grafiki bezpieczny, rysowania i pracą z nimi za pomocą kolorów i palet. Zapewnia także funkcje Członkowskie służące do pobierania i ustawienie rysowania atrybuty mapowania, Praca z okienka ekranu, pracę w zakresie okna, Konwersja współrzędnych, Praca z regionów, wycinka elipsy Rysowanie linii i proste do rysowania, i wielokątów. Funkcje Członkowskie również są dostarczone dla Rysowanie tekstu, pracy w przypadku czcionek, za pomocą ucieczki drukarki, przewijania i odtwarzanie metapliki.

Aby użyć `CDC` obiekt, jego konstruowania, a następnie wywołaj członków funkcje, które równoległe funkcji Windows, które używają konteksty urządzenia.

> [!NOTE]
>  W obszarze Windows 95/98 wszystkie współrzędne ekranu mogą zawierać maksymalnie 16 bitów. W związku z tym **int** przekazany do `CDC` funkcja elementu członkowskiego musi należeć do zakresu od -32768 do 32767.

Do określonych zastosowań biblioteki klas Microsoft Foundation udostępnia kilka klas pochodnych `CDC` . `CPaintDC` hermetyzuje wywołania `BeginPaint` i `EndPaint`. `CClientDC` zarządza kontekst wyświetlania skojarzonych z obszaru klienckiego okna. `CWindowDC` zarządza kontekst wyświetlania skojarzonych z całe okno, w tym jego ramki i formantów. `CMetaFileDC` Kojarzy kontekstu urządzenia z metaplik.

`CDC` zapewnia dwie funkcje Członkowskie, [GetLayout](#getlayout) i [SetLayout](#setlayout), dla cofania układ kontekstu urządzenia, który nie dziedziczy jej układ okna. Takie orientacja od prawej do lewej jest niezbędne dla aplikacji napisanych dla kultur, jak arabski i hebrajski, gdzie Układ znak nie jest Europejskiego standard.

`CDC` zawiera dwa konteksty urządzenia, [m_hDC](#m_hdc) i [m_hAttribDC](#m_hattribdc), która od utworzenia `CDC` obiektu, zapoznaj się na tym samym urządzeniu. `CDC` Określa, że wszystkie dane wyjściowe GDI wywołania `m_hDC` i większość atrybut GDI `m_hAttribDC`. (Na przykład wywołanie atrybut `GetTextColor`, podczas gdy `SetTextColor` to wywołanie danych wyjściowych.)

Na przykład struktura używa tych kontekstach dwa urządzenia do zaimplementowania `CMetaFileDC` obiektu, który będzie wysyłać dane wyjściowe do metaplik podczas odczytywania atrybuty z urządzenia fizycznego. Podgląd wydruku jest wdrażany w ramach w podobny sposób. Umożliwia także konteksty urządzenia dwa w podobny sposób jak w kodzie aplikacji.

Istnieją czasami może być potrzebne informacje tekstowe metryki z obu `m_hDC` i `m_hAttribDC` konteksty urządzenia. Następujące pary funkcje zapewniają tej funkcji:

|Używa m_hAttribDC|Używa m_hDC|
|-----------------------|-----------------|
|[GetTextExtent](#gettextextent)|[GetOutputTextExtent](#getoutputtextextent)|
|[GetTabbedTextExtent](#gettabbedtextextent)|[GetOutputTabbedTextExtent](#getoutputtabbedtextextent)|
|[GetTextMetrics](#gettextmetrics)|[GetOutputTextMetrics](#getoutputtextmetrics)|
|[GetCharWidth](#getcharwidth)|[GetOutputCharWidth](#getoutputcharwidth)|

Aby uzyskać więcej informacji na temat `CDC`, zobacz [konteksty urządzenia](../../mfc/device-contexts.md).

## <a name="inheritance-hierarchy"></a>Hierarchia dziedziczenia

[CObject](../../mfc/reference/cobject-class.md)

`CDC`

## <a name="requirements"></a>Wymagania

**Nagłówek:** afxwin.h

##  <a name="abortdoc"></a>  CDC::AbortDoc

Kończy działanie bieżącego zadania drukowania i usuwa wszystkie elementy aplikacji zapisane na urządzeniu od czasu ostatniego wywołania do [StartDoc](#startdoc) funkcja elementu członkowskiego.

```
int AbortDoc();
```

### <a name="return-value"></a>Wartość zwracana

Wartość większa niż lub równa 0, jeśli kończy się pomyślnie, lub wartość ujemną, jeśli wystąpił błąd. Na poniższej liście przedstawiono typowe wartości błędów i ich znaczenie:

- Błąd ogólny SP_ERROR.

- Nie SP_OUTOFDISK wystarczającej ilości miejsca na dysku jest obecnie dostępna dla buforowania i miejsca staną się dostępne.

- Nie SP_OUTOFMEMORY wystarczającą ilość pamięci dostępnej dla buforowania.

- Użytkownik SP_USERABORT zakończone zadania przy użyciu Menedżera wydruku.

### <a name="remarks"></a>Uwagi

Ta funkcja elementu członkowskiego zastępuje znak ucieczki ABORTDOC drukarki.

`AbortDoc` powinien być używany do zakończenia następujące czynności:

- Operacje drukowania, które nie zostanie określony, funkcja przerwania przy użyciu [SetAbortProc](#setabortproc).

- Operacje drukowania, które jeszcze nie osiągnęły ich pierwszym NEWFRAME lub NEXTBAND ucieczki wywołania.

Jeśli aplikacja napotka błąd drukowania lub anulowanych operacji wydruku, nie należy spróbować zakończyć operację przy użyciu [EndDoc](#enddoc) lub `AbortDoc` funkcji elementów członkowskich klasy `CDC`. GDI automatycznie kończy operację przed zwróceniem wartości błędu.

Jeśli aplikacja wyświetla okno dialogowe, aby umożliwić użytkownikowi anulować operację wydruku, należy wywołać `AbortDoc` przed niszczenie okna dialogowego.

Jeśli Menedżera drukowania był używany do uruchomienia zadania drukowania, wywołanie `AbortDoc` usuwa zadanie buforu całego — drukarki odbiera żadne. Jeśli Menedżer drukowania nie był używany do uruchomienia zadania drukowania, dane mogą został wysłany do drukarki przed `AbortDoc` została wywołana. W tym przypadku sterownika drukarki będzie zresetować drukarki (jeśli jest to możliwe) i zamknięte zadania drukowania.

### <a name="example"></a>Przykład

  Zobacz przykład [CDC::StartDoc](#startdoc).

##  <a name="abortpath"></a>  CDC::AbortPath

Zamyka i odrzuca wszystkie ścieżki w kontekście urządzenia.

```
BOOL AbortPath();
```

### <a name="return-value"></a>Wartość zwracana

Różne od zera, jeśli funkcja zakończyła się pomyślnie; w przeciwnym razie 0.

### <a name="remarks"></a>Uwagi

Jeśli występuje nawias Otwórz ścieżkę w kontekście urządzenia, nawiasu ścieżki jest zamknięty, a ścieżka jest odrzucany. Jeśli jest ścieżką zamknięte w kontekście urządzenia, ścieżka zostanie odrzucony.

##  <a name="addmetafilecomment"></a>  CDC::AddMetaFileComment

Kopiuje komentarz z buforu w określonym metaplik rozszerzony format.

```
BOOL AddMetaFileComment(
    UINT nDataSize,
    const BYTE* pCommentData);
```

### <a name="parameters"></a>Parametry

*nDataSize*<br/>
Określa długość buforu komentarza, w bajtach.

*pCommentData*<br/>
Wskazuje buforu, który zawiera komentarz.

### <a name="return-value"></a>Wartość zwracana

Różne od zera, jeśli funkcja zakończyła się pomyślnie; w przeciwnym razie 0.

### <a name="remarks"></a>Uwagi

Komentarz może zawierać żadnych informacji prywatnych — na przykład źródło obrazu i daty utworzenia. Komentarz powinien zaczynać się od podpis aplikacji, a następnie na podstawie danych. Komentarze nie może zawierać dane specyficzne dla pozycji. Dane dotyczące położenia Określa lokalizację rekordu, a nie może być uwzględniony, ponieważ jeden metaplik może być osadzony w innym metaplik. Ta funkcja może służyć tylko przy użyciu rozszerzonych metaplików.

##  <a name="alphablend"></a>  CDC::AlphaBlend

Wywołaj tę funkcję elementu członkowskiego do wyświetlania mapy bitowe, które mają przezroczyste lub półprzezroczystych pikseli.

```
BOOL AlphaBlend(
    int xDest,
    int yDest,
    int nDestWidth,
    int nDestHeight,
    CDC* pSrcDC,
    int xSrc,
    int ySrc,
    int nSrcWidth,
    int nSrcHeight,
    BLENDFUNCTION blend);
```

### <a name="parameters"></a>Parametry

*xDest*<br/>
Określa współrzędną x w jednostkach logicznych, w lewym górnym rogu prostokąta docelowego.

*yDest*<br/>
Określa współrzędną y w jednostkach logicznych, w lewym górnym rogu prostokąta docelowego.

*nDestWidth*<br/>
Określa szerokość w jednostkach logicznych, prostokąta docelowego.

*nDestHeight*<br/>
Określa wysokość w jednostkach logicznych, prostokąta docelowego.

*pSrcDC*<br/>
Wskaźnik do kontekst urządzenia źródłowego.

*xSrc*<br/>
Określa współrzędną x w jednostkach logicznych, w lewym górnym rogu prostokąta źródłowego.

*ySrc*<br/>
Określa współrzędną y w jednostkach logicznych, w lewym górnym rogu prostokąta źródłowego.

*nSrcWidth*<br/>
Określa szerokość w jednostkach logicznych, prostokąta źródłowego.

*nSrcHeight*<br/>
Określa wysokość w jednostkach logicznych, prostokąta źródłowego.

*program Blend*<br/>
Określa [BLENDFUNCTION](/windows/desktop/api/wingdi/ns-wingdi-_blendfunction) struktury.

### <a name="return-value"></a>Wartość zwracana

Wartość TRUE, jeśli to się powiedzie; w przeciwnym razie wartość FALSE.

### <a name="remarks"></a>Uwagi

Zobacz [AlphaBlend](/windows/desktop/api/wingdi/nf-wingdi-alphablend) w zestawie Windows SDK, aby uzyskać więcej informacji.

##  <a name="anglearc"></a>  CDC::AngleArc

Rysuje segment linii i łuku.

```
BOOL AngleArc(
    int x,
    int y,
    int nRadius,
    float fStartAngle,
    float fSweepAngle);
```

### <a name="parameters"></a>Parametry

*x*<br/>
Określa logiczną współrzędną x środka okręgu.

*y*<br/>
Określa logiczną współrzędną y środka okręgu.

*nRadius*<br/>
Określa promień koła w jednostkach logicznych. Ta wartość musi być dodatnia.

*fStartAngle*<br/>
Określa kąt początkowy w stopniach względem osi x.

*fSweepAngle*<br/>
Określa kąt odchylenia w stopniach względem Kąt początkowy.

### <a name="return-value"></a>Wartość zwracana

Wartość różną od zera, jeśli to się powiedzie; w przeciwnym razie 0.

### <a name="remarks"></a>Uwagi

Segment linii jest rysowana od bieżącej pozycji do stanu sprzed łuku. Łuku wzdłuż obwód koła Centrum i danej usługi radius. Długość łuk jest definiowany przez dany kąty początkową i odchylenia.

`AngleArc` Przenosi bieżącej pozycji punktu końcowego łuku. Łuk rysowane przez tę funkcję może wyglądać na elipsy, w zależności od tego, bieżący tryb mapowania i przekształcania. Przed narysowaniem łuk, ta funkcja rysuje segment linii z bieżącego położenia na początku łuku. Łuku tworząc urojone koło z wybranego promienia wokół punktu określonego Centrum. Punkt początkowy łuku jest określana przez dokonywanie pomiarów zegara od osi x okręgu przez liczbę stopni w Kąt początkowy. Punkt końcowy znajduje się podobnie mierząc zegara od punktu początkowego przez liczbę stopni w kąta odchylenia.

Jeśli kąta odchylenia jest większa niż 360 stopni kątowych przechwytywana wiele razy. Ta funkcja rysuje linie przy użyciu bieżącego pióra. Rysunek nie jest wypełnione.

##  <a name="arc"></a>  CDC::ARC

Rysuje łuk eliptyczny.

```
BOOL Arc(
    int x1,
    int y1,
    int x2,
    int y2,
    int x3,
    int y3,
    int x4,
    int y4);

BOOL Arc(
    LPCRECT lpRect,
    POINT ptStart,
    POINT ptEnd);
```

### <a name="parameters"></a>Parametry

*x1*<br/>
Określa współrzędną x w lewym górnym rogu prostokąt otaczający (w jednostkach logicznych).

*y1*<br/>
Określa współrzędną y lewego górnego rogu prostokąt otaczający (w jednostkach logicznych).

*x2*<br/>
Określa współrzędną x w prawym dolnym rogu prostokąt otaczający (w jednostkach logicznych).

*y2*<br/>
Określa współrzędną y prawego dolnego rogu prostokąt otaczający (w jednostkach logicznych).

*x3*<br/>
Określa współrzędną x punktu, który definiuje łuk użytkownika początkowy (w jednostkach logicznych). Ten punkt nie musi znajdować się dokładnie na łuk.

*y3*<br/>
Określa współrzędną y punktu, który definiuje łuk użytkownika początkowy (w jednostkach logicznych). Ten punkt nie musi znajdować się dokładnie na łuk.

*x4*<br/>
Określa współrzędną x punktu, który definiuje endpoint łuku (w jednostkach logicznych). Ten punkt nie musi znajdować się dokładnie na łuk.

*y4*<br/>
Określa współrzędną y punktu, który definiuje endpoint łuku (w jednostkach logicznych). Ten punkt nie musi znajdować się dokładnie na łuk.

*lpRect*<br/>
Określa prostokąt otaczający (w jednostkach logicznych). Można przekazać albo lprect — lub [CRect](../../atl-mfc-shared/reference/crect-class.md) obiektu dla tego parametru.

*ptStart*<br/>
Określa, że współrzędnych x i y punktu, który definiuje łuk użytkownika początkowy (w jednostkach logicznych). Ten punkt nie musi znajdować się dokładnie na łuk. Można przekazać [punktu](/windows/desktop/api/windef/ns-windef-tagpoint) struktury lub [CPoint](../../atl-mfc-shared/reference/cpoint-class.md) obiektu dla tego parametru.

*ptEnd*<br/>
Określa współrzędne x i y punktu, który definiuje łuku punkt końcowy (w jednostkach logicznych). Ten punkt nie musi znajdować się dokładnie na łuk. Można przekazać `POINT` struktury lub `CPoint` obiektu dla tego parametru.

### <a name="return-value"></a>Wartość zwracana

Różne od zera, jeśli funkcja zakończyła się pomyślnie; w przeciwnym razie 0.

### <a name="remarks"></a>Uwagi

Łuk rysowania za pomocą funkcji jest segmentem elipsy, zdefiniowane przez określony prostokąt otaczający.

Rzeczywiste rozpoczęcie łuku to punkt, jaką promień od środka prostokąt otaczający za pośrednictwem określonego punktu początkowego przecina elipsy. Rzeczywisty punkt końcowy łuku to punkt, jaką promień od środka prostokąt otaczający za pośrednictwem określonego punktu końcowego przecina elipsy. Łuku w kierunku do ruchu wskazówek zegara. Ponieważ łuk nie figury zamkniętej nie jest wypełniony. Szerokość i wysokość prostokąta musi być większa niż 2 i mniej niż 32 767 jednostek.

### <a name="example"></a>Przykład

[!code-cpp[NVC_MFCDocView#29](../../mfc/codesnippet/cpp/cdc-class_1.cpp)]

##  <a name="arcto"></a>  CDC::ArcTo

Rysuje łuk eliptyczny.

```
BOOL ArcTo(
    int x1,
    int y1,
    int x2,
    int y2,
    int x3,
    int y3,
    int x4,
    int y4);

BOOL ArcTo(
    LPCRECT lpRect,
    POINT ptStart,
    POINT ptEnd);
```

### <a name="parameters"></a>Parametry

*x1*<br/>
Określa współrzędną x w lewym górnym rogu prostokąt otaczający (w jednostkach logicznych).

*y1*<br/>
Określa współrzędną y lewego górnego rogu prostokąt otaczający (w jednostkach logicznych).

*x2*<br/>
Określa współrzędną x w prawym dolnym rogu prostokąt otaczający (w jednostkach logicznych).

*y2*<br/>
Określa współrzędną y prawego dolnego rogu prostokąt otaczający (w jednostkach logicznych).

*x3*<br/>
Określa współrzędną x punktu, który definiuje łuk użytkownika początkowy (w jednostkach logicznych). Ten punkt nie musi znajdować się dokładnie na łuk.

*y3*<br/>
Określa współrzędną y punktu, który definiuje łuk użytkownika początkowy (w jednostkach logicznych). Ten punkt nie musi znajdować się dokładnie na łuk.

*x4*<br/>
Określa współrzędną x punktu, który definiuje endpoint łuku (w jednostkach logicznych). Ten punkt nie musi znajdować się dokładnie na łuk.

*y4*<br/>
Określa współrzędną y punktu, który definiuje endpoint łuku (w jednostkach logicznych). Ten punkt nie musi znajdować się dokładnie na łuk.

*lpRect*<br/>
Określa prostokąt otaczający (w jednostkach logicznych). Można przekazać wskaźnik do [Prostokąt](/windows/desktop/api/windef/ns-windef-tagrect) struktury danych lub [CRect](../../atl-mfc-shared/reference/crect-class.md) obiektu dla tego parametru.

*ptStart*<br/>
Określa, że współrzędnych x i y punktu, który definiuje łuk użytkownika początkowy (w jednostkach logicznych). Ten punkt nie musi znajdować się dokładnie na łuk. Można przekazać [punktu](/windows/desktop/api/windef/ns-windef-tagpoint) struktury danych lub [CPoint](../../atl-mfc-shared/reference/cpoint-class.md) obiektu dla tego parametru.

*ptEnd*<br/>
Określa współrzędne x i y punktu, który definiuje łuku punkt końcowy (w jednostkach logicznych). Ten punkt nie musi znajdować się dokładnie na łuk. Można przekazać `POINT` struktury danych lub `CPoint` obiektu dla tego parametru.

### <a name="return-value"></a>Wartość zwracana

Różne od zera, jeśli funkcja zakończyła się pomyślnie; w przeciwnym razie 0.

### <a name="remarks"></a>Uwagi

Ta funkcja jest podobny do `CDC::Arc`, z tą różnicą, że bieżące położenie jest aktualizowana. Punkty ( *x1*, *y1*) i ( *x2*, *y2*) określ prostokąt otaczający. Elipsy utworzone przez dany prostokąt otaczający definiuje krzywej łuku. Łuk rozszerza zegara (domyślny kierunek łuk) z punktu końcowe promieniowego wiersza z Centrum prostokąt otaczający ( *x3*, *y3*). Końcowe promieniowego wiersza z Centrum prostokąt otaczający do zakończenia łuk ( *x4*, *y4*). Jeśli punkt początkowy i punkt końcowy są takie same, jest rysowana pełną elipsy.

Linia jest rysowana od bieżącej pozycji do punktu początkowego łuku. Jeśli żaden błąd nie wystąpi, bieżące położenie jest równa punktu końcowego łuku. Łuku przy użyciu bieżącego pióra; nie jest wypełnione.

##  <a name="attach"></a>  CDC::attach

Użyj tej funkcji elementu członkowskiego do dołączenia *elementu hDC* do `CDC` obiektu.

```
BOOL Attach(HDC hDC);
```

### <a name="parameters"></a>Parametry

*hDC*<br/>
Windows kontekstu urządzenia.

### <a name="return-value"></a>Wartość zwracana

Różne od zera, jeśli funkcja zakończyła się pomyślnie; w przeciwnym razie 0.

### <a name="remarks"></a>Uwagi

*Elementu hDC* znajduje się w obu `m_hDC`, dane wyjściowe kontekstu urządzenia, a następnie w `m_hAttribDC`, atrybut kontekstu urządzenia.

##  <a name="beginpath"></a>  CDC::BeginPath

Zostanie otwarty nawias ścieżki w kontekście urządzenia.

```
BOOL BeginPath();
```

### <a name="return-value"></a>Wartość zwracana

Różne od zera, jeśli funkcja zakończyła się pomyślnie; w przeciwnym razie 0.

### <a name="remarks"></a>Uwagi

Po otwarciu nawiasu ścieżki aplikacji można rozpocząć podczas wywoływania funkcji rysowania GDI do definiowania punkty, które znajdują się w ścieżce. Aplikację można zamknąć nawias Otwórz ścieżkę przez wywołanie metody `EndPath` funkcja elementu członkowskiego. Kiedy aplikacja wywołuje `BeginPath`, wszystkie poprzednie ścieżki są odrzucane.

Zobacz [BeginPath](/windows/desktop/api/wingdi/nf-wingdi-beginpath) w zestawie Windows SDK dla listy rysowania funkcji, które definiują punkty w ścieżce.

### <a name="example"></a>Przykład

[!code-cpp[NVC_MFCDocView#30](../../mfc/codesnippet/cpp/cdc-class_2.cpp)]

##  <a name="bitblt"></a>  CDC::BitBlt

Kopiuje mapę bitową z kontekstem urządzenia źródłowego dla tego bieżącego kontekstu urządzenia.

```
BOOL BitBlt(
    int x,
    int y,
    int nWidth,
    int nHeight,
    CDC* pSrcDC,
    int xSrc,
    int ySrc,
    DWORD dwRop);
```

### <a name="parameters"></a>Parametry

*x*<br/>
Określa logiczną współrzędną x lewego górnego rogu prostokąta docelowego.

*y*<br/>
Określa logiczną współrzędną y lewego górnego rogu prostokąta docelowego.

*nWidth*<br/>
Określa szerokość (w jednostkach logicznych) docelowej prostokąt i źródłowej mapy bitowej.

*nHeight*<br/>
Określa wysokość (w jednostkach logicznych) docelowej prostokąt i źródłowej mapy bitowej.

*pSrcDC*<br/>
Wskaźnik do `CDC` obiektu, który identyfikuje kontekst urządzenia, z którego zostaną skopiowane mapy bitowej. Musi mieć wartość NULL, jeśli *dwRop* określa operację rastrową, która, który nie zawiera źródła.

*xSrc*<br/>
Określa logiczną współrzędną x lewego górnego rogu źródłową mapę bitową.

*ySrc*<br/>
Określa logiczną współrzędną y lewego górnego rogu źródłową mapę bitową.

*dwRop*<br/>
Określa operację rastrową, która ma być wykonana. Kody operacji rastrowych definiują, jak interfejs GDI łączy kolory w operacjach wyjściowych, które obejmują aktualny Pędzel, możliwą źródłową mapę bitową i docelową mapę bitową. Zobacz [BitBlt](/windows/desktop/api/wingdi/nf-wingdi-bitblt) w zestawie Windows SDK dla listy kody operacji rastrowych *dwRop* wraz z opisami

Aby uzyskać pełną listę kody operacji rastrowych, zobacz [o kody operacji rastrowych](/windows/desktop/gdi/raster-operation-codes) w zestawie Windows SDK.

### <a name="return-value"></a>Wartość zwracana

Różne od zera, jeśli funkcja zakończyła się pomyślnie; w przeciwnym razie 0.

### <a name="remarks"></a>Uwagi

Aplikację można wyrównać systemu windows lub obszary klienta w granicach bajtowych, aby upewnić się, że `BitBlt` operacje są wykonywane na bajtami prostokąty. (Ustawia flagi CS_BYTEALIGNWINDOW lub CS_BYTEALIGNCLIENT, rejestrując klasy okna).

`BitBlt` operacje na bajtami prostokąty są znacznie szybsze niż `BitBlt` operacji na prostokątami, które nie są wyrównane bajtów. Jeśli chcesz określić style klasy, takie jak wyrównanie bajt kontekstu urządzenia, musisz zarejestrować klasy okna zamiast polegać na klasy Microsoft Foundation, aby to zrobił dla Ciebie. Użyj funkcji globalnych [afxregisterwndclass —](../../mfc/reference/application-information-and-management.md#afxregisterwndclass).

Przekształca GDI *nWidth* i *nHeight*, jeden raz przy użyciu kontekstu urządzenia docelowego i jeden raz, korzystając z kontekstem urządzenia źródłowego. Jeśli wynikowe zakresów nie są zgodne, GDI używa Windows `StretchBlt` funkcji do skompresowania lub rozproszonego źródłową mapę bitową zgodnie z potrzebami.

Jeśli miejsce docelowe, źródła i desenia nie mają tego samego formatu koloru `BitBlt` funkcja konwertuje mapy bitowe źródła i wzorzec do dopasowania miejsca docelowego. Kolory pierwszego planu i tła docelową mapę bitową są używane do konwersji.

Gdy `BitBlt` funkcja konwertuje monochromatyczną mapę bitową na kolor, to ustawia bity białe (1) do koloru tła i bity czarne (0) kolor pierwszego planu. Używane są kolory pierwszego planu i tła kontekstu urządzenia docelowego. Aby przekonwertować kolor na monochromatyczny, `BitBlt` ustawia piksele, które odpowiadają kolorowi tła, na biały i wszystkie inne piksele ustawia na czarny. `BitBlt` Aby przekonwertować kolor na monochromatyczny, używa kolory pierwszego planu i tła kontekstu urządzenia kolor.

Należy zauważyć, że nie wszystkie konteksty urządzenia obsługują `BitBlt`. Aby sprawdzić, czy kontekst danego urządzenia obsługują `BitBlt`, użyj `GetDeviceCaps` elementu członkowskiego działać, a następnie określ indeks RASTERCAPS.

### <a name="example"></a>Przykład

  Zobacz przykład [CDC::CreateCompatibleDC](#createcompatibledc).

##  <a name="cdc"></a>  CDC::CDC

Konstruuje `CDC` obiektu.

```
CDC();
```

##  <a name="chord"></a>  CDC::Chord

Rysuje skrót (figurę zamkniętą ograniczany przez przecięcie elipsę i segment linii).

```
BOOL Chord(
    int x1,
    int y1,
    int x2,
    int y2,
    int x3,
    int y3,
    int x4,
    int y4);

BOOL Chord(
    LPCRECT lpRect,
    POINT ptStart,
    POINT ptEnd);
```

### <a name="parameters"></a>Parametry

*x1*<br/>
Określa współrzędną x lewym górnym rogu akordu użytkownika blokujących prostokąt (w jednostkach logicznych).

*y1*<br/>
Określa współrzędną y lewego górnego rogu skrót użytkownika blokujących prostokąt (w jednostkach logicznych).

*x2*<br/>
Określa współrzędną x w prawym dolnym rogu skrót użytkownika blokujących prostokąt (w jednostkach logicznych).

*y2*<br/>
Określa współrzędną y prawego dolnego rogu skrót użytkownika blokujących prostokąt (w jednostkach logicznych).

*x3*<br/>
Określa współrzędną x punktu, który definiuje skrót użytkownika początkowy (w jednostkach logicznych).

*y3*<br/>
Określa współrzędną y punktu, który definiuje skrót użytkownika początkowy (w jednostkach logicznych).

*x4*<br/>
Określa współrzędną x punktu, który definiuje endpoint skrót (w jednostkach logicznych).

*y4*<br/>
Określa współrzędną y punktu, który definiuje endpoint skrót (w jednostkach logicznych).

*lpRect*<br/>
Określa prostokąt otaczający (w jednostkach logicznych). Można przekazać albo lprect — lub [CRect](../../atl-mfc-shared/reference/crect-class.md) obiektu dla tego parametru.

*ptStart*<br/>
Określa, że współrzędnych x i y punktu, który definiuje skrót użytkownika początkowy (w jednostkach logicznych). Ten punkt nie musi znajdować się dokładnie na skrót. Można przekazać `POINT` struktury lub `CPoint` obiektu dla tego parametru.

*ptEnd*<br/>
Określa współrzędne x i y punktu, który definiuje skrót punkt końcowy (w jednostkach logicznych). Ten punkt nie musi znajdować się dokładnie na skrót. Można przekazać [punktu](/windows/desktop/api/windef/ns-windef-tagpoint) struktury lub [CPoint](../../atl-mfc-shared/reference/cpoint-class.md) obiektu dla tego parametru.

### <a name="return-value"></a>Wartość zwracana

Różne od zera, jeśli funkcja zakończyła się pomyślnie; w przeciwnym razie 0.

### <a name="remarks"></a>Uwagi

( *X1*, *y1*) i ( *x2*, *y2*) parametry określają narożników lewym i prawym dolnym odpowiednio prostokąta blokujących elipsy, który jest częścią skrót. ( *X3*, *y3*) i ( *x4*, *y4*) parametry określają punktów końcowych linii, które przecinają elipsy. Skrót jest rysowany przy użyciu wybranego pióra i wypełnione przy użyciu wybranego pędzla.

Rysunek narysowanymi przez `Chord` funkcja rozciąga się do, ale nie zawiera współrzędne po prawej stronie i u dołu. Oznacza, że wysokość rysunku *y2* - *y1* i szerokość rysunku jest *x2* - *x1*.

### <a name="example"></a>Przykład

[!code-cpp[NVC_MFCDocView#31](../../mfc/codesnippet/cpp/cdc-class_3.cpp)]

##  <a name="closefigure"></a>  CDC::CloseFigure

Zamyka figurę otwartą. w ścieżce.

```
BOOL CloseFigure();
```

### <a name="return-value"></a>Wartość zwracana

Różne od zera, jeśli funkcja zakończyła się pomyślnie; w przeciwnym razie 0.

### <a name="remarks"></a>Uwagi

Funkcja zostanie zamknięte rysunku Rysowanie linii z bieżącego położenia na pierwszym punktem rysunku (zazwyczaj określony przez wywołanie najnowszych punkt `MoveTo` funkcja elementu członkowskiego) i łączy wierszy przy użyciu styl łączenia linii. Gdy rysunek jest zamknięty przy użyciu `LineTo` funkcja elementu członkowskiego zamiast `CloseFigure`, zakończenia są używane do tworzenia rogu zamiast sprzężenia. `CloseFigure` powinna być wywoływana tylko w przypadku nawias Otwórz ścieżkę w kontekście urządzenia.

Rysunek w ścieżce jest otwarty, chyba że wyraźnie jest zamknięty przy użyciu tej funkcji. (Rysunek można otworzyć nawet, jeśli bieżącym punktem a punktem początkowym ilustracji są takie same.) Dowolną linię lub krzywą dodawany do ścieżki po `CloseFigure` uruchamia nowy rysunek.

##  <a name="createcompatibledc"></a>  CDC::CreateCompatibleDC

Tworzy kontekst urządzenia pamięci zgodnego z urządzenia określone przez *kontrolera pDC*.

```
BOOL CreateCompatibleDC(CDC* pDC);
```

### <a name="parameters"></a>Parametry

*pDC*<br/>
Wskaźnik do kontekstu urządzenia. Jeśli *kontrolera pDC* ma wartość NULL, funkcja tworzy kontekst urządzenia pamięci, zgodny z wyświetlaniem systemu.

### <a name="return-value"></a>Wartość zwracana

Różne od zera, jeśli funkcja zakończyła się pomyślnie; w przeciwnym razie 0.

### <a name="remarks"></a>Uwagi

Kontekst urządzenia pamięci jest blok pamięci, który reprezentuje powierzchni ekranu. Może służyć do przygotowania obrazów w pamięci przed skopiowaniem ich do powierzchni rzeczywistego urządzenia zgodnych urządzeń.

Podczas tworzenia kontekstu urządzenia pamięci GDI automatycznie wybiera monochromatycznych map bitowych podstawowe 1-przez-1 dla niego. Funkcje danych wyjściowych z użyciem interfejsu GDI może służyć za pomocą kontekstu urządzenia pamięci tylko wtedy, gdy utworzono mapę bitową i zaznaczone w tym kontekście.

Ta funkcja tylko może służyć do tworzenia kontekstów zgodnych urządzeń dla urządzeń, które obsługują rastrowych. Zobacz [CDC::BitBlt](#bitblt) funkcja elementu członkowskiego, aby uzyskać informacje dotyczące przesunięcia bitowego bloku między konteksty urządzenia. Aby ustalić, czy kontekst urządzenia obsługuje rastrowych, zobacz możliwości rastrowych rastercaps w funkcji składowej `CDC::GetDeviceCaps`.

### <a name="example"></a>Przykład

[!code-cpp[NVC_MFCDocView#32](../../mfc/codesnippet/cpp/cdc-class_4.cpp)]

##  <a name="createdc"></a>  CDC::CreateDC

Tworzy kontekst urządzenia dla określonego urządzenia.

```
BOOL CreateDC(
    LPCTSTR lpszDriverName,
    LPCTSTR lpszDeviceName,
    LPCTSTR lpszOutput,
    const void* lpInitData);
```

### <a name="parameters"></a>Parametry

*lpszDriverName*<br/>
Wskazuje ciąg zakończony znakiem null, który określa nazwę pliku (bez rozszerzenia) sterownika urządzenia (na przykład "EPSON"). Można również przekazać `CString` obiektu dla tego parametru.

*lpszDeviceName*<br/>
Wskazuje ciąg zakończony znakiem null, który określa nazwę określonego urządzenia, są obsługiwane (na przykład "EPSON FX-80"). *LpszDeviceName* parametr jest używany, jeśli moduł obsługuje więcej niż jedno urządzenie. Można również przekazać `CString` obiektu dla tego parametru.

*lpszOutput*<br/>
Wskazuje ciąg zakończony znakiem null, który określa nazwę pliku lub urządzenia dla średnich wyjściowego fizycznej (port pliku lub dane wyjściowe). Można również przekazać `CString` obiektu dla tego parametru.

*lpInitData*<br/>
Wskazuje `DEVMODE` struktury zawierającej dane specyficzne dla urządzenia inicjowania dla sterownika urządzenia. Windows `DocumentProperties` funkcja pobiera tej struktury, wypełnione dla danego urządzenia. *LpInitData* parametr musi mieć wartość NULL, jeśli sterownik urządzenia użycia inicjowanie domyślnych (jeśli istnieje), określony przez użytkownika za pomocą Panelu sterowania.

### <a name="return-value"></a>Wartość zwracana

Różne od zera, jeśli funkcja zakończyła się pomyślnie; w przeciwnym razie 0.

### <a name="remarks"></a>Uwagi

Drukuj. Plik nagłówkowy H jest wymagany, jeśli [DEVMODE](/windows/desktop/api/wingdi/ns-wingdi-_devicemodea) struktura jest używana.

Nazwy urządzeń z tymi konwencjami: końcowy dwukropek (:) jest zalecane, ale opcjonalne. Windows usuwa kończący dwukropek, tak, aby nazwa urządzenia, kończąc dwukropek jest mapowany na tym samym porcie taką samą nazwę bez dwukropka. Nazwy sterowników i port nie może zawierać spacji wiodących i końcowych. Nie można używać funkcji danych wyjściowych interfejsu GDI z kontekstami informacji.

##  <a name="createic"></a>  CDC::CreateIC

Tworzy kontekst informacje dla określonego urządzenia.

```
BOOL CreateIC(
    LPCTSTR lpszDriverName,
    LPCTSTR lpszDeviceName,
    LPCTSTR lpszOutput,
    const void* lpInitData);
```

### <a name="parameters"></a>Parametry

*lpszDriverName*<br/>
Wskazuje ciąg zakończony znakiem null, który określa nazwę pliku (bez rozszerzenia) sterownika urządzenia (na przykład "EPSON"). Możesz przekazać `CString` obiektu dla tego parametru.

*lpszDeviceName*<br/>
Wskazuje ciąg zakończony znakiem null, który określa nazwę określonego urządzenia, są obsługiwane (na przykład "EPSON FX-80"). *LpszDeviceName* parametr jest używany, jeśli moduł obsługuje więcej niż jedno urządzenie. Możesz przekazać `CString` obiektu dla tego parametru.

*lpszOutput*<br/>
Wskazuje ciąg zakończony znakiem null, który określa nazwę pliku lub urządzenia dla średnich wyjściowego fizycznej (pliku lub port). Możesz przekazać `CString` obiektu dla tego parametru.

*lpInitData*<br/>
Punkty danych specyficznych dla urządzenia inicjowania sterownika urządzenia. *LpInitData* parametr musi mieć wartość NULL, jeśli sterownik urządzenia użycia inicjowanie domyślnych (jeśli istnieje), określony przez użytkownika za pomocą Panelu sterowania. Zobacz `CreateDC` dla formatu danych inicjowania specyficznych dla urządzenia.

### <a name="return-value"></a>Wartość zwracana

Wartość różną od zera, jeśli to się powiedzie; w przeciwnym razie 0.

### <a name="remarks"></a>Uwagi

Informacje o kontekście umożliwia szybkie uzyskiwanie informacji dotyczących urządzenia, bez tworzenia kontekstu urządzenia.

Nazwy urządzeń z tymi konwencjami: końcowy dwukropek (:) jest zalecane, ale opcjonalne. Windows usuwa kończący dwukropek, tak, aby nazwa urządzenia, kończąc dwukropek jest mapowany na tym samym porcie taką samą nazwę bez dwukropka. Nazwy sterowników i port nie może zawierać spacji wiodących i końcowych. Nie można używać funkcji danych wyjściowych interfejsu GDI z kontekstami informacji.

##  <a name="deletedc"></a>  CDC::DeleteDC

Ogólnie rzecz biorąc nie wywołuj tej funkcji; destruktor zostanie zrobił dla Ciebie.

```
BOOL DeleteDC();
```

### <a name="return-value"></a>Wartość zwracana

Wartość różną od zera, jeśli funkcja została ukończona pomyślnie; w przeciwnym razie 0.

### <a name="remarks"></a>Uwagi

`DeleteDC` Funkcja członkowska usuwa konteksty urządzenia Windows, które są skojarzone z `m_hDC` w bieżącym `CDC` obiektu. Jeśli ten `CDC` obiekt jest kontekst ostatniego aktywnych urządzeń, dla danego urządzenia, urządzenie zostanie powiadomiony i udostępniane wszystkie zasoby systemu i magazynu używane przez urządzenie.

Aplikacja nie powinien wywoływać `DeleteDC` Jeśli wybrano obiektów do kontekstu urządzenia. Najpierw należy wybrać obiekty poza kontekstem urządzenia przed usunięciem.

Aplikacja nie musi usunąć kontekst urządzenia, którego uchwyt został uzyskany przez wywołanie metody [CWnd::GetDC](../../mfc/reference/cwnd-class.md#getdc). Zamiast tego należy wywołać [CWnd::ReleaseDC](../../mfc/reference/cwnd-class.md#releasedc) zwolnienie kontekstu urządzenia. [Cclientdc —](../../mfc/reference/cclientdc-class.md) i [CWindowDC](../../mfc/reference/cwindowdc-class.md) klasy są dostarczane do opakowania tej funkcji.

`DeleteDC` Funkcja jest zwykle używana do usuwania konteksty urządzenia utworzonych za pomocą [CreateDC](#createdc), [CreateIC](#createic), lub [CreateCompatibleDC](#createcompatibledc).

### <a name="example"></a>Przykład

  Zobacz przykład [CPrintDialog::GetPrinterDC](../../mfc/reference/cprintdialog-class.md#getprinterdc).

##  <a name="deletetempmap"></a>  CDC::DeleteTempMap

Wywoływana automatycznie przez `CWinApp` obsługi czasu bezczynności `DeleteTempMap` usuwa wszystkie tymczasowe `CDC` obiekty utworzone przez `FromHandle`, ale nie niszczy uchwytów kontekstu urządzenia ( `hDC`s) tymczasowo skojarzony `CDC` obiektów.

```
static void PASCAL DeleteTempMap();
```

##  <a name="detach"></a>  CDC::Detach

Wywołaj tę funkcję, aby odłączyć `m_hDC` (kontekst urządzenia dane wyjściowe) z `CDC` obiektu i ustaw obie `m_hDC` i `m_hAttribDC` na wartość NULL.

```
HDC Detach();
```

### <a name="return-value"></a>Wartość zwracana

Windows kontekstu urządzenia.

##  <a name="dptohimetric"></a>  CDC::DPtoHIMETRIC

Tę funkcję możesz przekazać rozmiary HIMETRIC OLE, konwersji HIMETRIC pikseli.

```
void DPtoHIMETRIC(LPSIZE lpSize) const;
```

### <a name="parameters"></a>Parametry

*lpSize*<br/>
Wskazuje [rozmiar](/windows/desktop/api/windef/ns-windef-tagsize) struktury lub [CSize](../../atl-mfc-shared/reference/csize-class.md) obiektu.

### <a name="remarks"></a>Uwagi

W przypadku MM_LOENGLISH, MM_HIENGLISH, MM_LOMETRIC lub MM_HIMETRIC tryb mapowania obiektu kontekstu urządzenia konwersji jest oparty na liczbę pikseli w fizycznych CAL. Jeśli tryb mapowania jest jednym z innych niż ograniczonego trybów (np. MM_TEXT), następnie konwersji opiera się na liczbę pikseli cal logiczny.

##  <a name="dptolp"></a>  CDC::DPtoLP

Konwertuje jednostek logicznych jednostek urządzenia.

```
void DPtoLP(
    LPPOINT lpPoints,
    int nCount = 1) const;

void DPtoLP(LPRECT lpRect) const;
void DPtoLP(LPSIZE lpSize) const;
```

### <a name="parameters"></a>Parametry

*lpPoints*<br/>
Wskazuje na tablicę [punktu](/windows/desktop/api/windef/ns-windef-tagpoint) struktury lub [CPoint](../../atl-mfc-shared/reference/cpoint-class.md) obiektów.

*nCount*<br/>
Liczba punktów w tablicy.

*lpRect*<br/>
Wskazuje [Prostokąt](/windows/desktop/api/windef/ns-windef-tagrect) struktury lub [CRect](../../atl-mfc-shared/reference/crect-class.md) obiektu. Ten parametr jest używany w przypadku prostych konwersji prostokąt jednego z punktów na urządzenie logiczne punktów.

*lpSize*<br/>
Wskazuje [rozmiar](/windows/desktop/api/windef/ns-windef-tagsize) struktury lub [CSize](../../atl-mfc-shared/reference/csize-class.md) obiektu.

### <a name="remarks"></a>Uwagi

Funkcja map, współrzędne każdego punktu lub wymiaru o rozmiarze, z system współrzędnych urządzenia do firmy GDI logiczne współrzędnych. Konwersja zależy od tego, bieżący tryb mapowania i ustawienia źródła i zakresów dla okna i okienka ekranu urządzenia.

##  <a name="draw3drect"></a>  CDC::Draw3dRect

Wywołaj tę funkcję elementu członkowskiego, aby narysować prostokąt trójwymiarowej.

```
void Draw3dRect(
    LPCRECT lpRect,
    COLORREF clrTopLeft,
    COLORREF clrBottomRight);

void Draw3dRect(
    int x,
    int y,
    int cx,
    int cy,
    COLORREF clrTopLeft,
    COLORREF clrBottomRight);
```

### <a name="parameters"></a>Parametry

*lpRect*<br/>
Określa prostokąt otaczający (w jednostkach logicznych). Można przekazać wskaźnik do [Prostokąt](/windows/desktop/api/windef/ns-windef-tagrect) struktury lub [CRect](../../atl-mfc-shared/reference/crect-class.md) obiektu dla tego parametru.

*clrTopLeft*<br/>
Określa kolor górnej i lewej strony trójwymiarowej prostokąta.

*clrBottomRight*<br/>
Określa kolor dolnej i prawej krawędzi prostokąta trójwymiarowej.

*x*<br/>
Określa logiczną współrzędną x lewego górnego rogu prostokąta trójwymiarowej.

*y*<br/>
Określa logiczną współrzędną y lewego górnego rogu prostokąta trójwymiarowej.

*cx*<br/>
Określa szerokość prostokąta trójwymiarowej.

*cy*<br/>
Określa wysokość prostokąta trójwymiarowej.

### <a name="remarks"></a>Uwagi

Prostokąt będzie rysowany przy użyciu górnej i lewej strony kolor określony przez *clrTopLeft* i dolnej i prawej stronie kolor określony przez *clrBottomRight*.

### <a name="example"></a>Przykład

[!code-cpp[NVC_MFCDocView#33](../../mfc/codesnippet/cpp/cdc-class_5.cpp)]

##  <a name="drawdragrect"></a>  CDC::DrawDragRect

Wywołanie tej funkcji elementu członkowskiego, aby narysować ponownie prostokąt przeciągania.

```
void DrawDragRect(
    LPCRECT lpRect,
    SIZE size,
    LPCRECT lpRectLast,
    SIZE sizeLast,
    CBrush* pBrush = NULL,
    CBrush* pBrushLast = NULL);
```

### <a name="parameters"></a>Parametry

*lpRect*<br/>
Wskazuje [Prostokąt](/windows/desktop/api/windef/ns-windef-tagrect) struktury lub [CRect](../../atl-mfc-shared/reference/crect-class.md) obiekt, który określa logiczny współrzędnych prostokąta — w tym przypadku pozycja końcowa prostokąta jest narysowany ponownie.

*Rozmiar*<br/>
Określa przesunięcie w lewym górnym rogu zewnętrznej krawędzi do lewego górnego rogu wewnętrznego obramowania prostokąta (czyli grubość obramowania).

*lpRectLast*<br/>
Wskazuje [Prostokąt](/windows/desktop/api/windef/ns-windef-tagrect) struktury lub [CRect](../../atl-mfc-shared/reference/crect-class.md) obiekt, który określa współrzędne logiczne pozycja prostokąta — w tym przypadku początkowe położenie prostokąt, odświeżana, trwa.

*sizeLast*<br/>
Określa przesunięcie w lewym górnym rogu zewnętrznej krawędzi do lewego górnego rogu wewnętrznego obramowania (czyli grubość obramowania) oryginalnego prostokąta jest narysowany ponownie.

*pBrush*<br/>
Wskaźnik do obiektu pędzla. Używać domyślny pędzel półtonów jest ustawiana wartość NULL.

*pBrushLast*<br/>
Wskaźnik do ostatniego obiekt pędzel używany. Używać domyślny pędzel półtonów jest ustawiana wartość NULL.

### <a name="remarks"></a>Uwagi

Wywołać go w pętli, jak przykładowa położenia kursora myszy, aby dać wizualną opinię. Gdy wywołujesz `DrawDragRect`, są usuwane w poprzednim prostokąt i jest rysowana nową. Na przykład, jako użytkownik przeciąga prostokąt na ekranie `DrawDragRect` będzie wymazać oryginalnego prostokąt i ponownie narysuj nową w jego nowego położenia. Domyślnie `DrawDragRect` rysuje prostokąt pędzlem półtonów wyeliminować migotania oraz utworzyć wygląd płynnie przenoszenie prostokąta.

Przy pierwszym wywołaniu `DrawDragRect`, *lpRectLast* parametru powinna być równa NULL.

##  <a name="drawedge"></a>  CDC::DrawEdge

Wywołaj tę funkcję elementu członkowskiego, aby narysować krawędzi prostokąta o określonym typie i stylu.

```
BOOL DrawEdge(
    LPRECT lpRect,
    UINT nEdge,
    UINT nFlags);
```

### <a name="parameters"></a>Parametry

*lpRect*<br/>
Wskaźnik do `RECT` strukturę, która zawiera logiczne współrzędnych prostokąta.

*nEdge*<br/>
Określa typ wewnętrznych i zewnętrznych urządzeniami brzegowymi w celu rysowania. Ten parametr musi być kombinacją jedną flagę wewnętrznego obramowania i jedną flagę zewnętrznego obramowania. Zobacz [DrawEdge](/windows/desktop/api/winuser/nf-winuser-drawedge) w zestawie Windows SDK dla tabeli typów parametrów.

*nFlags*<br/>
Flagi określające typ ma być rysowane obramowanie. Zobacz `DrawEdge` w zestawie Windows SDK dla tabeli wartości parametru. Dla linii ukośnych flagi BF_RECT Określ punkt końcowy wektora ograniczany przez parametr prostokąta.

### <a name="return-value"></a>Wartość zwracana

Wartość różną od zera, jeśli to się powiedzie; w przeciwnym razie 0.

##  <a name="drawescape"></a>  CDC::DrawEscape

Uzyskuje dostęp do rysowania możliwości wyświetlania wideo, które nie są bezpośrednio dostępne za pośrednictwem graficzny interfejs urządzenia (GDI).

```
int DrawEscape(
    int nEscape,
    int nInputSize,
    LPCSTR lpszInputData);
```

### <a name="parameters"></a>Parametry

*nEscape*<br/>
Określa funkcję ucieczki do wykonania.

*nInputSize*<br/>
Określa liczbę bajtów danych wskazywanego przez *lpszInputData* parametru.

*lpszInputData*<br/>
Wskazuje strukturę danych wejściowych, wymagane dla określonego znak ucieczki.

### <a name="return-value"></a>Wartość zwracana

Określa wynik funkcji. Większa od zera, jeśli to się powiedzie, z wyjątkiem QUERYESCSUPPORT ucieczki rysowania, które sprawdza, czy są dostępne tylko w implementacji lub zero, jeśli znak ucieczki nie jest zaimplementowana; lub mniejsza niż zero, jeśli błąd wystąpił.

### <a name="remarks"></a>Uwagi

Kiedy aplikacja wywołuje `DrawEscape`, danych, identyfikowany przez *nInputSize* i *lpszInputData* jest przekazywana bezpośrednio do wyświetlania określonego sterownika.

##  <a name="drawfocusrect"></a>  CDC::DrawFocusRect

Rysuje prostokąt w stylu używany do wskazania, że prostokąt ma fokus.

```
void DrawFocusRect(LPCRECT lpRect);
```

### <a name="parameters"></a>Parametry

*lpRect*<br/>
Wskazuje [Prostokąt](/windows/desktop/api/windef/ns-windef-tagrect) struktury lub [CRect](../../atl-mfc-shared/reference/crect-class.md) obiekt, który określa logiczny współrzędnych prostokąta do narysowania.

### <a name="remarks"></a>Uwagi

Ponieważ jest to funkcja logicznego XOR, wywołaniu tej funkcji po raz drugi z tego samego prostokąt usuwa prostokąt z widoku. Nie mogą być przewijane prostokąt rysowane przez tę funkcję. Aby przewijać obszar zawierający prostokąt rysowane przez tę funkcję, należy najpierw wywołać `DrawFocusRect` do usunięcia prostokąt z ekranu, następnie przewiń listę w obszarze, a następnie wywołaj `DrawFocusRect` ponownie, aby narysować prostokąt w nowym miejscu.

> [!CAUTION]
> `DrawFocusRect` działa tylko w trybie MM_TEXT. W innych trybach ta funkcja nie Rysuj prostokąt fokusu poprawnie, ale nie zwraca wartości błędu.

##  <a name="drawframecontrol"></a>  CDC::DrawFrameControl

Wywołaj tę funkcję elementu członkowskiego, aby narysować formantu ramki określonego typu i stylu.

```
BOOL DrawFrameControl(
    LPRECT lpRect,
    UINT nType,
    UINT nState);
```

### <a name="parameters"></a>Parametry

*lpRect*<br/>
Wskaźnik do `RECT` strukturę, która zawiera logiczne współrzędnych prostokąta.

*nType*<br/>
Określa typ formant ramki do rysowania. Zobacz *uType* parametru w [DrawFrameControl](/windows/desktop/api/winuser/nf-winuser-drawframecontrol) w zestawie SDK Windows, aby uzyskać listę możliwych wartości tego parametru.

*nState*<br/>
Określa początkowy stan formant ramki. Może być przynajmniej jedna z wartości opisanych dla *uState* parametr `DrawFrameControl` w zestawie Windows SDK. Użyj *nInformacje* wartość DFCS_ADJUSTRECT, aby dopasować prostokąt otaczający, aby wykluczyć otaczającego krawędzi przycisku polecenia.

### <a name="return-value"></a>Wartość zwracana

Wartość różną od zera, jeśli to się powiedzie; w przeciwnym razie 0.

### <a name="remarks"></a>Uwagi

W kilku przypadkach *nInformacje* zależy od *nNie* parametru. Na poniższej liście przedstawiono relacje między cztery *nNie* wartości i *nInformacje*:

- DFC_BUTTON

    - Przycisk trójstanowych DFCS_BUTTON3STATE

    - Pole Sprawdź DFCS_BUTTONCHECK

    - Wypychanie DFCS_BUTTONPUSH przycisku

    - Przycisk radiowy DFCS_BUTTONRADIO

    - DFCS_BUTTONRADIOIMAGE obrazu dla przycisku radiowego (o niekwadratowych wymaga obrazu)

    - Maska DFCS_BUTTONRADIOMASK dla przycisku radiowego (o niekwadratowych wymaga maska)

- DFC_CAPTION

    - Przycisk Zamknij DFCS_CAPTIONCLOSE

    - Przycisk Pomoc DFCS_CAPTIONHELP

    - Przycisk maksymalizacji DFCS_CAPTIONMAX

    - Przycisk Minimalizuj DFCS_CAPTIONMIN

    - Przycisk Przywróć DFCS_CAPTIONRESTORE

- DFC_MENU

    - Strzałka DFCS_MENUARROW podmenu

    - DFCS_MENUBULLET Bullet

    - DFCS_MENUCHECK Check mark

- DFC_SCROLL

    - Pasek przewijania w polu kombi DFCS_SCROLLCOMBOBOX

    - Strzałka w dół DFCS_SCROLLDOWN, pasek przewijania jest widoczny

    - Strzałka w lewo DFCS_SCROLLLEFT paska przewijania

    - Strzałka w prawo DFCS_SCROLLRIGHT paska przewijania

    - Uchwyt zmiany rozmiaru DFCS_SCROLLSIZEGRIP, w prawym dolnym rogu okna

    - Strzałka w górę DFCS_SCROLLUP, pasek przewijania jest widoczny

### <a name="example"></a>Przykład

Ten kod rysuje uchwyt rozmiaru w prawym dolnym rogu okna. Jest ona odpowiednia dla `OnPaint` obsługi okno dialogowe, które ma nie stylów i normalnie nie zawiera inne kontrolki (np. paska stanu), które może nadać mu rozmiar uchwytu.

[!code-cpp[NVC_MFCDocView#34](../../mfc/codesnippet/cpp/cdc-class_6.cpp)]

##  <a name="drawicon"></a>  CDC::DrawIcon

Rysuje ikony na urządzeniu, reprezentowane przez bieżącą `CDC` obiektu.

```
BOOL DrawIcon(
    int x,
    int y,
    HICON hIcon);

BOOL DrawIcon(
    POINT point,
    HICON hIcon);
```

### <a name="parameters"></a>Parametry

*x*<br/>
Określa logiczną współrzędną x lewego górnego rogu ikony.

*y*<br/>
Określa logiczną współrzędną y lewego górnego rogu ikony.

*hIcon*<br/>
Identyfikuje uchwyt ikony do narysowania.

*Punkt*<br/>
Określa logiczną - współrzędnych x i y lewego górnego rogu ikony. Możesz przekazać [punktu](/windows/desktop/api/windef/ns-windef-tagpoint) struktury lub [CPoint](../../atl-mfc-shared/reference/cpoint-class.md) obiektu dla tego parametru.

### <a name="return-value"></a>Wartość zwracana

Wartość różną od zera, jeśli funkcja została ukończona pomyślnie; w przeciwnym razie 0.

### <a name="remarks"></a>Uwagi

Funkcja umieszcza ikonę w prawym górnym rogu w lokalizacji określonej przez *x* i *y*. Lokalizacja podlega bieżący tryb mapowania kontekstu urządzenia.

Zasobu ikony musi zostały wcześniej załadowane za pomocą funkcji `CWinApp::LoadIcon`, `CWinApp::LoadStandardIcon`, lub `CWinApp::LoadOEMIcon`. `MM_TEXT` Przed użyciem tej funkcji należy wybrać tryb mapowania.

### <a name="example"></a>Przykład

  Zobacz przykład [CWnd::IsIconic](../../mfc/reference/cwnd-class.md#isiconic).

##  <a name="drawstate"></a>  CDC::DrawState

Wywołaj tę funkcję elementu członkowskiego wyświetlania obrazu i Zastosuj efekt wizualny do wskazania stanu, takie jak wyłączone lub stanu domyślnego.

> [!NOTE]
>  Dla wszystkich *Usuń flagę ze* stanów z wyjątkiem DSS_NORMAL, obraz, który jest konwertowany na monochromatyczny, przed zastosowaniem efekt wizualny.

```
BOOL DrawState(
    CPoint pt,
    CSize size,
    HBITMAP hBitmap,
    UINT nFlags,
    HBRUSH hBrush = NULL);

BOOL DrawState(
    CPoint pt,
    CSize size,
    CBitmap* pBitmap,
    UINT nFlags,
    CBrush* pBrush = NULL);

BOOL DrawState(
    CPoint pt,
    CSize size,
    HICON hIcon,
    UINT nFlags,
    HBRUSH hBrush = NULL);

BOOL DrawState(
    CPoint pt,
    CSize size,
    HICON hIcon,
    UINT nFlags,
    CBrush* pBrush = NULL);

BOOL DrawState(
    CPoint pt,
    CSize size,
    LPCTSTR lpszText,
    UINT nFlags,
    BOOL bPrefixText = TRUE,
    int nTextLen = 0,
    HBRUSH hBrush = NULL);

BOOL DrawState(
    CPoint pt,
    CSize size,
    LPCTSTR lpszText,
    UINT nFlags,
    BOOL bPrefixText = TRUE,
    int nTextLen = 0,
    CBrush* pBrush = NULL);

BOOL DrawState(
    CPoint pt,
    CSize size,
    DRAWSTATEPROC lpDrawProc,
    LPARAM lData,
    UINT nFlags,
    HBRUSH hBrush = NULL);

BOOL DrawState(
    CPoint pt,
    CSize size,
    DRAWSTATEPROC lpDrawProc,
    LPARAM lData,
    UINT nFlags,
    CBrush* pBrush = NULL);
```

### <a name="parameters"></a>Parametry

*(czas pacyficzny)*<br/>
Określa lokalizację obrazu.

*Rozmiar*<br/>
Określa rozmiar obrazu.

*hBitmap*<br/>
Dojście do mapy bitowej.

*nFlags*<br/>
Flagi, które określają typ obrazu i stanu. Zobacz [DrawState](/windows/desktop/api/winuser/nf-winuser-drawstatea) w zestawie Windows SDK dla możliwe *nFlags* typów i stanów.

*hBrush*<br/>
Dojście do pędzla.

*pBitmap*<br/>
Wskaźnik do obiektu CBitmap.

*pBrush*<br/>
Wskaźnik do obiektu CBrush.

*hIcon*<br/>
Dojście do ikony.

*lpszText*<br/>
Wskaźnik na tekst.

*bPrefixText*<br/>
Tekst, który może zawierać skrót klawiszowy akceleratora. *LData* parametr określa adres ciągu, a *nTextLen* parametr określa długość. Jeśli *nTextLen* wynosi 0, ciąg jest zakłada się, że zakończony znakiem null.

*nTextLen*<br/>
Długość ciągu tekstowego, wskazywana przez *lpszText*. Jeśli *nTextLen* wynosi 0, ciąg jest zakłada się, że zakończony znakiem null.

*lpDrawProc*<br/>
Wskaźnik do funkcji wywołania zwrotnego, używany do renderowania obrazu. Ten parametr jest wymagany, jeśli obraz wpisać *nFlags* jest DST_COMPLEX. Jest opcjonalne i może mieć wartość NULL, jeśli typ obrazu jest DST_TEXT. Ten parametr jest ignorowany dla innych typów obrazu. Aby uzyskać więcej informacji na temat funkcji wywołania zwrotnego, zobacz [DrawStateProc](/windows/desktop/api/winuser/nc-winuser-drawstateproc) funkcji w zestawie Windows SDK.

*lData*<br/>
Określa informacje o obrazie. Znaczenie tego parametru, zależy od typu obraz.

### <a name="return-value"></a>Wartość zwracana

Wartość różną od zera, jeśli to się powiedzie; w przeciwnym razie 0.

##  <a name="drawtext"></a>  CDC::DrawText

Wywołaj tę funkcję elementu członkowskiego do formatowania tekstu w prostokącie danego. Aby określić dodatkowe opcje formatowania, użyj [CDC::DrawTextEx](#drawtextex).

```
virtual int DrawText(
    LPCTSTR lpszString,
    int nCount,
    LPRECT lpRect,
    UINT nFormat);

int DrawText(
    const CString& str,
    LPRECT lpRect,
    UINT nFormat);
```

### <a name="parameters"></a>Parametry

*lpszString*<br/>
Wskazuje ciąg znaków do rysowania. Jeśli *nCount* wynosi -1, ciąg musi być zakończony znakiem null.

*nCount*<br/>
Określa liczbę znaków w ciągu. Jeśli *nCount* jest -1, następnie *lpszString* zakłada, że długie wskaźnik na ciąg zakończony znakiem null i `DrawText` automatycznie oblicza liczbę znaków.

*lpRect*<br/>
Wskazuje [Prostokąt](/windows/desktop/api/windef/ns-windef-tagrect) struktury lub [CRect](../../atl-mfc-shared/reference/crect-class.md) obiekt, który zawiera prostokąt (we współrzędnych logicznego) w którym ma być sformatowany tekst.

*str*<br/>
A [CString](../../atl-mfc-shared/reference/cstringt-class.md) obiekt, który zawiera określony znaki do rysowania.

*nFormat*<br/>
Określa metodę formatowania tekstu. Może być dowolną kombinacją wartości opisanych dla *uFormat* parametru w [DrawText](/windows/desktop/api/winuser/nf-winuser-drawtext) w zestawie Windows SDK. (Połącz je przy użyciu bitowego operatora OR):

> [!NOTE]
>  Niektóre *uFormat* kombinacje flagi może spowodować, że przekazany ciąg do zmodyfikowania. Przy DT_MODIFYSTRING DT_END_ELLIPSIS lub DT_PATH_ELLIPSIS może spowodować, że ciąg, który może zostać zmodyfikowany, co powoduje potwierdzenie w `CString` zastąpienia. Nie można użyć wartości DT_CALCRECT, DT_EXTERNALLEADING, DT_INTERNAL, DT_NOCLIP i DT_NOPREFIX wartością DT_TABSTOP.

### <a name="return-value"></a>Wartość zwracana

Wysokość tekstu, jeśli funkcja się powiedzie.

### <a name="remarks"></a>Uwagi

Jego formatowania tekstu, rozwijając karty do odpowiednich miejsc do magazynowania, wyrównanie tekstu w lewo, prawo, lub Centrum danego prostokąt i podzielenie tekst na wiersze, które mieszczą się w danym prostokąta. Typ formatowania jest określany przez *nFormat*.

Ta funkcja członkowska używa wybranej czcionki, kolor tekstu i kolor tła kontekstu urządzenia ma zostać narysowany tekst. O ile nie jest używany DT_NOCLIP format, `DrawText` przycina tekst tak, aby tekst nie pojawia się poza danego prostokąta. Całego formatowania zakłada się, że ma wiele wierszy, o ile nie jest podany w formacie DT_SINGLELINE.

Jeśli wybrana czcionka jest zbyt duży dla określonego prostokąta `DrawText` funkcji składowej nie jest podejmowana próba zastąpienia mniejszej czcionki.

Jeśli określono flagę DT_CALCRECT, prostokąt określony przez *lprect —* zostanie zaktualizowana w celu odzwierciedlenia szerokość i wysokość potrzebne ma zostać narysowany tekst.

Jeśli została ustawiona flaga wyrównanie tekstu TA_UPDATECP (zobacz [CDC::SetTextAlign](#settextalign)), `DrawText` będzie wyświetlany tekst uruchamianie w bieżącym położeniu, a nie na lewo od danego prostokąta. `DrawText` nie będzie zawijany tekstu, jeśli została ustawiona flaga TA_UPDATECP (czyli flagi DT_WORDBREAK nie odniesie skutku).

Kolor tekstu może być ustawiona [CDC::SetTextColor](#settextcolor).

##  <a name="drawtextex"></a>  CDC::DrawTextEx

Formatuje tekst w prostokącie danego.

```
virtual int DrawTextEx(
    LPTSTR lpszString,
    int nCount,
    LPRECT lpRect,
    UINT nFormat,
    LPDRAWTEXTPARAMS lpDTParams);

int DrawTextEx(
    const CString& str,
    LPRECT lpRect,
    UINT nFormat,
    LPDRAWTEXTPARAMS lpDTParams);
```

### <a name="parameters"></a>Parametry

*lpszString*<br/>
Wskazuje ciąg znaków do rysowania. Jeśli *nCount* wynosi -1, ciąg musi być zakończone znakiem null.

*nCount*<br/>
Określa liczbę znaków w ciągu. Jeśli *nCount* jest -1, następnie *lpszString* zakłada, że długie wskaźnik na ciąg zakończony znakiem null i `DrawText` automatycznie oblicza liczbę znaków.

*lpRect*<br/>
Wskazuje [Prostokąt](/windows/desktop/api/windef/ns-windef-tagrect) struktury lub [CRect](../../atl-mfc-shared/reference/crect-class.md) obiekt, który zawiera prostokąt (we współrzędnych logicznego) w którym ma być sformatowany tekst.

*str*<br/>
A [CString](../../atl-mfc-shared/reference/cstringt-class.md) obiekt, który zawiera określony znaki do rysowania.

*nFormat*<br/>
Określa metodę formatowania tekstu. Może być dowolną kombinacją wartości opisanych dla *uFormat* parametru w [DrawText](/windows/desktop/api/winuser/nf-winuser-drawtext) w zestawie Windows SDK. (Połącz użycie operatora testu koniunkcji **lub** operator):

> [!NOTE]
>  Niektóre *uFormat* kombinacje flagi może spowodować, że przekazany ciąg do zmodyfikowania. Przy DT_MODIFYSTRING DT_END_ELLIPSIS lub DT_PATH_ELLIPSIS może spowodować, że ciąg, który może zostać zmodyfikowany, co powoduje potwierdzenie w `CString` zastąpienia. Nie można użyć wartości DT_CALCRECT, DT_EXTERNALLEADING, DT_INTERNAL, DT_NOCLIP i DT_NOPREFIX wartością DT_TABSTOP.

*lpDTParams*<br/>
Wskaźnik do [DRAWTEXTPARAMS](/windows/desktop/api/winuser/ns-winuser-tagdrawtextparams) strukturę, która określa formatowanie dodatkowe opcje. Ten parametr może mieć wartości NULL.

### <a name="remarks"></a>Uwagi

Jego formatowania tekstu, rozwijając karty do odpowiednich miejsc do magazynowania, wyrównanie tekstu w lewo, prawo, lub Centrum danego prostokąt i podzielenie tekst na wiersze, które mieszczą się w danym prostokąta. Typ formatowania jest określany przez *nFormat* i *lpDTParams*. Aby uzyskać więcej informacji, zobacz [CDC::DrawText](#drawtext) i [DrawTextEx](/windows/desktop/api/winuser/nf-winuser-drawtextexa) w zestawie Windows SDK.

Kolor tekstu może być ustawiona [CDC::SetTextColor](#settextcolor).

##  <a name="ellipse"></a>  CDC::Ellipse

Rysuje elipsę.

```
BOOL Ellipse(
    int x1,
    int y1,
    int x2,
    int y2);

BOOL Ellipse(LPCRECT lpRect);
```

### <a name="parameters"></a>Parametry

*x1*<br/>
Określa logiczną współrzędną x lewego górnego rogu prostokąt otaczający elipsy.

*y1*<br/>
Określa logiczną współrzędną y lewego górnego rogu prostokąt otaczający elipsy.

*x2*<br/>
Określa logiczną współrzędną x w prawym dolnym rogu prostokąt otaczający elipsy.

*y2*<br/>
Określa logiczną współrzędną y prawego dolnego rogu prostokąt otaczający elipsy.

*lpRect*<br/>
Określa, że elipsy użytkownika prostokąt ograniczający. Można również przekazać [CRect](../../atl-mfc-shared/reference/crect-class.md) obiektu dla tego parametru.

### <a name="return-value"></a>Wartość zwracana

Różne od zera, jeśli funkcja zakończyła się pomyślnie; w przeciwnym razie 0.

### <a name="remarks"></a>Uwagi

Środek elipsy jest środek prostokąt otaczający określony przez *x1*, *y1*, *x2*, i *y2*, lub  *lprect —*. Elipsy jest rysowany przy użyciu bieżącego pióra, a jego wewnętrznych jest wypełniany aktualny pędzel.

Rysunek rysowane przez tę funkcję rozciąga się do, ale nie zawiera współrzędne po prawej stronie i u dołu. Oznacza, że wysokość rysunku *y2* - *y1* i szerokość rysunku jest *x2* - *x1*.

Jeśli szerokość lub wysokość prostokąt otaczający ma wartość 0, jest rysowana nie elipsy.

##  <a name="enddoc"></a>  CDC::EndDoc

Kończy zadanie drukowania, uruchomione przez wywołanie do [StartDoc](#startdoc) funkcja elementu członkowskiego.

```
int EndDoc();
```

### <a name="return-value"></a>Wartość zwracana

Większa lub równa 0, jeśli funkcja się powiedzie, lub wartość ujemną, jeśli wystąpił błąd.

### <a name="remarks"></a>Uwagi

Ta funkcja elementu członkowskiego zastępuje znak ucieczki ENDDOC drukarki i powinna być wywoływana bezpośrednio po zakończeniu pomyślne zadania drukowania.

Jeśli aplikacja napotka błąd drukowania lub anulowanych operacji wydruku, nie należy spróbować zakończyć operację przy użyciu `EndDoc` lub [AbortDoc](#abortdoc). GDI automatycznie kończy operację przed zwróceniem wartości błędu.

Ta funkcja powinna nie można używać wewnątrz metapliki.

### <a name="example"></a>Przykład

  Zobacz przykład [CDC::StartDoc](#startdoc).

##  <a name="endpage"></a>  CDC::EndPage

Informuje urządzenie, że aplikacja została zakończona zapisywania strony.

```
int EndPage();
```

### <a name="return-value"></a>Wartość zwracana

Większa lub równa 0, jeśli funkcja się powiedzie, lub wartość ujemną, jeśli wystąpił błąd.

### <a name="remarks"></a>Uwagi

Ta funkcja elementu członkowskiego zwykle jest używana do kierowania sterownika urządzenia, aby przejść do nowej strony.

Ta funkcja elementu członkowskiego zastępuje znak ucieczki NEWFRAME drukarki. W odróżnieniu od NEWFRAME ta funkcja zawsze jest wywoływana po drukowanie strony.

### <a name="example"></a>Przykład

  Zobacz przykład [CDC::StartDoc](#startdoc).

##  <a name="endpath"></a>  CDC::EndPath

Zamyka nawiasu ścieżki i wybiera ścieżkę zdefiniowaną przez nawias do kontekstu urządzenia.

```
BOOL EndPath();
```

### <a name="return-value"></a>Wartość zwracana

Różne od zera, jeśli funkcja zakończyła się pomyślnie; w przeciwnym razie 0.

### <a name="example"></a>Przykład

  Zobacz przykład [CDC::BeginPath](#beginpath).

##  <a name="enumobjects"></a>  CDC::EnumObjects

Wylicza pióra i pędzle dostępne w kontekście urządzenia.

```
int EnumObjects(
    int nObjectType,
    int (CALLBACK* lpfn)(
    LPVOID,
    LPARAM),
    LPARAM lpData);
```

### <a name="parameters"></a>Parametry

*nObjectType*<br/>
Określa typ obiektu. Może mieć wartości OBJ_BRUSH lub OBJ_PEN.

*lpfn*<br/>
Jest adresem instancję procedury, dostarczone przez aplikację funkcji wywołania zwrotnego. Zobacz poniżej sekcję "Uwagi".

*lpData*<br/>
Punkty danych dostarczone przez aplikację. Dane są przekazywane do funkcji wywołania zwrotnego oraz informacji o obiekcie.

### <a name="return-value"></a>Wartość zwracana

Określa ostatnią wartość zwrócona przez [funkcji wywołania zwrotnego](callback-functions-used-by-mfc.md#enum_objects). Jego znaczenie jest zdefiniowane przez użytkownika.

### <a name="remarks"></a>Uwagi

Dla każdego obiektu danego typu funkcji wywołania zwrotnego, który jest przekazywany jest wywoływana z informacjami dla tego obiektu. System wywołuje funkcję wywołania zwrotnego, dopóki nie ma żadnych więcej obiektów lub funkcji wywołania zwrotnego zwraca wartość 0.

Należy pamiętać, że nowe funkcje programu Microsoft Visual C++ pozwala użyć zwykłej funkcji jako funkcja przekazywany do `EnumObjects`. Adres jest przekazywany do `EnumObjects` jest wskaźnikiem do funkcji wyeksportowanej z **WYEKSPORTOWAĆ** i konwencji wywoływania języka Pascal. W trybie ochrony aplikacji nie trzeba Utwórz tę funkcję za pomocą funkcji Windows MakeProcInstance lub bezpłatnych funkcji po użyciu za pomocą funkcji Windows FreeProcInstance.

Również trzeba wyeksportować nazwy funkcji w **EKSPORTY** instrukcja w pliku definicji modułu Twojej aplikacji. Zamiast tego można użyć **WYEKSPORTOWAĆ** funkcji modyfikator, podobnie jak w

**int WYEKSPORTOWAĆ wywołania zwrotnego** AFunction **(LPSTR**, **LPSTR);**

Aby spowodować, że kompilator będzie rekordu odpowiednie eksportu do eksportu o nazwie bez aliasów. Działa to w przypadku większości potrzeb. W specjalnych przypadkach, takich jak eksportowanie funkcji przez numer lub aliasów eksportu, nadal należy użyć **EKSPORTY** instrukcja w pliku definicji modułu.

Do kompilowania programów Microsoft Foundation, zwykle użyjesz /GA i /GEs — opcje kompilatora. /Gw — opcja kompilatora nie jest używana w przypadku klas Microsoft Foundation. (Jeśli jest używana funkcja Windows `MakeProcInstance`, konieczne będzie jawne rzutowanie wskaźnika zwróconej funkcji z FARPROC typowi potrzebne w tym interfejsie API.) Wywołanie zwrotne rejestracji interfejsy są teraz bezpieczny (należy przekazać w wskaźnik funkcji, wskazujący rodzaj funkcji do wywołania zwrotnego).

Należy również zauważyć, że wszystkie funkcje wywołania zwrotnego musi przechwytują wyjątki Microsoft Foundation przed zwróceniem do Windows, ponieważ nie może być zgłaszane wyjątki granice wywołania zwrotnego. Aby uzyskać więcej informacji na temat wyjątków, zobacz artykuł [wyjątki](../../mfc/exception-handling-in-mfc.md).

### <a name="example"></a>Przykład

[!code-cpp[NVC_MFCDocView#35](../../mfc/codesnippet/cpp/cdc-class_7.cpp)]

##  <a name="escape"></a>  CDC::Escape

Ta funkcja członkowska jest praktycznie przestarzałe w programowaniu Win32.

```
virtual int Escape(
    int nEscape,
    int nCount,
    LPCSTR lpszInData,
    LPVOID lpOutData);

int Escape(
    int nEscape,
    int nInputSize,
    LPCSTR lpszInputData,
    int nOutputSize,
    LPSTR lpszOutputData);
```

### <a name="parameters"></a>Parametry

*nEscape*<br/>
Określa funkcję ucieczki do wykonania.

Aby uzyskać pełną listę funkcji ucieczki, zobacz [ucieczki](/windows/desktop/api/wingdi/nf-wingdi-escape) w zestawie Windows SDK.

*nCount*<br/>
Określa liczbę bajtów danych wskazywanego przez *lpszInData*.

*lpszInData*<br/>
Wskazuje strukturę danych wejściowych wymaganych dla tego ucieczki.

*lpOutData*<br/>
Wskazuje strukturę, która będzie odbierać dane wyjściowe z tego ucieczki. *LpOutData* parametr ma wartość NULL, jeśli są zwracane żadne dane.

*nInputSize*<br/>
Określa liczbę bajtów danych wskazywanego przez *lpszInputData* parametru.

*lpszInputData*<br/>
Wskazuje strukturę danych wejściowych, wymagane dla określonego znak ucieczki.

*nOutputSize*<br/>
Określa liczbę bajtów danych wskazywanego przez *lpszOutputData* parametru.

*lpszOutputData*<br/>
Wskazuje strukturę, która odbiera dane wyjściowe z tego ucieczki. Ten parametr powinien mieć wartości NULL, jeśli zwrócone żadne dane.

### <a name="return-value"></a>Wartość zwracana

Dodatnia wartość jest zwracana, jeśli funkcja się powiedzie, z wyjątkiem escape QUERYESCSUPPORT sprawdza tylko dla implementacji. Zero jest zwracany, jeśli znak ucieczki nie jest zaimplementowana. Wartość ujemna jest zwracany, jeśli wystąpił błąd. Poniżej przedstawiono typowe wartości błędów:

- Błąd ogólny SP_ERROR.

- Nie SP_OUTOFDISK wystarczającej ilości miejsca na dysku jest obecnie dostępna dla buforowania i miejsca staną się dostępne.

- Nie SP_OUTOFMEMORY wystarczającą ilość pamięci dostępnej dla buforowania.

- Użytkownik SP_USERABORT zakończone zadania przy użyciu Menedżera wydruku.

### <a name="remarks"></a>Uwagi

Z oryginalnego sekwencje ucieczki drukarki tylko QUERYESCSUPPORT jest obsługiwana dla aplikacji Win32. Wszystkie inne sekwencje ucieczki drukarki są przestarzałe i są obsługiwane tylko na potrzeby utrzymywania zgodności z 16-bitowych aplikacji.

W programowaniu Win32 `CDC` udostępnia teraz sześć funkcji Członkowskich, które zastępują ich odpowiednich wyprowadza drukarki:

- [CDC::AbortDoc](#abortdoc)

- [CDC::EndDoc](#enddoc)

- [CDC::EndPage](#endpage)

- [CDC::SETABORTPROC](#setabortproc)

- [CDC::StartDoc](#startdoc)

- [CDC::StartPage](#startpage)

Ponadto [rc_bitblt](#getdevicecaps) obsługuje indeksy Win32, które zastępują inne wyprowadza drukarki. Zobacz [GetDeviceCaps](/windows/desktop/api/wingdi/nf-wingdi-getdevicecaps) w zestawie Windows SDK, aby uzyskać więcej informacji.

Ta funkcja elementu członkowskiego zezwala aplikacjom na dostęp do urządzenia określonego urządzenia, które nie są bezpośrednio dostępne za pośrednictwem interfejsu GDI.

Jeśli aplikacja używa ucieczki wstępnie zdefiniowane wartości, należy użyć pierwszej wersji. Druga wersja należy użyć, jeśli aplikacja definiuje wartości prywatne ucieczki. Zobacz [ExtEscape](/windows/desktop/api/wingdi/nf-wingdi-extescape) w zestawie SDK Windows, aby uzyskać więcej informacji o drugiej wersji.

##  <a name="excludecliprect"></a>  CDC::ExcludeClipRect

Tworzy nowy region wycinek, który składa się z istniejącym regionem wycinka pomniejszoną o określony prostokąt.

```
int ExcludeClipRect(
    int x1,
    int y1,
    int x2,
    int y2);

int ExcludeClipRect(LPCRECT lpRect);
```

### <a name="parameters"></a>Parametry

*x1*<br/>
Określa logiczną współrzędną x lewego górnego rogu prostokąta.

*y1*<br/>
Określa logiczną współrzędną y lewego górnego rogu prostokąta.

*x2*<br/>
Określa logiczną współrzędną x w prawym dolnym rogu prostokąta.

*y2*<br/>
Określa logiczną współrzędną y prawego dolnego rogu prostokąta.

*lpRect*<br/>
Określa prostokąta. Można też `CRect` obiektu.

### <a name="return-value"></a>Wartość zwracana

Określa typ nowego obszaru przycinania. Może być dowolną z następujących wartości:

- COMPLEXREGION regionu ma nakładających się obramowań.

- Błąd został utworzony nie regionu.

- NULLREGION regionu jest pusta.

- SIMPLEREGION regionie nie ma nakładające się obramowania.

### <a name="remarks"></a>Uwagi

Szerokość prostokąta, określony przez wartość bezwzględną liczby *x2* - *x1*, nie może przekraczać 32 767 jednostki. Ten limit dotyczy wysokość prostokąta, jak również.

##  <a name="excludeupdatergn"></a>  CDC::ExcludeUpdateRgn

Zapobiega rysowania w obszarach nieprawidłowy okna przez wykluczenie zaktualizowano region, w oknie z obszaru przycinania skojarzone z `CDC` obiektu.

```
int ExcludeUpdateRgn(CWnd* pWnd);
```

### <a name="parameters"></a>Parametry

*pWnd*<br/>
Wskazuje obiekt okna, którego okno jest aktualizowana.

### <a name="return-value"></a>Wartość zwracana

Typ regionu wykluczone. Może być jednym z następujących wartości:

- COMPLEXREGION regionu ma nakładających się obramowań.

- Błąd został utworzony nie regionu.

- NULLREGION regionu jest pusta.

- SIMPLEREGION regionie nie ma nakładające się obramowania.

##  <a name="extfloodfill"></a>  CDC::ExtFloodFill

Aktualny pędzel wypełnia obszar powierzchni ekranu.

```
BOOL ExtFloodFill(
    int x,
    int y,
    COLORREF crColor,
    UINT nFillType);
```

### <a name="parameters"></a>Parametry

*x*<br/>
Określa logiczną współrzędną x punktu, gdzie rozpoczyna się wypełnianie.

*y*<br/>
Określa logiczną współrzędną y punktu, gdzie rozpoczyna się wypełnianie.

*crColor*<br/>
Określa kolor granicy lub obszaru do wypełnienia. Interpretacja *crColor* zależy od wartości *nFillType*.

*nFillType*<br/>
Określa typ wypełnienia powódź do wykonania. Musi być jedną z następujących wartości:

- FLOODFILLBORDER obszar wypełnienia jest ograniczone przez kolor określony przy użyciu *crColor*. Ten styl jest taka sama jak wypełnianie wykonywane przez `FloodFill`.

- FLOODFILLSURFACE obszar wypełnienia jest definiowany przez kolor określony przy użyciu *crColor*. Wypełnianie nadal na zewnątrz w wszystkie kierunki, tak długo, jak kolor zostanie osiągnięty. Ten styl jest przydatne w przypadku wypełnianie obszarów granic różnych kolorach.

### <a name="return-value"></a>Wartość zwracana

Wartość różną od zera, jeśli funkcja się powiedzie; w przeciwnym razie 0, jeśli wypełniania nie można ukończyć, jeśli dany punkt ma granicę kolor określony przy użyciu *crColor* (jeśli FLOODFILLBORDER zażądano), jeśli dany punkt nie ma kolor określony przy użyciu *crColor* (jeśli FLOODFILLSURFACE zażądano), czy punkt znajduje się spoza obszaru przycinania.

### <a name="remarks"></a>Uwagi

Ta funkcja elementu członkowskiego oferuje bardziej elastyczne niż `FloodFill` ponieważ można określić typ wypełnienia w *nFillType*.

Jeśli *nFillType* jest ustawiona na FLOODFILLBORDER, obszar zakłada się, że można całkowicie poprowadzoną kolor określony przy użyciu *crColor*. Funkcja rozpoczyna się w punkcie określonym przez *x* i *y* i wypełni wszystkie kierunki do granicy kolorów.

Jeśli *nFillType* jest ustawiona na FLOODFILLSURFACE, funkcja rozpoczyna się w punkcie określonym przez *x* i *y* i jest kontynuowane w wszystkie kierunki, wypełniając wszystkich obszarów sąsiadująco zawierający kolor określony przy użyciu *crColor*.

Tylko konteksty urządzenia pamięci i urządzeń, które obsługują wyświetlanie rastrowych Obsługa technologii `ExtFloodFill`. Aby uzyskać więcej informacji, zobacz [GetDeviceCaps](#getdevicecaps) funkcja elementu członkowskiego.

##  <a name="exttextout"></a>  CDC::ExtTextOut

Wywołaj tę funkcję elementu członkowskiego, aby zapisać ciąg znaków w ramach prostokątny obszar za pomocą aktualnie wybranej czcionki.

```
virtual BOOL ExtTextOut(
    int x,
    int y,
    UINT nOptions,
    LPCRECT lpRect,
    LPCTSTR lpszString,
    UINT nCount,
    LPINT lpDxWidths);

BOOL ExtTextOut(
    int x,
    int y,
    UINT nOptions,
    LPCRECT lpRect,
    const CString& str,
    LPINT lpDxWidths);
```

### <a name="parameters"></a>Parametry

*x*<br/>
Określa logiczną współrzędną x komórki znaków pierwszego znaku w określonym ciągu.

*y*<br/>
Określa logiczną współrzędną y górnej komórki znaków pierwszego znaku w określonym ciągu.

*nOptions*<br/>
Określa typ prostokąta. Ten parametr może być jeden, zarówno lub żadnego z następujących wartości:

- ETO_CLIPPED Określa, że zostanie obcięta obszar przycinania na prostokąt.

- ETO_OPAQUE Określa, czy bieżący kolor tła wypełnia prostokąta. (Można ustaw i kwerendy bieżący kolor tła z [SetBkColor](#setbkcolor) i [GetBkColor](#getbkcolor) funkcji elementów członkowskich.)

*lpRect*<br/>
Wskazuje [Prostokąt](/windows/desktop/api/windef/ns-windef-tagrect) strukturę, która określa wymiary prostokąta. Ten parametr może mieć wartości NULL. Można również przekazać [CRect](../../atl-mfc-shared/reference/crect-class.md) obiektu dla tego parametru.

*lpszString*<br/>
Wskazuje ciąg znaków określony do narysowania. Można również przekazać [CString](../../atl-mfc-shared/reference/cstringt-class.md) obiektu dla tego parametru.

*nCount*<br/>
Określa liczbę znaków w ciągu.

*lpDxWidths*<br/>
Wskazuje na tablicę wartości, które wskazują odległość między źródła znaków sąsiadujących komórek. Na przykład *lpDxWidths*[ *i*] jednostki logiczne będą oddzielić źródła komórki znaków *i* i komórki znaków *i* + 1. Jeśli *lpDxWidths* ma wartość NULL, `ExtTextOut` korzysta z domyślnego odstępów między znakami.

*str*<br/>
A `CString` obiekt, który zawiera określony znaki do rysowania.

### <a name="return-value"></a>Wartość zwracana

Różne od zera, jeśli funkcja zakończyła się pomyślnie; w przeciwnym razie 0.

### <a name="remarks"></a>Uwagi

Prostokątny obszar może być nieprzezroczyste (wypełnione z bieżącym kolorem tła) i może być obszaru przycinania.

Jeśli *nOptions* wynosi 0 i *lprect —* ma wartość NULL, funkcja zapisuje tekst do kontekstu urządzenia bez użycia prostokątny obszar. Domyślnie, funkcja nie używa ani nie aktualizuje bieżącej pozycji. Jeśli aplikacja musi zaktualizować bieżącą pozycję w przypadku, gdy wywołuje `ExtTextOut`, aplikacja może wywołać `CDC` funkcja elementu członkowskiego [SetTextAlign](#settextalign) z *nFlags* równa TA_UPDATECP. Jeśli ta flaga jest ustawiona, Windows ignoruje *x* i *y* w kolejnych wywołaniach `ExtTextOut` i zamiast nich używa bieżącej pozycji. Gdy aplikacja używa TA_UPDATECP można zaktualizować bieżącą pozycję `ExtTextOut` Ustawia bieżącą pozycję, albo do końca poprzedniego wiersza tekstu albo w położeniu wskazanym przez ostatniego elementu w tablicy, do których prowadzą *lpDxWidths*, która kwota jest większa.

##  <a name="fillpath"></a>  CDC::FillPath

Zamyka żadnych otwartych figur w bieżącej ścieżce i wypełnia wewnątrz ścieżki przy użyciu aktualny Pędzel i tryb wypełnianie wielokąta.

```
BOOL FillPath();
```

### <a name="return-value"></a>Wartość zwracana

Różne od zera, jeśli funkcja zakończyła się pomyślnie; w przeciwnym razie 0.

### <a name="remarks"></a>Uwagi

Po wypełnieniu jego wewnętrznych ścieżka zostanie usunięty z kontekstu urządzenia.

##  <a name="fillrect"></a>  CDC::FillRect

Wywołaj tę funkcję elementu członkowskiego do wypełnienia danego prostokąt przy użyciu określonego pędzla.

```
void FillRect(
    LPCRECT lpRect,
    CBrush* pBrush);
```

### <a name="parameters"></a>Parametry

*lpRect*<br/>
Wskazuje [Prostokąt](/windows/desktop/api/windef/ns-windef-tagrect) strukturę, która zawiera logiczne współrzędnych prostokąta do wypełnienia. Można również przekazać [CRect](../../atl-mfc-shared/reference/crect-class.md) obiektu dla tego parametru.

*pBrush*<br/>
Identyfikuje pędzel używany do wypełniania prostokąta.

### <a name="remarks"></a>Uwagi

Funkcja wypełnia pełną prostokąt, łącznie z lewej i górnej krawędzi, ale nie wypełnia prawej i dolnej krawędzi.

Pędzel musi albo zostać utworzony przy użyciu [CBrush](../../mfc/reference/cbrush-class.md) elementów członkowskich [CreateHatchBrush](../../mfc/reference/cbrush-class.md#createhatchbrush), [CreatePatternBrush](../../mfc/reference/cbrush-class.md#createpatternbrush), i [CreateSolidBrush](../../mfc/reference/cbrush-class.md#createsolidbrush), lub pobierane przez `GetStockObject` funkcji Windows.

Podczas wypełniania określonego prostokąta `FillRect` nie obejmuje boków po prawej stronie i u dołu prostokąta. GDI do wypełnienia prostokąt, ale nie obejmuje prawego wiersza kolumny i u dołu, niezależnie od tego, bieżący tryb mapowania. `FillRect` porównuje wartości wystąpienia `top`, `bottom`, `left`, i `right` elementy członkowskie określonego prostokąta. Jeśli `bottom` jest mniejsza niż lub równa `top`, lub jeśli `right` jest mniejsza niż lub równa `left`, nie jest narysowany prostokąta.

`FillRect` jest podobny do [CDC::FillSolidRect](#fillsolidrect); jednak `FillRect` przyjmuje pędzla i w związku z tym można wypełnić prostokąt jednolitego koloru, kolor symulowany, pędzle kreskowane lub wzorca. `FillSolidRect` używa tylko jednolitymi kolorami (wskazywany przez parametr COLORREF). `FillRect` Zazwyczaj jest mniejsza niż `FillSolidRect`.

##  <a name="fillrgn"></a>  CDC::FillRgn

Wypełnia określonego przez regionu *pRgn* pędzlem określony przez *pBrush*.

```
BOOL FillRgn(
    CRgn* pRgn,
    CBrush* pBrush);
```

### <a name="parameters"></a>Parametry

*pRgn*<br/>
Wskaźnik do regionu, który ma zostać wypełniony. Współrzędnych dla danego regionu są określone w jednostkach logicznych.

*pBrush*<br/>
Identyfikuje pędzla, który ma być użyta do wypełnienia obszaru.

### <a name="return-value"></a>Wartość zwracana

Różne od zera, jeśli funkcja zakończyła się pomyślnie; w przeciwnym razie 0.

### <a name="remarks"></a>Uwagi

Pędzel musi być utworzony przy użyciu `CBrush` elementów członkowskich `CreateHatchBrush`, `CreatePatternBrush`, `CreateSolidBrush`, lub można pobrać za pomocą `GetStockObject`.

### <a name="example"></a>Przykład

  Zobacz przykład [CRgn::CreateRoundRectRgn](../../mfc/reference/crgn-class.md#createroundrectrgn).

##  <a name="fillsolidrect"></a>  CDC::FillSolidRect

Wywołaj tę funkcję elementu członkowskiego, aby wypełnić prostokąt danego określonego jednolitego koloru.

```
void FillSolidRect(
    LPCRECT lpRect,
    COLORREF clr);

void FillSolidRect(
    int x,
    int y,
    int cx,
    int cy,
    COLORREF clr);
```

### <a name="parameters"></a>Parametry

*lpRect*<br/>
Określa prostokąt otaczający (w jednostkach logicznych). Można przekazać wskaźnik do [Prostokąt](/windows/desktop/api/windef/ns-windef-tagrect) struktury danych lub `CRect` obiektu dla tego parametru.

*CLR* Określa kolor, który ma być używany, aby wypełnić prostokąt.

*x*<br/>
Określa logiczną współrzędną x lewego górnego rogu prostokąta.

*y*<br/>
Określa logiczną współrzędną y lewego górnego rogu prostokąta docelowego.

*cx*<br/>
Określa szerokość prostokąta.

*cy*<br/>
Określa wysokość prostokąta.

### <a name="remarks"></a>Uwagi

`FillSolidRect` jest bardzo podobny do [CDC::FillRect](#fillrect); jednak `FillSolidRect` używa tylko jednolitymi kolorami (wskazywany przez parametr COLORREF), podczas `FillRect` przyjmuje pędzla i w związku z tym można wypełnić prostokąt pełny kolor symulowany kolor, pędzle kreskowane lub wzorca. `FillSolidRect` Zazwyczaj jest szybsza niż `FillRect`.

> [!NOTE]
>  Gdy wywołujesz `FillSolidRect`, kolor tła, które było wcześniej ustawione przy użyciu [SetBkColor](#setbkcolor), jest ustawiony kolor, wskazywanym przez *clr*.

##  <a name="flattenpath"></a>  CDC::FlattenPath

Przekształca wszelkie krzywych w ścieżce zaznaczone w bieżącym kontekście urządzenia i każdej krzywej jest przekształcany sekwencja wierszy.

```
BOOL FlattenPath();
```

### <a name="return-value"></a>Wartość zwracana

Różne od zera, jeśli funkcja zakończyła się pomyślnie; w przeciwnym razie 0.

##  <a name="floodfill"></a>  CDC::FloodFill

Aktualny pędzel wypełnia obszar powierzchni ekranu.

```
BOOL FloodFill(
    int x,
    int y,
    COLORREF crColor);
```

### <a name="parameters"></a>Parametry

*x*<br/>
Określa logiczną współrzędną x punktu, gdzie rozpoczyna się wypełnianie.

*y*<br/>
Określa logiczną współrzędną y punktu, gdzie rozpoczyna się wypełnianie.

*crColor*<br/>
Określa kolor granicy.

### <a name="return-value"></a>Wartość zwracana

Wartość różną od zera, jeśli funkcja się powiedzie; w przeciwnym razie 0 jest zwracany, jeśli nie można ukończyć wypełniania, danego punktu ma kolor granic określony przy użyciu *crColor*, lub punktem jest spoza obszaru przycinania.

### <a name="remarks"></a>Uwagi

Obszar zakłada, że aby wyznaczają jako określony przez *crColor*. `FloodFill` Funkcja rozpoczyna się w punkcie określonym przez *x* i *y* i kontynuuje we wszystkich kierunkach do granicy kolorów.

Tylko konteksty urządzenia pamięci i urządzeń, które obsługują wyświetlanie rastrowych Obsługa technologii `FloodFill` funkcja elementu członkowskiego. Aby uzyskać informacji na temat możliwości rastercaps, zobacz `GetDeviceCaps` funkcja elementu członkowskiego.

`ExtFloodFill` Funkcja udostępnia podobną funkcję, ale większa elastyczność.

##  <a name="framerect"></a>  CDC::FrameRect

Rysuje obramowanie wokół prostokąt określony przez *lprect —*.

```
void FrameRect(
    LPCRECT lpRect,
    CBrush* pBrush);
```

### <a name="parameters"></a>Parametry

*lpRect*<br/>
Wskazuje [Prostokąt](/windows/desktop/api/windef/ns-windef-tagrect) struktury lub [CRect](../../atl-mfc-shared/reference/crect-class.md) obiekt, który zawiera współrzędne logiczne lewym i prawym dolnym rogu prostokąta. Można również przekazać `CRect` obiektu dla tego parametru.

*pBrush*<br/>
Identyfikuje pędzla, który ma służyć do ramek prostokąta.

### <a name="remarks"></a>Uwagi

Funkcja używa danego pędzla do rysowania obramowania. Szerokość i wysokość obramowania jest zawsze 1 jednostkę logiczną.

Jeśli prostokąta `bottom` Współrzędna jest mniejsze niż lub równe `top`, lub, jeśli `right` jest mniejsza niż lub równa `left`, nie jest narysowany prostokąta.

Obramowanie narysowanymi przez `FrameRect` znajduje się w tym samym miejscu obramowanie narysowanymi przez `Rectangle` funkcja elementu członkowskiego przy użyciu takich samych współrzędnych (Jeśli `Rectangle` używa Pióro 1 jednostkę logiczną szerokości). Wewnątrz prostokąta nie jest wypełnione przez `FrameRect`.

##  <a name="framergn"></a>  CDC::FrameRgn

Rysuje obramowanie wokół określonego przez regionu *pRgn* pędzla, określony przez *pBrush*.

```
BOOL FrameRgn(
    CRgn* pRgn,
    CBrush* pBrush,
    int nWidth,
    int nHeight);
```

### <a name="parameters"></a>Parametry

*pRgn*<br/>
Wskazuje `CRgn` obiekt, który identyfikuje region, aby być ujęte w obramowaniu. Współrzędnych dla danego regionu są określone w jednostkach logicznych.

*pBrush*<br/>
Wskazuje `CBrush` obiektu, który identyfikuje pędzla, który ma być używany do rysowania obramowania.

*nWidth*<br/>
Określa szerokość obramowania w pionie pociągnięć w jednostkach urządzenia.

*nHeight*<br/>
Określa wysokość obramowania w poziomie pociągnięć w jednostkach urządzenia.

### <a name="return-value"></a>Wartość zwracana

Różne od zera, jeśli funkcja zakończyła się pomyślnie; w przeciwnym razie 0.

### <a name="example"></a>Przykład

  Zobacz przykład [CRgn::CombineRgn](../../mfc/reference/crgn-class.md#combinergn).

##  <a name="fromhandle"></a>  CDC::FromHandle

Zwraca wskaźnik do `CDC` obiektu, kiedy podane dojście do kontekstu urządzenia.

```
static CDC* PASCAL FromHandle(HDC hDC);
```

### <a name="parameters"></a>Parametry

*hDC*<br/>
Zawiera dojście do kontekstu urządzenia Windows.

### <a name="return-value"></a>Wartość zwracana

Wskaźnik mogą być tymczasowe i nie powinny być przechowywane poza bezpośredniego użycia.

### <a name="remarks"></a>Uwagi

Jeśli `CDC` obiektu nie jest dołączony do uchwyt tymczasowego `CDC` obiekt zostanie utworzony i dołączony.

### <a name="example"></a>Przykład

  Zobacz przykład [CPrintDialog::GetPrinterDC](../../mfc/reference/cprintdialog-class.md#getprinterdc).

##  <a name="getarcdirection"></a>  CDC::GetArcDirection

Zwraca bieżący kierunek łuk kontekstu urządzenia.

```
int GetArcDirection() const;
```

### <a name="return-value"></a>Wartość zwracana

Określa bieżący kierunek arc, jeśli to się powiedzie. Poniżej przedstawiono prawidłowe wartości zwracane:

- Łuki AD_COUNTERCLOCKWISE i prostokąty narysowane zegara.

- Łuki AD_CLOCKWISE i prostokąty rysowane w prawo.

Jeśli wystąpi błąd, wartość zwracana wynosi zero.

### <a name="remarks"></a>Uwagi

Funkcje łuk i prostokąt używają kierunek łuku.

##  <a name="getaspectratiofilter"></a>  CDC::GetAspectRatioFilter

Pobiera ustawienie dla bieżącego filtru współczynnik proporcji.

```
CSize GetAspectRatioFilter() const;
```

### <a name="return-value"></a>Wartość zwracana

A `CSize` obiekt reprezentujący współczynnik proporcji, używane przez bieżący filtr współczynnik proporcji.

### <a name="remarks"></a>Uwagi

Współczynnik proporcji jest współczynnik utworzone przez urządzenie pikseli szerokości i wysokości. Informacje o urządzeniu współczynnik proporcji jest używany podczas tworzenia, wybieranie i Wyświetl czcionki. Windows oferuje filtra specjalnego filtra współczynnik proporcji, aby wybrać czcionki przeznaczone dla danego współczynnika proporcji ze wszystkich dostępnych czcionek. Filtr korzysta określony przez współczynnik proporcji `SetMapperFlags` funkcja elementu członkowskiego.

##  <a name="getbkcolor"></a>  CDC::GetBkColor

Zwraca bieżący kolor tła.

```
COLORREF GetBkColor() const;
```

### <a name="return-value"></a>Wartość zwracana

Wartość koloru RGB.

### <a name="remarks"></a>Uwagi

Jeśli tryb tła NIEPRZEZROCZYSTE, system używa kolor tła do wypełniania luk w wierszach ze stylem, odstępy między kreskowane linie pędzle i tła komórek znaków. Podczas konwertowania mapy bitowe między koloru i konteksty urządzenia monochromatyczny, wówczas system używa także kolor tła.

##  <a name="getbkmode"></a>  CDC::GetBkMode

Zwraca tryb tła.

```
int GetBkMode() const;
```

### <a name="return-value"></a>Wartość zwracana

Bieżący tryb tła, który może być NIEPRZEZROCZYSTE lub PRZEZROCZYSTE.

### <a name="remarks"></a>Uwagi

Tryb tła definiuje, czy system usunie istniejące kolory tła na powierzchni do rysowania przed Rysowanie tekstu, pędzle kreskowane lub dowolny styl pióra, który nie jest linię ciągłą.

##  <a name="getboundsrect"></a>  CDC::GetBoundsRect

Zwraca bieżący prostokąt otaczający zebranych dla kontekstu określonego urządzenia.

```
UINT GetBoundsRect(
    LPRECT lpRectBounds,
    UINT flags);
```

### <a name="parameters"></a>Parametry

*lpRectBounds*<br/>
Wskazuje buforu, który będzie otrzymywał bieżący prostokąt otaczający. Prostokąt, jest zwracany we współrzędnych logiczne.

*flagi*<br/>
Określa, czy prostokąt otaczający można wyczyścić zostanie zwrócona. Ten parametr powinien mieć wartość zero lub Ustaw następującą wartość:

- DCB_RESET wymusza prostokąt otaczający zostaje wyczyszczona po zwróceniu go.

### <a name="return-value"></a>Wartość zwracana

Określa bieżący stan prostokąt otaczający, jeśli funkcja się powiedzie. Może być kombinacją następujących wartości:

- Występuje blokujących DCB_ACCUMULATE akumulacja prostokąta.

- Prostokąt blokujących DCB_RESET jest pusty.

- Prostokąt blokujących DCB_SET nie jest pusty.

- Akumulacja blokujących DCB_ENABLE znajduje się na.

- Akumulacja blokujących DCB_DISABLE jest wyłączona.

##  <a name="getbrushorg"></a>  CDC::GetBrushOrg

Pobiera pochodzenia pędzla aktualnie wybrany do kontekstu urządzenia (w jednostkach urządzenia).

```
CPoint GetBrushOrg() const;
```

### <a name="return-value"></a>Wartość zwracana

Bieżące źródło pędzla (w jednostkach urządzenia) jako [CPoint](../../atl-mfc-shared/reference/cpoint-class.md) obiektu.

### <a name="remarks"></a>Uwagi

Źródła początkowego pędzla wynosi (0,0) obszaru klienta. Wartość zwracana określa ten punkt w jednostkach urządzenia pokrewny ze źródłem okien pulpitu.

##  <a name="getcharacterplacement"></a>  CDC::GetCharacterPlacement

Pobiera różne rodzaje informacji dla ciągu znaków.

```
DWORD GetCharacterPlacement(
    LPCTSTR lpString,
    int nCount,
    int nMaxExtent,
    LPGCP_RESULTS lpResults,
    DWORD dwFlags) const;

DWORD GetCharacterPlacement(
    CString& str,
    int nMaxExtent,
    LPGCP_RESULTS lpResults,
    DWORD dwFlags) const;
```

### <a name="parameters"></a>Parametry

*lpString*<br/>
Wskaźnik do ciągu znakowego do przetwarzania.

*nCount*<br/>
Określa długość ciągu. Dla wersji ANSI jest to liczba BAJTÓW, a dla funkcja Unicode jest to liczba WYRAZÓW. Aby uzyskać więcej informacji, zobacz [GetCharacterPlacement](/windows/desktop/api/wingdi/nf-wingdi-getcharacterplacementa).

*nMaxExtent*<br/>
Określa maksymalny zakres (w jednostkach logicznych), do której są przetwarzane w ciągu. Znaki, których przetwarzanie, przekracza ten zakres, są ignorowane. Obliczeń dla wszelkich wymaganych tablic zamawiania lub glifów dotyczą tylko znaki uwzględniane. Ten parametr jest używany tylko wtedy, gdy wartość GCP_MAXEXTENT określono w *Flagidw* parametru. Funkcja przetwarza ciąg wejściowy, każdy znak i jego rozszerzenie są dodawane do danych wyjściowych, zakresu i innych tablic tylko wtedy, gdy całkowita wielkość jeszcze nie przekracza maksymalnej. Po osiągnięciu limitu przetwarzanie zostanie zatrzymane.

*lpResults*<br/>
Wskaźnik do [GCP_Results](/windows/desktop/api/wingdi/ns-wingdi-taggcp_resultsa) strukturę, która otrzymuje wyniki funkcji.

*dwFlags*<br/>
Określa sposób przetwarzania ciągu do wymaganych tablic. Ten parametr może mieć jedną lub więcej wartości na liście *Flagidw* części [GetCharacterPlacement](/windows/desktop/api/wingdi/nf-wingdi-getcharacterplacementa) tematu.

*str*<br/>
Wskaźnik do [CString](../../atl-mfc-shared/reference/cstringt-class.md) obiektu do procesu.

### <a name="return-value"></a>Wartość zwracana

Jeśli funkcja się powiedzie, wartość zwracana jest szerokością i wysokością ciągu w jednostkach logicznych.

Jeśli funkcja zawiedzie, wartość zwracana wynosi zero.

### <a name="remarks"></a>Uwagi

Ta funkcja członkowska emuluje funkcjonalność funkcji [GetCharacterPlacement](/windows/desktop/api/wingdi/nf-wingdi-getcharacterplacementa), zgodnie z opisem w zestawie Windows SDK.

##  <a name="getcharabcwidths"></a>  CDC::GetCharABCWidths

Pobiera szerokość kolejnych znaków w określonym zakresie z bieżącej czcionki TrueType.

```
BOOL GetCharABCWidths(
    UINT nFirstChar,
    UINT nLastChar,
    LPABC lpabc) const;

BOOL GetCharABCWidths(
    UINT nFirstChar,
    UINT nLastChar,
    LPABCFLOAT lpABCF) const;
```

### <a name="parameters"></a>Parametry

*nFirstChar*<br/>
Określa pierwszy znak z zakresu znaków od bieżącej czcionki, dla którego są zwracane szerokości znaków.

*nLastChar*<br/>
Określa ostatni znak zakresu znaków od bieżącej czcionki, dla którego są zwracane szerokości znaków.

*lpabc*<br/>
Wskazuje na tablicę [ABC](/windows/desktop/api/wingdi/ns-wingdi-_abc) struktur, które odbierają szerokości znaków, gdy funkcja zwraca. Tablica musi zawierać co najmniej tyle `ABC` struktury jak znaków znajduje się w zakresie określonym przez *nFirstChar* i *nLastChar* parametrów.

*lpABCF*<br/>
Wskazuje buforu aplikacja dostarczona z tablicą [ABCFLOAT](/windows/desktop/api/wingdi/ns-wingdi-_abcfloat) struktury, aby otrzymywać szerokości znaków, gdy funkcja zwraca. Szerokości zwrócona przez tę funkcję, są w formacie zmiennoprzecinkowych IEEE.

### <a name="return-value"></a>Wartość zwracana

Różne od zera, jeśli funkcja zakończyła się pomyślnie; w przeciwnym razie 0.

### <a name="remarks"></a>Uwagi

Szerokość są zwracane w jednostkach logicznych. Ta funkcja powiedzie się tylko z czcionki TrueType.

Rasteryzatora TrueType zapewnia odstępów między znakami "ABC", po wybraniu rozmiaru określonego punktu. "" Jest odległość, który jest dodawany do bieżącego położenia przed wprowadzeniem glif. Odstępy między "B" jest szerokość części czarny symbol. Odstępy "C" zostanie dodany do aktualnej pozycji, aby uwzględnić białe miejsca z prawej strony symbolu. Łączna szerokość zaawansowane jest nadawana przez A + B + C.

Gdy `GetCharABCWidths` funkcja elementu członkowskiego pobiera ujemny "A" lub "C" szerokość znaku, znaku zawiera underhangs lub znacznego udziału.

Aby przekonwertować szerokości ABC jednostki projektu czcionki, aplikację należy utworzyć czcionkę którego wysokość (jak określono w `lfHeight` członkiem [LOGFONT](/windows/desktop/api/wingdi/ns-wingdi-taglogfonta) struktury) jest równa wartości przechowywane w `ntmSizeEM` członkiem [ NEWTEXTMETRIC](/windows/desktop/api/wingdi/ns-wingdi-tagnewtextmetrica) struktury. (Wartość `ntmSizeEM` element członkowski może być pobierany przez wywołanie [EnumFontFamilies](/windows/desktop/api/wingdi/nf-wingdi-enumfontfamiliesa) funkcji Windows.)

Szerokość ABC, domyślny znak są używane znaki, które wykraczają poza zakres aktualnie wybranej czcionki.

Aby pobrać szerokości znaków w zwykłe czcionki, aplikacje powinny używać [GetCharWidth](/windows/desktop/api/wingdi/nf-wingdi-getcharwidtha) funkcji Windows.

##  <a name="getcharabcwidthsi"></a>  CDC::GetCharABCWidthsI

Pobiera szerokości, w jednostkach logicznych, indeksów kolejnych symbol w określonym zakresie z bieżącej czcionki TrueType.

```
BOOL GetCharABCWidthsI(
    UINT giFirst,
    UINT cgi,
    LPWORD pgi,
    LPABC lpabc) const;
```

### <a name="parameters"></a>Parametry

*giFirst*<br/>
Określa pierwszy indeks symbolu w grupie wskaźniki kolejnych symbol z bieżącej czcionki. Ten parametr jest używany tylko, jeśli *pgi* parametr ma wartość NULL.

*cgi*<br/>
Określa liczbę indeksów symboli.

*pgi*<br/>
Wskaźnik do tablicę zawierającą indeksów symboli. Jeśli wartość wynosi NULL, *giFirst* parametr jest używany zamiast tego. *Cgi* parametr określa liczbę indeksów symbol w tej tablicy.

*lpabc*<br/>
Wskaźnik do tablicy [ABC](/windows/desktop/api/wingdi/ns-wingdi-_abc) struktury odbieranie szerokości znaków. Tablica musi zawierać co najmniej tyle `ABC` struktury, ponieważ indeksy symbolu, określony przez *cgi* parametru.

### <a name="return-value"></a>Wartość zwracana

Różne od zera, jeśli funkcja zakończyła się pomyślnie; w przeciwnym razie 0.

### <a name="remarks"></a>Uwagi

Ta funkcja członkowska emuluje funkcjonalność funkcji [GetCharABCWidthsI](/windows/desktop/api/wingdi/nf-wingdi-getcharabcwidthsi), zgodnie z opisem w zestawie Windows SDK.

##  <a name="getcharwidth"></a>  CDC::GetCharWidth

Pobiera szerokość poszczególnych znaków w grupie następujących po sobie znaków z bieżącą czcionkę przy użyciu `m_hAttribDC`, kontekst urządzenia wejściowego.

```
BOOL GetCharWidth(
    UINT nFirstChar,
    UINT nLastChar,
    LPINT lpBuffer) const;

BOOL GetCharWidth(
    UINT nFirstChar,
    UINT nLastChar,
    float* lpFloatBuffer) const;
```

### <a name="parameters"></a>Parametry

*nFirstChar*<br/>
Określa pierwszy znak w grupie następujących po sobie znaków w bieżącej czcionki.

*nLastChar*<br/>
Określa ostatni znak w grupie następujących po sobie znaków w bieżącej czcionki.

*lpBuffer*<br/>
Wskazuje buforu, który będzie otrzymywał wartości szerokości dla grupy kolejnych znaków w bieżącej czcionki.

*lpFloatBuffer*<br/>
Wskazuje bufor odbioru szerokości znaków. Szerokości zwracane są w formacie zmiennoprzecinkowych IEEE 32-bitowych. (Szerokość są mierzone wzdłuż linii bazowej znaków).

### <a name="return-value"></a>Wartość zwracana

Różne od zera, jeśli funkcja zakończyła się pomyślnie; w przeciwnym razie 0.

### <a name="remarks"></a>Uwagi

Na przykład jeśli *nFirstChar* identyfikuje literę "" i *nLastChar* identyfikuje litera "z", pobiera funkcja szerokości wszystkie małe litery.

Funkcja przechowuje wartości w bufor wskazywany przez *sprawdzanie*. Tego buforu musi być wystarczająco duży, aby pomieścić całą szerokość. Oznacza to musi istnieć co najmniej 26 wpisów w powyższym przykładzie.

Jeśli znak w kolejnych grupy znaków nie istnieje w określonej czcionki, będzie można przypisać wartość szerokości domyślny znak.

##  <a name="getcharwidthi"></a>  CDC::GetCharWidthI

Pobiera szerokości w logiczne współrzędne wskaźniki kolejnych symbol w określonym zakresie z bieżącej czcionki.

```
BOOL GetCharWidthI(
    UINT giFirst,
    UINT cgi,
    LPWORD pgi,
    LPINT lpBuffer) const;
```

### <a name="parameters"></a>Parametry

*giFirst*<br/>
Określa pierwszy indeks symbolu w grupie wskaźniki kolejnych symbol z bieżącej czcionki. Ten parametr jest używany tylko, jeśli *pgi* parametr ma wartość NULL.

*cgi*<br/>
Określa liczbę indeksów symboli.

*pgi*<br/>
Wskaźnik do tablicę zawierającą indeksów symboli. Jeśli wartość wynosi NULL, *giFirst* parametr jest używany zamiast tego. *Cgi* parametr określa liczbę indeksów symbol w tej tablicy.

*lpBuffer*<br/>
Wskaźnik do buforu, który otrzymuje szerokości.

### <a name="return-value"></a>Wartość zwracana

Różne od zera, jeśli funkcja zakończyła się pomyślnie; w przeciwnym razie 0.

### <a name="remarks"></a>Uwagi

Ta funkcja członkowska emuluje funkcjonalność funkcji [GetCharWidthI](/windows/desktop/api/wingdi/nf-wingdi-getcharwidthi), zgodnie z opisem w zestawie Windows SDK.

##  <a name="getclipbox"></a>  CDC::GetClipBox

Pobiera wymiary tightest otaczający prostokąt wokół granicy bieżącego wycinka.

```
virtual int GetClipBox(LPRECT lpRect) const;
```

### <a name="parameters"></a>Parametry

*lpRect*<br/>
Wskazuje [Prostokąt](/windows/desktop/api/windef/ns-windef-tagrect) struktury lub [CRect](../../atl-mfc-shared/reference/crect-class.md) obiektu, który ma otrzymać wymiary prostokąta.

### <a name="return-value"></a>Wartość zwracana

Typ obszaru przycinania. Może być dowolną z następujących wartości:

- Przycinanie COMPLEXREGION regionu ma nakładających się obramowań.

- Kontekst urządzenia błędu jest nieprawidłowa.

- Przycinanie NULLREGION regionu jest pusta.

- Przycinanie SIMPLEREGION regionie nie ma nakładające się obramowania.

### <a name="remarks"></a>Uwagi

Wymiary są kopiowane do bufor wskazywany przez *lprect —*.

##  <a name="getcoloradjustment"></a>  CDC::GetColorAdjustment

Pobiera wartości dostosowanie kolorów dla kontekstu urządzenia.

```
BOOL GetColorAdjustment(LPCOLORADJUSTMENT lpColorAdjust) const;
```

### <a name="parameters"></a>Parametry

*lpColorAdjust*<br/>
Wskazuje [COLORADJUSTMENT](/windows/desktop/api/wingdi/ns-wingdi-tagcoloradjustment) struktury danych, aby odbierać wartości dostosowanie kolorów.

### <a name="return-value"></a>Wartość zwracana

Różne od zera, jeśli funkcja zakończyła się pomyślnie; w przeciwnym razie 0.

##  <a name="getcurrentbitmap"></a>  CDC::GetCurrentBitmap

Zwraca wskaźnik do aktualnie wybranego `CBitmap` obiektu.

```
CBitmap* GetCurrentBitmap() const;
```

### <a name="return-value"></a>Wartość zwracana

Wskaźnik do `CBitmap` obiektu, jeśli to się powiedzie; w przeciwnym razie wartość NULL.

### <a name="remarks"></a>Uwagi

Ta funkcja elementu członkowskiego mogą zwracać obiekty tymczasowe.

##  <a name="getcurrentbrush"></a>  CDC::GetCurrentBrush

Zwraca wskaźnik do aktualnie wybranego `CBrush` obiektu.

```
CBrush* GetCurrentBrush() const;
```

### <a name="return-value"></a>Wartość zwracana

Wskaźnik do `CBrush` obiektu, jeśli to się powiedzie; w przeciwnym razie wartość NULL.

### <a name="remarks"></a>Uwagi

Ta funkcja elementu członkowskiego mogą zwracać obiekty tymczasowe.

##  <a name="getcurrentfont"></a>  CDC::GetCurrentFont

Zwraca wskaźnik do aktualnie wybranego `CFont` obiektu.

```
CFont* GetCurrentFont() const;
```

### <a name="return-value"></a>Wartość zwracana

Wskaźnik do `CFont` obiektu, jeśli to się powiedzie; w przeciwnym razie wartość NULL.

### <a name="remarks"></a>Uwagi

Ta funkcja elementu członkowskiego mogą zwracać obiekty tymczasowe.

##  <a name="getcurrentpalette"></a>  CDC::GetCurrentPalette

Zwraca wskaźnik do aktualnie wybranego `CPalette` obiektu.

```
CPalette* GetCurrentPalette() const;
```

### <a name="return-value"></a>Wartość zwracana

Wskaźnik do `CPalette` obiektu, jeśli to się powiedzie; w przeciwnym razie wartość NULL.

### <a name="remarks"></a>Uwagi

Ta funkcja elementu członkowskiego mogą zwracać obiekty tymczasowe.

##  <a name="getcurrentpen"></a>  CDC::GetCurrentPen

Zwraca wskaźnik do aktualnie wybranego `CPen` obiektu.

```
CPen* GetCurrentPen() const;
```

### <a name="return-value"></a>Wartość zwracana

Wskaźnik do `CPen` obiektu, jeśli to się powiedzie; w przeciwnym razie wartość NULL.

### <a name="remarks"></a>Uwagi

Ta funkcja elementu członkowskiego mogą zwracać obiekty tymczasowe.

##  <a name="getcurrentposition"></a>  CDC::GetCurrentPosition

Pobiera bieżącą pozycję (we współrzędnych logicznych).

```
CPoint GetCurrentPosition() const;
```

### <a name="return-value"></a>Wartość zwracana

Bieżąca pozycja jako `CPoint` obiektu.

### <a name="remarks"></a>Uwagi

Bieżące położenie, można ustawić za pomocą `MoveTo` funkcja elementu członkowskiego.

##  <a name="getdcbrushcolor"></a>  CDC::GetDCBrushColor

Pobiera bieżący kolor pędzla.

```
COLORREF GetDCBrushColor() const;
```

### <a name="return-value"></a>Wartość zwracana

Jeśli funkcja się powiedzie, wartość zwracana jest [COLORREF](/windows/desktop/gdi/colorref) wartość bieżący kolor pędzla.

Jeśli funkcja zawiedzie, wartość zwracana jest CLR_INVALID.

### <a name="remarks"></a>Uwagi

Ta funkcja członkowska emuluje funkcjonalność funkcji [GetDCBrushColor](/windows/desktop/api/wingdi/nf-wingdi-getdcbrushcolor), zgodnie z opisem w zestawie Windows SDK.

##  <a name="getdcpencolor"></a>  CDC::GetDCPenColor

Pobiera bieżący kolor pióra.

```
COLORREF GetDCPenColor() const;
```

### <a name="return-value"></a>Wartość zwracana

Jeśli funkcja się powiedzie, wartość zwracana jest [COLORREF](/windows/desktop/gdi/colorref) wartość dla bieżącego koloru pióra.

Jeśli funkcja zawiedzie, wartość zwracana jest CLR_INVALID.

### <a name="remarks"></a>Uwagi

Ta funkcja elementu członkowskiego wykorzystuje funkcję Win32 [GetDCPenColor](/windows/desktop/api/wingdi/nf-wingdi-getdcpencolor), zgodnie z opisem w zestawie Windows SDK.

##  <a name="getdevicecaps"></a>  Rc_bitblt

Pobiera szerokiej gamy informacji specyficznych dla urządzenia o urządzenia.

```
int GetDeviceCaps(int nIndex) const;
```

### <a name="parameters"></a>Parametry

*nIndex*<br/>
Określa typ danych do zwrócenia. Zobacz [GetDeviceCaps](/windows/desktop/api/wingdi/nf-wingdi-getdevicecaps) w zestawie Windows SDK dla listy wartości.

### <a name="return-value"></a>Wartość zwracana

Wartość żądanej funkcji, jeśli funkcja się powiedzie.

### <a name="example"></a>Przykład

  Zobacz przykład [CPrintDialog::GetDefaults](../../mfc/reference/cprintdialog-class.md#getdefaults).

##  <a name="getfontdata"></a>  CDC::GetFontData

Pobiera metryki czcionki informacje z pliku czcionek skalowalnych.

```
DWORD GetFontData(
    DWORD dwTable,
    DWORD dwOffset,
    LPVOID lpData,
    DWORD cbData) const;
```

### <a name="parameters"></a>Parametry

*dwTable*<br/>
Określa nazwę tabeli metryk do zwrócenia. Ten parametr może być jedną z tabel metryki opisane w specyfikacji pliki czcionki TrueType opublikowane przez firmę Microsoft Corporation. Jeśli ten parametr ma wartość 0, informacje są pobierane, zaczynając od początku pliku czcionki.

*dwOffset*<br/>
Określa przesunięcie od początku tabeli, od którego należy rozpocząć pobieranie informacji. Jeśli ten parametr ma wartość 0, informacje są pobierane, zaczynając od początku tabeli określony przez *dwTable* parametru. Jeśli ta wartość jest większa niż lub równy rozmiarowi tabeli `GetFontData` zwraca wartość 0.

*lpData*<br/>
Wskazuje buforu, który będzie otrzymywać informacje dotyczące czcionek. Jeśli ta wartość wynosi NULL, funkcja zwraca rozmiar buforu wymagane dla czcionki dane określone w *dwTable* parametru.

*cbData*<br/>
Określa długość w bajtach, informacje, które mają zostać pobrane. Jeśli ten parametr ma wartość 0, `GetFontData` zwraca rozmiar dane określone w *dwTable* parametru.

### <a name="return-value"></a>Wartość zwracana

Określa liczbę bajtów zwróconych w bufor wskazywany przez *lpData* Jeśli funkcja się powiedzie; w przeciwnym razie wartość -1.

### <a name="remarks"></a>Uwagi

Informacje należy pobrać, jest identyfikowany przez określanie przesunięcia do pliku czcionki i długość danych do zwrócenia.

Aplikację można czasami wykorzystują `GetFontData` funkcja elementu członkowskiego, aby zapisać czcionki TrueType dokumentu. Aby to zrobić, aplikacja określa, czy czcionka mogą być osadzone, a następnie pobiera plik całą czcionkę, określając 0 dla *dwTable*, *dwOffset*, i *cbData* Parametry.

Aplikacje można określić, czy można osadzić czcionkę, sprawdzając `otmfsType` członkiem [OUTLINETEXTMETRIC](/windows/desktop/api/wingdi/ns-wingdi-_outlinetextmetrica) struktury. Jeśli bit 1 `otmfsType` jest ustawiony, Osadzanie czcionki, nie jest dozwolona. W przypadku clear bit 1 czcionkę można osadzać. Jeśli ustawiono bit 2, osadzania jest tylko do odczytu.

Jeśli aplikacja próbuje użyć tej funkcji można pobrać informacji o zwykłe czcionki, `GetFontData` funkcja elementu członkowskiego zwraca -1.

##  <a name="getfontlanguageinfo"></a>  CDC::GetFontLanguageInfo

Zwraca informacje o aktualnie wybranej czcionki dla kontekstu określonego ekranu.

```
DWORD GetFontLanguageInfo() const;
```

### <a name="return-value"></a>Wartość zwracana

Wartość zwracana określa właściwości aktualnie wybranej czcionki. Aby uzyskać pełną listę możliwych wartości, zobacz [GetFontLanguageInfo](/windows/desktop/api/wingdi/nf-wingdi-getfontlanguageinfo).

### <a name="remarks"></a>Uwagi

Ta funkcja członkowska emuluje funkcjonalność funkcji [GetFontLanguageInfo](/windows/desktop/api/wingdi/nf-wingdi-getfontlanguageinfo), zgodnie z opisem w zestawie Windows SDK.

##  <a name="getglyphoutline"></a>  CDC::GetGlyphOutline

Pobiera krzywej konspektu lub mapy bitowej dla znaku konturu w bieżącej czcionki.

```
DWORD GetGlyphOutline(
    UINT nChar,
    UINT nFormat,
    LPGLYPHMETRICS lpgm,
    DWORD cbBuffer,
    LPVOID lpBuffer,
    const MAT2* lpmat2) const;
```

### <a name="parameters"></a>Parametry

*nChar*<br/>
Określa znak, dla którego ma zostać zwrócone informacje.

*nFormat*<br/>
Określa format, w którym funkcja do zwracania informacji. Może być jedną z następujących wartości lub 0:

|Wartość|Znaczenie|
|-----------|-------------|
|GGO_BITMAP|Zwraca symbol mapy bitowej. Gdy funkcja zwróci wynik, bufor wskazywany przez *sprawdzanie* zawiera mapę bitową 1 bit każdego piksela, w której wiersze uruchomić się w granicach bitowego.|
|GGO_NATIVE|Zwraca krzywej punktów danych w formacie natywnym rasteryzatora, przy użyciu jednostek urządzenia. Gdy ta wartość jest określona, wszystkie przekształcenia określone w *lpmat2* jest ignorowana.|

Gdy wartość *nFormat* wynosi 0, funkcja wypełnia [GLYPHMETRICS](/windows/desktop/api/wingdi/ns-wingdi-_glyphmetrics) struktury, ale nie może zwracać danych obrysu symbolu.

*lpgm*<br/>
Wskazuje strukturę GLYPHMETRICS, która opisuje położenie symbol w komórce znaków.

*cbBuffer*<br/>
Określa rozmiar buforu, w której funkcja kopiuje informacje o znaku konspektu. Jeśli ta wartość wynosi 0 i *nFormat* parametr jest GGO_BITMAP albo GGO_NATIVE wartości, funkcja zwraca wymagany rozmiar buforu.

*lpBuffer*<br/>
Wskazuje buforu, w której funkcja kopiuje informacje o znaku konspektu. Jeśli *nFormat* określa wartość GGO_NATIVE informacje są kopiowane w postaci TTPOLYGONHEADER i TTPOLYCURVE struktur. Jeśli ta wartość jest równa NULL i *nFormat* jest wartością GGO_BITMAP albo GGO_NATIVE, funkcja zwraca wymagany rozmiar buforu.

*lpmat2*<br/>
Wskazuje [MAT2](/windows/desktop/api/wingdi/ns-wingdi-_mat2) strukturę, która zawiera znak, macierzy transformacji. Ten parametr nie może mieć wartości NULL, nawet wtedy, gdy określona jest wartość GGO_NATIVE dla *nFormat*.

### <a name="return-value"></a>Wartość zwracana

Rozmiar w bajtach buforu wymagane pobrane informacje, jeśli *cbBuffer* ma wartość 0 lub *sprawdzanie* ma wartość NULL. W przeciwnym razie jest to wartość dodatnią, jeśli funkcja się powiedzie, lub wartość -1, jeśli występuje błąd.

### <a name="remarks"></a>Uwagi

Aplikację można obracać znaków, pobrać w formacie mapy bitowej, określając macierzy transformacji 2-przez-2 w strukturze wskazywany przez *lpmat2*.

Obrysu symbolu jest zwracana jako szereg konturów. Każdy rozkład jest definiowany przez [TTPOLYGONHEADER](/windows/desktop/api/wingdi/ns-wingdi-tagttpolygonheader) struktury następuje tyle `TTPOLYCURVE` struktur, które są wymagane do opisania go. Wszystkie punkty są zwracane jako [POINTFX](/windows/desktop/api/wingdi/ns-wingdi-tagpointfx) struktury i reprezentują położenia bezwzględne względna nie przenosi. Początkowy punkt przez `pfxStart` członkiem [TTPOLYGONHEADER](/windows/desktop/api/wingdi/ns-wingdi-tagttpolygonheader) struktury to punkt, od której rozpoczyna się konturu dla ROZKŁAD. [TTPOLYCURVE](/windows/desktop/api/wingdi/ns-wingdi-tagttpolycurve) struktur, które należy wykonać, może być linii łamanej rekordów i rekordy z krzywymi składanymi. Wielokąt rekordy, które są serii punktów. linii między punktami opisują konspektu znaku. Rekordy z krzywymi składanymi reprezentują drugiego stopnia krzywych używanych przez TrueType (czyli drugiego stopnia b — krzywe).

##  <a name="getgraphicsmode"></a>  CDC::GetGraphicsMode

Pobiera bieżący tryb graficznych dla kontekstu określonego urządzenia.

```
int GetGraphicsMode() const;
```

### <a name="return-value"></a>Wartość zwracana

Zwraca bieżący tryb grafiki w przypadku powodzenia. Aby uzyskać listę wartości, które może zwracać tej metody, zobacz [GetGraphicsMode](/windows/desktop/api/wingdi/nf-wingdi-getgraphicsmode).

Zwraca wartość 0 w przypadku niepowodzenia.

Aby uzyskać rozszerzone informacje o błędzie, należy wywołać [GetLastError](https://msdn.microsoft.com/library/windows/desktop/ms679360).

### <a name="remarks"></a>Uwagi

Ta metoda opakowuje funkcję Windows GDI [GetGraphicsMode](/windows/desktop/api/wingdi/nf-wingdi-getgraphicsmode).

##  <a name="gethalftonebrush"></a>  CDC::GetHalftoneBrush

Wywołaj tę funkcję elementu członkowskiego, aby pobrać pędzla półtonów.

```
static CBrush* PASCAL GetHalftoneBrush();
```

### <a name="return-value"></a>Wartość zwracana

Wskaźnik do `CBrush` obiektu, jeśli operacja się powiedzie; w przeciwnym razie wartość NULL.

### <a name="remarks"></a>Uwagi

Pędzel półtonów pokazuje piksele, które są też kolorach pierwszoplanowych i tła, aby utworzyć szarych wzorca. Oto przykład wzorca szarych utworzone przez pędzla półtonów.

![Szczegółowe informacje na temat pociągnięcia pióra szarych](../../mfc/reference/media/vc318s1.gif "szczegółowe informacje na temat pociągnięcia pióra szarych")

##  <a name="getkerningpairs"></a>  CDC::GetKerningPairs

Pobiera znak kerning pary czcionka, która jest aktualnie wybrany w kontekście określonego urządzenia.

```
int GetKerningPairs(
    int nPairs,
    LPKERNINGPAIR lpkrnpair) const;
```

### <a name="parameters"></a>Parametry

*nPairs*<br/>
Określa liczbę [KERNINGPAIR](/windows/desktop/api/wingdi/ns-wingdi-tagkerningpair) struktury wskazywany przez *lpkrnpair*. Funkcja nie skopiuje pary kerningu więcej niż określony przez *nPairs*.

*lpkrnpair*<br/>
Wskazuje na tablicę `KERNINGPAIR` struktur, które odbierają kerning pary, gdy funkcja zwraca. Tablica musi zawierać co najmniej tyle struktury określony przez *nPairs*. Jeśli ten parametr ma wartość NULL, funkcja zwraca sumę kerning pary czcionki.

### <a name="return-value"></a>Wartość zwracana

Określa liczbę kerning pary pobierane lub całkowita liczba kerning pary w czcionce, jeśli funkcja się powiedzie. Zero jest zwracany, jeśli funkcja kończy się niepowodzeniem lub jest nie kerningu pary czcionki.

##  <a name="getlayout"></a>  CDC::GetLayout

Wywołaj tę funkcję elementu członkowskiego do określania układu tekstu i grafiki do kontekstu urządzenia, takie jak drukarka lub metaplik.

```
DWORD GetLayout() const;
```

### <a name="return-value"></a>Wartość zwracana

Jeśli to się powiedzie, układ flagi dla bieżącego kontekstu urządzenia. W przeciwnym razie GDI_ERROR. Aby uzyskać rozszerzone informacje o błędzie, wywołaj [GetLastError](https://msdn.microsoft.com/library/windows/desktop/ms679360). Aby uzyskać listę flag, układ, zobacz [CDC::SetLayout](#setlayout).

### <a name="remarks"></a>Uwagi

Układ domyślny jest od lewej do prawej.

##  <a name="getmapmode"></a>  CDC::GetMapMode

Pobiera bieżący tryb mapowania.

```
int GetMapMode() const;
```

### <a name="return-value"></a>Wartość zwracana

Tryb mapowania.

### <a name="remarks"></a>Uwagi

Opis tych trybów mapowania, zobacz `SetMapMode` funkcja elementu członkowskiego.

> [!NOTE]
>  Jeśli wywołasz [SetLayout](#setlayout) Aby zmienić układ od prawej do lewej, kontroler domeny `SetLayout` zmienia się MM_ISOTROPIC automatycznie tryb mapowania. W związku z tym, każde kolejne wywołanie `GetMapMode` zwróci MM_ISOTROPIC.

##  <a name="getmiterlimit"></a>  CDC::GetMiterLimit

Zwraca limit skosu do kontekstu urządzenia.

```
float GetMiterLimit() const;
```

### <a name="return-value"></a>Wartość zwracana

Różne od zera, jeśli funkcja zakończyła się pomyślnie; w przeciwnym razie 0.

### <a name="remarks"></a>Uwagi

Limit ukośnych jest używany, gdy Rysowanie linii geometryczne, które mają ostre sprzężenia.

##  <a name="getnearestcolor"></a>  CDC::GetNearestColor

Zwraca pełny kolor, który najlepiej odpowiada określonym kolor logiczne.

```
COLORREF GetNearestColor(COLORREF crColor) const;
```

### <a name="parameters"></a>Parametry

*crColor*<br/>
Określa kolor do dopasowania.

### <a name="return-value"></a>Wartość zwracana

Wartość koloru RGB (czerwony, zielony, niebieski), który definiuje stałą kolor najbliżej *crColor* wartość, która może reprezentować urządzenia.

### <a name="remarks"></a>Uwagi

Danego urządzenia musi być w stanie odtworzyć tego koloru.

##  <a name="getoutlinetextmetrics"></a>  CDC::GetOutlineTextMetrics

Pobiera informacje dotyczące pomiaru dla czcionki TrueType.

```
UINT GetOutlineTextMetrics(
    UINT cbData,
    LPOUTLINETEXTMETRIC lpotm) const;
```

### <a name="parameters"></a>Parametry

*lpotm*<br/>
Wskazuje na tablicę [OUTLINETEXTMETRIC](/windows/desktop/api/wingdi/ns-wingdi-_outlinetextmetrica) struktury. Jeśli ten parametr ma wartość NULL, funkcja zwraca rozmiar buforu wymagane dla pobranych danych metryk.

*cbData*<br/>
Określa rozmiar w bajtach, bufor, do których informacje są zwracane.

*lpotm*<br/>
Wskazuje `OUTLINETEXTMETRIC` struktury. Jeśli ten parametr ma wartość NULL, funkcja zwraca rozmiar buforu wymagane dla metryki pobrane informacje.

### <a name="return-value"></a>Wartość zwracana

Różne od zera, jeśli funkcja zakończyła się pomyślnie; w przeciwnym razie 0.

### <a name="remarks"></a>Uwagi

[OUTLINETEXTMETRIC](/windows/desktop/api/wingdi/ns-wingdi-_outlinetextmetrica) struktura zawiera większość informacji metryki czcionki podany w formacie TrueType tym [TEXTMETRIC](/windows/desktop/api/wingdi/ns-wingdi-tagtextmetrica) struktury. Cztery ostatnie elementy członkowskie `OUTLINETEXTMETRIC` struktury są wskaźnikami do ciągów. Aplikacje należy przydzielić miejsce dla tych ciągów, oprócz miejsca wymaganego dla innych członków. Ponieważ nie ma żadnego limitu rozmiaru ciągi nałożone przez system, najprostszą metodą przydzielania pamięci jest pobrać wymagany rozmiar, określając wartość NULL w przypadku *lpotm* w pierwszym wywołaniu `GetOutlineTextMetrics` funkcji.

##  <a name="getoutputcharwidth"></a>  CDC::GetOutputCharWidth

Używany jest kontekst urządzenia wyjściowego `m_hDC`i pobiera szerokości pojedynczych znaków w grupie następujących po sobie znaków z bieżącej czcionki.

```
BOOL GetOutputCharWidth(
    UINT nFirstChar,
    UINT nLastChar,
    LPINT lpBuffer) const;
```

### <a name="parameters"></a>Parametry

*nFirstChar*<br/>
Określa pierwszy znak w grupie następujących po sobie znaków w bieżącej czcionki.

*nLastChar*<br/>
Określa ostatni znak w grupie następujących po sobie znaków w bieżącej czcionki.

*lpBuffer*<br/>
Wskazuje buforu, który będzie otrzymywał wartości szerokości dla grupy kolejnych znaków w bieżącej czcionki.

### <a name="return-value"></a>Wartość zwracana

Różne od zera, jeśli funkcja zakończyła się pomyślnie; w przeciwnym razie 0.

### <a name="remarks"></a>Uwagi

Na przykład jeśli *nFirstChar* identyfikuje literę "" i *nLastChar* identyfikuje litera "z", pobiera funkcja szerokości wszystkie małe litery.

Funkcja przechowuje wartości w bufor wskazywany przez *sprawdzanie*. Tego buforu musi być wystarczająco duży, aby pomieścić całą szerokość; oznacza to musi istnieć co najmniej 26 wpisów w powyższym przykładzie.

Jeśli znak w kolejnych grupy znaków nie istnieje w określonej czcionki, będzie można przypisać wartość szerokości domyślny znak.

##  <a name="getoutputtabbedtextextent"></a>  CDC::GetOutputTabbedTextExtent

Wywołaj tę funkcję elementu członkowskiego, do obliczenia szerokością i wysokością ciągu znaków za pomocą [m_hDC](#m_hdc), dane wyjściowe kontekstu urządzenia.

```
CSize GetOutputTabbedTextExtent(
    LPCTSTR lpszString,
    int nCount,
    int nTabPositions,
    LPINT lpnTabStopPositions) const;

CSize GetOutputTabbedTextExtent(
    const CString& str,
    int nTabPositions,
    LPINT lpnTabStopPositions) const;
```

### <a name="parameters"></a>Parametry

*lpszString*<br/>
Wskazuje ciąg znaków do zmierzenia. Można również przekazać [CString](../../atl-mfc-shared/reference/cstringt-class.md) obiektu dla tego parametru.

*nCount*<br/>
Określa [długość ciągu](/windows/desktop/gdi/specifying-length-of-text-output-string) wskazywany przez *lpszString*.

*nTabPositions*<br/>
Określa liczbę pozycji tabulatorów w tablicy, do których prowadzą *lpnTabStopPositions*.

*lpnTabStopPositions*<br/>
Wskazuje tablicy liczb całkowitych, zawierający pozycji tabulatorów w jednostkach logicznych. Pozycji tabulatorów muszą być posortowane rosnąco; najmniejsza wartość x powinien być pierwszy element w tablicy. Tabulatory wsteczne są niedozwolone.

*str*<br/>
A `CString` obiekt, który zawiera określonych znaków do zmierzenia.

### <a name="return-value"></a>Wartość zwracana

Wymiary w ciągu (w jednostkach logicznych) [CSize](../../atl-mfc-shared/reference/csize-class.md) obiektu.

### <a name="remarks"></a>Uwagi

Jeśli ciąg zawiera jeden lub więcej znaków tabulacji, szerokości ciągu opiera się na pozycji tabulatorów, określony przez *lpnTabStopPositions*. Funkcja używa aktualnie wybranej czcionki do obliczenia wymiarów ciągu.

Bieżący region wycinka nie przesunięcia, szerokość i wysokość zwrócony przez `GetOutputTabbedTextExtent` funkcji.

Ponieważ niektóre urządzenia nie należy umieszczać w komórce regularnych tablic znaków (czyli one kerning znaków), Suma zakres znaków w ciągu mogą być różne w zakresie ciągu.

Jeśli *nTabPositions* wynosi 0 i *lpnTabStopPositions* ma wartość NULL, karty są rozszerzane do ośmiu szerokości znaków średniej. Jeśli *nTabPositions* wynosi 1, tabulatorów będą oddzielone odległości określonej przez pierwszą wartość w tablicy, do którego *lpnTabStopPositions* punktów. Jeśli *lpnTabStopPositions* punktów do więcej niż jedną wartość, dla każdej wartości w tablicy, maksymalna liczba określona przez ustawiono tabulatora *nTabPositions*.

##  <a name="getoutputtextextent"></a>  CDC::GetOutputTextExtent

Wywołaj tę funkcję elementu członkowskiego, aby użyć danych wyjściowych kontekstu urządzenia, [m_hDC](#m_hdc)i zasobów obliczeniowych, szerokość i wysokość wiersza tekstu, przy użyciu bieżącej czcionki.

```
CSize GetOutputTextExtent(
    LPCTSTR lpszString,
    int nCount) const;

CSize GetOutputTextExtent(const CString& str) const;
```

### <a name="parameters"></a>Parametry

*lpszString*<br/>
Wskazuje ciąg znaków. Można również przekazać [CString](../../atl-mfc-shared/reference/cstringt-class.md) obiektu dla tego parametru.

*nCount*<br/>
Określa [długość ciągu](/windows/desktop/gdi/specifying-length-of-text-output-string) wskazywany przez *lpszString*.

*str*<br/>
A `CString` obiekt, który zawiera określonych znaków do zmierzenia.

### <a name="return-value"></a>Wartość zwracana

Wymiary ciągu (w jednostkach logicznych) zwracane w [CSize](../../atl-mfc-shared/reference/csize-class.md) obiektu.

### <a name="remarks"></a>Uwagi

Bieżący region wycinka nie ma wpływu na szerokość i wysokość zwrócony przez `GetOutputTextExtent`.

Ponieważ niektóre urządzenia nie należy umieszczać w komórce regularnych tablic znaków (czyli wykonują kerning), Suma zakres znaków w ciągu mogą być różne w zakresie ciągu.

##  <a name="getoutputtextmetrics"></a>  CDC::GetOutputTextMetrics

Pobiera metryki dla bieżącego przy użyciu czcionki `m_hDC`, dane wyjściowe kontekstu urządzenia.

```
BOOL GetOutputTextMetrics(LPTEXTMETRIC lpMetrics) const;
```

### <a name="parameters"></a>Parametry

*lpMetrics*<br/>
Wskazuje [TEXTMETRIC](/windows/desktop/api/wingdi/ns-wingdi-tagtextmetrica) strukturę, która odbiera metryki.

### <a name="return-value"></a>Wartość zwracana

Różne od zera, jeśli funkcja zakończyła się pomyślnie; w przeciwnym razie 0.

##  <a name="getpath"></a>  CDC::GetPath

Pobiera współrzędne Definiowanie punktów końcowych wierszy i punkty kontrolne krzywych odnaleziona w ścieżce, który wybrano w kontekście urządzenia.

```
int GetPath(
    LPPOINT lpPoints,
    LPBYTE lpTypes,
    int nCount) const;
```

### <a name="parameters"></a>Parametry

*lpPoints*<br/>
Wskazuje na tablicę [punktu](/windows/desktop/api/windef/ns-windef-tagpoint) struktur danych lub `CPoint` obiekty, których punkty końcowe linii i krzywych kontrolować punkty są umieszczane.

*lpTypes*<br/>
Wskazuje na tablicę bajtów, gdzie są umieszczone typy wierzchołka. Wartości są jedną z następujących czynności:

- PT_MOVETO Określa, że odpowiednie do punktu w *lpPoints* uruchamia rozłączne rysunku.

- PT_LINETO Określa, że poprzedni punkt i odpowiedniego punktu *lpPoints* to punkty końcowe linii.

- PT_BEZIERTO Określa, że odpowiednie do punktu w *lpPoints* jest punkt kontrolny lub punkt końcowy dla krzywej Bzier.

Typy PT_BEZIERTO zawsze wykonywane w trzech zestawów. Punkt w ścieżce, bezpośrednio poprzedzających je definiuje punkt początkowy dla krzywej Bzier. Pierwsze dwa punkty PT_BEZIERTO są punkty kontrolne, a trzeci punktu PT_BEZIERTO jest punktem końcowym (jeśli zakodowane).

   PT_LINETO lub PT_BEZIERTO typu mogą być łączone z następujących flag (przy użyciu bitowego operatora **lub**) oznacza, że odpowiedni punkt jest ostatni punkt na rysunku i ilustracji powinno zostać zamknięte:

- PT_CLOSEFIGURE Określa, że rysunku zostanie automatycznie zamknięte po odpowiednim wierszu lub krzywą wzorcową. Rysunek jest zamknięty za pomocą rysowania linii z punktu końcowego linii lub krzywej do punktu, odpowiadający ostatniej PT_MOVETO.

*nCount*<br/>
Określa łączną liczbę [punktu](/windows/desktop/api/windef/ns-windef-tagpoint) struktur danych, które mogą być umieszczane w *lpPoints* tablicy. Ta wartość musi być taka sama jak liczba bajtów, które mogą być umieszczane w *lpTypes* tablicy.

### <a name="return-value"></a>Wartość zwracana

Jeśli *nCount* parametr ma wartość różną od zera, liczba punktów wyliczenia. Jeśli *nCount* ma wartość 0, łączna liczba punktów w ścieżce (i `GetPath` zapisuje nic buforów). Jeśli *nCount* jest różna od zera i jest mniejsza niż liczba punktów w ścieżce, wartość zwracana jest wartość -1.

### <a name="remarks"></a>Uwagi

Kontekst urządzenia musi zawierać ścieżkę zamkniętą. Punkty ścieżki są zwracane w logiczne współrzędnych. Punkty są przechowywane w ścieżce we współrzędnych urządzenia, więc `GetPath` zmienia się punkty z współrzędnych urządzenia logicznego współrzędnych przy użyciu odwrotność bieżącego transformacji. `FlattenPath` Funkcji składowej może zostać wywołana przed `GetPath`, aby skonwertować wszystkie krzywych w ścieżce segmenty linii.

### <a name="example"></a>Przykład

  Zobacz przykład [CDC::BeginPath](#beginpath).

##  <a name="getpixel"></a>  CDC::GetPixel

Pobiera wartość koloru RGB piksel w punkcie określonym przez *x* i *y*.

```
COLORREF GetPixel(
    int x,
    int y) const;

COLORREF GetPixel(POINT point) const;
```

### <a name="parameters"></a>Parametry

*x*<br/>
Określa logiczną współrzędną x punktu, który ma być badany.

*y*<br/>
Określa logiczną współrzędną y punktu, który ma być badany.

*Punkt*<br/>
Określa logiczną - współrzędnych x i y punktu, który ma być badany.

### <a name="return-value"></a>Wartość zwracana

W przypadku obu wersji funkcji, wartość koloru RGB koloru danego punktu. Jest to wartość -1, jeśli współrzędne nie określisz punkt w obszaru przycinania.

### <a name="remarks"></a>Uwagi

Punkt musi znajdować się w regionie wycinka. Jeśli punkt nie ma obszaru przycinania, funkcja nie ma wpływu i zwraca wartość -1.

Nie wszystkie urządzenia obsługują `GetPixel` funkcji. Aby uzyskać więcej informacji, zobacz możliwości rastrowych rastercaps w obszarze [GetDeviceCaps](#getdevicecaps) funkcja elementu członkowskiego.

`GetPixel` Funkcja elementu członkowskiego ma dwie formy. Pierwszy przyjmuje dwie wartości współrzędnych. drugi zajmuje albo [punktu](/windows/desktop/api/windef/ns-windef-tagpoint) struktury lub [CPoint](../../atl-mfc-shared/reference/cpoint-class.md) obiektu.

##  <a name="getpolyfillmode"></a>  CDC::GetPolyFillMode

Pobiera bieżący tryb wypełnianie wielokąta.

```
int GetPolyFillMode() const;
```

### <a name="return-value"></a>Wartość zwracana

Bieżący wypełnione wielokąta tryb, ALTERNATYWNYM lub rozwiązanie, jeśli funkcja się powiedzie.

### <a name="remarks"></a>Uwagi

Zobacz `SetPolyFillMode` funkcję członkowską opis tych trybów wypełnianie wielokąta.

##  <a name="getrop2"></a>  CDC::GetROP2

Pobiera bieżący tryb rysowania.

```
int GetROP2() const;
```

### <a name="return-value"></a>Wartość zwracana

Tryb rysowania. Aby uzyskać listę rysunkowe wartości trybu zobacz `SetROP2` funkcja elementu członkowskiego.

### <a name="remarks"></a>Uwagi

Tryb rysowania Określa, jak połączone kolory pióra i wewnętrznych obiektów wypełniony kolorem już na wyświetlanej powierzchni.

##  <a name="getsafehdc"></a>  CDC::GetSafeHdc

Wywołaj tę funkcję elementu członkowskiego, aby uzyskać [m_hDC](#m_hdc), dane wyjściowe kontekstu urządzenia.

```
HDC GetSafeHdc() const;
```

### <a name="return-value"></a>Wartość zwracana

Uchwyt kontekstu urządzenia.

### <a name="remarks"></a>Uwagi

Ta funkcja elementu członkowskiego współpracuje również z wskaźników o wartości null.

##  <a name="getstretchbltmode"></a>  CDC::GetStretchBltMode

Pobiera bieżący tryb rozciąganie mapy bitowej.

```
int GetStretchBltMode() const;
```

### <a name="return-value"></a>Wartość zwracana

Wartość zwracana określa bieżący tryb rozciąganie mapy bitowej — STRETCH_ANDSCANS, STRETCH_DELETESCANS lub STRETCH_ORSCANS — Jeśli funkcja się powiedzie.

### <a name="remarks"></a>Uwagi

Rozciąganie mapy bitowej trybu definiuje, jak informacji jest usuwany z mapy bitowe, które są wyczerpywane lub skompresowane za `StretchBlt` funkcja elementu członkowskiego.

Tryby STRETCH_ANDSCANS i STRETCH_ORSCANS są zwykle używane do zachować monochromatyczne pikseli pierwszego planu. Tryb STRETCH_DELETESCANS zazwyczaj jest używane do zachowania kolor map bitowych.

##  <a name="gettabbedtextextent"></a>  CDC::GetTabbedTextExtent

Wywołaj tę funkcję elementu członkowskiego, do obliczenia szerokością i wysokością ciągu znaków za pomocą [m_hAttribDC](#m_hattribdc), atrybut kontekstu urządzenia.

```
CSize GetTabbedTextExtent(
    LPCTSTR lpszString,
    int nCount,
    int nTabPositions,
    LPINT lpnTabStopPositions) const;

CSize GetTabbedTextExtent(
    const CString& str,
    int nTabPositions,
    LPINT lpnTabStopPositions) const;
```

### <a name="parameters"></a>Parametry

*lpszString*<br/>
Wskazuje ciąg znaków. Można również przekazać [CString](../../atl-mfc-shared/reference/cstringt-class.md) obiektu dla tego parametru.

*nCount*<br/>
Określa [długość ciągu](/windows/desktop/gdi/specifying-length-of-text-output-string) wskazywany przez *lpszString*.

*nTabPositions*<br/>
Określa liczbę pozycji tabulatorów w tablicy, do których prowadzą *lpnTabStopPositions*.

*lpnTabStopPositions*<br/>
Wskazuje tablicy liczb całkowitych, zawierający pozycji tabulatorów w jednostkach logicznych. Pozycji tabulatorów muszą być posortowane rosnąco; najmniejsza wartość x powinien być pierwszy element w tablicy. Tabulatory wsteczne są niedozwolone.

*str*<br/>
A `CString` obiekt, który zawiera określony znaki do rysowania.

### <a name="return-value"></a>Wartość zwracana

Wymiary w ciągu (w jednostkach logicznych) [CSize](../../atl-mfc-shared/reference/csize-class.md) obiektu.

### <a name="remarks"></a>Uwagi

Jeśli ciąg zawiera jeden lub więcej znaków tabulacji, szerokości ciągu opiera się na pozycji tabulatorów, określony przez *lpnTabStopPositions*. Funkcja używa aktualnie wybranej czcionki do obliczenia wymiarów ciągu.

Bieżący region wycinka nie przesunięcia, szerokość i wysokość zwrócony przez `GetTabbedTextExtent` funkcji.

Ponieważ niektóre urządzenia nie należy umieszczać w komórce regularnych tablic znaków (czyli one kerning znaków), Suma zakres znaków w ciągu mogą być różne w zakresie ciągu.

Jeśli *nTabPositions* wynosi 0 i *lpnTabStopPositions* ma wartość NULL, kartach są rozszerzane do ośmiu godzin szerokość znaków średniej. Jeśli *nTabPositions* wynosi 1, tabulatorów będą oddzielone odległości określonej przez pierwszą wartość w tablicy, do którego *lpnTabStopPositions* punktów. Jeśli *lpnTabStopPositions* punktów do więcej niż jedną wartość, dla każdej wartości w tablicy, maksymalna liczba określona przez ustawiono tabulatora *nTabPositions*.

##  <a name="gettextalign"></a>  CDC::GetTextAlign

Pobiera stan flagi wyrównanie tekstu do kontekstu urządzenia.

```
UINT GetTextAlign() const;
```

### <a name="return-value"></a>Wartość zwracana

Stan flagi wyrównania tekstu. Wartość zwracana jest co najmniej jeden z następujących wartości:

- Określa TA_BASELINE dostosowania osi x i linii bazowej wybranej czcionki w ramach prostokąt otaczający.

- Określa TA_BOTTOM wyrównanie osi x i u dołu prostokąt otaczający.

- Określa TA_CENTER dostosowania osi y i środek prostokąt otaczający.

- Określa TA_LEFT dostosowania osi y i z lewej strony prostokąt otaczający.

- TA_NOUPDATECP Określa, czy bieżące położenie nie jest aktualizowana.

- Określa TA_RIGHT wyrównanie osi y i po prawej stronie prostokąt otaczający.

- Określa TA_TOP wyrównanie osi x, a górną krawędzią prostokąt otaczający.

- TA_UPDATECP Określa, czy bieżące położenie jest aktualizowana.

### <a name="remarks"></a>Uwagi

Flagi wyrównanie tekstu określić sposób, w jaki `TextOut` i `ExtTextOut` elementów członkowskich Dopasuj ciąg tekstu w odniesieniu do ciągu punkt początkowy. Flagi wyrównanie tekstu nie są flagi niekoniecznie pojedynczego bitowe i może być równa 0. Aby sprawdzić, czy ustawiono flagę, aplikacji powinni wykonać następujące czynności:

1. Bitowy operator OR dotyczą flagę i jej powiązane flag, pogrupowane w następujący sposób:

    - TA_LEFT TA_CENTER i TA_RIGHT

    - TA_BASELINE TA_BOTTOM i TA_TOP

    - TA_NOUPDATECP i TA_UPDATECP

1. Zastosowanie operatora testu koniunkcji — i operatora wynik i wartość zwracana przez `GetTextAlign`.

1. Testowanie pod kątem równości ten wynik i flagi.

##  <a name="gettextcharacterextra"></a>  CDC::GetTextCharacterExtra

Pobiera bieżące ustawienie wielkości intercharacter odstępów.

```
int GetTextCharacterExtra() const;
```

### <a name="return-value"></a>Wartość zwracana

Wartość odstępu intercharacter.

### <a name="remarks"></a>Uwagi

GDI dodaje odstępy w tym do każdego znaku, w tym znaki podziału, gdy zapisuje wiersz tekstu w kontekście urządzenia.

Wartość domyślna wielkości odstępów intercharacter to 0.

##  <a name="gettextcolor"></a>  CDC::GetTextColor

Pobiera bieżący kolor tekstu.

```
COLORREF GetTextColor() const;
```

### <a name="return-value"></a>Wartość zwracana

Bieżący kolor tekstu jako wartość koloru RGB.

### <a name="remarks"></a>Uwagi

Kolor tekstu jest kolor pierwszego planu znaków rysowania za pomocą funkcji elementów członkowskich tekst wyjściowy GDI [TextOut](#textout), [ExtTextOut](#exttextout), i [TabbedTextOut](#tabbedtextout).

##  <a name="gettextextent"></a>  CDC::GetTextExtent

Wywołaj tę funkcję elementu członkowskiego do obliczenia, szerokość i wysokość wiersza tekstu przy użyciu bieżącej czcionki, aby określić wymiary.

```
CSize GetTextExtent(
    LPCTSTR lpszString,
    int nCount) const;

CSize GetTextExtent(const CString& str) const;
```

### <a name="parameters"></a>Parametry

*lpszString*<br/>
Wskazuje ciąg znaków. Można również przekazać [CString](../../atl-mfc-shared/reference/cstringt-class.md) obiektu dla tego parametru.

*nCount*<br/>
Określa liczbę znaków w ciągu.

*str*<br/>
A `CString` obiekt, który zawiera określonych znaków.

### <a name="return-value"></a>Wartość zwracana

Wymiary w ciągu (w jednostkach logicznych) [CSize](../../atl-mfc-shared/reference/csize-class.md) obiektu.

### <a name="remarks"></a>Uwagi

Informacje są pobierane z [m_hAttribDC](#m_hattribdc), atrybut kontekstu urządzenia.

Domyślnie `GetTextExtent` przyjęto założenie, tekst, dla której jest pobierany wymiaru ustawiono wzdłuż linii poziomej (czyli escapement wynosi 0). Jeśli tworzysz czcionki, określając escapement różna od zera, należy przekonwertować kąt tekstu jawnie, aby uzyskać wymiary ciągu.

Bieżący region wycinka nie ma wpływu na szerokość i wysokość zwrócony przez `GetTextExtent`.

Ponieważ niektóre urządzenia nie należy umieszczać w komórce regularnych tablic znaków (czyli wykonują kerning), Suma zakres znaków w ciągu mogą być różne w zakresie ciągu.

##  <a name="gettextextentexpointi"></a>  CDC::GetTextExtentExPointI

Pobiera liczbę znaków w określonym ciągu, który zmieści się w określonej przestrzeni i wypełnia tablicę w zakresie tekst dla każdego z tych znaków.

```
BOOL GetTextExtentExPointI(
    LPWORD pgiIn,
    int cgi,
    int nMaxExtent,
    LPINT lpnFit,
    LPINT alpDx,
    LPSIZE lpSize) const;
```

### <a name="parameters"></a>Parametry

*pgiIn*<br/>
Wskaźnik do tablicy wskaźników symbol, dla których mają być pobierane zakresów.

*cgi*<br/>
Określa liczbę symboli w tablicy, do których prowadzą *pgiIn*.

*nMaxExtent*<br/>
Określa maksymalną szerokość dopuszczalny rozmiar, w jednostkach logicznych, sformatowany ciąg.

*lpnFit*<br/>
Wskaźnik na liczbę całkowitą, która odbiera liczbę maksymalną liczbę znaków, które zmieści się w miejscu określonym przez *nMaxExtent*. Gdy *lpnFit* ma wartość NULL, *nMaxExtent* jest ignorowana.

*alpDx*<br/>
Wskaźnik do tablicy liczb całkowitych, odbierająca częściowe symbol zakresów. Każdy element w tablicy zapewnia odległość, w jednostkach logicznych, od początku tabeli indeksów symbol do jednego glify, która pasuje w miejscu określonym przez *nMaxExtent*. Chociaż ta tablica powinien mieć co najmniej tyle elementów, jak indeksy symbolu, określony przez *cgi*, funkcja wypełnia tablicę z zakresów, tylko w przypadku dowolną liczbę indeksów symbol określone przez *lpnFit*. Jeśli *lpnDx* ma wartość NULL, funkcja nie może obliczyć szerokości częściowe ciągu.

*lpSize*<br/>
Wskaźnik do [rozmiar](/windows/desktop/api/windef/ns-windef-tagsize) struktury, która odbiera wymiary tablicy wskaźników symbol w jednostkach logicznych. Ta wartość nie może mieć wartości NULL.

### <a name="return-value"></a>Wartość zwracana

Różne od zera, jeśli funkcja zakończyła się pomyślnie; w przeciwnym razie 0.

### <a name="remarks"></a>Uwagi

Ta funkcja członkowska emuluje funkcjonalność funkcji [GetTextExtentExPointI](/windows/desktop/api/wingdi/nf-wingdi-gettextextentexpointi), zgodnie z opisem w zestawie Windows SDK.

##  <a name="gettextextentpointi"></a>  CDC::GetTextExtentPointI

Pobiera szerokość i wysokość określonej tablicy indeksów symboli.

```
BOOL GetTextExtentPointI(
    LPWORD pgiIn,
    int cgi,
    LPSIZE lpSize) const;
```

### <a name="parameters"></a>Parametry

*pgiIn*<br/>
Wskaźnik do tablicy wskaźników symbol, dla których mają być pobierane zakresów.

*cgi*<br/>
Określa liczbę symboli w tablicy, do których prowadzą *pgiIn*.

*lpSize*<br/>
Wskaźnik do [rozmiar](/windows/desktop/api/windef/ns-windef-tagsize) struktury, która odbiera wymiary tablicy wskaźników symbol w jednostkach logicznych. Ta wartość nie może mieć wartości NULL.

### <a name="return-value"></a>Wartość zwracana

Różne od zera, jeśli funkcja zakończyła się pomyślnie; w przeciwnym razie 0.

### <a name="remarks"></a>Uwagi

Ta funkcja członkowska emuluje funkcjonalność funkcji [GetTextExtentPointI](/windows/desktop/api/wingdi/nf-wingdi-gettextextentpointi), zgodnie z opisem w zestawie Windows SDK.

##  <a name="gettextface"></a>  CDC::GetTextFace

Wywołaj tę funkcję elementu członkowskiego, skopiujesz nazwę krój czcionki bieżącego do bufora.

```
int GetTextFace(
    int nCount,
    LPTSTR lpszFacename) const;

int GetTextFace(CString& rString) const;
```

### <a name="parameters"></a>Parametry

*nCount*<br/>
Określa rozmiar buforu (w bajtach). Jeśli nazwa kroju jest dłuższa niż liczba bajtów podanym w tym parametrze, nazwa zostanie obcięta.

*lpszFacename*<br/>
Wskazuje buforu dla nazwy krój czcionki.

*rString*<br/>
Odwołanie do [CString](../../atl-mfc-shared/reference/cstringt-class.md) obiektu.

### <a name="return-value"></a>Wartość zwracana

Liczba bajtów skopiowanych w buforze, nie wliczając kończącego znaku null. Jeśli wystąpi błąd, to 0.

### <a name="remarks"></a>Uwagi

Nazwa krój czcionki jest kopiowana jako ciąg znaków zakończony znakiem null.

##  <a name="gettextmetrics"></a>  CDC::GetTextMetrics

Pobiera metryki dla bieżącej czcionki przy użyciu atrybutu kontekstu urządzenia.

```
BOOL GetTextMetrics(LPTEXTMETRIC lpMetrics) const;
```

### <a name="parameters"></a>Parametry

*lpMetrics*<br/>
Wskazuje [TEXTMETRIC](/windows/desktop/api/wingdi/ns-wingdi-tagtextmetrica) strukturę, która odbiera metryki.

### <a name="return-value"></a>Wartość zwracana

Różne od zera, jeśli funkcja zakończyła się pomyślnie; w przeciwnym razie 0.

##  <a name="getviewportext"></a>  CDC::GetViewportExt

Pobiera zakresów x i y okienka ekranu kontekstu urządzenia.

```
CSize GetViewportExt() const;
```

### <a name="return-value"></a>Wartość zwracana

X - i y zakres (w jednostkach urządzenia) jako `CSize` obiektu.

##  <a name="getviewportorg"></a>  CDC::GetViewportOrg

Pobiera współrzędnych x i y pochodzenia okienka ekranu skojarzonego z kontekstem urządzenia.

```
CPoint GetViewportOrg() const;
```

### <a name="return-value"></a>Wartość zwracana

Pochodzenie okienka ekranu (we współrzędnych urządzenia), jako `CPoint` obiektu.

##  <a name="getwindow"></a>  CDC::GetWindow

Zwraca okno skojarzonego z kontekstem urządzenia wyświetlaną.

```
CWnd* GetWindow() const;
```

### <a name="return-value"></a>Wartość zwracana

Wskaźnik do `CWnd` obiektu, jeśli operacja się powiedzie; w przeciwnym razie wartość NULL.

### <a name="remarks"></a>Uwagi

To jest funkcja zaawansowana. Na przykład ta funkcja elementu członkowskiego nie może zwrócić okno Widok podczas drukowania i podglądu wydruku. Zawsze zwraca okno skojarzonego z danymi wyjściowymi. Rysuj funkcje danych wyjściowych, korzystających z danego kontrolera domeny do tego okna.

##  <a name="getwindowext"></a>  CDC::GetWindowExt

Pobiera zakresów x i y okna skojarzonego z kontekstem urządzenia.

```
CSize GetWindowExt() const;
```

### <a name="return-value"></a>Wartość zwracana

X - i y zakres (w jednostkach logicznych) jako `CSize` obiektu.

##  <a name="getwindoworg"></a>  CDC::GetWindowOrg

Pobiera współrzędnych x i y pochodzenia okna skojarzonego z kontekstem urządzenia.

```
CPoint GetWindowOrg() const;
```

### <a name="return-value"></a>Wartość zwracana

Pochodzenie okna (w logiczne współrzędne) jako `CPoint` obiektu.

##  <a name="getworldtransform"></a>  CDC::GetWorldTransform

Pobiera bieżący przestrzeni świata transformację miejsce na stronie.

```
BOOL GetWorldTransform(XFORM& rXform) const;
```

### <a name="parameters"></a>Parametry

*rXform*<br/>
Odwołanie do [XFORM](/windows/desktop/api/wingdi/ns-wingdi-tagxform) strukturę, która odbiera bieżącej przestrzeni świata transformację miejsce na stronie.

### <a name="return-value"></a>Wartość zwracana

Zwraca wartość różną od zera w przypadku powodzenia.

Zwraca wartość 0 w przypadku niepowodzenia.

Aby uzyskać rozszerzone informacje o błędzie, należy wywołać [GetLastError](https://msdn.microsoft.com/library/windows/desktop/ms679360).

### <a name="remarks"></a>Uwagi

Ta metoda opakowuje funkcję Windows GDI [GetWorldTransform](/windows/desktop/api/wingdi/nf-wingdi-getworldtransform).

##  <a name="gradientfill"></a>  CDC::GradientFill

Wywołaj tę funkcję elementu członkowskiego, aby wypełnić prostokąt, trójkąt struktury kolorem, które płynnie stopniowo zmienia się z jednej strony do drugiego.

```
BOOL GradientFill(
    TRIVERTEX* pVertices,
    ULONG nVertices,
    void* pMesh,
    ULONG nMeshElements,
    DWORD dwMode);
```

### <a name="parameters"></a>Parametry

*pVertices*<br/>
Wskaźnik do tablicy [TRIVERTEX](/windows/desktop/api/wingdi/ns-wingdi-_trivertex) struktury, że każdy definiuje wierzchołka trójkąt.

*nVertices*<br/>
Liczba wierzchołków.

*pMesh*<br/>
Tablica [GRADIENT_TRIANGLE](/windows/desktop/api/wingdi/ns-wingdi-_gradient_triangle) struktur w trybie trójkąt lub tablicę [GRADIENT_RECT](/windows/desktop/api/wingdi/ns-wingdi-_gradient_rect) struktur w trybie prostokąta.

*nMeshElements*<br/>
Liczba elementów (trójkąty lub prostokąty) w *pMesh*.

*dwMode*<br/>
Określa tryb gradientu wypełnienia. Aby uzyskać listę możliwych wartości, zobacz [GradientFill](/windows/desktop/api/wingdi/nf-wingdi-gradientfill) w zestawie Windows SDK.

### <a name="return-value"></a>Wartość zwracana

Wartość TRUE, jeśli to się powiedzie; w przeciwnym razie wartość FALSE.

### <a name="remarks"></a>Uwagi

Aby uzyskać więcej informacji, zobacz `GradientFill` w zestawie Windows SDK.

##  <a name="graystring"></a>  CDC::GrayString

Rysuje wyszarzony (szary) tekst w podanej lokalizacji wpisywanie tekstu w pamięci mapy bitowej, przygaszania mapy bitowej, a następnie kopiując mapy bitowej do wyświetlenia.

```
virtual BOOL GrayString(
    CBrush* pBrush,
    BOOL (CALLBACK* lpfnOutput)(
    HDC,
    LPARAM,
    int),
    LPARAM lpData,
    int nCount,
    int x,
    int y,
    int nWidth,
    int nHeight);
```

### <a name="parameters"></a>Parametry

*pBrush*<br/>
Identyfikuje pędzla, który ma być używane dla przygasania (graying).

*lpfnOutput*<br/>
Określa adres instancję procedury, dostarczone przez aplikację funkcji wywołania zwrotnego, narysuje ciągu. Aby uzyskać więcej informacji, zobacz opis Windows `OutputFunc` [funkcji wywołania zwrotnego](callback-functions-used-by-mfc.md#graystring). Jeśli ten parametr ma wartość NULL, wówczas system używa Windows `TextOut` funkcję, aby narysować ciągu, a *lpData* zakłada, że długie wskaźnik do ciągu znaków na wyjściu.

*lpData*<br/>
Określa Daleki wskaźnik do danych, które mają być przekazane do funkcji danych wyjściowych. Jeśli *lpfnOutput* ma wartość NULL, *lpData* musi być wskaźnikiem długi ciąg jako dane wyjściowe.

*nCount*<br/>
Określa liczbę znaków, które mają być danych wyjściowych. Jeśli ten parametr ma wartość 0, `GrayString` oblicza długość ciągu (przy założeniu, że *lpData* jest wskaźnikiem do ciągu). Jeśli *nCount* jest 1 i funkcja wskazywany przez *lpfnOutput* zwraca wartość 0, obraz, który jest wyświetlany, ale nie są wygaszone.

*x*<br/>
Określa logiczną współrzędną x pozycji początkowej prostokąt, który zawiera ciąg.

*y*<br/>
Określa logiczną współrzędną y pozycji początkowej prostokąt, który zawiera ciąg.

*nWidth*<br/>
Określa szerokość (w jednostkach logicznych) prostokąta, który zawiera ciąg. Jeśli *nWidth* ma wartość 0, `GrayString` oblicza szerokość obszaru, zakładając, że *lpData* jest wskaźnikiem do ciągu.

*nHeight*<br/>
Określa wysokość (w jednostkach logicznych) prostokąta, który zawiera ciąg. Jeśli *nHeight* ma wartość 0, `GrayString` oblicza wysokość obszaru, zakładając, że *lpData* jest wskaźnikiem do ciągu.

### <a name="return-value"></a>Wartość zwracana

Wartość różną od zera, jeśli ciąg jest rysowana, lub 0, jeśli `TextOut` funkcji lub aplikacja dostarczona dane wyjściowe zwrócił wartość 0, lub za mało pamięci, aby utworzyć mapę bitową pamięci dla przygaszania.

### <a name="remarks"></a>Uwagi

Funkcja wygasza tekstu, niezależnie od tego, czy wybrany pędzel i tła. `GrayString` Funkcja członkowska używa aktualnie wybranej czcionki. Przed rozpoczęciem korzystania z tej funkcji należy wybrać tryb mapowania MM_TEXT.

Aplikację można narysować wygaszone ciągów (wygaszone) na urządzeniach, które obsługuje jednolitego szarego koloru bez wywoływania `GrayString` funkcja elementu członkowskiego. Kolor system COLOR_GRAYTEXT jest kolor szary stałe systemu, używany do rysowania wyłączonego tekstu. Aplikacja może wywołać `GetSysColor` funkcji Windows można pobrać wartości koloru COLOR_GRAYTEXT. Jeśli kolor jest równa 0 (czarny), aplikacja może wywołać `SetTextColor` funkcja elementu członkowskiego, aby ustawić kolor tekstu na wartość koloru, a następnie narysuj ciąg bezpośrednio. Jeśli pobrane kolor czarny, aplikacja musi wywołać `GrayString` do dim (szare) tekst.

Jeśli *lpfnOutput* ma wartość NULL, Windows korzysta z użyciem interfejsu GDI [TextOut](/windows/desktop/api/wingdi/nf-wingdi-textouta) funkcji i *lpData* zakłada, że Daleki wskaźnik znak na wyjściu. Jeśli znaki, które mają być danych wyjściowych nie mogą być obsługiwane przez `TextOut` funkcja elementu członkowskiego (na przykład, ciąg jest przechowywany jako mapę bitową), aplikacji, należy podać jego własnej funkcji danych wyjściowych.

Należy również zauważyć, że wszystkie funkcje wywołania zwrotnego musi przechwytują wyjątki Microsoft Foundation przed zwróceniem do Windows, ponieważ nie może być zgłaszane wyjątki granice wywołania zwrotnego. Aby uzyskać więcej informacji na temat wyjątków, zobacz artykuł [wyjątki](../../mfc/exception-handling-in-mfc.md).

Funkcja wywołania zwrotnego jest przekazywany do `GrayString` należy użyć `__stdcall` konwencji wywoływania i musi zostać wyeksportowany z `__declspec`.

Kiedy struktura jest w trybie podglądu, wywołanie `GrayString` funkcja członkowska jest tłumaczona na `TextOut` wywołanie i funkcji wywołania zwrotnego nie jest wywoływana.

##  <a name="himetrictodp"></a>  CDC::HIMETRICtoDP

Podczas konwersji HIMETRIC rozmiarów z OLE na pikseli, należy użyć tej funkcji.

```
void HIMETRICtoDP(LPSIZE lpSize) const;
```

### <a name="parameters"></a>Parametry

*lpSize*<br/>
Wskazuje [rozmiar](/windows/desktop/api/windef/ns-windef-tagsize) struktury lub [CSize](../../atl-mfc-shared/reference/csize-class.md) obiektu.

### <a name="remarks"></a>Uwagi

W przypadku MM_LOENGLISH, MM_HIENGLISH, MM_LOMETRIC lub MM_HIMETRIC tryb mapowania obiektu kontekstu urządzenia konwersji jest oparty na liczbę pikseli w fizycznych CAL. Jeśli tryb mapowania jest jednym z innych niż ograniczonego trybów (np. MM_TEXT), następnie konwersji opiera się na liczbę pikseli cal logiczny.

##  <a name="himetrictolp"></a>  CDC::HIMETRICtoLP

Wywołaj tę funkcję, aby przekonwertować jednostkach HIMETRIC jednostki logiczne.

```
void HIMETRICtoLP(LPSIZE lpSize) const;
```

### <a name="parameters"></a>Parametry

*lpSize*<br/>
Wskazuje [rozmiar](/windows/desktop/api/windef/ns-windef-tagsize) struktury lub [CSize](../../atl-mfc-shared/reference/csize-class.md) obiektu.

### <a name="remarks"></a>Uwagi

Funkcja ta jest używana, po uzyskiwanie rozmiary HIMETRIC OLE i chcesz konwertować je na tryb mapowania fizyczną aplikacji.

Konwersja odbywa się przez najpierw przekształcania jednostkach HIMETRIC w pikselach, a następnie konwertując te jednostki do jednostek logicznych przy użyciu jednostek mapowania z bieżącego kontekstu urządzenia. Należy zauważyć, że zakres okna i okienka ekranu urządzenia będzie mieć wpływ na wynik.

##  <a name="intersectcliprect"></a>  CDC::IntersectClipRect

Tworzy nowy obszar przycinania, stanowiące część wspólną bieżący region i prostokąt określony przez *x1*, *y1*, *x2*, i *y2*.

```
int IntersectClipRect(
    int x1,
    int y1,
    int x2,
    int y2);

int IntersectClipRect(LPCRECT lpRect);
```

### <a name="parameters"></a>Parametry

*x1*<br/>
Określa logiczną współrzędną x lewego górnego rogu prostokąta.

*y1*<br/>
Określa logiczną współrzędną y lewego górnego rogu prostokąta.

*x2*<br/>
Określa logiczną współrzędną x w prawym dolnym rogu prostokąta.

*y2*<br/>
Określa logiczną współrzędną y prawego dolnego rogu prostokąta.

*lpRect*<br/>
Określa prostokąta. Można przekazać `CRect` obiekt lub wskaźnik do `RECT` struktury dla tego parametru.

### <a name="return-value"></a>Wartość zwracana

Typ nowego obszaru przycinania. Może być jednym z następujących wartości:

- COMPLEXREGION nowego obszaru przycinania ma nakładających się obramowań.

- Kontekst urządzenia błędu jest nieprawidłowa.

- NULLREGION nowy region wycinka jest pusty.

- SIMPLEREGION nowy region wycinka nie ma nakładające się obramowania.

### <a name="remarks"></a>Uwagi

GDI przycina wszystkie kolejne dane wyjściowe mieścić się w nową granicę. Szerokość i wysokość nie może przekraczać 32 767 znaków.

##  <a name="invertrect"></a>  CDC::InvertRect

Odwraca zawartość danego prostokąta.

```
void InvertRect(LPCRECT lpRect);
```

### <a name="parameters"></a>Parametry

*lpRect*<br/>
Wskazuje `RECT` zawierający logiczne współrzędnych prostokąta do być zmieniany. Można również przekazać `CRect` obiektu dla tego parametru.

### <a name="remarks"></a>Uwagi

Odwracanie jest wartość logiczna nie operacji i Przerzuca bity każdego piksela. Na ekranach monochromatyczny funkcja sprawia, że piksele czarne i czarny pikseli białe. Na ekranach kolor odwrócenie zależy od tego, jak kolory są generowane podczas wyświetlania. Wywoływanie `InvertRect` dwukrotnie z tego samego prostokąt przywraca wyświetlania poprzednich kolorów.

Jeśli prostokąta jest pusta, nic nie jest rysowane.

### <a name="example"></a>Przykład

[!code-cpp[NVC_MFCDocView#36](../../mfc/codesnippet/cpp/cdc-class_8.cpp)]

##  <a name="invertrgn"></a>  CDC::InvertRgn

Odwraca kolory w regionie, określony przez *pRgn*.

```
BOOL InvertRgn(CRgn* pRgn);
```

### <a name="parameters"></a>Parametry

*pRgn*<br/>
Identyfikuje region, który chcesz odwrócić. Współrzędne dla regionu są określone w jednostkach logicznych.

### <a name="return-value"></a>Wartość zwracana

Różne od zera, jeśli funkcja zakończyła się pomyślnie; w przeciwnym razie 0.

### <a name="remarks"></a>Uwagi

Na ekranach monochromatyczny funkcja sprawia, że piksele czarne i czarny pikseli białe. Na ekranach kolor odwrócenie zależy od tego, jak kolory są generowane podczas wyświetlania.

##  <a name="isprinting"></a>  CDC::IsPrinting

Określa, czy kontekst urządzenia jest używana do drukowania.

```
BOOL IsPrinting() const;
```

### <a name="return-value"></a>Wartość zwracana

Jeśli wartość różną od zera `CDC` drukarka jest obiekt kontrolera domeny; w przeciwnym razie 0.

##  <a name="lineto"></a>  CDC::LineTo

Rysuje linię z bieżącej pozycji w górę do, ale nie tym, określony przez punkt *x* i *y* (lub *punktu*).

```
BOOL LineTo(
    int x,
    int y);

BOOL LineTo(POINT point);
```

### <a name="parameters"></a>Parametry

*x*<br/>
Określa logiczną współrzędną x punktu końcowego dla wiersza.

*y*<br/>
Określa logiczną współrzędną y punktu końcowego dla wiersza.

*Punkt*<br/>
Określa punkt końcowy dla wiersza. Można przekazać `POINT` struktury lub `CPoint` obiektu dla tego parametru.

### <a name="return-value"></a>Wartość zwracana

Wartość różną od zera, jeśli linia jest rysowana; w przeciwnym razie 0.

### <a name="remarks"></a>Uwagi

Linia jest rysowana dla wybranego pióra. Bieżące położenie jest ustawiona na *x*, *y* lub *punktu*.

### <a name="example"></a>Przykład

  Zobacz przykład [CRect::CenterPoint](../../atl-mfc-shared/reference/crect-class.md#centerpoint).

##  <a name="lptodp"></a>  CDC::LPtoDP

Konwertuje jednostek logicznych jednostek urządzenia.

```
void LPtoDP(
    LPPOINT lpPoints,
    int nCount = 1) const;

void LPtoDP(LPRECT lpRect) const;
void LPtoDP(LPSIZE lpSize) const;
```

### <a name="parameters"></a>Parametry

*lpPoints*<br/>
Wskazuje tablicy punktów. Każdy punkt w tablicy jest [punktu](/windows/desktop/api/windef/ns-windef-tagpoint) struktury lub [CPoint](../../atl-mfc-shared/reference/cpoint-class.md) obiektu.

*nCount*<br/>
Liczba punktów w tablicy.

*lpRect*<br/>
Wskazuje [Prostokąt](/windows/desktop/api/windef/ns-windef-tagrect) struktury lub [CRect](../../atl-mfc-shared/reference/crect-class.md) obiektu. Ten parametr jest używany w przypadku typowych mapowanie prostokąt, od logicznych jednostek urządzenia.

*lpSize*<br/>
Wskazuje [rozmiar](/windows/desktop/api/windef/ns-windef-tagsize) struktury lub [CSize](../../atl-mfc-shared/reference/csize-class.md) obiektu.

### <a name="remarks"></a>Uwagi

Funkcja map, współrzędne każdego punktu lub wymiary rozmiaru, od firmy GDI logiczne współrzędnych w układzie współrzędnych urządzenia. Konwersja zależy od tego, bieżący tryb mapowania i ustawienia źródła i zakresów okna i okienka ekranu urządzenia.

Współrzędne x i y punkty są 2-bajtowych liczb całkowitych ze znakiem z zakresu od-32 768 za pośrednictwem 32 767 znaków. W przypadkach, w których tryb mapowania mogłoby spowodować wartości większej niż te limity system ustawia wartości-32 768 do 32 767, odpowiednio.

##  <a name="lptohimetric"></a>  CDC::LPtoHIMETRIC

Wywołaj tę funkcję, aby przekonwertować jednostek logicznych jednostkach HIMETRIC.

```
void LPtoHIMETRIC(LPSIZE lpSize) const;
```

### <a name="parameters"></a>Parametry

*lpSize*<br/>
Wskazuje `SIZE` struktury lub `CSize` obiektu.

### <a name="remarks"></a>Uwagi

Tę funkcję możesz przekazać rozmiary HIMETRIC OLE, konwertowanie z trybu naturalnych mapowania aplikacji. Należy zauważyć, że zakres okna i okienka ekranu urządzenia będzie mieć wpływ na wynik.

Konwersja odbywa się przy pierwszym konwersji jednostki logiczne do pikseli przy użyciu kontekstu urządzenia bieżące mapowania jednostki, a następnie konwertując tych jednostek w jednostkach HIMETRIC.

##  <a name="m_hattribdc"></a>  CDC::m_hAttribDC

Atrybutu kontekst urządzenia dla tego `CDC` obiektu.

```
HDC m_hAttribDC;
```

### <a name="remarks"></a>Uwagi

Domyślnie ten kontekst urządzenia jest równa `m_hDC`. Ogólnie rzecz biorąc `CDC` wywołania interfejsu GDI, które żądają informacji z kontekstu urządzenia są kierowane do `m_hAttribDC`. Zobacz [CDC](../../mfc/reference/cdc-class.md) opis Aby uzyskać więcej informacji dotyczących używania tych kontekstach urządzenia dwóch klas.

##  <a name="m_hdc"></a>  CDC::m_hDC

Kontekst urządzenia dane wyjściowe, w tym `CDC` obiektu.

```
HDC m_hDC;
```

### <a name="remarks"></a>Uwagi

Domyślnie `m_hDC` jest równa `m_hAttribDC`, innych kontekstu urządzenia opakowane przez `CDC`. Ogólnie rzecz biorąc `CDC` wywołania interfejsu GDI, tworzące dane wyjściowe, przejdź do `m_hDC` kontekstu urządzenia. Można zainicjować `m_hDC` i `m_hAttribDC` aby wskazywały na różnych urządzeniach. Zobacz [CDC](../../mfc/reference/cdc-class.md) opis Aby uzyskać więcej informacji dotyczących używania tych kontekstach urządzenia dwóch klas.

##  <a name="maskblt"></a>  CDC::MaskBlt

Łączy dane koloru dla map bitowych źródłowych i docelowych przy użyciu danego maski i operacja rastrowa.

```
BOOL MaskBlt(
    int x,
    int y,
    int nWidth,
    int nHeight,
    CDC* pSrcDC,
    int xSrc,
    int ySrc,
    CBitmap& maskBitmap,
    int xMask,
    int yMask,
    DWORD dwRop);
```

### <a name="parameters"></a>Parametry

*x*<br/>
Określa logiczną współrzędną x lewego górnego rogu prostokąta docelowego.

*y*<br/>
Określa logiczną współrzędną y lewego górnego rogu prostokąta docelowego.

*nWidth*<br/>
Określa szerokość w logiczne jednostki docelowej prostokąt i źródłowej mapy bitowej.

*nHeight*<br/>
Określa wysokość w logiczne jednostki docelowej prostokąt i źródłowej mapy bitowej.

*pSrcDC*<br/>
Identyfikuje kontekst urządzenia, z którego ma zostać skopiowany mapy bitowej. Musi to być zero, jeśli *dwRop* parametr określa operację rastrową, która, który nie zawiera źródła.

*xSrc*<br/>
Określa logiczną współrzędną x lewego górnego rogu źródłową mapę bitową.

*ySrc*<br/>
Określa logiczną współrzędną y lewego górnego rogu źródłową mapę bitową.

*maskBitmap*<br/>
Identyfikuje mapy bitowej maski monochromatyczny, w połączeniu z mapą bitową kolorów w kontekście urządzenia źródłowego.

*xMask*<br/>
Określa przesunięcie poziomy pikseli mapy bitowej maski określony przez *maskBitmap* parametru.

*yMask*<br/>
Określa przesunięcie pikseli w pionie mapy bitowej maski określony przez *maskBitmap* parametru.

*dwRop*<br/>
Określa pierwszego planu i tła liczbą kody operacji rastrowych trójargumentowy, które funkcja używa do kontrolowania kombinację danych źródłowych i docelowych. Kod operacji rastrowych tła jest przechowywany w bajcie słowo wysokiej wartości; Kod operacji rastrowych pierwszego planu jest przechowywany w bajcie słowo wysokiej wartości; niższe słowo ta wartość jest ignorowana, a powinna wynosić zero. Makro MAKEROP4 tworzy kombinacji pierwszego planu i tła, kody operacji rastrowych. Zobacz sekcję Uwagi omówienie pierwszego planu i tła w kontekście tej funkcji. Zobacz `BitBlt` funkcja elementu członkowskiego, aby uzyskać listę typowych kody operacji rastrowych.

### <a name="return-value"></a>Wartość zwracana

Różne od zera, jeśli funkcja zakończyła się pomyślnie; w przeciwnym razie 0.

### <a name="remarks"></a>Uwagi

Wartość 1 w masce określony przez *maskBitmap* wskazuje, że kod operacji rastrowych pierwszego planu, określony przez *dwRop* powinny być stosowane w tej lokalizacji. Wartość 0 w masce wskazuje na to, że kod operacji rastrowych tła określony przez *dwRop* powinny być stosowane w tej lokalizacji. Jeśli operacji rastrowych wymaga źródła, prostokąt maska musi obejmować prostokąta źródłowego. Jeśli nie, funkcja zakończy się niepowodzeniem. W przypadku operacji rastrowych niewymagające źródłem prostokąt maska musi obejmować prostokąta docelowego. Jeśli nie, funkcja zakończy się niepowodzeniem.

Jeśli transformacja obrót lub Pochyl są włączone dla kontekst urządzenia źródłowego, gdy ta funkcja jest wywoływana, wystąpi błąd. Jednak inne typy przekształcenia są dozwolone.

Jeśli są różne formaty kolor źródła, wzorzec i docelowego, mapy bitowe, ta funkcja konwertuje wzorzec format źródła i/lub, zgodnie z formatem docelowego. Jeśli mapy bitowej maski jest monochromatycznych map bitowych, wystąpi błąd. Gdy rozszerzony metaplik jest rejestrowany, wystąpi błąd (i funkcja zwraca 0) jeśli kontekst urządzenia źródłowego identyfikuje rozszerzonych metaplików kontekstu urządzenia. Nie wszystkie urządzenia obsługują `MaskBlt`. Aplikacja powinna wywołać `GetDeviceCaps` do określenia, czy urządzenie obsługuje tę funkcję. Jeśli nie dostarczono żadnych mapy bitowej maski, ta funkcja działa dokładnie tak jak `BitBlt`, przy użyciu kodu operacji rastrowych pierwszego planu. Piksel powoduje przesunięcie w mapie mapy bitowej maski do punktu (0,0) w mapie bitowej kontekst urządzenia źródłowego. Jest to przydatne w sytuacjach, w których mapy bitowej maski zawiera zbiór maski; aplikację można z łatwością zastosować jeden z nich do zadania maska — Kopiowanie bloku z powierzchni, dostosowując przesunięcia pikseli i rozmiary prostokąt wysyłane do `MaskBlt`.

##  <a name="modifyworldtransform"></a>  CDC::ModifyWorldTransform

Zmienia transformacji świata dla kontekstu urządzenia za pomocą określonego trybu.

```
BOOL ModifyWorldTransform(
    const XFORM& rXform,
    DWORD iMode);
```

### <a name="parameters"></a>Parametry

*rXform*<br/>
Odwołanie do [XFORM](/windows/desktop/api/wingdi/ns-wingdi-tagxform) struktury, używane do modyfikowania transformacji świata w kontekście danego urządzenia.

*iMode*<br/>
Określa, jak dane transformacji modyfikuje bieżącego transformacji świata. Aby uzyskać listę wartości, które można wykonać tego parametru zobacz [ModifyWorldTransform](/windows/desktop/api/wingdi/nf-wingdi-modifyworldtransform).

### <a name="return-value"></a>Wartość zwracana

Zwraca wartość różną od zera w przypadku powodzenia.

Zwraca wartość 0 w przypadku niepowodzenia.

Aby uzyskać rozszerzone informacje o błędzie, należy wywołać [GetLastError](https://msdn.microsoft.com/library/windows/desktop/ms679360).

### <a name="remarks"></a>Uwagi

Ta metoda opakowuje funkcję Windows GDI [ModifyWorldTransform](/windows/desktop/api/wingdi/nf-wingdi-modifyworldtransform).

##  <a name="moveto"></a>  CDC::MoveTo

Przenosi bieżącą pozycję w punkcie określonym przez *x* i *y* (lub *punktu*).

```
CPoint MoveTo(
    int x,
    int y);

CPoint MoveTo(POINT point);
```

### <a name="parameters"></a>Parametry

*x*<br/>
Określa logiczną współrzędną x pozycji nowy.

*y*<br/>
Określa logiczną współrzędną y pozycji nowy.

*Punkt*<br/>
Określa nowe miejsce. Można przekazać `POINT` struktury lub `CPoint` obiektu dla tego parametru.

### <a name="return-value"></a>Wartość zwracana

Współrzędne x i y poprzedniej pozycji jako `CPoint` obiektu.

### <a name="example"></a>Przykład

  Zobacz przykład [CRect::CenterPoint](../../atl-mfc-shared/reference/crect-class.md#centerpoint).

##  <a name="offsetcliprgn"></a>  CDC::OffsetClipRgn

Przenosi obszaru przycinania kontekstu urządzenia według określonych przesunięć.

```
int OffsetClipRgn(
    int x,
    int y);

int OffsetClipRgn(SIZE size);
```

### <a name="parameters"></a>Parametry

*x*<br/>
Określa liczbę jednostek logicznych, aby przesunąć w lewo lub w prawo.

*y*<br/>
Określa liczbę jednostek logicznych na przeniesienie w górę lub w dół.

*Rozmiar*<br/>
Określa ilość, o które zostanie przesunięte.

### <a name="return-value"></a>Wartość zwracana

Typ w nowym regionie. Może być jednym z następujących wartości:

- Przycinanie COMPLEXREGION regionu ma nakładających się obramowań.

- Kontekst urządzenia błędu jest nieprawidłowa.

- Przycinanie NULLREGION regionu jest pusta.

- Przycinanie SIMPLEREGION regionie nie ma nakładające się obramowania.

### <a name="remarks"></a>Uwagi

Funkcja przenosi region *x* jednostek wzdłuż osi x i *y* jednostki wzdłuż osi y.

##  <a name="offsetviewportorg"></a>  CDC::OffsetViewportOrg

Modyfikuje współrzędne źródła okienka ekranu względem współrzędnych pochodzenia bieżącego okienka ekranu.

```
virtual CPoint OffsetViewportOrg(
    int nWidth,
    int nHeight);
```

### <a name="parameters"></a>Parametry

*nWidth*<br/>
Określa liczbę jednostek urządzenia można dodać do współrzędnej x bieżącego źródła.

*nHeight*<br/>
Określa liczbę jednostek urządzeń do dodania do bieżącego źródła współrzędną y punktu.

### <a name="return-value"></a>Wartość zwracana

Poprzednie okienko ekranu punkt początkowy (we współrzędnych urządzenia) jako `CPoint` obiektu.

##  <a name="offsetwindoworg"></a>  CDC::OffsetWindowOrg

Modyfikuje współrzędne źródła okna względem współrzędnych pochodzenia bieżącego okna.

```
CPoint OffsetWindowOrg(
    int nWidth,
    int nHeight);
```

### <a name="parameters"></a>Parametry

*nWidth*<br/>
Określa liczbę jednostek logicznych do dodania do współrzędnej x bieżącego źródła.

*nHeight*<br/>
Określa liczbę jednostek logicznych do dodania do bieżącego źródła współrzędną y punktu.

### <a name="return-value"></a>Wartość zwracana

Poprzednie okno miejsca pochodzenia (w logiczne współrzędne) jako `CPoint` obiektu.

##  <a name="operator_hdc"></a>  CDC::operator elementu HDC

Użyj tego operatora, aby pobrać uchwyt kontekstu urządzenia z `CDC` obiektu.

```
operator HDC() const;
```

### <a name="return-value"></a>Wartość zwracana

Jeśli to się powiedzie, uchwyt obiektu kontekstu urządzenia; w przeciwnym razie wartość NULL.

### <a name="remarks"></a>Uwagi

Dojście służy do wywoływania interfejsów API Windows bezpośrednio.

##  <a name="paintrgn"></a>  CDC::PaintRgn

Wypełnia określonego przez regionu *pRgn* przy użyciu bieżącego pędzla.

```
BOOL PaintRgn(CRgn* pRgn);
```

### <a name="parameters"></a>Parametry

*pRgn*<br/>
Identyfikuje region, który ma zostać wypełniony. Współrzędnych dla danego regionu są określone w jednostkach logicznych.

### <a name="return-value"></a>Wartość zwracana

Różne od zera, jeśli funkcja zakończyła się pomyślnie; w przeciwnym razie 0.

##  <a name="patblt"></a>  CDC::PatBlt

Tworzy wzorca bitowego na urządzeniu.

```
BOOL PatBlt(
    int x,
    int y,
    int nWidth,
    int nHeight,
    DWORD dwRop);
```

### <a name="parameters"></a>Parametry

*x*<br/>
Określa logiczną współrzędną x lewego górnego rogu prostokąta, który ma otrzymać wzorzec.

*y*<br/>
Określa logiczną współrzędną y lewego górnego rogu prostokąta, który ma otrzymać wzorzec.

*nWidth*<br/>
Określa szerokość (w jednostkach logicznych) prostokąta, który ma otrzymać wzorzec.

*nHeight*<br/>
Określa wysokość (w jednostkach logicznych) prostokąta, który ma otrzymać wzorzec.

*dwRop*<br/>
Określa operację rastrową, która kod. Kody operacji rastrowych (ROPs) definiują, jak interfejs GDI łączy kolory w operacjach wyjściowych, które obejmują aktualny Pędzel, możliwą źródłową mapę bitową i docelową mapę bitową. Ten parametr może być jedną z następujących wartości:

- Wzorzec PATCOPY kopie do docelowej mapy bitowej.

- Łączy PATINVERT docelową mapę bitową z deseniem za pomocą operatora logicznego XOR.

- DSTINVERT odwraca docelową mapę bitową.

- Włącza CZERNI wyjściowy na czerń.

- Włącza WHITENESS wyjściowy na biel.

### <a name="return-value"></a>Wartość zwracana

Różne od zera, jeśli funkcja zakończyła się pomyślnie; w przeciwnym razie 0.

### <a name="remarks"></a>Uwagi

Wzorzec jest kombinacją wybrany pędzel i wzorzec już na urządzeniu. Operacja rastrowa kod określony przez *dwRop* definiuje, jak wzorce mają być łączone. Rastrowych wymienionych dla tej funkcji są ograniczonym podzbiorem pełnej 256 kody trójargumentowy operacja rastrowa; w szczególności nie można użyć kodu operacja rastrowa, która odwołuje się do źródła.

Nie wszystkie konteksty urządzenia obsługują `PatBlt` funkcji. Aby sprawdzić, czy kontekst urządzenia obsługuje `PatBlt`, wywołaj `GetDeviceCaps` element członkowski funkcji o indeksie RASTERCAPS i sprawdź wartość zwracaną dla flagi rastercaps.

##  <a name="pie"></a>  CDC::Pie

Rysuje klina ukształtowane kołowy za pomocą rysowania łuk eliptyczny którego Centrum i dwa punkty końcowe są połączone liniami.

```
BOOL Pie(
    int x1,
    int y1,
    int x2,
    int y2,
    int x3,
    int y3,
    int x4,
    int y4);

BOOL Pie(
    LPCRECT lpRect,
    POINT ptStart,
    POINT ptEnd);
```

### <a name="parameters"></a>Parametry

*x1*<br/>
Określa współrzędną x w lewym górnym rogu prostokąt otaczający (w jednostkach logicznych).

*y1*<br/>
Określa współrzędną y lewego górnego rogu prostokąt otaczający (w jednostkach logicznych).

*x2*<br/>
Określa współrzędną x w prawym dolnym rogu prostokąt otaczający (w jednostkach logicznych).

*y2*<br/>
Określa współrzędną y prawego dolnego rogu prostokąt otaczający (w jednostkach logicznych).

*x3*<br/>
Określa współrzędną x punktu początkowego łuku (w jednostkach logicznych). Ten punkt nie musi znajdować się dokładnie na łuk.

*y3*<br/>
Określa współrzędną y punktu początkowego łuku (w jednostkach logicznych). Ten punkt nie musi znajdować się dokładnie na łuk.

*x4*<br/>
Określa współrzędną x punktu końcowego łuku (w jednostkach logicznych). Ten punkt nie musi znajdować się dokładnie na łuk.

*y4*<br/>
Określa współrzędną y punktu końcowego łuku (w jednostkach logicznych). Ten punkt nie musi znajdować się dokładnie na łuk.

*lpRect*<br/>
Określa prostokąt otaczający. Można przekazać `CRect` obiekt lub wskaźnik do `RECT` struktury dla tego parametru.

*ptStart*<br/>
Określa punkt początkowy łuku. Ten punkt nie musi znajdować się dokładnie na łuk. Można przekazać [punktu](/windows/desktop/api/windef/ns-windef-tagpoint) struktury lub [CPoint](../../atl-mfc-shared/reference/cpoint-class.md) obiektu dla tego parametru.

*ptEnd*<br/>
Określa punkt końcowy łuku. Ten punkt nie musi znajdować się dokładnie na łuk. Można przekazać `POINT` struktury lub `CPoint` obiektu dla tego parametru.

### <a name="return-value"></a>Wartość zwracana

Różne od zera, jeśli funkcja zakończyła się pomyślnie; w przeciwnym razie 0.

### <a name="remarks"></a>Uwagi

Środek łuk jest środek prostokąt otaczający określony przez *x1*, *y1*, *x2*, i *y2* (lub *lprect —* ). Początkowe i końcowe punkty łuku są określone przez *x3*, *y3*, *x4*, i *y4* (lub *ptStart*i *ptEnd*).

Łuku wybranego pióra, przesunięcie do ruchu wskazówek zegara. Dwa dodatkowe wiersze są pobierane z każdego punktu końcowego w Centrum łuku. Obszar w kształcie kołowy jest wypełniony aktualny pędzel. Jeśli *x3* jest równa *x4* i *y3* jest równa *y4*, wynik jest elipsę za pomocą pojedynczego wiersza ze środka elipsy do punktu ( *x3*, *y3*) lub ( *x4*, *y4*).

Rysunek rysowane przez tę funkcję rozciąga się do, ale nie uwzględnia współrzędne po prawej stronie i u dołu. Oznacza, że wysokość rysunku *y2* - *y1* i szerokość rysunku jest *x2* - *x1*. Szerokość i wysokość prostokąta otaczający musi być większa niż 2 i mniej niż 32 767 jednostek.

### <a name="example"></a>Przykład

[!code-cpp[NVC_MFCDocView#37](../../mfc/codesnippet/cpp/cdc-class_9.cpp)]

##  <a name="playmetafile"></a>  CDC::PlayMetaFile

Odtwarza zawartość określonego meta pliku w kontekście urządzenia.

```
BOOL PlayMetaFile(HMETAFILE hMF);

BOOL PlayMetaFile(
    HENHMETAFILE hEnhMetaFile,
    LPCRECT lpBounds);
```

### <a name="parameters"></a>Parametry

*hMF*<br/>
Identyfikuje metaplik do odtworzenia.

*hEnhMetaFile*<br/>
Identyfikuje rozszerzony metaplik.

*lpBounds*<br/>
Wskazuje `RECT` struktury lub `CRect` obiekt, który zawiera współrzędne prostokąt otaczający używany do wyświetlania obrazu. Współrzędne są określone w jednostkach logicznych.

### <a name="return-value"></a>Wartość zwracana

Różne od zera, jeśli funkcja zakończyła się pomyślnie; w przeciwnym razie 0.

### <a name="remarks"></a>Uwagi

Metaplik mogą być odtwarzane dowolną liczbę razy.

Druga wersja `PlayMetaFile` Wyświetla obraz przechowywany w danym metaplik rozszerzony format. Kiedy aplikacja wywołuje drugą wersję `PlayMetaFile`, Windows używa ramki obrazu w nagłówku rozszerzonych metaplików do mapowania obrazu na prostokącie wskazywany przez *lpBounds* parametru. (Ten obraz może być pochylono lub obracać, ustawiając Przekształcanie świata w danych wyjściowych urządzenia przed wywołaniem `PlayMetaFile`.) Na ilustracji znajdują się punkty wzdłuż krawędzi prostokąta. Obraz rozszerzonych metaplików funkcję jej obcinania, definiując obszaru przycinania w pliku danych wyjściowych przed odtwarzanie rozszerzony metaplik.

Jeśli rozszerzony metaplik zawiera opcjonalne palety, aplikacja może osiągnąć spójnych kolorów, konfigurując palety kolorów na urządzeniu wyjściowym przed wywołaniem drugą wersję `PlayMetaFile`. Aby pobrać opcjonalne palety, użyj `GetEnhMetaFilePaletteEntries` funkcji Windows. Rozszerzony metaplik mogą być osadzone w nowo utworzonej rozszerzony metaplik przez wywołanie metody drugą wersję `PlayMetaFile` i odtwarzanie metaplik rozszerzone źródło do kontekstu urządzenia dla nowego rozszerzony metaplik.

Stany kontekstu urządzenia dane wyjściowe są zachowywane przez tę funkcję. Każdy obiekt utworzony, ale nie są usuwane w rozszerzony metaplik usunięcia przez tę funkcję. Aby zatrzymać tę funkcję, aplikacja może wywołać `CancelDC` Windows funkcji z innego wątku, aby zakończyć operację. W takim przypadku funkcja zwraca wartość zero.

##  <a name="plgblt"></a>  CDC::PlgBlt

Wykonuje transfer blok bitowy bity danych kolor prostokąta określonego w kontekście urządzenia źródłowego w określonym równoległobok w kontekście danego urządzenia.

```
BOOL PlgBlt(
    LPPOINT lpPoint,
    CDC* pSrcDC,
    int xSrc,
    int ySrc,
    int nWidth,
    int nHeight,
    CBitmap& maskBitmap,
    int xMask,
    int yMask);
```

### <a name="parameters"></a>Parametry

*lpPoint*<br/>
Wskazuje tablicy trzech punktów w przestrzeni logicznej, identyfikujący trzy narożników równoległobok docelowego. W lewym górnym rogu prostokąta źródłowego jest mapowana do pierwszego punktu, w tej tablicy, prawym górnym rogu do drugiego w tej tablicy i lewego dolnego rogu w punkcie trzeci. W prawym dolnym rogu prostokąta źródłowego jest zamapowana na czwarty niejawne momentów równoległobok.

*pSrcDC*<br/>
Identyfikuje kontekst urządzenia źródłowego.

*xSrc*<br/>
Określa współrzędną x w jednostkach logicznych, w lewym górnym rogu prostokąta źródłowego.

*ySrc*<br/>
Określa współrzędną y w jednostkach logicznych, w lewym górnym rogu prostokąta źródłowego.

*nWidth*<br/>
Określa szerokość w jednostkach logicznych, prostokąta źródłowego.

*nHeight*<br/>
Określa wysokość w jednostkach logicznych, prostokąta źródłowego.

*maskBitmap*<br/>
Określa opcjonalny monochromatycznych map bitowych, służący do zamaskowania kolory prostokąta źródłowego.

*xMask*<br/>
Określa współrzędną x w lewym górnym rogu monochromatyczną mapę bitową.

*yMask*<br/>
Określa współrzędną y lewego górnego rogu monochromatyczną mapę bitową.

### <a name="return-value"></a>Wartość zwracana

Różne od zera, jeśli funkcja zakończyła się pomyślnie; w przeciwnym razie 0.

### <a name="remarks"></a>Uwagi

Jeśli uchwyt danego maski bitów identyfikuje Nieprawidłowa mapa bitowa monochromatyczna, funkcja używa tej mapy bitowej do maski bitów dane koloru z prostokąta źródłowego.

Czwarty wierzchołka równoległobok (D) jest zdefiniowany przez traktowanie pierwsze trzy punkty (A, B i C) jako wektorów i obliczeń D = B i C - A.

Jeśli istnieje maski bitów, wartość 1 w masce wskazuje, że kolor piksela źródła powinny zostać skopiowane do lokalizacji docelowej. Wartość 0 w masce wskazuje, że kolor piksela docelowym nie ma zostać zmieniony.

Prostokąt maska jest mniejszy niż prostokąty źródłowy i docelowy, funkcja replikuje dane wzorzec maski.

Skalowanie, tłumaczenia i odbicia przekształcenia są dozwolone w kontekst urządzenia źródłowego; jednak przekształceń obrotu i pochyl nie są. Jeśli mapy bitowej maski jest monochromatycznych map bitowych, wystąpi błąd. Trybu rozciągania kontekstu urządzenia docelowego jest używany do określenia jak rozciągnąć lub zmniejszyć pikseli, jeżeli jest to konieczne. Gdy rozszerzony metaplik jest rejestrowane, jeśli kontekst urządzenia źródłowego identyfikuje kontekst urządzenia rozszerzonych metaplików wystąpi błąd.

Współrzędne miejsca przeznaczenia są przekształcane zgodnie z kontekstem urządzenia docelowego; współrzędne źródła są przekształcane zgodnie z kontekstem urządzenia źródłowego. Jeśli Przekształcenie źródła ma obrotu lub Pochyl, zwracany jest błąd. Jeśli prostokąty źródłowym i docelowym nie ma tego samego formatu koloru `PlgBlt` konwertuje prostokąta źródłowego, aby dopasować prostokąta docelowego. Nie wszystkie urządzenia obsługują `PlgBlt`. Aby uzyskać więcej informacji, zobacz opis funkcji rastrowych rastercaps w `CDC::GetDeviceCaps` funkcja elementu członkowskiego.

Jeśli konteksty urządzenia źródłowego i docelowego reprezentują niezgodnych urządzeń `PlgBlt` zwraca błąd.

##  <a name="polybezier"></a>  CDC::PolyBezier

Rysuje krzywe Bzier jeden lub więcej.

```
BOOL PolyBezier(
    const POINT* lpPoints,
    int nCount);
```

### <a name="parameters"></a>Parametry

*lpPoints*<br/>
Wskazuje na tablicę [punktu](/windows/desktop/api/windef/ns-windef-tagpoint) struktur danych, które zawierają punkty końcowe i kontrolować punktów spline(s).

*nCount*<br/>
Określa liczbę punktów w *lpPoints* tablicy. Ta wartość musi mieć jedną więcej niż trzy razy liczba krzywe do rysowania, ponieważ każdy krzywej składanej Bzier wymaga dwóch punktów kontrolnych i punktu końcowego i początkowego z krzywymi składanymi wymaga dodatkowy punkt początkowy.

### <a name="return-value"></a>Wartość zwracana

Różne od zera, jeśli funkcja zakończyła się pomyślnie; w przeciwnym razie 0.

### <a name="remarks"></a>Uwagi

Ta funkcja rysuje trzeciego stopnia krzywe Bzier za pomocą punktów końcowych i punkty kontrolne, określony przez *lpPoints* parametru. Pierwszy z krzywymi składanymi jest rysowana od pierwszego punktu punkt czwarty przy użyciu punktów drugi i trzeci jako punkty kontrolne. Każda kolejne z krzywymi składanymi w sekwencji musi dokładnie trzy większej liczby punktów: punkt końcowy krzywej składanej poprzedniego służy jako punkt początkowy, następne dwa punkty w sekwencji są punkty kontrolne i trzeci jest punktem końcowym.

Bieżącej pozycji nie jest używany ani aktualizowane przez `PolyBezier` funkcji. Rysunek nie jest wypełnione. Ta funkcja rysuje linie przy użyciu bieżącego pióra.

##  <a name="polybezierto"></a>  CDC::PolyBezierTo

Rysuje krzywe Bzier jeden lub więcej.

```
BOOL PolyBezierTo(
    const POINT* lpPoints,
    int nCount);
```

### <a name="parameters"></a>Parametry

*lpPoints*<br/>
Wskazuje na tablicę [punktu](/windows/desktop/api/windef/ns-windef-tagpoint) wskazuje struktur danych, które zawiera punkty końcowe i kontroli.

*nCount*<br/>
Określa liczbę punktów w *lpPoints* tablicy. Ta wartość musi być trzy razy liczba krzywe do rysowania, ponieważ każdy krzywej składanej Bzier wymaga dwóch punktów kontrolnych i punkt końcowy.

### <a name="return-value"></a>Wartość zwracana

Różne od zera, jeśli funkcja zakończyła się pomyślnie; w przeciwnym razie 0.

### <a name="remarks"></a>Uwagi

Ta funkcja rysuje trzeciego stopnia krzywe Bzier przy użyciu punktów kontrolnych, określony przez *lpPoints* parametru. Pierwszy z krzywymi składanymi jest rysowana od bieżącej pozycji punktu trzeci przy użyciu dwóch pierwszych punktów jako punkty kontrolne. Dla każdej kolejnej krzywej składanej funkcja wymaga dokładnie trzy większej liczby punktów i używa punktu końcowego w poprzednim z krzywymi składanymi jako punktu wyjścia dla następnego. `PolyBezierTo` Przenosi punkt końcowy z krzywymi składanymi Bzier ostatniego bieżącej pozycji. Rysunek nie jest wypełnione. Ta funkcja rysuje linie przy użyciu bieżącego pióra.

### <a name="example"></a>Przykład

  Zobacz przykład [CDC::BeginPath](#beginpath).

##  <a name="polydraw"></a>  CDC::PolyDraw

Rysuje zestaw segmenty linii i krzywe Bzier.

```
BOOL PolyDraw(
    const POINT* lpPoints,
    const BYTE* lpTypes,
    int nCount);
```

### <a name="parameters"></a>Parametry

*lpPoints*<br/>
Wskazuje na tablicę [punktu](/windows/desktop/api/windef/ns-windef-tagpoint) struktur danych, które zawierają punkty końcowe dla każdego wiersza segmentu i punktów końcowych i kontrolować punktów dla poszczególnych Bzier krzywej składanej.

*lpTypes*<br/>
Wskazuje na tablicy, który określa, w jaki sposób każda wskazuje w *lpPoints* tablica jest używana. Może to być jeden z następujących wartości:

- PT_MOVETO Określa, że ten punkt zaczyna się w rozłącznej rysunek. Ten punkt staje się nowe bieżącej pozycji.

- PT_LINETO Określa, że wiersz ma być rysowany od bieżącej pozycji do tej pory staje się nowe bieżącej pozycji.

- PT_BEZIERTO Określa, że ten punkt jest punkt kontrolny lub punkt końcowy dla krzywej składanej Bzier.

Typy PT_BEZIERTO zawsze wykonywane w trzech zestawów. Bieżące położenie definiuje punkt początkowy dla krzywej składanej Bzier. Pierwsze dwa punkty PT_BEZIERTO są punkty kontrolne, a trzeci punkt PT_BEZIERTO znajduje się punkt końcowy. Punkt końcowy staje się nowe bieżącej pozycji. W przypadku nie trzech kolejnych PT_BEZIERTO punkty powoduje błąd.

   PT_LINETO lub PT_BEZIERTO typu może być łączone z następującą stałą za pomocą operatora bitowego lub wskazać, że odpowiedni punkt ostatniego punktu w rysunku i ilustracji jest zamknięty:

- PT_CLOSEFIGURE Określa, że wartość zostanie automatycznie zamknięte po PT_LINETO lub odbywa się PT_BEZIERTO typu dla tego punktu. Linia jest rysowana od tej pory do najnowszych PT_MOVETO lub `MoveTo` punktu.

   Ta flaga jest połączony z typem PT_LINETO dla wiersza lub typem PT_BEZIERTO zakończenia punktu dla krzywej składanej Bzier za pomocą operatora testu koniunkcji **lub** operatora. Bieżące położenie jest ustawiona na punkt końcowy linii zamknięcia.

*nCount*<br/>
Określa, łączna liczba punktów *lpPoints* tablicy liczba bajtów w *lpTypes* tablicy.

### <a name="return-value"></a>Wartość zwracana

Różne od zera, jeśli funkcja zakończyła się pomyślnie; w przeciwnym razie 0.

### <a name="remarks"></a>Uwagi

Ta funkcja może służyć do rysowania rozłączne rysunki zamiast kolejnych wywołań `CDC::MoveTo`, `CDC::LineTo`, i `CDC::PolyBezierTo` funkcji elementów członkowskich. Linie i krzywe rysowania za pomocą bieżącego pióra, a dane nie zostaną wypełnione. Jeśli jest aktywnej ścieżki, uruchomione przez wywołanie `CDC::BeginPath` funkcja elementu członkowskiego `PolyDraw` dodaje do ścieżki. Zagadnienia zawarte w *lpPoints* tablicy i *lpTypes* wskazują, czy każdy punkt jest częścią `CDC::MoveTo`, `CDC::LineTo`, lub `CDC::BezierTo` operacji. Jest również możliwe zamknąć dane. Ta funkcja aktualizuje bieżącej pozycji.

### <a name="example"></a>Przykład

  Zobacz przykład [CDC::BeginPath](#beginpath).

##  <a name="polygon"></a>  CDC::Polygon

Rysuje wielokąt składający się z dwóch lub więcej punktów (wierzchołków) połączone liniami przy użyciu bieżącego pióra.

```
BOOL Polygon(
    LPPOINT lpPoints,
    int nCount);
```

### <a name="parameters"></a>Parametry

*lpPoints*<br/>
Wskazuje tablicy punktów, które określa wierzchołki wielokąta. Każdy punkt w tablicy jest `POINT` struktury lub `CPoint` obiektu.

*nCount*<br/>
Określa liczbę wierzchołków w tablicy.

### <a name="return-value"></a>Wartość zwracana

Różne od zera, jeśli funkcja zakończyła się pomyślnie; w przeciwnym razie 0.

### <a name="remarks"></a>Uwagi

System wielokąta zostanie automatycznie zamknięte, jeśli to konieczne, za pomocą rysowania linii z ostatnim wierzchołku do pierwszej.

Bieżący tryb wypełnianie wielokąta można pobrać lub ustawić za pomocą `GetPolyFillMode` i `SetPolyFillMode` funkcji elementów członkowskich.

### <a name="example"></a>Przykład

[!code-cpp[NVC_MFCDocView#38](../../mfc/codesnippet/cpp/cdc-class_10.cpp)]

##  <a name="polyline"></a>  CDC::Polyline

Rysuje zbiór segmenty linii łączenia punktów określony przez *lpPoints*.

```
BOOL Polyline(
    LPPOINT lpPoints,
    int nCount);
```

### <a name="parameters"></a>Parametry

*lpPoints*<br/>
Wskazuje na tablicę `POINT` struktury lub `CPoint` obiekty do podłączenia.

*nCount*<br/>
Określa liczbę punktów w tablicy. Ta wartość musi być co najmniej 2.

### <a name="return-value"></a>Wartość zwracana

Różne od zera, jeśli funkcja zakończyła się pomyślnie; w przeciwnym razie 0.

### <a name="remarks"></a>Uwagi

Wiersze są pobierane z pierwszym punktem przez kolejne punkty za pomocą bieżącego pióra. W odróżnieniu od `LineTo` funkcja elementu członkowskiego `Polyline` funkcja używa ani aktualizuje bieżącej pozycji.

Aby uzyskać więcej informacji, zobacz [linii łamanej](/windows/desktop/api/wingdi/nf-wingdi-polyline) w zestawie Windows SDK.

##  <a name="polylineto"></a>  CDC::PolylineTo

Rysuje jeden lub więcej wierszy proste.

```
BOOL PolylineTo(
    const POINT* lpPoints,
    int nCount);
```

### <a name="parameters"></a>Parametry

*lpPoints*<br/>
Wskazuje na tablicę [punktu](/windows/desktop/api/windef/ns-windef-tagpoint) struktur danych, które zawiera wierzchołki wiersza.

*nCount*<br/>
Określa liczbę punktów w tablicy.

### <a name="return-value"></a>Wartość zwracana

Różne od zera, jeśli funkcja zakończyła się pomyślnie; w przeciwnym razie 0.

### <a name="remarks"></a>Uwagi

Linia jest rysowana od bieżącej pozycji do pierwszego punktu określonego przez *lpPoints* parametru za pomocą bieżącego pióra. Funkcja pobiera w każdy dodatkowy wiersz z punktu końcowego poprzedniego wiersza do następnego punktu określonego przez *lpPoints*. `PolylineTo` Przenosi bieżącej pozycji punktu końcowego ostatniego wiersza. Jeśli segmenty linii rysowane przez tę funkcję tworzą figurę zamkniętą, rysunek nie jest wypełnione.

##  <a name="polypolygon"></a>  CDC::PolyPolygon

Tworzy co najmniej dwóch wielokątów są wypełniane przy użyciu bieżącego trybu wypełnianie wielokąta.

```
BOOL PolyPolygon(
    LPPOINT lpPoints,
    LPINT lpPolyCounts,
    int nCount);
```

### <a name="parameters"></a>Parametry

*lpPoints*<br/>
Wskazuje na tablicę `POINT` struktury lub `CPoint` obiekty, które określają wierzchołki wielokątów.

*lpPolyCounts*<br/>
Wskazuje tablicy liczb całkowitych, z których każdy określa liczbę punktów w jednym z wielokątów w *lpPoints* tablicy.

*nCount*<br/>
Liczba wpisów w *lpPolyCounts* tablicy. Liczba ta określa liczbę wielokątów do narysowania. Ta wartość musi być co najmniej 2.

### <a name="return-value"></a>Wartość zwracana

Różne od zera, jeśli funkcja zakończyła się pomyślnie; w przeciwnym razie 0.

### <a name="remarks"></a>Uwagi

Wielokąty mogą być rozłączne lub nakładające się.

Każdego wielokąta określone w wywołaniu `PolyPolygon` funkcji muszą być zamknięte. W odróżnieniu od wielokątów utworzone przez `Polygon` funkcja elementu członkowskiego, wielokąty, utworzone przez `PolyPolygon` nie zostaną automatycznie zamknięte.

Funkcja tworzy co najmniej dwóch wielokątów. Aby utworzyć pojedynczy wielokąta, aplikacja powinna używać `Polygon` funkcja elementu członkowskiego.

Bieżący tryb wypełnianie wielokąta można pobrać lub ustawić za pomocą `GetPolyFillMode` i `SetPolyFillMode` funkcji elementów członkowskich.

##  <a name="polypolyline"></a>  CDC::PolyPolyline

Rysuje wielu serii segmenty linii połączonej.

```
BOOL PolyPolyline(
    const POINT* lpPoints,
    const DWORD* lpPolyPoints,
    int nCount);
```

### <a name="parameters"></a>Parametry

*lpPoints*<br/>
Wskazuje tablicy struktur, które zawierają wierzchołki łamane. Linie łamane podano pod rząd.

*lpPolyPoints*<br/>
Wskazuje na tablicę zmiennych, określający, ile punktów w *lpPoints* tablicy dla odpowiedniego wielokąta. Każdy wpis musi być większa lub równa 2.

*nCount*<br/>
Określa łączną liczbę liczników w *lpPolyPoints* tablicy.

### <a name="return-value"></a>Wartość zwracana

Różne od zera, jeśli funkcja zakończyła się pomyślnie; w przeciwnym razie 0.

### <a name="remarks"></a>Uwagi

Segmenty linii są rysowane przy użyciu bieżącego pióra. Dane utworzone przez segmenty nie są wypełnione. Bieżącej pozycji nie jest używany ani aktualizowane przez tę funkcję.

##  <a name="ptvisible"></a>  CDC::PtVisible

Określa, czy dany punkt znajduje się w regionie wycinka kontekstu urządzenia.

```
virtual BOOL PtVisible(
    int x,
    int y) const;

BOOL PtVisible(POINT point) const;
```

### <a name="parameters"></a>Parametry

*x*<br/>
Określa logiczną współrzędną x punktu.

*y*<br/>
Określa logiczną współrzędną y punktu.

*Punkt*<br/>
Określa punkt do zaewidencjonowania logiczne współrzędnych. Można przekazać `POINT` struktury lub `CPoint` obiektu dla tego parametru.

### <a name="return-value"></a>Wartość zwracana

Wartość różną od zera, jeśli określony punkt znajduje się w obrębie regionu wycinka; w przeciwnym razie 0.

##  <a name="queryabort"></a>  CDC::QueryAbort

Wywołuje funkcję przerwania instalowane przez [SetAbortProc](#setabortproc) funkcję członkowską drukowania aplikacji i zapytania, czy powinno zostać zakończone drukowania.

```
BOOL QueryAbort() const;
```

### <a name="return-value"></a>Wartość zwracana

Wartość zwracana jest wartość różną od zera, jeśli drukowanie powinno być kontynuowane, lub jeśli istnieje procedura przerwania. Jest to 0, jeśli powinno zostać zakończone zadanie drukowania. Wartość zwracana jest dostarczany przez funkcję przerwania.

##  <a name="realizepalette"></a>  CDC::RealizePalette

Wpisy mapy z bieżącym palety logiczne do palety systemu.

```
UINT RealizePalette();
```

### <a name="return-value"></a>Wartość zwracana

Wskazuje, ile wpisy palety logiczne zostały przyporządkowane wpisy palety systemu. Reprezentuje liczbę wpisów, które tę funkcję ponownie mapowany do uwzględnienia zmian w palecie systemu, ponieważ logiczną paletę ostatnio zostało zrealizowane.

### <a name="remarks"></a>Uwagi

Palety kolorów logiczny działa jako bufor między aplikacji intensywnie korzystających z kolorami i systemu, umożliwiając aplikację do korzystania z wielu kolorów, stosownie do potrzeb bez konieczności zmieniania jego własnej wyświetlana kolorów lub za pomocą kolorów wyświetlanych przez inne okna.

Jeśli okno ma fokus wprowadzania i wywołania `RealizePalette`, Windows zapewnia, że w oknie będą wyświetlane wszystkie żądane kolory maksymalnie maksymalna liczba równocześnie dostępnych na ekranie. Windows wyświetla również kolory, dopasowując je do dostępnych kolorów, nie znaleziono w palecie okna.

Ponadto Windows pasuje do kolorów, żądane przez nieaktywnych okien, które wywołanie funkcji w możliwie najlepszy sposób na dostępnych kolorów. Pozwala to znacznie ograniczyć niepożądanych zmian w kolorach wyświetlane w oknach nieaktywne.

##  <a name="rectangle"></a>  CDC::Rectangle

Rysuje prostokąt przy użyciu bieżącego pióra.

```
BOOL Rectangle(
    int x1,
    int y1,
    int x2,
    int y2);

BOOL Rectangle(LPCRECT lpRect);
```

### <a name="parameters"></a>Parametry

*x1*<br/>
Określa współrzędną x lewego górnego rogu prostokąta (w jednostkach logicznych).

*y1*<br/>
Określa współrzędną y lewego górnego rogu prostokąta (w jednostkach logicznych).

*x2*<br/>
Określa współrzędną x w prawym dolnym rogu prostokąt (w jednostkach logicznych).

*y2*<br/>
Określa współrzędną y prawego dolnego rogu prostokąta (w jednostkach logicznych).

*lpRect*<br/>
Określa prostokąt w jednostkach logicznych. Można przekazać `CRect` obiekt lub wskaźnik do `RECT` struktury dla tego parametru.

### <a name="return-value"></a>Wartość zwracana

Różne od zera, jeśli funkcja zakończyła się pomyślnie; w przeciwnym razie 0.

### <a name="remarks"></a>Uwagi

Wewnątrz prostokąta jest wypełniony przy użyciu bieżącego pędzla.

Prostokąt rozciąga się do, ale nie zawiera współrzędne po prawej stronie i u dołu. Oznacza, że wysokość prostokąta *y2* - *y1* i szerokości prostokąta *x2* - *x1*. Szerokość i wysokość prostokąta musi być większa niż 2 i mniej niż 32 767 jednostek.

### <a name="example"></a>Przykład

[!code-cpp[NVC_MFCDocView#39](../../mfc/codesnippet/cpp/cdc-class_11.cpp)]

##  <a name="rectvisible"></a>  CDC::RectVisible

Określa, czy jakakolwiek część danej prostokąt mieści się w obszaru przycinania kontekstu wyświetlania.

```
virtual BOOL RectVisible(LPCRECT lpRect) const;
```

### <a name="parameters"></a>Parametry

*lpRect*<br/>
Wskazuje `RECT` struktury lub `CRect` obiekt, który zawiera współrzędne logiczne określonego prostokąta.

### <a name="return-value"></a>Wartość zwracana

Wartość różną od zera, jeśli jakakolwiek część danej prostokąt znajduje się w obrębie regionu wycinka; w przeciwnym razie 0.

##  <a name="releaseattribdc"></a>  CDC::ReleaseAttribDC

Wywołaj tę funkcję elementu członkowskiego, aby ustawić `m_hAttribDC` na wartość NULL.

```
virtual void ReleaseAttribDC();
```

### <a name="remarks"></a>Uwagi

Ten błąd nie powoduje `Detach` wystąpienia. Kontekst urządzenia danych wyjściowych jest dołączony do `CDC` można odłączyć obiektu, a tylko.

##  <a name="releaseoutputdc"></a>  CDC::ReleaseOutputDC

Wywołaj tę funkcję elementu członkowskiego, aby ustawić `m_hDC` elementu członkowskiego na wartość NULL.

```
virtual void ReleaseOutputDC();
```

### <a name="remarks"></a>Uwagi

Nie można wywołać tej funkcji elementu członkowskiego, jeśli kontekst urządzenia danych wyjściowych jest dołączony do `CDC` obiektu. Użyj `Detach` funkcja elementu członkowskiego do odłączenia kontekstu urządzenia dane wyjściowe.

##  <a name="resetdc"></a>  CDC::ResetDC

Wywołaj tę funkcję elementu członkowskiego, aby zaktualizować kontekstu urządzenia opakowane przez `CDC` obiektu.

```
BOOL ResetDC(const DEVMODE* lpDevMode);
```

### <a name="parameters"></a>Parametry

*lpDevMode*<br/>
Wskaźnik do Windows `DEVMODE` struktury.

### <a name="return-value"></a>Wartość zwracana

Różne od zera, jeśli funkcja zakończyła się pomyślnie; w przeciwnym razie 0.

### <a name="remarks"></a>Uwagi

Kontekst urządzenia są aktualizowane na podstawie informacji określonych w Windows `DEVMODE` struktury. Ta funkcja elementu członkowskiego resetuje tylko atrybut kontekstu urządzenia.

Aplikacja zazwyczaj będzie używać `ResetDC` funkcja elementu członkowskiego, gdy okno przetwarza `WM_DEVMODECHANGE` wiadomości. Ta funkcja elementu członkowskiego umożliwia również zmienić orientację lub dokument pojemniki podczas drukowania dokumentów.

Nie można użyć tej funkcji elementu członkowskiego, zmienić nazwę sterownika, nazwę urządzenia lub danych wyjściowych portu. Gdy użytkownik zmieni połączenia portu lub nazwy urządzenia, należy usunąć z oryginalnego kontekstu urządzenia i tworzy nowy kontekst urządzenia o nowe informacje.

Przed wywołaniem tej funkcji elementu członkowskiego, upewnij się, że wybrano wszystkie obiekty (innych niż podstawowe obiekty), które miały zostały wybrane do kontekstu urządzenia.

##  <a name="restoredc"></a>  CDC::RestoreDC

Przywraca kontekst urządzenia do poprzedniego stanu, które są identyfikowane za pomocą *nSavedDC*.

```
virtual BOOL RestoreDC(int nSavedDC);
```

### <a name="parameters"></a>Parametry

*nSavedDC*<br/>
Określa kontekst urządzenia do przywrócenia. Może to być wartość zwracana przez poprzednie `SaveDC` wywołania funkcji. Jeśli *nSavedDC* wynosi -1, ostatnio zapisany kontekstu urządzenia zostanie przywrócony.

### <a name="return-value"></a>Wartość zwracana

Wartość różną od zera, jeśli określony kontekst został przywrócony; w przeciwnym razie 0.

### <a name="remarks"></a>Uwagi

`RestoreDC` Przywraca kontekstu urządzenia przez wyświetlanie informacji o stanie stosu, utworzony przez poprzednie wywołania do `SaveDC` funkcja elementu członkowskiego.

Stos może zawierać informacje o stanie dla kilku konteksty urządzenia. Jeśli kontekst jest określony przez *nSavedDC* nie znajduje się w górnej części stosu, `RestoreDC` usuwa wszystkie informacje o stanie od kontekstu urządzenia określone przez *nSavedDC* a górną krawędzią stosu. Usunięto informacje zostaną utracone.

##  <a name="roundrect"></a>  CDC::RoundRect

Rysuje prostokąt z zaokrąglonymi rogami przy użyciu bieżącego pióra.

```
BOOL RoundRect(
    int x1,
    int y1,
    int x2,
    int y2,
    int x3,
    int y3);

BOOL RoundRect(
    LPCRECT lpRect,
    POINT point);
```

### <a name="parameters"></a>Parametry

*x1*<br/>
Określa współrzędną x lewego górnego rogu prostokąta (w jednostkach logicznych).

*y1*<br/>
Określa współrzędną y lewego górnego rogu prostokąta (w jednostkach logicznych).

*x2*<br/>
Określa współrzędną x w prawym dolnym rogu prostokąt (w jednostkach logicznych).

*y2*<br/>
Określa współrzędną y prawego dolnego rogu prostokąta (w jednostkach logicznych).

*x3*<br/>
Określa szerokość elipsy używanej do rysowania zaokrąglone rogi (w jednostkach logicznych).

*y3*<br/>
Określa wysokość elipsy, używany do rysowania zaokrąglone rogi (w jednostkach logicznych).

*lpRect*<br/>
Określa prostokąt otaczający w jednostkach logicznych. Można przekazać `CRect` obiekt lub wskaźnik do `RECT` struktury dla tego parametru.

*Punkt*<br/>
Współrzędną x *punktu* Określa szerokość ikonę wielokropka, aby narysować zaokrąglone rogi (w jednostkach logicznych). Współrzędną y *punktu* określa wysokość elipsy, aby narysować zaokrąglone rogi (w jednostkach logicznych). Można przekazać `POINT` struktury lub `CPoint` obiektu dla tego parametru.

### <a name="return-value"></a>Wartość zwracana

Różne od zera, jeśli funkcja zakończyła się pomyślnie; w przeciwnym razie 0.

### <a name="remarks"></a>Uwagi

Wewnątrz prostokąta jest wypełniony przy użyciu bieżącego pędzla.

Rysunek, w których ta funkcja pobiera rozciąga się do, ale nie uwzględnia współrzędne po prawej stronie i u dołu. Oznacza, że wysokość rysunku *y2* - *y1* i szerokość rysunku jest *x2* - *x1*. Wysokość i szerokość prostokąt otaczający musi być większa niż 2 i mniej niż 32 767 jednostek.

### <a name="example"></a>Przykład

[!code-cpp[NVC_MFCDocView#40](../../mfc/codesnippet/cpp/cdc-class_12.cpp)]

##  <a name="savedc"></a>  CDC::SaveDC

Zapisuje bieżący stan kontekstu urządzenia przez kopiowanie informacji o stanie (na przykład obszaru przycinania, wybranych obiektów i tryb mapowania) obsługiwane przez Windows Stos kontekstu.

```
virtual int SaveDC();
```

### <a name="return-value"></a>Wartość zwracana

Liczba całkowita identyfikacji kontekstu urządzenia zapisane. Jeśli wystąpi błąd, to 0. To zwraca wartość może być używana do przywrócenia kontekście urządzenia przez wywołanie metody `RestoreDC`.

### <a name="remarks"></a>Uwagi

Kontekst urządzenia zapisane później można przywrócić za pomocą `RestoreDC`.

`SaveDC` może być użyta dowolną liczbę razy do zapisania dowolną liczbę stanów kontekstu urządzenia.

##  <a name="scaleviewportext"></a>  CDC::ScaleViewportExt

Modyfikuje zakresów okienka ekranu względem bieżących wartości.

```
virtual CSize ScaleViewportExt(
    int xNum,
    int xDenom,
    int yNum,
    int yDenom);
```

### <a name="parameters"></a>Parametry

*xNum*<br/>
Określa, którą chcesz pomnożyć w bieżącym zakresie x.

*xDenom*<br/>
Określa ilość, przez którą chcesz podzielić wynik mnożenia wartości w bieżącym zakresie x przez wartość *xNum* parametru.

*yNum*<br/>
Określa, którą chcesz pomnożyć w bieżącym zakresie y.

*yDenom*<br/>
Określa ilość, przez którą chcesz podzielić wynik mnożenia wartości w bieżącym zakresie-przez wartość *yNum* parametru.

### <a name="return-value"></a>Wartość zwracana

Poprzednie zakresów okienka ekranu (w jednostkach urządzenia) jako `CSize` obiektu.

### <a name="remarks"></a>Uwagi

Formuły są zapisywane w następujący sposób:

`xNewVE = ( xOldVE * xNum ) / xDenom`

`yNewVE = ( yOldVE * yNum ) / yDenom`

Nowe zakresy okienka ekranu są obliczane przez pomnożenie bieżącego zakresów przez dany licznik, a następnie podzielenie przez dany mianownik.

##  <a name="scalewindowext"></a>  CDC::ScaleWindowExt

Modyfikuje zakresów okna względem bieżących wartości.

```
virtual CSize ScaleWindowExt(
    int xNum,
    int xDenom,
    int yNum,
    int yDenom);
```

### <a name="parameters"></a>Parametry

*xNum*<br/>
Określa, którą chcesz pomnożyć w bieżącym zakresie x.

*xDenom*<br/>
Określa ilość, przez którą chcesz podzielić wynik mnożenia wartości w bieżącym zakresie x przez wartość *xNum* parametru.

*yNum*<br/>
Określa, którą chcesz pomnożyć w bieżącym zakresie y.

*yDenom*<br/>
Określa ilość, przez którą chcesz podzielić wynik mnożenia wartości w bieżącym zakresie-przez wartość *yNum* parametru.

### <a name="return-value"></a>Wartość zwracana

Zakresy poprzedniego okna (w jednostkach logicznych) jako `CSize` obiektu.

### <a name="remarks"></a>Uwagi

Formuły są zapisywane w następujący sposób:

`xNewWE = ( xOldWE * xNum ) / xDenom`

`yNewWE = ( yOldWE * yNum ) / yDenom`

Nowe zakresy okna są obliczane przez pomnożenie bieżącego zakresów przez dany licznik, a następnie podzielenie przez dany mianownik.

##  <a name="scrolldc"></a>  CDC::ScrollDC

Przewija prostokąt bitów w poziomie i w pionie.

```
BOOL ScrollDC(
    int dx,
    int dy,
    LPCRECT lpRectScroll,
    LPCRECT lpRectClip,
    CRgn* pRgnUpdate,
    LPRECT lpRectUpdate);
```

### <a name="parameters"></a>Parametry

*dx*<br/>
Określa liczbę jednostek przewijania w poziomie.

*dy*<br/>
Określa liczbę jednostek przewijanie w pionie.

*lpRectScroll*<br/>
Wskazuje `RECT` struktury lub `CRect` obiekt, który zawiera współrzędne przewijania prostokąta.

*lpRectClip*<br/>
Wskazuje `RECT` struktury lub `CRect` obiekt, który zawiera współrzędne prostokątny. Gdy prostokąta jest mniejszy niż oryginalny jeden wskazywany przez *lpRectScroll*, przewijania występuje tylko w mniejszych prostokąta.

*pRgnUpdate*<br/>
Identyfikuje region, niewykrytych przez proces przewijania. `ScrollDC` Funkcja definiuje ten region; nie jest koniecznie prostokąta.

*lpRectUpdate*<br/>
Wskazuje `RECT` struktury lub `CRect` obiekt, który odbiera współrzędne prostokąt, który granic obszarze przewijana aktualizacji. Jest to największa prostokątny obszar, który wymaga ponownego rysowania. Wartości w strukturze lub obiektu, gdy funkcja zwraca znajdują się w współrzędne klienta, niezależnie od tego trybu mapowania w kontekście danego urządzenia.

### <a name="return-value"></a>Wartość zwracana

Wartość różną od zera, jeśli przewijania jest wykonywana. w przeciwnym razie 0.

### <a name="remarks"></a>Uwagi

Jeśli *lpRectUpdate* ma wartość NULL, Windows nie może obliczyć prostokąt aktualizacji. Jeśli oba *pRgnUpdate* i *lpRectUpdate* mają wartość NULL, Windows nie może obliczyć region aktualizacji. Jeśli *pRgnUpdate* nie ma wartości NULL, Windows przyjęto założenie, że zawiera on nieprawidłowy wskaźnik do regionu niewykrytych przez proces przewijania (zdefiniowany przez `ScrollDC` funkcja elementu członkowskiego). Region aktualizacji zwracanych w *lpRectUpdate* mogą być przekazywane do `CWnd::InvalidateRgn` w razie potrzeby.

Aplikacja powinna używać `ScrollWindow` funkcji składowej klasy typu `CWnd` gdy jest konieczne Przewijanie całego obszaru klienta okna. W przeciwnym razie należy użyć `ScrollDC`.

##  <a name="selectclippath"></a>  CDC::SelectClipPath

Wybiera bieżącą ścieżkę jako obszar przycinania kontekstu urządzenia, łącząc nowego regionu z dowolnego istniejącego obszaru przycinania za pomocą określonego trybu.

```
BOOL SelectClipPath(int nMode);
```

### <a name="parameters"></a>Parametry

*nMode*<br/>
Określa sposób używania ścieżki. Dozwolone są następujące wartości:

- RGN_AND nowego obszaru przycinania zawiera część wspólną (nakładającymi się obszarami) bieżącego obszaru przycinania, a bieżąca ścieżka.

- RGN_COPY nowy region wycinka jest bieżąca ścieżka.

- RGN_DIFF nowego obszaru przycinania obejmuje obszary bieżącego obszaru przycinania, a te bieżącej ścieżki są wyłączone.

- Nowy region wycinka RGN_OR obejmuje Unii (połączone obszary) z bieżącego obszaru przycinania, a bieżąca ścieżka.

- RGN_XOR nowego obszaru przycinania obejmuje Unii bieżącego obszaru przycinania, a bieżąca ścieżka, ale bez nakładających się obszarów.

### <a name="return-value"></a>Wartość zwracana

Różne od zera, jeśli funkcja zakończyła się pomyślnie; w przeciwnym razie 0.

### <a name="remarks"></a>Uwagi

Kontekst urządzenia zidentyfikowane musi zawierać ścieżkę zamkniętą.

##  <a name="selectcliprgn"></a>  CDC::SelectClipRgn

Wybiera danego regionu jako bieżący obszar przycinania kontekstu urządzenia.

```
int SelectClipRgn(CRgn* pRgn);

int SelectClipRgn(
    CRgn* pRgn,
    int nMode);
```

### <a name="parameters"></a>Parametry

*pRgn*<br/>
Identyfikuje region, należy wybrać.

- W pierwszej wersji tej funkcji Jeśli ta wartość wynosi NULL, całego obszaru klienta jest zaznaczone, a okno danych wyjściowych nadal zostanie obcięta.

- Druga wersja tej funkcji to dojście może mieć wartość NULL tylko wtedy, gdy określono tryb RGN_COPY.

*nMode*<br/>
Określa operację do wykonania. Musi mieć jedną z następujących wartości:

- RGN_AND nowego obszaru przycinania łączy obszary nakładających się bieżącego obszaru przycinania i regionu określonego przez *pRgn*.

- RGN_COPY nowy region wycinka jest kopią regionu określonego przez *pRgn*. To jest funkcja jest taka sama jak pierwsza wersja `SelectClipRgn`. Jeśli region identyfikowane przez *pRgn* ma wartość NULL, nowe obszaru przycinania staje się domyślnym regionem wycinka (region o wartości null).

- RGN_DIFF nowego obszaru przycinania łączy obszarów bieżącego obszaru przycinania za pomocą tych obszarów wykluczone z regionu określonego przez *pRgn*.

- RGN_OR nowego obszaru przycinania łączy bieżącego obszaru przycinania i regionu określonego przez *pRgn*.

- RGN_XOR nowego obszaru przycinania łączy bieżącego obszaru przycinania i regionu określonego przez *pRgn* , ale nie obejmuje wszystkie obszary nakładających się.

### <a name="return-value"></a>Wartość zwracana

Typ regionu. Może być dowolną z następujących wartości:

- COMPLEXREGION nowego obszaru przycinania ma nakładających się obramowań.

- Kontekst urządzenia błędu lub region jest nieprawidłowy.

- NULLREGION nowy region wycinka jest pusty.

- SIMPLEREGION nowy region wycinka nie ma nakładające się obramowania.

### <a name="remarks"></a>Uwagi

Używana jest tylko kopia wybranego regionu. Dla dowolnej liczby innych kontekstach urządzenia można wybrać region, samego, lub można je usunąć.

Funkcji przyjęto założenie, że współrzędnych dla danego regionu są określone w jednostkach urządzenia. Niektóre urządzenia drukarek obsługują tekst wyjściowy w wyższej rozdzielczości niż grafiki w danych wyjściowych, aby zachować dokładności potrzebnych do express metryki tekstu. Te urządzenia, będą zgłaszać urządzenia jednostki o rozdzielczości wyższej, oznacza to, w jednostkach tekstowe. Te urządzenia następnie skalować współrzędne grafiki, aby kilku zgłoszonych Mapa jednostki urządzenia tylko 1 jednostkę grafiki. Zawsze powinna wywołać `SelectClipRgn` funkcję za pomocą jednostek tekstu.

Aplikacje, które należy wykonać skalowanie obiektów grafiki w GDI umożliwia ucieczki drukarki GETSCALINGFACTOR określić współczynnik skalowania. Ten współczynnik skalowania ma wpływ na wycinka. Jeśli region jest używany do klipu grafiki, GDI dzieli współrzędne przez współczynnik skalowania. Jeśli region jest używany do klipu tekstu, GDI sprawia, że żadne dostosowanie skalowania. Współczynnik skalowania 1 powoduje, że współrzędne podzielony przez 2; współrzędne miejsca zostanie podzielona przez 4; powoduje, że współczynnik skalowania 2 i tak dalej.

##  <a name="selectobject"></a>  CDC::SelectObject

Wybiera obiekt do kontekstu urządzenia.

```
CPen* SelectObject(CPen* pPen);
CBrush* SelectObject(CBrush* pBrush);
virtual CFont* SelectObject(CFont* pFont);
CBitmap* SelectObject(CBitmap* pBitmap);
int SelectObject(CRgn* pRgn);
CGdiObject* SelectObject(CGdiObject* pObject);
```

### <a name="parameters"></a>Parametry

*pPen*<br/>
Wskaźnik do [CPen](../../mfc/reference/cpen-class.md) obiektu do wybrania.

*pBrush*<br/>
Wskaźnik do [CBrush](../../mfc/reference/cbrush-class.md) obiektu do wybrania.

*pFont*<br/>
Wskaźnik do [CFont](../../mfc/reference/cfont-class.md) obiektu do wybrania.

*pBitmap*<br/>
Wskaźnik do [CBitmap](../../mfc/reference/cbitmap-class.md) obiektu do wybrania.

*pRgn*<br/>
Wskaźnik do [CRgn](../../mfc/reference/crgn-class.md) obiektu do wybrania.

*pObject*<br/>
Wskaźnik do [CGdiObject](../../mfc/reference/cgdiobject-class.md) obiektu do wybrania.

### <a name="return-value"></a>Wartość zwracana

Wskaźnik do obiektu, jest zastępowany. Jest to wskaźnik do obiektu z jednej z klas pochodnych `CGdiObject`, takich jak `CPen`, w zależności od używanej wersji funkcji. Wartość zwracana ma wartość NULL, jeśli wystąpi błąd. Ta funkcja może zwrócić wskaźnik do obiektów tymczasowych. Ten tymczasowy obiekt jest prawidłowy tylko podczas przetwarzania jeden komunikat Windows. Aby uzyskać więcej informacji, zobacz `CGdiObject::FromHandle`.

Wersja funkcji składowej, która przyjmuje parametr region wykonuje to samo zadanie `SelectClipRgn` funkcja elementu członkowskiego. Wartość zwracaną może być dowolny z następujących czynności:

- COMPLEXREGION nowego obszaru przycinania ma nakładających się obramowań.

- Kontekst urządzenia błędu lub region jest nieprawidłowy.

- NULLREGION nowy region wycinka jest pusty.

- SIMPLEREGION nowy region wycinka nie ma nakładające się obramowania.

### <a name="remarks"></a>Uwagi

Klasa `CDC` zawiera pięć wersji przeznaczone specjalnie do określonego rodzaju obiektów interfejsu GDI, w tym pióra, pędzle, czcionki, mapy bitowe i regionach. Nowo wybrany obiekt zastępuje poprzedni obiekt tego samego typu. Na przykład jeśli *obiekt* ogólne wersji `SelectObject` wskazuje [CPen](../../mfc/reference/cpen-class.md) obiektu funkcji Zamienia bieżące pióro pióra, określony przez *obiekt* .

Aplikację można wybrać mapę bitową do konteksty urządzenia pamięci tylko i do kontekstu urządzenia pamięci tylko jeden w danym momencie. Format mapy bitowej muszą zostać monochromatycznych lub niezgodny z kontekstem urządzenia; Jeśli nie jest dostępna, `SelectObject` zwraca błąd.

Dla Windows 3.1 lub nowszego `SelectObject` funkcja zwraca tę samą wartość, czy jest on używany w metaplik, czy nie. W poprzednich wersjach systemu Windows `SelectObject` zwrócił wartość różną od zera w celu osiągnięcia sukcesu i 0 w przypadku niepowodzenia stosowania w metaplik.

##  <a name="selectpalette"></a>  CDC::SelectPalette

Wybiera logiczną paletę, który jest określony przez *pPalette* jako obiekt wybrany palety kontekstu urządzenia.

```
CPalette* SelectPalette(
    CPalette* pPalette,
    BOOL bForceBackground);
```

### <a name="parameters"></a>Parametry

*pPalette*<br/>
Określa logiczną paletę do wybrania. Tej palety, musi już być utworzony przy użyciu `CPalette` funkcja elementu członkowskiego [CreatePalette](../../mfc/reference/cpalette-class.md#createpalette).

*bForceBackground*<br/>
Określa, czy logiczną paletę jest zmuszony do palety tła. Jeśli *bForceBackground* jest różna od zera, wybranych palety zawsze znajduje się paleta zawierająca tła, niezależnie od tego, czy okno ma fokus wprowadzania. Jeśli *bForceBackground* wynosi 0 i kontekst urządzenia jest dołączony do okna, logiczną paletę znajduje się paleta zawierająca pierwszego planu, gdy okno ma fokusa wejścia.

### <a name="return-value"></a>Wartość zwracana

Wskaźnik do `CPalette` identyfikowanie logiczną paletę zastępuje palety, określony przez obiekt *pPalette*. Ma wartość NULL, jeśli wystąpi błąd.

### <a name="remarks"></a>Uwagi

Nowa paleta staje się obiektem palety kolorów kontrolki wyświetlane w kontekście urządzenia posługują się GDI i zastępuje palecie poprzedniej.

Aplikację można wybrać logiczną paletę do więcej niż jeden kontekstu urządzenia. Jednak zmiany logiczną paletę wpłynie na wszystkie konteksty urządzenia, dla których jest zaznaczona. Jeśli aplikacja wybierze paletę do więcej niż jeden kontekstu urządzenia, konteksty urządzenia muszą wszystkie należeć do tego samego urządzenia fizycznego.

##  <a name="selectstockobject"></a>  CDC::SelectStockObject

Wybiera [CGdiObject](../../mfc/reference/cgdiobject-class.md) obiekt, który odpowiada jednej z wstępnie zdefiniowanych standardowych pióra, pędzli i czcionki.

```
virtual CGdiObject* SelectStockObject(int nIndex);
```

### <a name="parameters"></a>Parametry

*nIndex*<br/>
Określa rodzaj obiektu podstawowego konieczne. Może to być jedna z następujących wartości:

- Pędzel BLACK_BRUSH czarny.

- Ciemny DKGRAY_BRUSH szarego pędzla.

- Pędzel GRAY_BRUSH szary.

- Pusty HOLLOW_BRUSH pędzla.

- Pędzel LTGRAY_BRUSH Light gray.

- Pędzel NULL_BRUSH o wartości Null.

- Pędzel WHITE_BRUSH biały.

- Pióro BLACK_PEN czarny.

- Pióro NULL_PEN o wartości Null.

- Pióro WHITE_PEN biały.

- ANSI_FIXED_FONT ANSI stała czcionki systemowej.

- Czcionki systemowej zmiennej ANSI_VAR_FONT ANSI.

- DEVICE_DEFAULT_FONT czcionka zależne od urządzenia.

- Zależne od producenta OEM OEM_FIXED_FONT stała czcionki.

- SYSTEM_FONT czcionki systemowej. Domyślnie Windows używa czcionki systemowej, aby narysować menu, okno dialogowe formanty i inne teksty. Najlepiej jest, jednak nie można polegać na SYSTEM_FONT uzyskać czcionki używany w oknach dialogowych i windows. Zamiast tego należy użyć `SystemParametersInfo` funkcji z parametrem SPI_GETNONCLIENTMETRICS, aby pobrać bieżącą czcionkę. `SystemParametersInfo` uwzględnia bieżący motyw i udostępnia informacje czcionki dla podpisów, menu i okien dialogowych wiadomości.

- SYSTEM_FIXED_FONT stałej szerokości Czcionka używana w Windows przed wersji 3.0 lub nowszej. Ten obiekt jest dostępny na potrzeby utrzymywania zgodności z wcześniejszymi wersjami systemu Windows.

- Domyślne DEFAULT_PALETTE palety kolorów. Tej palety, składa się z 20 statyczne kolorów palety systemu.

### <a name="return-value"></a>Wartość zwracana

Wskaźnik do `CGdiObject` obiektu, który został zastąpiony, jeśli funkcja się powiedzie. Rzeczywiste, jaki wskazał obiekt [CPen](../../mfc/reference/cpen-class.md), [CBrush](../../mfc/reference/cbrush-class.md), lub [CFont](../../mfc/reference/cfont-class.md) obiektu. Jeśli wywołanie zakończy się niepowodzeniem, wartość zwracana jest wartość NULL.

##  <a name="setabortproc"></a>  CDC::SETABORTPROC

Instaluje procedury przerwania dla zadania drukowania.

```
int SetAbortProc(BOOL (CALLBACK* lpfn)(HDC, int));
```

### <a name="parameters"></a>Parametry

*lpfn*<br/>
Wskaźnik do funkcji przerwanie instalacji w procedurze przerwania. Aby uzyskać więcej informacji o funkcji wywołania zwrotnego, zobacz [funkcji wywołania zwrotnego dla CDC::SetAbortProc](callback-functions-used-by-mfc.md#setabortproc).

### <a name="return-value"></a>Wartość zwracana

Określa wynik `SetAbortProc` funkcji. Niektóre z następujących wartości są bardziej prawdopodobne niż inne, ale są wszystkie możliwe.

- Błąd ogólny SP_ERROR.

- Nie SP_OUTOFDISK wystarczającej ilości miejsca na dysku jest obecnie dostępna dla buforowania i miejsca staną się dostępne.

- Nie SP_OUTOFMEMORY wystarczającą ilość pamięci dostępnej dla buforowania.

- Użytkownik SP_USERABORT zakończone zadania przy użyciu Menedżera wydruku.

### <a name="remarks"></a>Uwagi

Jeśli aplikacja jest umożliwienie zadania drukowania, które zostaną anulowane podczas buforowania, musi on ustawiony funkcja przerwania przed rozpoczęciem zadania drukowania z [StartDoc](#startdoc) funkcja elementu członkowskiego. Menedżer drukowanie wywołuje funkcję przerwania podczas buforowania, aby umożliwić aplikacji, aby anulować zadanie drukowania lub w celu przetwarzania warunki limit dla ilości miejsca. Jeśli żadna funkcja przerwania jest ustawiony, zadanie drukowania zakończy się niepowodzeniem, jeśli nie ma wystarczającej ilości miejsca na dysku do buforowania.

Należy pamiętać, że funkcje programu Microsoft Visual C++, ułatwiając tworzenie przekazany do funkcji wywołania zwrotnego `SetAbortProc`. Adres jest przekazywany do `EnumObjects` funkcja członkowska jest wskaźnikiem do funkcji wyeksportowanej z `__declspec(dllexport)` i `__stdcall` konwencji wywoływania.

Również trzeba wyeksportować nazwy funkcji w **EKSPORTY** instrukcja w pliku definicji modułu Twojej aplikacji. Zamiast tego można użyć **WYEKSPORTOWAĆ** funkcji modyfikator, podobnie jak w

**EKSPORTOWANIE wywołania zwrotnego BOOL** AFunction ( **elementu HDC**, `int` **);**

Aby spowodować, że kompilator będzie rekordu odpowiednie eksportu do eksportu o nazwie bez aliasów. Działa to w przypadku większości potrzeb. W specjalnych przypadkach, takich jak eksportowanie funkcji przez numer lub aliasów eksportu, nadal należy użyć **EKSPORTY** instrukcja w pliku definicji modułu.

Wywołanie zwrotne rejestracji interfejsy są teraz bezpieczny (należy przekazać w wskaźnik funkcji, wskazujący rodzaj funkcji do wywołania zwrotnego).

Należy również zauważyć, że wszystkie funkcje wywołania zwrotnego musi przechwytują wyjątki Microsoft Foundation przed zwróceniem do Windows, ponieważ nie może być zgłaszane wyjątki granice wywołania zwrotnego. Aby uzyskać więcej informacji na temat wyjątków, zobacz artykuł [wyjątki](../../mfc/exception-handling-in-mfc.md).

##  <a name="setarcdirection"></a>  CDC::SetArcDirection

Określa kierunek rysowania, które ma być używany dla funkcji łuk i prostokąt.

```
int SetArcDirection(int nArcDirection);
```

### <a name="parameters"></a>Parametry

*nArcDirection*<br/>
Określa kierunek nowych łuku. Ten parametr może być jedną z następujących wartości:

- Rysunki AD_COUNTERCLOCKWISE rysowane w lewo.

- Rysunki AD_CLOCKWISE rysowane w prawo.

### <a name="return-value"></a>Wartość zwracana

Określa stary kierunku arc, jeśli to się powiedzie; w przeciwnym razie 0.

### <a name="remarks"></a>Uwagi

Domyślny kierunek jest do ruchu wskazówek zegara. `SetArcDirection` Funkcja określa kierunek, w którym następujące funkcje rysowania:

|Łuk|Kołowy|
|---------|---------|
|`ArcTo`|`Rectangle`|
|`Chord`|`RoundRect`|
|`Ellipse`||

##  <a name="setattribdc"></a>  CDC::SetAttribDC

Wywołaj tę funkcję, aby ustawić atrybut kontekstu urządzenia, `m_hAttribDC`.

```
virtual void SetAttribDC(HDC hDC);
```

### <a name="parameters"></a>Parametry

*hDC*<br/>
Windows kontekstu urządzenia.

### <a name="remarks"></a>Uwagi

Ta funkcja elementu członkowskiego nie dołączy kontekst urządzenia do `CDC` obiektu. Kontekst urządzenia danych wyjściowych jest dołączony do `CDC` obiektu.

##  <a name="setbkcolor"></a>  CDC::SetBkColor

Ustawia bieżący kolor tła na kolor określony.

```
virtual COLORREF SetBkColor(COLORREF crColor);
```

### <a name="parameters"></a>Parametry

*crColor*<br/>
Określa nowy kolor tła.

### <a name="return-value"></a>Wartość zwracana

Poprzedni kolor tła jako wartość koloru RGB. Jeśli wystąpi błąd, wartość zwracana jest 0x80000000.

### <a name="remarks"></a>Uwagi

Jeśli tryb tła NIEPRZEZROCZYSTE, system używa kolor tła do wypełniania luk w wierszach ze stylem, odstępy między kreskowane linie pędzle i tła komórek znaków. Podczas konwertowania mapy bitowe między koloru i konteksty urządzenia monochromatyczny, wówczas system używa także kolor tła.

Jeśli urządzenie nie może wyświetlić określony kolor, system ustawia kolor tła do najbliższej koloru fizycznych.

##  <a name="setbkmode"></a>  CDC::SetBkMode

Ustawia tryb tła.

```
int SetBkMode(int nBkMode);
```

### <a name="parameters"></a>Parametry

*nBkMode*<br/>
Określa tryb, należy ustawić. Ten parametr może być jedną z następujących wartości:

- Tło NIEPRZEZROCZYSTE jest wypełniany bieżący kolor tła przed tekstem zakreskowane pędzla lub jest rysowana pióra. Jest to domyślny tryb tła.

- PRZEZROCZYSTE tło nie ulega zmianie przed rysowaniem.

### <a name="return-value"></a>Wartość zwracana

Poprzednie tryb tła.

### <a name="remarks"></a>Uwagi

Tryb tła definiuje, czy system usunie istniejące kolory tła na powierzchni do rysowania przed Rysowanie tekstu, pędzle kreskowane lub dowolny styl pióra, który nie jest linię ciągłą.

### <a name="example"></a>Przykład

  Zobacz przykład [CWnd::OnCtlColor](../../mfc/reference/cwnd-class.md#onctlcolor).

##  <a name="setboundsrect"></a>  CDC::SetBoundsRect

Steruje gromadzenie informacji blokujących prostokąt dla kontekstu określonego urządzenia.

```
UINT SetBoundsRect(
    LPCRECT lpRectBounds,
    UINT flags);
```

### <a name="parameters"></a>Parametry

*lpRectBounds*<br/>
Wskazuje `RECT` struktury lub `CRect` obiekt, który służy do ustawiania prostokąt otaczający. Wymiary prostokąta są podane w logiczne współrzędnych. Ten parametr może mieć wartości NULL.

*flagi*<br/>
Określa, jak nowy prostokąt będzie połączona z skumulowana prostokąta. Ten parametr może być kombinacją następujących wartości:

- DCB_ACCUMULATE Dodaj prostokąt określony przez *lpRectBounds* obszar przycinania na prostokąt otaczający (przy użyciu operacji union prostokąta).

- DCB_DISABLE wyłączyć akumulacja granic.

- DCB_ENABLE Włącz gromadzenie granic. (Ustawienie domyślne akumulacji granice jest wyłączona).

### <a name="return-value"></a>Wartość zwracana

Bieżący stan prostokąt otaczający, jeśli funkcja się powiedzie. Podobnie jak *flagi*, zwracana wartość może być kombinacją **DCB_** wartości:

- DCB_ACCUMULATE prostokąt otaczający nie jest pusty. Wartość ta zawsze będzie ustawiał.

- Akumulacja granice DCB_DISABLE jest wyłączona.

- Akumulacja granice DCB_ENABLE znajduje się na.

### <a name="remarks"></a>Uwagi

Windows może zachować prostokąt otaczający dla wszystkich operacji rysowania. Prostokąt można można tworzyć zapytania i zresetować przez aplikację. Rysowanie granice są przydatne do unieważnienia pamięci podręcznych mapy bitowej.

##  <a name="setbrushorg"></a>  CDC::SetBrushOrg

Określa źródło, które GDI przypisze dalej pędzla, który aplikacja wybiera się do kontekstu urządzenia.

```
CPoint SetBrushOrg(
    int x,
    int y);

CPoint SetBrushOrg(POINT point);
```

### <a name="parameters"></a>Parametry

*x*<br/>
Określa współrzędną x (w jednostkach urządzenia) nowego źródła. Ta wartość musi należeć do zakresu 0-7.

*y*<br/>
Określa współrzędną y (w jednostkach urządzenia) nowego źródła. Ta wartość musi należeć do zakresu 0-7.

*Punkt*<br/>
Określa współrzędne x i y nowego źródła. Każda wartość musi należeć do zakresu 0-7. Można przekazać `POINT` struktury lub `CPoint` obiektu dla tego parametru.

### <a name="return-value"></a>Wartość zwracana

Poprzednie pochodzenie pędzla w jednostkach urządzenia.

### <a name="remarks"></a>Uwagi

Domyślnie współrzędne punktu początkowego pędzla czy (0, 0). Aby zmienić źródło pędzla, należy wywołać `UnrealizeObject` działać w ramach `CBrush` obiektu, wywołaj `SetBrushOrg`, a następnie wywołać `SelectObject` funkcja elementu członkowskiego, aby wybrać pędzel w kontekście urządzenia.

Nie używaj `SetBrushOrg` za pomocą akcji `CBrush` obiektów.

##  <a name="setcoloradjustment"></a>  CDC::SetColorAdjustment

Ustawia wartości dostosowanie kolorów dla kontekstu urządzenia przy użyciu określonych wartości.

```
BOOL SetColorAdjustment(const COLORADJUSTMENT* lpColorAdjust);
```

### <a name="parameters"></a>Parametry

*lpColorAdjust*<br/>
Wskazuje [COLORADJUSTMENT](/windows/desktop/api/wingdi/ns-wingdi-tagcoloradjustment) struktury danych, zawierające wartości dostosowanie kolorów.

### <a name="return-value"></a>Wartość zwracana

Wartość różną od zera, jeśli to się powiedzie; w przeciwnym razie 0.

### <a name="remarks"></a>Uwagi

Wartości dostosowanie kolorów są używane do dostosowania koloru okna wprowadzania źródłowej mapy bitowej dla wywołań `CDC::StretchBlt` funkcja elementu członkowskiego, gdy jest ustawiona w trybie.

##  <a name="setdcbrushcolor"></a>  CDC::SetDCBrushColor

Ustawia wartość określonego koloru bieżący kolor pędzla kontekstu (DC) urządzenia.

```
COLORREF SetDCBrushColor(COLORREF crColor);
```

### <a name="parameters"></a>Parametry

*crColor*<br/>
Określa nowy kolor pędzla.

### <a name="return-value"></a>Wartość zwracana

Jeśli funkcja się powiedzie, wartość zwracana określa na poprzedni kolor pędzla kontrolera domeny jako wartość COLORREF.

Jeśli funkcja zawiedzie, wartość zwracana jest CLR_INVALID.

### <a name="remarks"></a>Uwagi

Ta metoda emuluje funkcjonalność funkcji [SetDCBrushColor](/windows/desktop/api/wingdi/nf-wingdi-setdcbrushcolor), zgodnie z opisem w zestawie Windows SDK.

##  <a name="setdcpencolor"></a>  CDC::SetDCPenColor

Ustawia wartość określonego koloru bieżącego koloru pióra (DC) kontekstu urządzenia.

```
COLORREF SetDCPenColor(COLORREF crColor);
```

### <a name="parameters"></a>Parametry

*crColor*<br/>
Określa nowy kolor pióra.

### <a name="return-value"></a>Wartość zwracana

Różne od zera, jeśli funkcja zakończyła się pomyślnie; w przeciwnym razie 0.

### <a name="remarks"></a>Uwagi

Ta funkcja elementu członkowskiego wykorzystuje funkcję Win32 [SetDCPenColor](/windows/desktop/api/wingdi/nf-wingdi-setdcpencolor), zgodnie z opisem w zestawie Windows SDK.

##  <a name="setgraphicsmode"></a>  CDC::SetGraphicsMode

Ustawia tryb graficznych dla kontekstu określonego urządzenia.

```
int SetGraphicsMode(int iMode);
```

### <a name="parameters"></a>Parametry

*iMode*<br/>
Określa tryb grafiki. Aby uzyskać listę wartości, które można wykonać tego parametru zobacz [SetGraphicsMode](/windows/desktop/api/wingdi/nf-wingdi-setgraphicsmode).

### <a name="return-value"></a>Wartość zwracana

Zwraca tryb stare grafiki w przypadku powodzenia.

Zwraca wartość 0 w przypadku niepowodzenia. Aby uzyskać rozszerzone informacje o błędzie, należy wywołać [GetLastError](https://msdn.microsoft.com/library/windows/desktop/ms679360).

### <a name="remarks"></a>Uwagi

Ta metoda opakowuje funkcję Windows GDI [SetGraphicsMode](/windows/desktop/api/wingdi/nf-wingdi-setgraphicsmode).

##  <a name="setlayout"></a>  CDC::SetLayout

Wywołaj tę funkcję elementu członkowskiego, aby zmienić układ tekstu i grafiki do kontekstu urządzenia do prawej do lewej, standardowego układu kultury, takie jak arabski i hebrajski.

```
DWORD SetLayout(DWORD dwLayout);
```

### <a name="parameters"></a>Parametry

*dwLayout*<br/>
Flagi kontrolne układ kontekstu urządzenia i mapy bitowej. Może być kombinacją następujących wartości.

|Wartość|Znaczenie|
|-----------|-------------|
|LAYOUT_BITMAPORIENTATIONPRESERVED|Wyłącza wszelkie odbicia dla wywołań [CDC::BitBlt](#bitblt) i [CDC::StretchBlt](#stretchblt).|
|LAYOUT_RTL|Ustawia domyślne poziomy układ prawej do lewej.|
|LAYOUT_LTR|Ustawia domyślny układ, aby być od lewej do prawej.|

### <a name="return-value"></a>Wartość zwracana

W przypadku powodzenia poprzedniej układ kontekstu urządzenia.

W przypadku niepowodzenia GDI_ERROR. Aby uzyskać rozszerzone informacje o błędzie, należy wywołać [GetLastError](https://msdn.microsoft.com/library/windows/desktop/ms679360).

### <a name="remarks"></a>Uwagi

Zazwyczaj użytkownik nie może wywołać `SetLayout` okna. Zamiast kontrolować układ od prawej do lewej w oknie przez ustawienie [rozszerzone Style okna ramowego](../../mfc/reference/styles-used-by-mfc.md#extended-window-styles) takich jak WS_EX_RTLREADING. Kontekst urządzenia, takie jak drukarka lub metaplik nie dziedziczy ten układ. Jedynym sposobem, aby ustawić kontekst urządzenia dla układ od prawej do lewej to przez wywołanie metody `SetLayout`.

Jeśli wywołasz **SetLayout (LAYOUT_RTL** ), `SetLayout` zmienia się MM_ISOTROPIC automatycznie tryb mapowania. W rezultacie, kolejne wywołanie [GetMapMode](#getmapmode) zwróci MM_ISOTROPIC zamiast MM_TEXT.

W niektórych przypadkach takich jak przy użyciu wielu map bitowych, warto zachować układ od lewej do prawej. W takich przypadkach renderowania obrazu, wywołując `BitBlt` lub `StretchBlt`, następnie ustaw flagę kontrolki mapy bitowej dla *dwLayout* do LAYOUT_BITMAPORIENTATIONPRESERVED.

Po zmianie układu z flagą LAYOUT_RTL flagi zwykle określenie prawej lub lewej zostały cofnięte. Aby uniknąć nieporozumień, można zdefiniować alternatywne nazwy dla standardowych flag. Aby uzyskać listę sugerowanych alternatywnych flagi nazw, zobacz [SetLayout](/windows/desktop/api/wingdi/nf-wingdi-setlayout) w zestawie Windows SDK.

##  <a name="setmapmode"></a>  CDC::SetMapMode

Ustawia tryb mapowania.

```
virtual int SetMapMode(int nMapMode);
```

### <a name="parameters"></a>Parametry

*nMapMode*<br/>
Określa nowy tryb mapowania. Może być jednym z następujących wartości:

- Jednostki logiczne MM_ANISOTROPIC są konwertowane do dowolnego jednostek za pomocą dowolnie skalowane osi. Ustawienie trybu mapowania MM_ANISOTROPIC nie zmienia bieżące ustawienia okna lub okienka ekranu. Aby zmienić liczbę jednostek, orientacji i skalowania, należy wywołać [SetWindowExt](#setwindowext) i [SetViewportExt](#setviewportext) funkcji elementów członkowskich.

- MM_HIENGLISH każdej jednostki logicznej jest konwertowana na 0,001 cala. Dodatnie x jest prawo; dodatnie y jest uruchomiony.

- MM_HIMETRIC każdej jednostki logicznej jest konwertowana na 0,01 milimetra. Dodatnie x jest prawo; dodatnie y jest uruchomiony.

- Jednostki logiczne MM_ISOTROPIC są konwertowane na dowolnej jednostki przy użyciu równie skalowanych osi 1 jednostka wzdłuż osi x jest równa 1 jednostka wzdłuż osi y. Użyj `SetWindowExt` i `SetViewportExt` funkcji elementów członkowskich, aby określić żądaną jednostek i orientację osi. GDI sprawia, że zmiany w razie potrzeby w celu zapewnienia, że x i y jednostki pozostają taki sam rozmiar.

- MM_LOENGLISH każdej jednostki logicznej jest konwertowana na cal 0,01. Dodatnie x jest prawo; dodatnie y jest uruchomiony.

- MM_LOMETRIC każdej jednostki logicznej jest konwertowana na milimetra 0,1. Dodatnie x jest prawo; dodatnie y jest uruchomiony.

- MM_TEXT każdej jednostki logicznej jest konwertowana na 1 urządzenie pikseli. Dodatnie x jest prawo; dodatnie y nie działa.

- MM_TWIPS każdej jednostki logicznej jest konwertowana na 1/20, punktu. (Ponieważ punkt 1/72 cala, twip jest 1/1440 cala). Dodatnie x jest prawo; dodatnie y jest uruchomiony.

### <a name="return-value"></a>Wartość zwracana

Poprzednie tryb mapowania.

### <a name="remarks"></a>Uwagi

Tryb mapowania Określa jednostkę miary użyty do konwertowania jednostek logicznych do jednostki urządzeń; definiuje również orientacji urządzenia osiami x i. GDI tryb mapowania przekonwertować współrzędne logicznych na współrzędne odpowiednie urządzenie. Tryb MM_TEXT umożliwia aplikacjom pracy urządzenia wyrażoną w pikselach, gdzie 1 jednostka jest równa 1 piksela. Rozmiar fizyczny piksela różni się od urządzenia.

Tryby MM_HIENGLISH MM_HIMETRIC, MM_LOENGLISH, MM_LOMETRIC i MM_TWIPS są przydatne w przypadku aplikacji, które należy narysować w fizycznie istotnych jednostki (takie jak cale lub milimetry). Tryb MM_ISOTROPIC zapewnia współczynnik proporcji 1:1, co jest przydatne, gdy jest ważne zachować dokładne kształtu obrazu. Tryb MM_ANISOTROPIC umożliwia współrzędne x i y-dostosowywana niezależnie.

> [!NOTE]
>  Jeśli wywołasz [SetLayout](#setlayout) Aby zmienić układ od prawej do lewej, kontroler domeny (kontekst urządzenia) `SetLayout` zmienia się MM_ISOTROPIC automatycznie tryb mapowania.

### <a name="example"></a>Przykład

  Zobacz przykład [CView::OnPrepareDC](../../mfc/reference/cview-class.md#onpreparedc).

##  <a name="setmapperflags"></a>  CDC::SetMapperFlags

Zmienia metodę używaną przez mapowania czcionki podczas konwertowania czcionki logiczne do fizycznej czcionki.

```
DWORD SetMapperFlags(DWORD dwFlag);
```

### <a name="parameters"></a>Parametry

*dwFlag*<br/>
Określa, czy mapowanie czcionek próbuje dopasować, czcionka aspekt wysokość i szerokość, do urządzenia. W przypadku wartości ASPECT_FILTERING mapera wybiera tylko czcionki, którego aspekt x i y aspekt dokładnie pasują do właściwości określonego urządzenia.

### <a name="return-value"></a>Wartość zwracana

Poprzednią wartość flagi czcionki mapowania.

### <a name="remarks"></a>Uwagi

Aplikacja może użyć `SetMapperFlags` spowodować mapowania czcionki podjąć próbę wybrania tylko fizyczne czcionkę, która dokładnie odpowiada współczynnik proporcji określonego urządzenia.

Można użyć aplikacji, która używa tylko czcionki rastrowe `SetMapperFlags` funkcję, aby upewnij się, że czcionka wybranych przez mapowanie czcionek atrakcyjne i czytelny na urządzeniu. Aplikacje, które używają skalowalnych czcionek (TrueType) zwykle nie należy używać `SetMapperFlags`.

Jeśli żadne fizyczne czcionki współczynnik proporcji, który odpowiada specyfikacji w logiczny czcionki, GDI wybiera nowy współczynnik proporcji i wybiera czcionkę, która jest zgodna z ten nowy współczynnik proporcji.

##  <a name="setmiterlimit"></a>  CDC::SetMiterLimit

Ustawia limit długości skosu sprzężenia dla kontekstu urządzenia.

```
BOOL SetMiterLimit(float fMiterLimit);
```

### <a name="parameters"></a>Parametry

*fMiterLimit*<br/>
Określa nowy limit skosu do kontekstu urządzenia.

### <a name="return-value"></a>Wartość zwracana

Różne od zera, jeśli funkcja zakończyła się pomyślnie; w przeciwnym razie 0.

### <a name="remarks"></a>Uwagi

Długości skosu jest zdefiniowany jako odległość między przecięcia ściany wiersza wewnątrz sprzężenia przecięcia ściany wiersza na zewnątrz sprzężenia. Limit ukośnych to maksymalny dozwolony stosunek długości skosu do szerokości linii. Domyślny limit ukośnych to 10.0.

##  <a name="setoutputdc"></a>  CDC::SetOutputDC

Wywołanie tej funkcji elementu członkowskiego, aby ustawić kontekst urządzenia dane wyjściowe, `m_hDC`.

```
virtual void SetOutputDC(HDC hDC);
```

### <a name="parameters"></a>Parametry

*hDC*<br/>
Windows kontekstu urządzenia.

### <a name="remarks"></a>Uwagi

Ta funkcja elementu członkowskiego można wywołać tylko, gdy kontekst urządzenia nie jest dołączony do `CDC` obiektu. Ta funkcja elementu członkowskiego ustawia `m_hDC` , ale nie dołączy kontekst urządzenia do `CDC` obiektu.

##  <a name="setpixel"></a>  CDC::SetPixel

Ustawia piksel w punkcie określonym najbliższego zbliżenia kolor określony przy użyciu *crColor*.

```
COLORREF SetPixel(
    int x,
    int y,
    COLORREF crColor);

COLORREF SetPixel(
    POINT point,
    COLORREF crColor);
```

### <a name="parameters"></a>Parametry

*x*<br/>
Określa logiczną współrzędną x punktu, który ma być ustawiona.

*y*<br/>
Określa logiczną współrzędną y punktu, który ma być ustawiona.

*crColor*<br/>
Wartość COLORREF RGB, która określa kolor używany do malowania w punkcie. Zobacz [COLORREF](/windows/desktop/gdi/colorref) w zestawie Windows SDK opis tej wartości.

*Punkt*<br/>
Określa logiczną - współrzędnych x i y punktu, który ma być ustawiona. Można przekazać `POINT` struktury lub `CPoint` obiektu dla tego parametru.

### <a name="return-value"></a>Wartość zwracana

Wartość RGB koloru faktycznie narysowaniu punkt. Ta wartość może być inny niż określony przez *crColor* Jeśli przybliżeniem ten kolor jest używany. Jeśli funkcja zawiedzie (jeśli jest to punkt jest spoza obszaru przycinania), wartość zwracana jest wartość -1.

### <a name="remarks"></a>Uwagi

Punkt musi znajdować się w regionie wycinka. Jeśli punkt nie ma obszaru przycinania, funkcja nie działa.

Nie wszystkie urządzenia obsługują `SetPixel` funkcji. Aby ustalić, czy urządzenie obsługuje `SetPixel`, wywołaj `GetDeviceCaps` element członkowski funkcji o indeksie RASTERCAPS i sprawdź wartość zwracaną dla flagi rastercaps.

##  <a name="setpixelv"></a>  CDC::SetPixelV

Ustawia piksela na określonych współrzędnych najbliższego zbliżenia określonego koloru.

```
BOOL SetPixelV(
    int x,
    int y,
    COLORREF crColor);

BOOL SetPixelV(
    POINT point,
    COLORREF crColor);
```

### <a name="parameters"></a>Parametry

*x*<br/>
Określa współrzędną x w jednostkach logicznych, punktu, który ma być ustawiona.

*y*<br/>
Określa współrzędną y w jednostkach logicznych, punktu, który ma być ustawiona.

*crColor*<br/>
Określa kolor, który ma być używany do malowania w punkcie.

*Punkt*<br/>
Określa logiczną - współrzędnych x i y punktu, który ma być ustawiona. Można przekazać [punktu](/windows/desktop/api/windef/ns-windef-tagpoint) struktury danych lub [CPoint](../../atl-mfc-shared/reference/cpoint-class.md) obiektu dla tego parametru.

### <a name="return-value"></a>Wartość zwracana

Różne od zera, jeśli funkcja zakończyła się pomyślnie; w przeciwnym razie 0.

### <a name="remarks"></a>Uwagi

Punkt musi należeć zarówno obszaru przycinania i widoczna część powierzchni urządzenia. Nie wszystkie urządzenia obsługują funkcja elementu członkowskiego. Aby uzyskać więcej informacji, zobacz możliwości rastercaps w `CDC::GetDeviceCaps` funkcja elementu członkowskiego. `SetPixelV` jest szybsza niż `SetPixel` ponieważ musi zwracać wartość koloru punktu, w rzeczywistości rysowane.

##  <a name="setpolyfillmode"></a>  CDC::SetPolyFillMode

Ustawia tryb wypełnianie wielokąta.

```
int SetPolyFillMode(int nPolyFillMode);
```

### <a name="parameters"></a>Parametry

*nPolyFillMode*<br/>
Określa nowy tryb wypełnianie. Ta wartość może być ALTERNATYWNYM lub rozwiązanie. Domyślny tryb w Windows to alternatywny.

### <a name="return-value"></a>Wartość zwracana

Poprzednie tryb wypełnianie, jeśli to się powiedzie; w przeciwnym razie 0.

### <a name="remarks"></a>Uwagi

Przy włączonym trybie wypełnianie wielokąta alternatywny, system wypełnia obszar między stronami nieparzystą i parzystych wielokąta w każdym wierszu skanowania. Oznacza to, że system wypełnia obszar między pierwszym i drugim po stronie, między strona trzecia i czwarta i tak dalej. Ten tryb jest ustawieniem domyślnym.

Gdy tryb wypełnianie Wielokąt jest rozwiązania, wówczas system używa kierunek, w którym rysunku została narysowana w celu ustalenia, czy wypełnił obszar. Każdy segment linii wielokąta jest rysowane w prawo lub wskazówek zegara. Zawsze, gdy wtedy linię pobrane z obszaru na zewnątrz rysunku przechodzi przez segment linii do ruchu wskazówek zegara, licznik jest zwiększany. Wiersz przejścia przez segment linii do ruchu wskazówek zegara, liczba zostanie zmniejszony. Obszar jest wypełniana, jeśli liczba jest różna od zera, gdy wiersz osiągnie poza rysunku.

##  <a name="setrop2"></a>  CDC::SetROP2

Ustawia bieżący tryb rysowania.

```
int SetROP2(int nDrawMode);
```

### <a name="parameters"></a>Parametry

*nDrawMode*<br/>
Określa nowy tryb rysowania. Może być dowolną z następujących wartości:

- Piksel R2_BLACK są zawsze czarne.

- Piksel R2_WHITE jest zawsze białe.

- Piksel R2_NOP pozostaje bez zmian.

- Piksel R2_NOT jest przeciwieństwem kolorem ekranu.

- Piksel R2_COPYPEN jest na kolor pióra.

- Piksel R2_NOTCOPYPEN jest przeciwieństwem na kolor pióra.

- Piksel R2_MERGEPENNOT jest kombinacją koloru pióra i odwrotność koloru ekranu (pikseli końcowych = (w pikselach nie ekranu) lub za pomocą pióra).

- Piksel R2_MASKPENNOT jest połączeniem kolorów, które są wspólne dla zarówno pióra i odwrotność ekranu (pikseli końcowych = (w pikselach nie ekranu) i za pomocą pióra).

- Piksel R2_MERGENOTPEN jest kombinacją kolorem ekranu oraz odwrotność koloru pióra (pikseli końcowych = (nie pen) lub ekranu w pikselach).

- Piksel R2_MASKNOTPEN jest kombinacją kolorów wspólnych zarówno na ekranie i odwrotność pióra (pikseli końcowych = (nie pen) i ekranu w pikselach).

- Piksel R2_MERGEPEN jest kombinacją koloru pióra i koloru ekranu (pikseli końcowych = pióra lub ekranu pikseli).

- Piksel R2_NOTMERGEPEN jest przeciwieństwem kolor R2_MERGEPEN (pikseli końcowych = (lub ekranu pikseli za pomocą pióra)).

- Piksel R2_MASKPEN jest kombinacją kolorów, które są wspólne dla pióra i ekranu (pikseli końcowych = pióra i ekranu pikseli).

- Piksel R2_NOTMASKPEN jest przeciwieństwem kolor R2_MASKPEN (pikseli końcowych = (za pomocą pióra i ekranu pikseli)).

- Piksel R2_XORPEN jest kombinacją kolorów, które są w pióra lub na ekranie, ale nie w obu (pikseli końcowych = pióra XOR ekranu pikseli).

- Piksel R2_NOTXORPEN jest przeciwieństwem kolor R2_XORPEN (pikseli końcowych = (pióro XOR ekranu pikseli)).

### <a name="return-value"></a>Wartość zwracana

Poprzednie tryb rysowania.

Może to być dowolna z wartości podanych w zestawie Windows SDK.

### <a name="remarks"></a>Uwagi

Tryb rysowania Określa, jak połączone kolory pióra i wewnętrznych obiektów wypełniony kolorem już na wyświetlanej powierzchni.

Tryb rysowania jest tylko w przypadku rastrowych urządzeń; nie ma zastosowania do urządzeń wektora. Tryby rysowania są kody binarne operację rastrową, która reprezentuje wszystkie możliwe kombinacje logiczna dwie zmienne, a nie przy użyciu operatorów binarnych AND, OR i XOR (OR wyłączne) i operację jednoargumentową.

##  <a name="setstretchbltmode"></a>  CDC::SetStretchBltMode

Ustawia tryb rozciąganie mapy bitowej `StretchBlt` funkcja elementu członkowskiego.

```
int SetStretchBltMode(int nStretchMode);
```

### <a name="parameters"></a>Parametry

*nStretchMode*<br/>
Określa tryb rozciągania. Może być dowolną z następujących wartości:

|Wartość|Opis|
|-----------|-----------------|
|BLACKONWHITE|Wykonuje operację LOGICZNEGO przy użyciu wartości kolorów pikseli usunięte i istniejące. Mapy bitowej w przypadku monochromatycznych map bitowych, w tym trybie zachowuje czarne pikseli kosztem piksele.|
|COLORONCOLOR|Usuwa pikseli. W tym trybie usuwa wszystkie usunięte wiersze pikseli bez próby zachować swoje informacje.|
|HALFTONE|Mapuje pikseli z prostokąta źródłowego na bloki pikseli prostokąta docelowego. Średnia kolor przez blok docelowy pikseli przybliża kolor źródłowych.|
||Po ustawieniu PÓŁTONÓW rozciąganie trybu, aplikacja musi wywołać funkcję Win32 [SetBrushOrgEx](/windows/desktop/api/wingdi/nf-wingdi-setbrushorgex) można ustawić źródła pędzla. Jeśli nie powiedzie się w tym celu, wystąpi niezgodność pędzla.|
|STRETCH_ANDSCANS|**Windows 95/98**: Takie same jak BLACKONWHITE|
|STRETCH_DELETESCANS|**Windows 95/98**: Takie same jak COLORONCOLOR|
|STRETCH_HALFTONE|**Windows 95/98**: Taka sama jak PÓŁTONÓW.|
|STRETCH_ORSCANS|**Windows 95/98**: Takie same jak WHITEONBLACK|
|WHITEONBLACK|Wykonuje operację logiczną lub przy użyciu wartości kolorów pikseli usunięte i istniejące. Mapy bitowej w przypadku monochromatycznych map bitowych, w tym trybie zachowuje białe piksele kosztem czarne pikseli.|

### <a name="return-value"></a>Wartość zwracana

Poprzednie trybu rozciągania. Może być STRETCH_ANDSCANS, STRETCH_DELETESCANS lub STRETCH_ORSCANS.

### <a name="remarks"></a>Uwagi

Rozciąganie mapy bitowej trybu definiuje, jak informacji jest usuwany z mapy bitowe, które są kompresowane za pomocą funkcji.

Tryby BLACKONWHITE (STRETCH_ANDSCANS) i WHITEONBLACK (STRETCH_ORSCANS) są zwykle używane do zachować monochromatyczne pikseli pierwszego planu. Tryb COLORONCOLOR (STRETCH_DELETESCANS) jest zwykle używany w zachować kolor map bitowych.

Trybie wymaga więcej przetwarzania obrazu źródłowego niż pozostałe trzy tryby; jest wolniejsza niż inne, ale tworzy obrazy o wyższej jakości. Należy również zauważyć, że `SetBrushOrgEx` musi zostać wywołana po ustawieniu trybie Aby uniknąć niespójności pędzla.

Dodatkowe tryby rozciągania może być również dostępne w zależności od możliwości sterownika urządzenia.

##  <a name="settextalign"></a>  CDC::SetTextAlign

Ustawia flagi wyrównania tekstu.

```
UINT SetTextAlign(UINT nFlags);
```

### <a name="parameters"></a>Parametry

*nFlags*<br/>
Określa wyrównanie tekstu flagi. Flagi Określ relację między punktem i prostokąt, który granic tekstu. Punkt może być bieżącym położeniu lub współrzędnych określonych przez funkcję tekst wyjściowy. Prostokąt, który granic tekst jest definiowany przez znaków sąsiadujących komórek w ciągu tekstowym. *NFlags* parametr może mieć flagi co najmniej jeden z następujących trzech kategorii. Wybierz tylko jedną flagę z każdej kategorii. Pierwsza kategoria wpływa na wyrównanie tekstu w kierunku x:

- TA_CENTER wyrównuje pkt ze środka w poziomie prostokąt otaczający.

- TA_LEFT wyrównuje punkt z lewej strony prostokąt otaczający. To jest ustawienie domyślne.

- TA_RIGHT wyrównuje punkt z prawej strony prostokąt otaczający.

Wyrównanie tekstu w kierunku y drugiej kategorii, ma wpływ na:

- TA_BASELINE wyrównuje punktu z linii bazowej wybranej czcionki.

- TA_BOTTOM wyrównuje punktu z dołu prostokąt otaczający.

- TA_TOP wyrównuje punktu z górną częścią prostokąt otaczający. To jest ustawienie domyślne.

Trzecia Kategoria określa, czy bieżące położenie jest aktualizowany, gdy tekst jest pisany:

- TA_NOUPDATECP nie aktualizuje bieżącej pozycji po każdym wywołaniu funkcji tekst wyjściowy. To jest ustawienie domyślne.

- Aktualizacje TA_UPDATECP bieżącej pozycji x po każdym wywołaniu funkcji tekst wyjściowy. Nowa pozycja jest po prawej stronie prostokąt otaczający tekstu. Gdy ta flaga jest ustawiona, współrzędnych określonych w wywołaniach `TextOut` funkcja elementu członkowskiego są ignorowane.

### <a name="return-value"></a>Wartość zwracana

Poprzednie wyrównanie tekstu ustawienie, jeśli to się powiedzie. Mniej znaczący bajt zawiera ustawienie poziomie, a bajt wyższego rzędu ustawienie pionowa; w przeciwnym razie 0.

### <a name="remarks"></a>Uwagi

`TextOut` i `ExtTextOut` Użyj funkcji elementów członkowskich tych flag podczas pozycjonowania ciągu tekstowego na urządzeniu lub wyświetlania. Flagi Określ relację między określonym punkcie i prostokąt, który granic tekstu. Współrzędne punktu tego są przekazywane jako parametry do `TextOut` funkcja elementu członkowskiego. Prostokąt, który granic tekst jest tworzona przez znaków sąsiadujących komórek w ciągu tekstowym.

##  <a name="settextcharacterextra"></a>  CDC::SetTextCharacterExtra

Ustawia intercharacter odstępu.

```
int SetTextCharacterExtra(int nCharExtra);
```

### <a name="parameters"></a>Parametry

*nCharExtra*<br/>
Określa ilość dodatkowego miejsca (w jednostkach logicznych), ma zostać dodany do każdego znaku. Jeśli nie jest bieżący tryb mapowania `MM_TEXT`, *nCharExtra* są przekształcane i zaokrąglane do najbliższego piksela.

### <a name="return-value"></a>Wartość zwracana

Wartość poprzedniego intercharacter odstępu.

### <a name="remarks"></a>Uwagi

GDI dodaje odstępy w tym do każdego znaku, w tym znaki podziału, gdy zapisuje wiersz tekstu w kontekście urządzenia. Wartość domyślna wielkości odstępów intercharacter to 0.

##  <a name="settextcolor"></a>  CDC::SetTextColor

Ustawia kolor tekstu określonego koloru.

```
virtual COLORREF SetTextColor(COLORREF crColor);
```

### <a name="parameters"></a>Parametry

*crColor*<br/>
Określa kolor tekstu jako wartość koloru RGB.

### <a name="return-value"></a>Wartość zwracana

Wartość RGB na poprzedni kolor tekstu.

### <a name="remarks"></a>Uwagi

Podczas zapisywania tego kontekstu urządzenia i również podczas konwertowania mapy bitowe między kolorów i konteksty urządzeniu monochromatycznym tekstu, system użyje tego koloru tekstu.

Jeśli urządzenie nie może reprezentować określonego koloru, system ustawia kolor tekstu do najbliższej koloru fizycznych. Kolor tła znak jest określona przez `SetBkColor` i `SetBkMode` funkcji elementów członkowskich.

### <a name="example"></a>Przykład

  Zobacz przykład [CWnd::OnCtlColor](../../mfc/reference/cwnd-class.md#onctlcolor).

##  <a name="settextjustification"></a>  CDC::SetTextJustification

Dodaje miejsce znaki końca ciągu.

```
int SetTextJustification(
    int nBreakExtra,
    int nBreakCount);
```

### <a name="parameters"></a>Parametry

*nBreakExtra*<br/>
Określa całkowity dodatkowe miejsce do dodania do wiersza tekstu (w jednostkach logicznych). Jeśli nie jest bieżący tryb mapowania `MM_TEXT`, wartość tego parametru jest konwertowane na bieżący tryb mapowania i zaokrąglony do najbliższej liczby całkowitej urządzenia.

*nBreakCount*<br/>
Określa liczbę znaków podziału w wierszu.

### <a name="return-value"></a>Wartość zwracana

Jeden, jeśli funkcja się powiedzie; w przeciwnym razie 0.

### <a name="remarks"></a>Uwagi

Aplikacja może użyć `GetTextMetrics` funkcje Członkowskie można pobrać czcionki Przerwij znaków.

Po `SetTextJustification` funkcja członkowska jest wywoływana, wywołanie funkcji tekstowych danych wyjściowych (takich jak `TextOut`) dystrybuuje określonego dodatkowe miejsce równomiernie między określoną liczbę znaków podziału. Znak podziału jest zazwyczaj znak spacji (ASCII 32), ale mogą być określone przez czcionki jako innego znaku.

Funkcja elementu członkowskiego `GetTextExtent` jest zwykle używany z `SetTextJustification`. `GetTextExtent` oblicza szerokość danego wiersza przed wyrównania. Aplikację można określić, ile miejsca, aby określić w *nBreakExtra* parametru przez odjęcie wartość zwrócona przez obiekt `GetTextExtent` z szerokość ciąg po znaku wyrównania.

`SetTextJustification` Funkcja może służyć do wyrównania wiersz, który zawiera wiele przebiegów w różnych czcionek. W tym przypadku wiersz musi przyjąć utworzony przez dopasowanie i zapisywanie poszczególnymi uruchomieniami oddzielnie.

Ponieważ błędów zaokrąglania mogą wystąpić podczas wyrównanie, system przechowuje uruchomionej termin błąd, który definiuje bieżącego błąd. Wyrównuje wiersz, który zawiera wiele przebiegów `GetTextExtent` automatycznie używa termin ten błąd, po jego zadaniem jest obliczanie zakresu następnego uruchomienia. Dzięki temu funkcja tekst wyjściowy do programu blend błędu na uruchomienie nowego przebiegu.

Po każdym wierszu zostały dostosowane, termin ten błąd muszą zostać wyczyszczone, aby uniemożliwić jest włączona do następnego wiersza. Wyrażenie może być obsadzona przez wywołanie metody `SetTextJustification` z *nBreakExtra* ustawione na 0.

##  <a name="setviewportext"></a>  CDC::SetViewportExt

Ustawia zakresów x i y okienka ekranu kontekstu urządzenia.

```
virtual CSize SetViewportExt(
    int cx,
    int cy);

CSize SetViewportExt(SIZE size);
```

### <a name="parameters"></a>Parametry

*cx*<br/>
Określa zakres x okienka ekranu (w jednostkach urządzenia).

*cy*<br/>
Określa zakres y okienka ekranu (w jednostkach urządzenia).

*Rozmiar*<br/>
Określa zakres x i y okienka ekranu (w jednostkach urządzenia).

### <a name="return-value"></a>Wartość zwracana

Poprzednie zakresów okienka ekranu jako [CSize](../../atl-mfc-shared/reference/csize-class.md) obiektu. Gdy wystąpi błąd, - współrzędnych x i y zwracanego `CSize` obiektu są ustawione na 0.

### <a name="remarks"></a>Uwagi

Okienka ekranu, wraz z okna kontekstu urządzenia definiuje sposób GDI mapowania punktów w logiczne współrzędnych punktów w układzie współrzędnych rzeczywistego urządzenia. Innymi słowy określają, jak interfejs GDI konwertuje współrzędne logiczne na współrzędnych urządzenia.

Kiedy następujących trybów mapowania są ustawione, wywołania `SetWindowExt` i `SetViewportExt` są ignorowane:

|MM_HIENGLISH|MM_LOMETRIC|
|-------------------|------------------|
|MM_HIMETRIC|MM_TEXT|
|MM_LOENGLISH|MM_TWIPS|

Jeśli skonfigurowano tryb MM_ISOTROPIC, aplikacja musi wywołać `SetWindowExt` funkcji składowej przed wywołaniem `SetViewportExt`.

### <a name="example"></a>Przykład

  Zobacz przykład [CView::OnPrepareDC](../../mfc/reference/cview-class.md#onpreparedc).

##  <a name="setviewportorg"></a>  CDC::SetViewportOrg

Ustawia okienko ekranu pochodzenia kontekstu urządzenia.

```
virtual CPoint SetViewportOrg(
    int x,
    int y);

CPoint SetViewportOrg(POINT point);
```

### <a name="parameters"></a>Parametry

*x*<br/>
Określa współrzędną x (w jednostkach urządzenia) pochodzenia okienka ekranu. Wartość musi być w zakresie system współrzędnych urządzenia.

*y*<br/>
Określa współrzędną y (w jednostkach urządzenia) pochodzenia okienka ekranu. Wartość musi być w zakresie system współrzędnych urządzenia.

*Punkt*<br/>
Określa punkt początkowy okienka ekranu. Wartości muszą być w zakresie system współrzędnych urządzenia. Można przekazać `POINT` struktury lub `CPoint` obiektu dla tego parametru.

### <a name="return-value"></a>Wartość zwracana

Pochodzenie poprzedniego okienka ekranu (we współrzędnych urządzenia), jako `CPoint` obiektu.

### <a name="remarks"></a>Uwagi

Okienka ekranu, wraz z okna kontekstu urządzenia definiuje sposób GDI mapowania punktów w logiczne współrzędnych punktów w układzie współrzędnych rzeczywistego urządzenia. Innymi słowy określają, jak interfejs GDI konwertuje współrzędne logiczne na współrzędnych urządzenia.

Pochodzenie okienka ekranu oznacza punkt w układzie współrzędnych urządzenia, do którego GDI mapy pochodzenia okna, punktem w logiczne współrzędnych określony przez `SetWindowOrg` funkcja elementu członkowskiego. GDI mapuje wszystkie inne punkty, postępując zgodnie z tym samym procesie potrzebne do mapowania źródła okna źródła okienka ekranu. Na przykład wszystkie punkty w kółko wokół punktu pochodzenia okno będzie w kółko wokół punktu pochodzenia okienka ekranu. Podobnie wszystkie punkty w wierszu, który przechodzi przez okno źródła będą znajdować się w wiersza, który przechodzi przez punkt początkowy okienka ekranu.

### <a name="example"></a>Przykład

  Zobacz przykład [CView::OnPrepareDC](../../mfc/reference/cview-class.md#onpreparedc).

##  <a name="setwindowext"></a>  CDC::SetWindowExt

Ustawia zakresów x i y okna skojarzonego z kontekstem urządzenia.

```
virtual CSize SetWindowExt(
    int cx,
    int cy);

CSize SetWindowExt(SIZE size);
```

### <a name="parameters"></a>Parametry

*cx*<br/>
Określa x zakresu (w jednostkach logicznych) okna.

*cy*<br/>
Określa y zakresu (w jednostkach logicznych) okna.

*Rozmiar*<br/>
Określa x - i y zakres (w jednostkach logicznych) okna.

### <a name="return-value"></a>Wartość zwracana

Zakres poprzednie okno (w jednostkach logicznych) jako `CSize` obiektu. Jeśli wystąpi błąd, - współrzędnych x i y zwracanego `CSize` obiektu są ustawione na 0.

### <a name="remarks"></a>Uwagi

Okna, wraz z okienka ekranu kontekstu urządzenia definiuje sposób GDI mapowania punktów w logiczne współrzędnych punktów w układzie współrzędnych urządzenia.

Kiedy następujących trybów mapowania są ustawione, wywołania `SetWindowExt` i `SetViewportExt` funkcji są ignorowane:

- MM_HIENGLISH

- MM_HIMETRIC

- MM_LOENGLISH

- MM_LOMETRIC

- MM_TEXT

- MM_TWIPS

Jeśli skonfigurowano tryb MM_ISOTROPIC, aplikacja musi wywołać `SetWindowExt` funkcji składowej przed wywołaniem `SetViewportExt`.

### <a name="example"></a>Przykład

  Zobacz przykład [CView::OnPrepareDC](../../mfc/reference/cview-class.md#onpreparedc).

##  <a name="setwindoworg"></a>  CDC::SetWindowOrg

Ustawia okno pochodzenia kontekstu urządzenia.

```
CPoint SetWindowOrg(
    int x,
    int y);

CPoint SetWindowOrg(POINT point);
```

### <a name="parameters"></a>Parametry

*x*<br/>
Określa logiczną współrzędną x pochodzenia nowego okna.

*y*<br/>
Określa logiczną współrzędną y pochodzenia nowego okna.

*Punkt*<br/>
Określa współrzędne logiczne pochodzenia nowego okna. Można przekazać `POINT` struktury lub `CPoint` obiektu dla tego parametru.

### <a name="return-value"></a>Wartość zwracana

Pochodzenie poprzednie okno jako `CPoint` obiektu.

### <a name="remarks"></a>Uwagi

Okna, wraz z okienka ekranu kontekstu urządzenia definiuje sposób GDI mapowania punktów w logiczne współrzędnych punktów w układzie współrzędnych urządzenia.

Okno źródła oznacza punkt, w układzie współrzędnych logiczne, z którego GDI mapy pochodzenia okienka ekranu, a punkt w układzie współrzędnych urządzenia, które są określone przez `SetWindowOrg` funkcji. GDI mapuje wszystkie inne punkty, postępując zgodnie z tym samym procesie potrzebne do mapowania źródła okna źródła okienka ekranu. Na przykład wszystkie punkty w kółko wokół punktu pochodzenia okno będzie w kółko wokół punktu pochodzenia okienka ekranu. Podobnie wszystkie punkty w wierszu, który przechodzi przez okno źródła będą znajdować się w wiersza, który przechodzi przez punkt początkowy okienka ekranu.

##  <a name="setworldtransform"></a>  CDC::SetWorldTransform

Ustawia dwuwymiarowa transformacja liniowy między świecie i strony miejsca dla kontekstu określonego urządzenia. Ta transformacja może służyć do skalowania, obracanie, zmienianie lub tłumaczenie grafiki w danych wyjściowych.

```
BOOL SetWorldTransform(const XFORM& rXform);
```

### <a name="parameters"></a>Parametry

*rXform*<br/>
Odwołanie do [XFORM](/windows/desktop/api/wingdi/ns-wingdi-tagxform) strukturę, która zawiera dane transformacji.

### <a name="return-value"></a>Wartość zwracana

Zwraca wartość różną od zera w przypadku powodzenia.

Zwraca wartość 0 w przypadku niepowodzenia.

Aby uzyskać rozszerzone informacje o błędzie, należy wywołać [GetLastError](https://msdn.microsoft.com/library/windows/desktop/ms679360).

### <a name="remarks"></a>Uwagi

Ta metoda opakowuje funkcję Windows GDI [SetWorldTransform](/windows/desktop/api/wingdi/nf-wingdi-setworldtransform).

##  <a name="startdoc"></a>  CDC::StartDoc

Informuje o sterownik urządzenia, który rozpoczyna nowe zadanie drukowania i wszystkich kolejnych `StartPage` i `EndPage` wywołania mają być buforowane w ramach tego samego zadania do momentu `EndDoc` wywołania.

```
int StartDoc(LPDOCINFO lpDocInfo);
int StartDoc(LPCTSTR lpszDocName);
```

### <a name="parameters"></a>Parametry

*lpDocInfo*<br/>
Wskazuje [DOCINFO](/windows/desktop/api/wingdi/ns-wingdi-_docinfoa) struktury zawierający nazwę pliku dokument i nazwę pliku wyjściowego.

*lpszDocName*<br/>
Wskaźnik do ciągu zawierającego nazwę pliku dokumentu.

### <a name="return-value"></a>Wartość zwracana

Jeśli funkcja się powiedzie, wartość zwracana jest większa niż zero. Ta wartość jest identyfikator zadania drukowania dokumentu.

Jeśli funkcja zawiedzie, zwracana wartość jest mniejsza lub równa zero.

### <a name="remarks"></a>Uwagi

Daje to gwarancję, że więcej niż jedną stronę dokumenty nie będą grupową inne zadania.

Windows w wersji 3.1 lub nowszej ta funkcja zastępuje STARTDOC ucieczki drukarki. Za pomocą tej funkcji gwarantuje, że dokumentów zawierających więcej niż jedną stronę nie grupową innych zadań drukowania.

`StartDoc` Nie można używać wewnątrz metapliki.

### <a name="example"></a>Przykład

Ten fragment kodu pobiera zostanie użyta drukarka domyślna otwiera zadania drukowania i buforuje jednej strony z "Hello, World!" na nim. Ponieważ tekst drukowanymi przez ten kod nie jest skalowany w jednostki logiczne drukarki, widoczny będzie tekst wyjścia może być w takich małych liter, że wynik nie będzie można odczytać. Skalowanie funkcji, takich jak Przechwytywanie zmian danych — `SetMapMode`, `SetViewportOrg`, i `SetWindowExt`, można rozwiązać, skalowanie.

[!code-cpp[NVC_MFCDocView#41](../../mfc/codesnippet/cpp/cdc-class_13.cpp)]

##  <a name="startpage"></a>  CDC::StartPage

Wywołaj tę funkcję elementu członkowskiego, aby przygotować sterownika drukarki na odbieranie danych.

```
int StartPage();
```

### <a name="return-value"></a>Wartość zwracana

Większa lub równa 0, jeśli funkcja się powiedzie, lub wartość ujemną, jeśli wystąpił błąd.

### <a name="remarks"></a>Uwagi

`StartPage` zastępuje NEWFRAME i BANDINFO sekwencje ucieczki.

Aby uzyskać omówienie sekwencję wywołań drukowania, zobacz [StartDoc](#startdoc) funkcja elementu członkowskiego.

System wyłącza `ResetDC` funkcja elementu członkowskiego między wywołaniami `StartPage` i `EndPage`.

### <a name="example"></a>Przykład

  Zobacz przykład [CDC::StartDoc](#startdoc).

##  <a name="stretchblt"></a>  CDC::StretchBlt

Kopiuje mapę bitową z prostokąta źródłowego do prostokąta docelowego, w razie potrzeby rozciągając ją lub zmniejszając, aby dopasować ją do wymiarów prostokąta docelowego.

```
BOOL StretchBlt(
    int x,
    int y,
    int nWidth,
    int nHeight,
    CDC* pSrcDC,
    int xSrc,
    int ySrc,
    int nSrcWidth,
    int nSrcHeight,
    DWORD dwRop);
```

### <a name="parameters"></a>Parametry

*x*<br/>
Określa współrzędną x (w jednostkach logicznych) lewego górnego rogu prostokąta docelowego.

*y*<br/>
Określa współrzędną y (w jednostkach logicznych) lewego górnego rogu prostokąta docelowego.

*nWidth*<br/>
Określa szerokość (w jednostkach logicznych) prostokąta docelowego.

*nHeight*<br/>
Określa wysokość (w jednostkach logicznych) prostokąta docelowego.

*pSrcDC*<br/>
Określa kontekst urządzenia źródłowego.

*xSrc*<br/>
Określa współrzędną x (w jednostkach logicznych) lewego górnego rogu prostokąta źródłowego.

*ySrc*<br/>
Określa współrzędną y (w jednostkach logicznych) lewego górnego rogu prostokąta źródłowego.

*nSrcWidth*<br/>
Określa szerokość (w jednostkach logicznych) prostokąta źródłowego.

*nSrcHeight*<br/>
Określa wysokość (w jednostkach logicznych) prostokąta źródłowego.

*dwRop*<br/>
Określa operację rastrową, która ma być wykonana. Kody operacji rastrowych definiują, jak interfejs GDI łączy kolory w operacjach wyjściowych, które obejmują aktualny pędzel, możliwą źródłową mapę bitową i docelową mapę bitową. Ten parametr może przybierać jedną z następujących wartości:

- Włącza CZERNI wyjściowy na czerń.

- DSTINVERT odwraca docelową mapę bitową.

- MERGECOPY łączy deseń i źródłową mapę bitową użyciu operatora logicznego.

- MERGEPAINT łączy odwróconą źródłową mapę bitową z docelową mapą bitową za pomocą operatora logicznego OR.

- NOTSRCCOPY kopiuje odwróconą źródłową mapę bitową do miejsca docelowego.

- NOTSRCERASE odwraca wynik połączenia docelowej i źródłowej mapy bitowej przy użyciu operatora logicznego OR.

- PATCOPY kopiuje deseń do docelowej mapy bitowej.

- PATINVERT łączy docelową mapę bitową z deseniem za pomocą operatora logicznego XOR.

- PATPAINT łączy odwróconą źródłową mapę bitową z deseniem za pomocą operatora logicznego OR. Łączy wynik tej operacji z docelową mapą bitową za pomocą operatora logicznego OR.

- SRCAND łączy piksele docelowej i źródłowej mapy bitowej przy użyciu operatora logicznego.

- SRCCOPY kopiuje źródłową mapę bitową do docelowej mapy bitowej.

- SRCERASE} odwraca docelową mapę bitową i łączy wynik ze źródłową mapę bitową użyciu operatora logicznego.

- SRCINVERT łączy piksele docelowej i źródłowej mapy bitowej przy użyciu operatora logicznego XOR.

- SRCPAINT łączy piksele docelowej i źródłowej mapy bitowej przy użyciu operatora logicznego OR.

- Włącza WHITENESS wyjściowy na biel.

### <a name="return-value"></a>Wartość zwracana

Różne od zera, jeśli mapa bitowa jest rysowana; w przeciwnym razie 0.

### <a name="remarks"></a>Uwagi

Funkcja używa trybu rozciągania kontekstu urządzenia docelowego (ustawione przez `SetStretchBltMode`) do określenia, jak rozciągnąć lub zmniejszyć mapę bitową.

`StretchBlt` Funkcja przenosi mapę bitową z urządzenia źródłowego podanego przez *pSrcDC* do urządzenia docelowego, reprezentowanego przez obiekt kontekstu urządzenia, którego funkcja członkowska jest wywoływana. *XSrc*, *ySrc*, *nSrcWidth*, i *nSrcHeight* parametry definiują lewy górny róg i wymiary prostokąta źródłowego . *x*, *y*, *nWidth*, i *nHeight* parametry zapewniają lewy górny róg i wymiary prostokąta docelowego. Operacja rastrowa określona przez *dwRop* definiuje sposób łączenia źródłowej mapy bitowej i bitów już na urządzeniu docelowym.

`StretchBlt` Funkcja tworzy obraz lustrzany mapy bitowej, jeżeli znaki *nSrcWidth* i *nWidth* lub *nSrcHeight* i *nHeight* różnią się parametrami. Jeśli *nSrcWidth* i *nWidth* mają różne znaki, funkcja tworzy obraz lustrzany mapy bitowej, wzdłuż osi x. Jeśli *nSrcHeight* i *nHeight* mają różne znaki, funkcja tworzy obraz lustrzany mapy bitowej, wzdłuż osi y.

`StretchBlt` Funkcja rozciąga lub kompresuje źródłową mapę bitową w pamięci, a następnie kopiuje wynik do miejsca docelowego. Jeśli deseń ma być połączony z wynikiem, nie jest łączony, dopóki rozciągnięta źródłowa mapa bitowa nie zostanie skopiowana do miejsca docelowego. Jeśli jest używany pędzel, jest to wybrany pędzel w kontekście urządzenia docelowego. Współrzędne miejsca przeznaczenia są przekształcane zgodnie z kontekstem urządzenia docelowego; współrzędne źródła są przekształcane zgodnie z kontekstem urządzenia źródłowego.

Jeśli miejsce docelowe, źródła i desenia nie mają tego samego formatu koloru `StretchBlt` konwertuje mapy bitowe źródła i wzorzec do dopasowania, bitmap docelowego. Kolory pierwszego planu i tła kontekstu urządzenia docelowego są używane do konwersji.

Jeśli `StretchBlt` musi przekonwertować monochromatyczną mapę bitową na kolor, to ustawia bity białe (1) do koloru tła i bity czarne (0) kolor pierwszego planu. Aby przekonwertować kolor na monochromatyczny, ustawia piksele, które odpowiadają kolorowi tła, na biały (1), a wszystkie inne piksele ustawia na czarny (0). Używane są kolory pierwszego planu i tła kontekstu urządzenia z kolorem.

Nie wszystkie urządzenia obsługują `StretchBlt` funkcji. Aby ustalić, czy urządzenie obsługuje `StretchBlt`, wywołaj `GetDeviceCaps` element członkowski funkcji o indeksie RASTERCAPS i sprawdź wartość zwracaną dla flagi RC_STRETCHBLT.

##  <a name="strokeandfillpath"></a>  CDC::StrokeAndFillPath

Zamyka wszystkie otwartych figur w ścieżce, obrysy konspektu ścieżki przy użyciu bieżącego pióra i wypełnia jego wewnętrznych przy użyciu aktualny pędzel.

```
BOOL StrokeAndFillPath();
```

### <a name="return-value"></a>Wartość zwracana

Różne od zera, jeśli funkcja zakończyła się pomyślnie; w przeciwnym razie 0.

### <a name="remarks"></a>Uwagi

Kontekst urządzenia musi zawierać ścieżkę zamkniętą. `StrokeAndFillPath` Funkcja elementu członkowskiego ma taki sam skutek jak zamknięcie wszystkich otwartych figur w ścieżce i stykają i wypełniając ścieżkę oddzielnie, z tą różnicą, że wypełnionego obszaru będzie nakłada się na region obrysowane nawet wtedy, gdy pióro jest szeroka.

##  <a name="strokepath"></a>  CDC::StrokePath

Renderuje określonej ścieżki przy użyciu bieżącego pióra.

```
BOOL StrokePath();
```

### <a name="return-value"></a>Wartość zwracana

Różne od zera, jeśli funkcja zakończyła się pomyślnie; w przeciwnym razie 0.

### <a name="remarks"></a>Uwagi

Kontekst urządzenia musi zawierać ścieżkę zamkniętą.

##  <a name="tabbedtextout"></a>  CDC::TabbedTextOut

Wywołaj tę funkcję elementu członkowskiego, aby zapisać ciąg znaków w określonej lokalizacji, w zasięgu karty na wartości określone w tablicy pozycji tabulatora.

```
virtual CSize TabbedTextOut(
    int x,
    int y,
    LPCTSTR lpszString,
    int nCount,
    int nTabPositions,
    LPINT lpnTabStopPositions,
    int nTabOrigin);

CSize TabbedTextOut(
    int x,
    int y,
    const CString& str,
    int nTabPositions,
    LPINT lpnTabStopPositions,
    int nTabOrigin);
```

### <a name="parameters"></a>Parametry

*x*<br/>
Określa logiczną współrzędną x punktu początkowego ciągu.

*y*<br/>
Określa logiczną współrzędną y punktu początkowego ciągu.

*lpszString*<br/>
Wskazuje ciąg znaków do rysowania. Można przekazać albo wskaźnika do tablicy znaków lub [CString](../../atl-mfc-shared/reference/cstringt-class.md) obiektu dla tego parametru.

*nCount*<br/>
Określa [długość ciągu](/windows/desktop/gdi/specifying-length-of-text-output-string) wskazywany przez *lpszString*.

*nTabPositions*<br/>
Określa liczbę wartości w tablicy pozycji tabulatora.

*lpnTabStopPositions*<br/>
Wskazuje tablicę zawierającą pozycji tabulatora (w jednostkach logicznych). Pozycji tabulatorów muszą być posortowane rosnąco; najmniejsza wartość x powinien być pierwszy element w tablicy.

*nTabOrigin*<br/>
Określa współrzędną x pozycji początkowej, z którego karty zostaną rozwinięte (w jednostkach logicznych).

*str*<br/>
A `CString` obiekt, który zawiera określonych znaków.

### <a name="return-value"></a>Wartość zwracana

Wymiary ciągu (w jednostkach logicznych) jako `CSize` obiektu.

### <a name="remarks"></a>Uwagi

Tekst został napisany w aktualnie wybranej czcionki. Jeśli *nTabPositions* wynosi 0 i *lpnTabStopPositions* ma wartość NULL, kartach są rozszerzane do ośmiu godzin szerokość znaków średniej.

Jeśli *nTabPositions* wynosi 1, karta zatrzymuje są oddzielone w odległości określonej przez pierwszą wartość *lpnTabStopPositions* tablicy. Jeśli *lpnTabStopPositions* tablica zawiera więcej niż jedną wartość, tabulator jest ustawiona dla każdej wartości w tablicy, maksymalna liczba określona przez *nTabPositions*. *NTabOrigin* parametr umożliwia aplikacji wywołanie `TabbedTextOut` funkcji dla pojedynczego wiersza. Jeśli aplikacja wywołuje funkcję więcej niż jeden raz z *nTabOrigin* ustawić taką samą wartość każdorazowo, funkcja rozwija wszystkie karty względem pozycji określonej przez *nTabOrigin*.

Domyślnie, funkcja nie używa ani nie aktualizuje bieżącej pozycji. Jeśli aplikacja musi zaktualizować bieżącą pozycję w przypadku, gdy wywołuje funkcję, aplikacja może wywołać [SetTextAlign](#settextalign) funkcji składowej z *nFlags* równa TA_UPDATECP. Jeśli ta flaga jest ustawiona, Windows ignoruje *x* i *y* parametrów w kolejnych wywołaniach `TabbedTextOut`, zamiast tego używa bieżącej pozycji.

##  <a name="textout"></a>  CDC::TextOut

Zapisuje ciąg znaków w określonej lokalizacji przy użyciu aktualnie wybranej czcionki.

```
virtual BOOL TextOut(
    int x,
    int y,
    LPCTSTR lpszString,
    int nCount);

BOOL TextOut(
    int x,
    int y,
    const CString& str);
```

### <a name="parameters"></a>Parametry

*x*<br/>
Określa logiczną współrzędną x punktu początkowego tekstu.

*y*<br/>
Określa logiczną współrzędną y punktu początkowego tekstu.

*lpszString*<br/>
Wskazuje ciąg znaków do rysowania.

*nCount*<br/>
Określa liczbę znaków w ciągu.

*str*<br/>
A `CString` obiekt, który zawiera znaki do rysowania.

### <a name="return-value"></a>Wartość zwracana

Różne od zera, jeśli funkcja zakończyła się pomyślnie; w przeciwnym razie 0.

### <a name="remarks"></a>Uwagi

Początki znaków są w lewym górnym rogu komórki znaków. Domyślnie, funkcja nie używa ani nie aktualizuje bieżącej pozycji.

Jeśli aplikacja musi zaktualizować bieżącą pozycję w przypadku, gdy wywołuje `TextOut`, aplikacja może wywołać `SetTextAlign` funkcji składowej z *nFlags* równa TA_UPDATECP. Jeśli ta flaga jest ustawiona, Windows ignoruje *x* i *y* parametrów w kolejnych wywołaniach `TextOut`, zamiast tego używa bieżącej pozycji.

### <a name="example"></a>Przykład

  Zobacz przykład [CDC::BeginPath](#beginpath).

##  <a name="transparentblt"></a>  CDC::TransparentBlt

Wywołaj tę funkcję elementu członkowskiego do transferu bloku bitowych danych kolor, który odnosi się do prostokąta pikseli z kontekstem urządzenia źródłowego określonym do kontekstu urządzenia docelowego.

```
BOOL TransparentBlt(
    int xDest,
    int yDest,
    int nDestWidth,
    int nDestHeight,
    CDC* pSrcDC,
    int xSrc,
    int ySrc,
    int nSrcWidth,
    int nSrcHeight,
    UINT clrTransparent);
```

### <a name="parameters"></a>Parametry

*xDest*<br/>
Określa współrzędną x w jednostkach logicznych, w lewym górnym rogu prostokąta docelowego.

*yDest*<br/>
Określa współrzędną y w jednostkach logicznych, w lewym górnym rogu prostokąta docelowego.

*nDestWidth*<br/>
Określa szerokość w jednostkach logicznych, prostokąta docelowego.

*nDestHeight*<br/>
Określa wysokość w jednostkach logicznych, prostokąta docelowego.

*pSrcDC*<br/>
Wskaźnik do kontekst urządzenia źródłowego.

*xSrc*<br/>
Określa współrzędną x w jednostkach logicznych, prostokąta źródłowego.

*ySrc*<br/>
Określa współrzędną y w jednostkach logicznych, prostokąta źródłowego.

*nSrcWidth*<br/>
Określa szerokość w jednostkach logicznych, prostokąta źródłowego.

*nSrcHeight*<br/>
Określa wysokość w jednostkach logicznych, prostokąta źródłowego.

*clrTransparent*<br/>
Kolor RGB w źródłową mapę bitową do traktowania jako przezroczysty.

### <a name="return-value"></a>Wartość zwracana

Wartość TRUE, jeśli to się powiedzie; w przeciwnym razie wartość FALSE.

### <a name="remarks"></a>Uwagi

`TransparentBlt` Umożliwia przejrzystości. oznacza to, że kolor RGB wskazywanym przez *clrTransparent* staje się przezroczyste w celu wykonania transferu.

Aby uzyskać więcej informacji, zobacz [TransparentBlt](/windows/desktop/api/wingdi/nf-wingdi-transparentblt) w zestawie Windows SDK.

##  <a name="updatecolors"></a>  CDC::UpdateColors

Aktualizacje obszaru klienta, kontekstu urządzenia, porównując bieżącą kolorów w obszar klienta do palety system na podstawie poszczególne piksele.

```
void UpdateColors();
```

### <a name="remarks"></a>Uwagi

Może wywołać nieaktywnego okna z zrealizowane logiczną paletę `UpdateColors` jako alternatywę do ponownego narysowania obszaru klienckiego po zmianie palety systemu.

Aby uzyskać więcej informacji o korzystaniu z palety kolorów, zobacz [UpdateColors](/windows/desktop/api/wingdi/nf-wingdi-updatecolors) w zestawie Windows SDK.

`UpdateColors` Funkcja elementu członkowskiego szybciej niż odświeżanie obszaru zazwyczaj aktualizuje obszaru klienta. Jednak ponieważ funkcja dokonuje translacji kolorów, na podstawie koloru każdego piksela przed zmianą paleta systemu, każde wywołanie tej funkcji powoduje utratę niektórych odwzorowanie kolorów.

##  <a name="widenpath"></a>  CDC::WidenPath

Ponownie bieżącą ścieżkę jako obszar, który będzie malowane, jeśli zostały malowania ścieżki, za pomocą pióra, aktualnie wybrany do kontekstu urządzenia.

```
BOOL WidenPath();
```

### <a name="return-value"></a>Wartość zwracana

Różne od zera, jeśli funkcja zakończyła się pomyślnie; w przeciwnym razie 0.

### <a name="remarks"></a>Uwagi

Ta funkcja się powiedzie, tylko wtedy, gdy pióro geometryczne, utworzone przez drugą wersję bieżącego pióra `CreatePen` funkcji członkowskiej, lub gdy pióro jest tworzony z pierwszą wersję `CreatePen` i ma szerokość w jednostkach urządzenia, większa niż 1. Kontekst urządzenia musi zawierać ścieżkę zamkniętą. Wszelkie krzywych Bzier w ścieżce są konwertowane na sekwencje proste linie, krzywe poszerzył po. W efekcie nie krzywych Bzier pozostają w ścieżce po `WidenPath` jest wywoływana.

## <a name="see-also"></a>Zobacz także

[Klasa CObject](../../mfc/reference/cobject-class.md)<br/>
[Wykres hierarchii](../../mfc/hierarchy-chart.md)<br/>
[Klasa CPaintDC](../../mfc/reference/cpaintdc-class.md)<br/>
[Klasa CWindowDC](../../mfc/reference/cwindowdc-class.md)<br/>
[Klasa CClientDC](../../mfc/reference/cclientdc-class.md)<br/>
[Klasa CMetaFileDC](../../mfc/reference/cmetafiledc-class.md)

---
title: Klasa CDC
ms.date: 11/19/2018
f1_keywords:
- CDC
- AFXWIN/CDC
- AFXWIN/CDC::CDC
- AFXWIN/CDC::AbortDoc
- AFXWIN/CDC::AbortPath
- AFXWIN/CDC::AddMetaFileComment
- AFXWIN/CDC::AlphaBlend
- AFXWIN/CDC::AngleArc
- AFXWIN/CDC::Arc
- AFXWIN/CDC::ArcTo
- AFXWIN/CDC::Attach
- AFXWIN/CDC::BeginPath
- AFXWIN/CDC::BitBlt
- AFXWIN/CDC::Chord
- AFXWIN/CDC::CloseFigure
- AFXWIN/CDC::CreateCompatibleDC
- AFXWIN/CDC::CreateDC
- AFXWIN/CDC::CreateIC
- AFXWIN/CDC::DeleteDC
- AFXWIN/CDC::DeleteTempMap
- AFXWIN/CDC::Detach
- AFXWIN/CDC::DPtoHIMETRIC
- AFXWIN/CDC::DPtoLP
- AFXWIN/CDC::Draw3dRect
- AFXWIN/CDC::DrawDragRect
- AFXWIN/CDC::DrawEdge
- AFXWIN/CDC::DrawEscape
- AFXWIN/CDC::DrawFocusRect
- AFXWIN/CDC::DrawFrameControl
- AFXWIN/CDC::DrawIcon
- AFXWIN/CDC::DrawState
- AFXWIN/CDC::DrawText
- AFXWIN/CDC::DrawTextEx
- AFXWIN/CDC::Ellipse
- AFXWIN/CDC::EndDoc
- AFXWIN/CDC::EndPage
- AFXWIN/CDC::EndPath
- AFXWIN/CDC::EnumObjects
- AFXWIN/CDC::Escape
- AFXWIN/CDC::ExcludeClipRect
- AFXWIN/CDC::ExcludeUpdateRgn
- AFXWIN/CDC::ExtFloodFill
- AFXWIN/CDC::ExtTextOut
- AFXWIN/CDC::FillPath
- AFXWIN/CDC::FillRect
- AFXWIN/CDC::FillRgn
- AFXWIN/CDC::FillSolidRect
- AFXWIN/CDC::FlattenPath
- AFXWIN/CDC::FloodFill
- AFXWIN/CDC::FrameRect
- AFXWIN/CDC::FrameRgn
- AFXWIN/CDC::FromHandle
- AFXWIN/CDC::GetArcDirection
- AFXWIN/CDC::GetAspectRatioFilter
- AFXWIN/CDC::GetBkColor
- AFXWIN/CDC::GetBkMode
- AFXWIN/CDC::GetBoundsRect
- AFXWIN/CDC::GetBrushOrg
- AFXWIN/CDC::GetCharABCWidths
- AFXWIN/CDC::GetCharABCWidthsI
- AFXWIN/CDC::GetCharacterPlacement
- AFXWIN/CDC::GetCharWidth
- AFXWIN/CDC::GetCharWidthI
- AFXWIN/CDC::GetClipBox
- AFXWIN/CDC::GetColorAdjustment
- AFXWIN/CDC::GetCurrentBitmap
- AFXWIN/CDC::GetCurrentBrush
- AFXWIN/CDC::GetCurrentFont
- AFXWIN/CDC::GetCurrentPalette
- AFXWIN/CDC::GetCurrentPen
- AFXWIN/CDC::GetCurrentPosition
- AFXWIN/CDC::GetDCBrushColor
- AFXWIN/CDC::GetDCPenColor
- AFXWIN/CDC::GetDeviceCaps
- AFXWIN/CDC::GetFontData
- AFXWIN/CDC::GetFontLanguageInfo
- AFXWIN/CDC::GetGlyphOutline
- AFXWIN/CDC::GetGraphicsMode
- AFXWIN/CDC::GetHalftoneBrush
- AFXWIN/CDC::GetKerningPairs
- AFXWIN/CDC::GetLayout
- AFXWIN/CDC::GetMapMode
- AFXWIN/CDC::GetMiterLimit
- AFXWIN/CDC::GetNearestColor
- AFXWIN/CDC::GetOutlineTextMetrics
- AFXWIN/CDC::GetOutputCharWidth
- AFXWIN/CDC::GetOutputTabbedTextExtent
- AFXWIN/CDC::GetOutputTextExtent
- AFXWIN/CDC::GetOutputTextMetrics
- AFXWIN/CDC::GetPath
- AFXWIN/CDC::GetPixel
- AFXWIN/CDC::GetPolyFillMode
- AFXWIN/CDC::GetROP2
- AFXWIN/CDC::GetSafeHdc
- AFXWIN/CDC::GetStretchBltMode
- AFXWIN/CDC::GetTabbedTextExtent
- AFXWIN/CDC::GetTextAlign
- AFXWIN/CDC::GetTextCharacterExtra
- AFXWIN/CDC::GetTextColor
- AFXWIN/CDC::GetTextExtent
- AFXWIN/CDC::GetTextExtentExPointI
- AFXWIN/CDC::GetTextExtentPointI
- AFXWIN/CDC::GetTextFace
- AFXWIN/CDC::GetTextMetrics
- AFXWIN/CDC::GetViewportExt
- AFXWIN/CDC::GetViewportOrg
- AFXWIN/CDC::GetWindow
- AFXWIN/CDC::GetWindowExt
- AFXWIN/CDC::GetWindowOrg
- AFXWIN/CDC::GetWorldTransform
- AFXWIN/CDC::GradientFill
- AFXWIN/CDC::GrayString
- AFXWIN/CDC::HIMETRICtoDP
- AFXWIN/CDC::HIMETRICtoLP
- AFXWIN/CDC::IntersectClipRect
- AFXWIN/CDC::InvertRect
- AFXWIN/CDC::InvertRgn
- AFXWIN/CDC::IsPrinting
- AFXWIN/CDC::LineTo
- AFXWIN/CDC::LPtoDP
- AFXWIN/CDC::LPtoHIMETRIC
- AFXWIN/CDC::MaskBlt
- AFXWIN/CDC::ModifyWorldTransform
- AFXWIN/CDC::MoveTo
- AFXWIN/CDC::OffsetClipRgn
- AFXWIN/CDC::OffsetViewportOrg
- AFXWIN/CDC::OffsetWindowOrg
- AFXWIN/CDC::PaintRgn
- AFXWIN/CDC::PatBlt
- AFXWIN/CDC::Pie
- AFXWIN/CDC::PlayMetaFile
- AFXWIN/CDC::PlgBlt
- AFXWIN/CDC::PolyBezier
- AFXWIN/CDC::PolyBezierTo
- AFXWIN/CDC::PolyDraw
- AFXWIN/CDC::Polygon
- AFXWIN/CDC::Polyline
- AFXWIN/CDC::PolylineTo
- AFXWIN/CDC::PolyPolygon
- AFXWIN/CDC::PolyPolyline
- AFXWIN/CDC::PtVisible
- AFXWIN/CDC::RealizePalette
- AFXWIN/CDC::Rectangle
- AFXWIN/CDC::RectVisible
- AFXWIN/CDC::ReleaseAttribDC
- AFXWIN/CDC::ReleaseOutputDC
- AFXWIN/CDC::ResetDC
- AFXWIN/CDC::RestoreDC
- AFXWIN/CDC::RoundRect
- AFXWIN/CDC::SaveDC
- AFXWIN/CDC::ScaleViewportExt
- AFXWIN/CDC::ScaleWindowExt
- AFXWIN/CDC::ScrollDC
- AFXWIN/CDC::SelectClipPath
- AFXWIN/CDC::SelectClipRgn
- AFXWIN/CDC::SelectObject
- AFXWIN/CDC::SelectPalette
- AFXWIN/CDC::SelectStockObject
- AFXWIN/CDC::SetAbortProc
- AFXWIN/CDC::SetArcDirection
- AFXWIN/CDC::SetAttribDC
- AFXWIN/CDC::SetBkColor
- AFXWIN/CDC::SetBkMode
- AFXWIN/CDC::SetBoundsRect
- AFXWIN/CDC::SetBrushOrg
- AFXWIN/CDC::SetColorAdjustment
- AFXWIN/CDC::SetDCBrushColor
- AFXWIN/CDC::SetDCPenColor
- AFXWIN/CDC::SetGraphicsMode
- AFXWIN/CDC::SetLayout
- AFXWIN/CDC::SetMapMode
- AFXWIN/CDC::SetMapperFlags
- AFXWIN/CDC::SetMiterLimit
- AFXWIN/CDC::SetOutputDC
- AFXWIN/CDC::SetPixel
- AFXWIN/CDC::SetPixelV
- AFXWIN/CDC::SetPolyFillMode
- AFXWIN/CDC::SetROP2
- AFXWIN/CDC::SetStretchBltMode
- AFXWIN/CDC::SetTextAlign
- AFXWIN/CDC::SetTextCharacterExtra
- AFXWIN/CDC::SetTextColor
- AFXWIN/CDC::SetTextJustification
- AFXWIN/CDC::SetViewportExt
- AFXWIN/CDC::SetViewportOrg
- AFXWIN/CDC::SetWindowExt
- AFXWIN/CDC::SetWindowOrg
- AFXWIN/CDC::SetWorldTransform
- AFXWIN/CDC::StartDoc
- AFXWIN/CDC::StartPage
- AFXWIN/CDC::StretchBlt
- AFXWIN/CDC::StrokeAndFillPath
- AFXWIN/CDC::StrokePath
- AFXWIN/CDC::TabbedTextOut
- AFXWIN/CDC::TextOut
- AFXWIN/CDC::TransparentBlt
- AFXWIN/CDC::UpdateColors
- AFXWIN/CDC::WidenPath
- AFXWIN/CDC::m_hAttribDC
- AFXWIN/CDC::m_hDC
helpviewer_keywords:
- CDC [MFC], CDC
- CDC [MFC], AbortDoc
- CDC [MFC], AbortPath
- CDC [MFC], AddMetaFileComment
- CDC [MFC], AlphaBlend
- CDC [MFC], AngleArc
- CDC [MFC], Arc
- CDC [MFC], ArcTo
- CDC [MFC], Attach
- CDC [MFC], BeginPath
- CDC [MFC], BitBlt
- CDC [MFC], Chord
- CDC [MFC], CloseFigure
- CDC [MFC], CreateCompatibleDC
- CDC [MFC], CreateDC
- CDC [MFC], CreateIC
- CDC [MFC], DeleteDC
- CDC [MFC], DeleteTempMap
- CDC [MFC], Detach
- CDC [MFC], DPtoHIMETRIC
- CDC [MFC], DPtoLP
- CDC [MFC], Draw3dRect
- CDC [MFC], DrawDragRect
- CDC [MFC], DrawEdge
- CDC [MFC], DrawEscape
- CDC [MFC], DrawFocusRect
- CDC [MFC], DrawFrameControl
- CDC [MFC], DrawIcon
- CDC [MFC], DrawState
- CDC [MFC], DrawText
- CDC [MFC], DrawTextEx
- CDC [MFC], Ellipse
- CDC [MFC], EndDoc
- CDC [MFC], EndPage
- CDC [MFC], EndPath
- CDC [MFC], EnumObjects
- CDC [MFC], Escape
- CDC [MFC], ExcludeClipRect
- CDC [MFC], ExcludeUpdateRgn
- CDC [MFC], ExtFloodFill
- CDC [MFC], ExtTextOut
- CDC [MFC], FillPath
- CDC [MFC], FillRect
- CDC [MFC], FillRgn
- CDC [MFC], FillSolidRect
- CDC [MFC], FlattenPath
- CDC [MFC], FloodFill
- CDC [MFC], FrameRect
- CDC [MFC], FrameRgn
- CDC [MFC], FromHandle
- CDC [MFC], GetArcDirection
- CDC [MFC], GetAspectRatioFilter
- CDC [MFC], GetBkColor
- CDC [MFC], GetBkMode
- CDC [MFC], GetBoundsRect
- CDC [MFC], GetBrushOrg
- CDC [MFC], GetCharABCWidths
- CDC [MFC], GetCharABCWidthsI
- CDC [MFC], GetCharacterPlacement
- CDC [MFC], GetCharWidth
- CDC [MFC], GetCharWidthI
- CDC [MFC], GetClipBox
- CDC [MFC], GetColorAdjustment
- CDC [MFC], GetCurrentBitmap
- CDC [MFC], GetCurrentBrush
- CDC [MFC], GetCurrentFont
- CDC [MFC], GetCurrentPalette
- CDC [MFC], GetCurrentPen
- CDC [MFC], GetCurrentPosition
- CDC [MFC], GetDCBrushColor
- CDC [MFC], GetDCPenColor
- CDC [MFC], GetDeviceCaps
- CDC [MFC], GetFontData
- CDC [MFC], GetFontLanguageInfo
- CDC [MFC], GetGlyphOutline
- CDC [MFC], GetGraphicsMode
- CDC [MFC], GetHalftoneBrush
- CDC [MFC], GetKerningPairs
- CDC [MFC], GetLayout
- CDC [MFC], GetMapMode
- CDC [MFC], GetMiterLimit
- CDC [MFC], GetNearestColor
- CDC [MFC], GetOutlineTextMetrics
- CDC [MFC], GetOutputCharWidth
- CDC [MFC], GetOutputTabbedTextExtent
- CDC [MFC], GetOutputTextExtent
- CDC [MFC], GetOutputTextMetrics
- CDC [MFC], GetPath
- CDC [MFC], GetPixel
- CDC [MFC], GetPolyFillMode
- CDC [MFC], GetROP2
- CDC [MFC], GetSafeHdc
- CDC [MFC], GetStretchBltMode
- CDC [MFC], GetTabbedTextExtent
- CDC [MFC], GetTextAlign
- CDC [MFC], GetTextCharacterExtra
- CDC [MFC], GetTextColor
- CDC [MFC], GetTextExtent
- CDC [MFC], GetTextExtentExPointI
- CDC [MFC], GetTextExtentPointI
- CDC [MFC], GetTextFace
- CDC [MFC], GetTextMetrics
- CDC [MFC], GetViewportExt
- CDC [MFC], GetViewportOrg
- CDC [MFC], GetWindow
- CDC [MFC], GetWindowExt
- CDC [MFC], GetWindowOrg
- CDC [MFC], GetWorldTransform
- CDC [MFC], GradientFill
- CDC [MFC], GrayString
- CDC [MFC], HIMETRICtoDP
- CDC [MFC], HIMETRICtoLP
- CDC [MFC], IntersectClipRect
- CDC [MFC], InvertRect
- CDC [MFC], InvertRgn
- CDC [MFC], IsPrinting
- CDC [MFC], LineTo
- CDC [MFC], LPtoDP
- CDC [MFC], LPtoHIMETRIC
- CDC [MFC], MaskBlt
- CDC [MFC], ModifyWorldTransform
- CDC [MFC], MoveTo
- CDC [MFC], OffsetClipRgn
- CDC [MFC], OffsetViewportOrg
- CDC [MFC], OffsetWindowOrg
- CDC [MFC], PaintRgn
- CDC [MFC], PatBlt
- CDC [MFC], Pie
- CDC [MFC], PlayMetaFile
- CDC [MFC], PlgBlt
- CDC [MFC], PolyBezier
- CDC [MFC], PolyBezierTo
- CDC [MFC], PolyDraw
- CDC [MFC], Polygon
- CDC [MFC], Polyline
- CDC [MFC], PolylineTo
- CDC [MFC], PolyPolygon
- CDC [MFC], PolyPolyline
- CDC [MFC], PtVisible
- CDC [MFC], RealizePalette
- CDC [MFC], Rectangle
- CDC [MFC], RectVisible
- CDC [MFC], ReleaseAttribDC
- CDC [MFC], ReleaseOutputDC
- CDC [MFC], ResetDC
- CDC [MFC], RestoreDC
- CDC [MFC], RoundRect
- CDC [MFC], SaveDC
- CDC [MFC], ScaleViewportExt
- CDC [MFC], ScaleWindowExt
- CDC [MFC], ScrollDC
- CDC [MFC], SelectClipPath
- CDC [MFC], SelectClipRgn
- CDC [MFC], SelectObject
- CDC [MFC], SelectPalette
- CDC [MFC], SelectStockObject
- CDC [MFC], SetAbortProc
- CDC [MFC], SetArcDirection
- CDC [MFC], SetAttribDC
- CDC [MFC], SetBkColor
- CDC [MFC], SetBkMode
- CDC [MFC], SetBoundsRect
- CDC [MFC], SetBrushOrg
- CDC [MFC], SetColorAdjustment
- CDC [MFC], SetDCBrushColor
- CDC [MFC], SetDCPenColor
- CDC [MFC], SetGraphicsMode
- CDC [MFC], SetLayout
- CDC [MFC], SetMapMode
- CDC [MFC], SetMapperFlags
- CDC [MFC], SetMiterLimit
- CDC [MFC], SetOutputDC
- CDC [MFC], SetPixel
- CDC [MFC], SetPixelV
- CDC [MFC], SetPolyFillMode
- CDC [MFC], SetROP2
- CDC [MFC], SetStretchBltMode
- CDC [MFC], SetTextAlign
- CDC [MFC], SetTextCharacterExtra
- CDC [MFC], SetTextColor
- CDC [MFC], SetTextJustification
- CDC [MFC], SetViewportExt
- CDC [MFC], SetViewportOrg
- CDC [MFC], SetWindowExt
- CDC [MFC], SetWindowOrg
- CDC [MFC], SetWorldTransform
- CDC [MFC], StartDoc
- CDC [MFC], StartPage
- CDC [MFC], StretchBlt
- CDC [MFC], StrokeAndFillPath
- CDC [MFC], StrokePath
- CDC [MFC], TabbedTextOut
- CDC [MFC], TextOut
- CDC [MFC], TransparentBlt
- CDC [MFC], UpdateColors
- CDC [MFC], WidenPath
- CDC [MFC], m_hAttribDC
- CDC [MFC], m_hDC
ms.assetid: 715b3334-cb2b-4c9c-8067-02eb7c66c8b2
ms.openlocfilehash: 830c6d068a5074d0918107ca601c51d198a8a912
ms.sourcegitcommit: c123cc76bb2b6c5cde6f4c425ece420ac733bf70
ms.translationtype: MT
ms.contentlocale: pl-PL
ms.lasthandoff: 04/14/2020
ms.locfileid: "81375714"
---
# <a name="cdc-class"></a>Klasa CDC

Definiuje klasę obiektów kontekstu urządzenia.

## <a name="syntax"></a>Składnia

```
class CDC : public CObject
```

## <a name="members"></a>Elementy członkowskie

### <a name="public-constructors"></a>Konstruktory publiczne

|Nazwa|Opis|
|----------|-----------------|
|[CDC::CDC](#cdc)|Konstruuje `CDC` obiekt.|

### <a name="public-methods"></a>Metody publiczne

|Nazwa|Opis|
|----------|-----------------|
|[CDC::AbortDoc](#abortdoc)|Kończy bieżące zadanie drukowania, wymazując wszystko, co aplikacja zapisała `StartDoc` do urządzenia od ostatniego wywołania funkcji elementu członkowskiego.|
|[CDC::AbortPath](#abortpath)|Zamyka i odrzuca wszystkie ścieżki w kontekście urządzenia.|
|[CDC::AddMetaFileComment](#addmetafilecomment)|Kopiuje komentarz z bufora do określonego metapliku formatu rozszerzonego.|
|[CDC::AlphaBlend](#alphablend)|Wyświetla mapy bitowe, które mają przezroczyste lub półprzezroczyste piksele.|
|[CDC::AngleArc](#anglearc)|Rysuje segment linii i łuk, a bieżąca pozycja przesuwa się do punktu końcowego łuku.|
|[CDC::Łuk](#arc)|Rysuje łuk eliptyczny.|
|[CDC::ArcTo](#arcto)|Rysuje łuk eliptyczny. Ta funkcja jest `Arc`podobna do , z tą różnicą, że bieżąca pozycja jest aktualizowana.|
|[CDC::Dołącz](#attach)|Dołącza kontekst urządzenia z `CDC` systemem Windows do tego obiektu.|
|[CDC::BeginPath](#beginpath)|Otwiera nawias ścieżki w kontekście urządzenia.|
|[CDC::BitBlt](#bitblt)|Kopiuje mapę bitową z określonego kontekstu urządzenia.|
|[CDC::Akord](#chord)|Rysuje akord (zamknięta postać ograniczona przecięciem elipsy i segmentu linii).|
|[CDC::Zamknijfigurę](#closefigure)|Zamyka otwartą postać w ścieżce.|
|[CDC::TworzeniecompatibleDC](#createcompatibledc)|Tworzy kontekst urządzenia pamięci, który jest zgodny z innym kontekście urządzenia. Można go używać do przygotowywania obrazów w pamięci.|
|[CDC::CreateDC](#createdc)|Tworzy kontekst urządzenia dla określonego urządzenia.|
|[CDC::CreateIC](#createic)|Tworzy kontekst informacji dla określonego urządzenia. Zapewnia to szybki sposób, aby uzyskać informacje o urządzeniu bez tworzenia kontekstu urządzenia.|
|[CDC::DeleteDC](#deletedc)|Usuwa kontekst urządzenia z systemem `CDC` Windows skojarzony z tym obiektem.|
|[CDC::DeleteTempMap](#deletetempmap)|Wywoływany `CWinApp` przez program obsługi czasu bezczynnego, aby usunąć dowolny obiekt tymczasowy `CDC` utworzony przez `FromHandle`program . Odłącza również kontekst urządzenia.|
|[CDC::Detach](#detach)|Odłącza kontekst urządzenia z `CDC` systemem Windows od tego obiektu.|
|[CDC::DPtoHIMETRIC](#dptohimetric)|Konwertuje jednostki urządzenia na jednostki HIMETRIC.|
|[CDC::DPtoLP](#dptolp)|Konwertuje jednostki urządzenia na jednostki logiczne.|
|[CDC::Draw3dRect](#draw3drect)|Rysuje trójwymiarowy prostokąt.|
|[CDC::DrawDragRect](#drawdragrect)|Wymazuje i ponownie rysuje prostokąt podczas przeciągania.|
|[CDC::DrawEdge](#drawedge)|Rysuje krawędzie prostokąta.|
|[CDC::DrawEscape](#drawescape)|Uzyskuje dostęp do możliwości rysowania wyświetlacza wideo, które nie są dostępne bezpośrednio za pośrednictwem interfejsu urządzenia graficznego (GDI).|
|[CDC::DrawFocusRect](#drawfocusrect)|Rysuje prostokąt w stylu używanym do wskazania fokusu.|
|[CDC::DrawFrameControl](#drawframecontrol)|Narysuj formant klatki.|
|[CDC::DrawIcon](#drawicon)|Rysuje ikonę.|
|[CDC::DrawPaństwo](#drawstate)|Wyświetla obraz i stosuje efekt wizualny, aby wskazać stan.|
|[CDC::DrawTekst](#drawtext)|Rysuje sformatowany tekst w określonym prostokącie.|
|[CDC::DrawTextEx](#drawtextex)|Rysuje sformatowany tekst w określonym prostokącie przy użyciu dodatkowych formatów.|
|[CDC::Elipsa](#ellipse)|Rysuje elipsę.|
|[CDC::EndDoc](#enddoc)|Kończy zadanie drukowania `StartDoc` rozpoczęte przez funkcję elementu członkowskiego.|
|[CDC::EndPage](#endpage)|Informuje sterownik urządzenia, że strona się kończy.|
|[CDC::Ścieżka końcowa](#endpath)|Zamyka nawias ścieżki i wybiera ścieżkę zdefiniowaną przez nawias w kontekście urządzenia.|
|[CDC::EnumObjects](#enumobjects)|Wylicza pióra i pędzle dostępne w kontekście urządzenia.|
|[CDC::Ucieczka](#escape)|Umożliwia aplikacjom dostęp do obiektów, które nie są bezpośrednio dostępne z określonego urządzenia za pośrednictwem interfejsu GDI. Umożliwia również dostęp do funkcji ucieczki systemu Windows. Połączenia ucieczki wykonane przez aplikację są tłumaczone i wysyłane do sterownika urządzenia.|
|[CDC::ExcludeClipRect](#excludecliprect)|Tworzy nowy obszar przycinania, który składa się z istniejącego regionu przycinania minus określony prostokąt.|
|[CDC::ExcludeUpdateRgn](#excludeupdatergn)|Zapobiega rysowaniu w nieprawidłowych obszarach okna, wykluczając zaktualizowany region w oknie z regionu przycinania.|
|[CDC::ExtFloodFill](#extfloodfill)|Wypełnia obszar bieżącą szczotką. Zapewnia większą elastyczność niż [CDC::FloodFill](#floodfill) funkcji elementu członkowskiego.|
|[CDC::ExtTextOut](#exttextout)|Zapisuje ciąg znaków w obrębie prostokątnego regionu przy użyciu aktualnie wybranej czcionki.|
|[CDC::FillPath](#fillpath)|Zamyka wszystkie otwarte figury w bieżącej ścieżce i wypełnia wnętrze ścieżki za pomocą bieżącego pędzla i trybu wypełniania wielokątów.|
|[CDC::FillRect](#fillrect)|Wypełnia dany prostokąt za pomocą określonego pędzla.|
|[CDC::FillRgn](#fillrgn)|Wypełnia określony region określonym pędzlem.|
|[CDC::FillSolidRect](#fillsolidrect)|Wypełnia prostokąt jednolitym kolorem.|
|[CDC::Spłaszczyć](#flattenpath)|Przekształca wszystkie krzywe w ścieżce wybranej w bieżącym kontekście urządzenia i zamienia każdą krzywą w sekwencję linii.|
|[CDC::FloodFill](#floodfill)|Wypełnia obszar bieżącą szczotką.|
|[CDC::FrameRect](#framerect)|Rysuje obramowanie wokół prostokąta.|
|[CDC::Framergn](#framergn)|Rysuje obramowanie wokół określonego regionu za pomocą pędzla.|
|[CDC::OdHandle](#fromhandle)|Zwraca wskaźnik do `CDC` obiektu, gdy podane dojście do kontekstu urządzenia. Jeśli `CDC` obiekt nie jest dołączony do uchwytu, tworzony i dołączany jest obiekt tymczasowy. `CDC`|
|[CDC::Kierunek GetArc](#getarcdirection)|Zwraca bieżący kierunek łuku dla kontekstu urządzenia.|
|[CDC::GetAspectRatioFilter](#getaspectratiofilter)|Pobiera ustawienie dla bieżącego filtru proporcji obrazu.|
|[CDC::GetBkColor](#getbkcolor)|Pobiera bieżący kolor tła.|
|[CDC::GetBkMode](#getbkmode)|Pobiera tryb tła.|
|[CDC::GetBoundsRect](#getboundsrect)|Zwraca bieżący skumulowany prostokąt ograniczający dla określonego kontekstu urządzenia.|
|[CDC::GetBrushOrg](#getbrushorg)|Pobiera początek bieżącego pędzla.|
|[CDC::GetCharABCWidths](#getcharabcwidths)|Pobiera szerokości w jednostkach logicznych kolejnych znaków w danym zakresie z bieżącej czcionki.|
|[CDC::GetCharABCWidthsI](#getcharabcwidthsi)|Pobiera szerokości w jednostkach logicznych kolejnych indeksów glifów w określonym zakresie z bieżącej czcionki TrueType.|
|[CDC::GetCharacterPlacement](#getcharacterplacement)|Pobiera różne typy informacji na ciąg znaków.|
|[CDC::GetCharWidth](#getcharwidth)|Pobiera ułamkowe szerokości kolejnych znaków w danym zakresie z bieżącej czcionki.|
|[CDC::GetCharWidthI](#getcharwidthi)|Pobiera szerokości, we współrzędnych logicznych, kolejnych indeksów glifów w określonym zakresie od bieżącej czcionki.|
|[CDC::GetClipBox](#getclipbox)|Pobiera wymiary najściślejszego prostokąta ograniczającego wokół bieżącej granicy przycinania.|
|[CDC::GetColorAdjustment](#getcoloradjustment)|Pobiera wartości dopasowania kolorów dla kontekstu urządzenia.|
|[CDC::GetCurrentBitmap](#getcurrentbitmap)|Zwraca wskaźnik do aktualnie `CBitmap` zaznaczonego obiektu.|
|[CDC::GetCurrentBrush](#getcurrentbrush)|Zwraca wskaźnik do aktualnie `CBrush` zaznaczonego obiektu.|
|[CDC::GetCurrentFont](#getcurrentfont)|Zwraca wskaźnik do aktualnie `CFont` zaznaczonego obiektu.|
|[CDC::GetCurrentPalette](#getcurrentpalette)|Zwraca wskaźnik do aktualnie `CPalette` zaznaczonego obiektu.|
|[CDC::GetCurrentPen](#getcurrentpen)|Zwraca wskaźnik do aktualnie `CPen` zaznaczonego obiektu.|
|[CDC::GetCurrentPosition](#getcurrentposition)|Pobiera bieżącą pozycję pióra (we współrzędnych logicznych).|
|[CDC::GetDCBrushColor](#getdcbrushcolor)|Pobiera bieżący kolor pędzla.|
|[CDC::GetDCPenColor](#getdcpencolor)|Pobiera bieżący kolor pióra.|
|[CDC::GetDeviceCaps](#getdevicecaps)|Pobiera określony rodzaj informacji specyficznych dla urządzenia o możliwościach danego urządzenia wyświetlającego.|
|[CDC::GetFontData](#getfontdata)|Pobiera informacje o metrykach czcionek ze skalowalnego pliku czcionki. Informacje do pobrania jest identyfikowany przez określenie przesunięcia do pliku czcionki i długość informacji do zwrócenia.|
|[CDC::GetFontLanguageInfo](#getfontlanguageinfo)|Zwraca informacje o aktualnie wybranej czcionce dla określonego kontekstu wyświetlania.|
|[CDC::GetglyphOutline](#getglyphoutline)|Pobiera krzywą konspektu lub mapę bitową dla znaku konspektu w bieżącej czcionce.|
|[CDC::GetGraphicsMode](#getgraphicsmode)|Pobiera bieżący tryb grafiki dla określonego kontekstu urządzenia.|
|[CDC::GetHalftoneBrush](#gethalftonebrush)|Pobiera pędzel półtonowy.|
|[CDC::GetKerningPary](#getkerningpairs)|Pobiera pary kerningu znaków dla czcionki, która jest aktualnie wybrana w określonym kontekście urządzenia.|
|[CDC::GetLayout](#getlayout)|Pobiera układ kontekstu urządzenia (DC). Układ może być od lewej do prawej (domyślnie) lub od prawej do lewej (dublowany).|
|[CDC::GetMapMode](#getmapmode)|Pobiera bieżący tryb mapowania.|
|[CDC::GetMiterLimit](#getmiterlimit)|Zwraca limit ścięcie dla kontekstu urządzenia.|
|[CDC::GetNearestColor](#getnearestcolor)|Pobiera najbliższy kolor logiczny do określonego koloru logicznego, który może reprezentować dane urządzenie.|
|[CDC::GetOutlineTextMetrics](#getoutlinetextmetrics)|Pobiera informacje o metrykach czcionek dla czcionek TrueType.|
|[CDC::GetOutputCharWidth](#getoutputcharwidth)|Pobiera szerokości poszczególnych znaków w kolejnej grupie znaków z bieżącej czcionki przy użyciu kontekstu urządzenia wyjściowego.|
|[CDC::GetOutputTabbedTextEkten](#getoutputtabbedtextextent)|Oblicza szerokość i wysokość ciągu znaków w kontekście urządzenia wyjściowego.|
|[CDC::GetOutputTextEkstent](#getoutputtextextent)|Oblicza szerokość i wysokość wiersza tekstu w kontekście urządzenia wyjściowego przy użyciu bieżącej czcionki w celu określenia wymiarów.|
|[CDC::GetOutputTextMetrics](#getoutputtextmetrics)|Pobiera metryki dla bieżącej czcionki z kontekstu urządzenia wyjściowego.|
|[CDC::GetPath](#getpath)|Pobiera współrzędne definiujące punkty końcowe linii i punkty kontrolne krzywych znalezione w ścieżce wybranej w kontekście urządzenia.|
|[CDC::GetPixel](#getpixel)|Pobiera wartość koloru RGB piksela w określonym punkcie.|
|[CDC::GetPolyFillMode](#getpolyfillmode)|Pobiera bieżący tryb wypełniania wielokątów.|
|[CDC::GetROP2](#getrop2)|Pobiera bieżący tryb rysowania.|
|[CDC::GetSafeHdc](#getsafehdc)|Zwraca [CDC::m_hDC](#m_hdc), kontekst urządzenia wyjściowego.|
|[CDC::GetStretchBltMode](#getstretchbltmode)|Pobiera bieżący tryb rozciągania mapy bitowej.|
|[CDC::GetTabbedTextEkten](#gettabbedtextextent)|Oblicza szerokość i wysokość ciągu znaków w kontekście urządzenia atrybutu.|
|[CDC::GetTextAlign](#gettextalign)|Pobiera flagi wyrównania tekstu.|
|[CDC::GetTextCharacterExtra](#gettextcharacterextra)|Pobiera bieżące ustawienie dla ilości odstępów międzyzachakami.|
|[CDC::GetTextColor](#gettextcolor)|Pobiera bieżący kolor tekstu.|
|[CDC::GetTextExtent](#gettextextent)|Oblicza szerokość i wysokość wiersza tekstu w kontekście urządzenia atrybutu przy użyciu bieżącej czcionki w celu określenia wymiarów.|
|[CDC::GetTextExtentExPointI](#gettextextentexpointi)|Pobiera liczbę znaków w określonym ciągu, który zmieści się w określonym miejscu i wypełnia tablicę zakresem tekstu dla każdego z tych znaków.|
|[CDC::GetTextExtentPointI](#gettextextentpointi)|Pobiera szerokość i wysokość określonej tablicy indeksów glifów.|
|[CDC::GetTextFace](#gettextface)|Kopiuje nazwę kroju pisma bieżącej czcionki do buforu jako ciąg zakończony z wartością null.|
|[CDC::GetTextMetrics](#gettextmetrics)|Pobiera metryki dla bieżącej czcionki z kontekstu urządzenia atrybutu.|
|[CDC::GetViewportext](#getviewportext)|Pobiera zakresy x- i y rzutni.|
|[CDC::GetViewportOrg](#getviewportorg)|Pobiera współrzędne x i y początku rzutni.|
|[CDC::GetWindow](#getwindow)|Zwraca okno skojarzone z kontekstem urządzenia wyświetlającego.|
|[CDC::GetWindowExt](#getwindowext)|Pobiera zakresy x- i y skojarzonego okna.|
|[CDC::GetWindowOrg](#getwindoworg)|Pobiera współrzędne x i y pochodzenia skojarzonego okna.|
|[CDC::GetWorldTransform](#getworldtransform)|Pobiera bieżącą przestrzeń świata do transformacji przestrzeni strony.|
|[CDC::GradientFill](#gradientfill)|Wypełnia prostokątne i trójkątne struktury kolorem gradacji.|
|[CDC::GrayString](#graystring)|Rysuje wygaszony (wyszarzony) tekst w danym miejscu.|
|[CDC::HIMETRICtoDP](#himetrictodp)|Konwertuje jednostki HIMETRIC na jednostki urządzenia.|
|[CDC::HIMETRICtoLP](#himetrictolp)|Konwertuje jednostki HIMETRIC na jednostki logiczne.|
|[CDC::IntersectClipRect](#intersectcliprect)|Tworzy nowy obszar przycinania, tworząc przecięcie bieżącego regionu i prostokąta.|
|[CDC::Invertrect](#invertrect)|Odwraca zawartość prostokąta.|
|[CDC::Invertrgn](#invertrgn)|Odwraca kolory w regionie.|
|[CDC::IsPrinting](#isprinting)|Określa, czy kontekst urządzenia jest używany do drukowania.|
|[CDC::LineTo](#lineto)|Rysuje linię od bieżącej pozycji do punktu, ale nie do punktu.|
|[CDC::LPtoDP](#lptodp)|Konwertuje jednostki logiczne na jednostki urządzenia.|
|[CDC::LPtoHIMETRIC](#lptohimetric)|Konwertuje jednostki logiczne na jednostki HIMETRIC.|
|[CDC::MaskBlt](#maskblt)|Łączy dane kolorów dla źródłowych i docelowych map bitowych przy użyciu danej maski i operacji rastrowej.|
|[CDC::ModifyWorldTransform](#modifyworldtransform)|Zmienia transformację świata dla kontekstu urządzenia przy użyciu określonego trybu.|
|[CDC::MoveTo](#moveto)|Przesuwa bieżącą pozycję.|
|[CDC::OffsetCliprgn](#offsetcliprgn)|Przenosi obszar przycinania danego urządzenia.|
|[CDC::OffsetViewportOrg](#offsetviewportorg)|Modyfikuje początek rzutni względem współrzędnych bieżącego początku rzutni.|
|[CDC::OffsetWindowOrg](#offsetwindoworg)|Modyfikuje początek okna względem współrzędnych bieżącego początku okna.|
|[CDC::PaintRgn](#paintrgn)|Wypełnia region wybranym pędzlem.|
|[CDC::PatBlt](#patblt)|Tworzy wzór bitowy.|
|[CDC::Pie](#pie)|Rysuje klin w kształcie koła.|
|[CDC::PlayMetaFile](#playmetafile)|Odtwarza zawartość określonego metapliku na danym urządzeniu. Ulepszona wersja `PlayMetaFile` wyświetla obraz zapisany w danym rozszerzonym formacie metaplik. Metaplik można odtwarzać dowolną liczbę razy.|
|[CDC::PlgBlt](#plgblt)|Wykonuje transfer bloku bitowego bitów bitów danych kolorów z określonego prostokąta w kontekście urządzenia źródłowego do określonego równoległoboku w danym kontekście urządzenia.|
|[CDC::PolyBezier](#polybezier)|Rysuje jeden lub więcej splajnów Bziera. Bieżąca pozycja nie jest używana ani aktualizowana.|
|[CDC::PolyBezierTo](#polybezierto)|Rysuje jeden lub więcej splajnów Bziera i przenosi bieżącą pozycję do punktu końcowego ostatniego splajnu Bziera.|
|[CDC::PolyDraw](#polydraw)|Rysuje zestaw segmentów linii i splajnów Bziera. Ta funkcja aktualizuje bieżącą pozycję.|
|[CDC::Polygon](#polygon)|Rysuje wielokąt składający się z dwóch lub więcej punktów (wierzchołków) połączonych liniami.|
|[CDC::Polilina](#polyline)|Rysuje zestaw segmentów linii łączących określone punkty.|
|[CDC::PolylineTo](#polylineto)|Rysuje jedną lub więcej linii prostych i przenosi bieżącą pozycję do punktu końcowego ostatniej linii.|
|[CDC::PolyPolygon](#polypolygon)|Tworzy dwa lub więcej wielokątów, które są wypełnione przy użyciu bieżącego trybu wypełniania wielokątów. Wielokąty mogą być rozłączne lub mogą się pokrywać.|
|[CDC::Polipolilina](#polypolyline)|Rysuje wiele serii połączonych segmentów linii. Bieżąca pozycja nie jest używana ani aktualizowana przez tę funkcję.|
|[CDC: :Pniewidoczne](#ptvisible)|Określa, czy dany punkt znajduje się w obrębie regionu przycinania.|
|[CDC::RealizePalette](#realizepalette)|Wpisy palety Map w bieżącej palecie logicznej do palety systemowej.|
|[CDC::Prostokąt](#rectangle)|Rysuje prostokąt za pomocą bieżącego pióra i wypełnia go za pomocą bieżącego pędzla.|
|[CDC::RectVisible](#rectvisible)|Określa, czy dowolna część danego prostokąta znajduje się w obrębie regionu przycinania.|
|[CDC::ReleaseAttribDC](#releaseattribdc)|Zwalnia `m_hAttribDC`, kontekst urządzenia atrybutu.|
|[CDC::ReleaseOutputDC](#releaseoutputdc)|Zwalnia `m_hDC`, kontekst urządzenia wyjściowego.|
|[CDC::ResetDC](#resetdc)|Aktualizuje `m_hAttribDC` kontekst urządzenia.|
|[CDC::RestoreDC](#restoredc)|Przywraca kontekst urządzenia do poprzedniego stanu `SaveDC`zapisanego za pomocą pliku .|
|[CDC::Roundrect](#roundrect)|Rysuje prostokąt z zaokrąglonymi narożnikami za pomocą bieżącego pióra i wypełniony bieżącym pędzlem.|
|[CDC::SaveDC](#savedc)|Zapisuje bieżący stan kontekstu urządzenia.|
|[CDC::SkalaViewportext](#scaleviewportext)|Modyfikuje zasięg rzutni względem bieżących wartości.|
|[CDC::ScaleWindowExt](#scalewindowext)|Modyfikuje zakresy okien względem bieżących wartości.|
|[CDC::ScrollDC](#scrolldc)|Przewija prostokąt bitów w poziomie i pionie.|
|[CDC::SelectClipPath](#selectclippath)|Wybiera bieżącą ścieżkę jako region przycinania dla kontekstu urządzenia, łącząc nowy region z dowolnym istniejącym regionem przycinania przy użyciu określonego trybu.|
|[CDC::SelectCliprgn](#selectcliprgn)|Łączy dany region z bieżącym regionem przycinania przy użyciu określonego trybu.|
|[CDC::SelectObject](#selectobject)|Wybiera obiekt rysunkowy GDI, taki jak pióro.|
|[CDC::SelectPalette](#selectpalette)|Wybiera paletę logiczną.|
|[CDC::SelectStockObject](#selectstockobject)|Wybiera jeden ze wstępnie zdefiniowanych piór, pędzli lub czcionek dostarczanych przez system Windows.|
|[CDC::SetAbortProc](#setabortproc)|Ustawia funkcję wywołania zwrotnego dostarczoną przez programistę, którą system Windows wywołuje, jeśli zadanie drukowania musi zostać przerwane.|
|[CDC::Kierunek Ustawiania eksc.](#setarcdirection)|Ustawia kierunek rysowania, który ma być używany dla funkcji łuku i prostokąta.|
|[CDC::SetAttribDC](#setattribdc)|Ustawia `m_hAttribDC`kontekst urządzenia atrybutu.|
|[CDC::SetBkColor](#setbkcolor)|Ustawia bieżący kolor tła.|
|[CDC::SetBkMode](#setbkmode)|Ustawia tryb tła.|
|[CDC::SetBoundsRect](#setboundsrect)|Steruje akumulacją informacji ograniczających prostokąta dla określonego kontekstu urządzenia.|
|[CDC::SetBrushOrg](#setbrushorg)|Określa początek następnego pędzla wybranego w kontekście urządzenia.|
|[CDC::SetColorAdjustment](#setcoloradjustment)|Ustawia wartości dopasowania kolorów dla kontekstu urządzenia przy użyciu określonych wartości.|
|[CDC::SetDCBrushColor](#setdcbrushcolor)|Ustawia bieżący kolor pędzla.|
|[CDC::SetDCPenColor](#setdcpencolor)|Ustawia bieżący kolor pióra.|
|[CDC::SetGraphicsMode](#setgraphicsmode)|Ustawia bieżący tryb grafiki dla określonego kontekstu urządzenia.|
|[CDC::SetLayout](#setlayout)|Zmienia układ kontekstu urządzenia (DC).|
|[CDC::SetMapMode](#setmapmode)|Ustawia bieżący tryb mapowania.|
|[CDC::SetMapperFlags](#setmapperflags)|Zmienia algorytm używany przez mapera czcionek podczas mapowania czcionek logicznych na czcionki fizyczne.|
|[CDC::SetMiterLimit](#setmiterlimit)|Ustawia limit długości sprzężeń ścięcie dla kontekstu urządzenia.|
|[CDC::SetOutputDC](#setoutputdc)|Ustawia `m_hDC`kontekst urządzenia wyjściowego.|
|[CDC::SetPixel](#setpixel)|Ustawia piksel w określonym punkcie na najbliższe przybliżenie określonego koloru.|
|[CDC::SetPixelv](#setpixelv)|Ustawia piksel w określonych współrzędnych na najbliższe przybliżenie określonego koloru. `SetPixelV`jest szybszy niż `SetPixel` dlatego, że nie musi zwracać wartości koloru punktu rzeczywiście malowane.|
|[CDC::SetPolyFillMode](#setpolyfillmode)|Ustawia tryb wypełniania wielokątów.|
|[CDC::SetROP2](#setrop2)|Ustawia bieżący tryb rysowania.|
|[CDC::SetStretchBltMode](#setstretchbltmode)|Ustawia tryb rozciągania mapy bitowej.|
|[CDC::SetTextAlign](#settextalign)|Ustawia flagi wyrównania tekstu.|
|[CDC::SetTextCharacterExtra](#settextcharacterextra)|Ustawia ilość odstępów międzycharakterowych.|
|[CDC::SetTextColor](#settextcolor)|Ustawia kolor tekstu.|
|[CDC::SetTextJustification](#settextjustification)|Dodaje spację do znaków podziału w ciągu.|
|[CDC::SetViewportExt](#setviewportext)|Ustawia zakresy x i y rzutni.|
|[CDC::SetViewportOrg](#setviewportorg)|Ustawia początek rzutni.|
|[CDC::SetWindowExt](#setwindowext)|Ustawia zakresy x- i y skojarzonego okna.|
|[CDC::SetWindowOrg](#setwindoworg)|Ustawia początek okna kontekstu urządzenia.|
|[CDC::SetWorldTransform](#setworldtransform)|Ustawia bieżącą przestrzeń świata na transformację przestrzeni strony.|
|[CDC::StartDoc](#startdoc)|Informuje sterownik urządzenia, że rozpoczyna się nowe zadanie drukowania.|
|[CDC::Strona startowa](#startpage)|Informuje sterownik urządzenia, że rozpoczyna się nowa strona.|
|[CDC::Rozciągnięcie](#stretchblt)|Przenosi mapę bitową z prostokąta źródłowego i urządzenia do prostokąta docelowego, rozciągając lub ściskając mapę bitową, jeśli jest to konieczne, aby dopasować wymiary prostokąta docelowego.|
|[CDC::StrokeAndFillPath](#strokeandfillpath)|Zamyka wszystkie otwarte figury w ścieżce, uderza w kontur ścieżki za pomocą bieżącego pióra i wypełnia jej wnętrze za pomocą bieżącego pędzla.|
|[CDC::StrokePath](#strokepath)|Renderuje określoną ścieżkę przy użyciu bieżącego pióra.|
|[CDC::KartaTextOut](#tabbedtextout)|Zapisuje ciąg znaków w określonej lokalizacji, rozwijając karty do wartości określonych w tablicy pozycji tabulatora.|
|[CDC::TextOut](#textout)|Zapisuje ciąg znaków w określonej lokalizacji przy użyciu aktualnie wybranej czcionki.|
|[CDC::TransparentBlt](#transparentblt)|Przesyła blok bitowy danych kolorów z określonego kontekstu urządzenia źródłowego do kontekstu urządzenia docelowego, czyniąc określony kolor przezroczystym w transferze.|
|[CDC::UpdateColors](#updatecolors)|Aktualizuje obszar klienta kontekstu urządzenia, dopasowując bieżące kolory w obszarze klienta do palety systemowej w zależności od piksela.|
|[CDC::Ścieżka poszerzyć](#widenpath)|Ponownie definiuje bieżącą ścieżkę jako obszar, który zostałby pomalowany, gdyby ścieżka została obrysowana za pomocą pióra aktualnie wybranego w kontekście urządzenia.|

### <a name="public-operators"></a>Operatory publiczne

|Nazwa|Opis|
|----------|-----------------|
|[CDC::operator HDC](#operator_hdc)|Pobiera dojście kontekstu urządzenia.|

### <a name="public-data-members"></a>Publiczne elementy członkowskie danych

|Nazwa|Opis|
|----------|-----------------|
|[CDC::m_hAttribDC](#m_hattribdc)|Kontekst urządzenia atrybutu używany `CDC` przez ten obiekt.|
|[CDC::m_hDC](#m_hdc)|Kontekst urządzenia wyjściowego używany `CDC` przez ten obiekt.|

## <a name="remarks"></a>Uwagi

Obiekt `CDC` udostępnia funkcje członkowskie do pracy z kontekstem urządzenia, takich jak wyświetlacz lub drukarki, a także elementy członkowskie do pracy z kontekstu wyświetlania skojarzone z obszarem klienta okna.

Wykonaj wszystkie rysunki za `CDC` pośrednictwem funkcji członkowskich obiektu. Klasa udostępnia funkcje członkowskie dla operacji kontekstu urządzenia, pracy z narzędziami do rysowania, wyboru obiektu interfejsu urządzenia graficznego (GDI) oraz pracy z kolorami i paletami. Zapewnia również funkcje elementów członkowskich do pobierania i ustawiania atrybutów rysowania, mapowania, pracy z rzutnią, pracy z zasięgiem okna, konwertowania współrzędnych, pracy z regionami, przycinania, rysowania linii i rysowania prostych kształtów, elips i wielokątów. Funkcje członkowskie są również dostępne do rysowania tekstu, pracy z czcionkami, używania funkcji wyjmowania drukarki, przewijania i odtwarzania metaplików.

Aby użyć `CDC` obiektu, skonstruuj go, a następnie wywołaj jego funkcje członkowskie, które równoległe funkcje systemu Windows, które używają kontekstów urządzenia.

> [!NOTE]
> W systemie Windows 95/98 wszystkie współrzędne ekranu są ograniczone do 16 bitów. W związku z tym **int** przekazywane do funkcji elementu `CDC` członkowskiego musi leżeć w zakresie -32768 do 32767.

W przypadku określonych zastosowań biblioteka klas programu Microsoft `CDC` Foundation zawiera kilka klas pochodzących z programu . `CPaintDC`hermetyzuje połączenia `BeginPaint` `EndPaint`do i . `CClientDC`zarządza kontekstem wyświetlania skojarzonym z obszarem klienta okna. `CWindowDC`zarządza kontekstem wyświetlania skojarzonym z całym oknem, w tym jego ramką i formantami. `CMetaFileDC`kojarzy kontekst urządzenia z metaplikem.

`CDC`udostępnia dwie funkcje członkowskie, [GetLayout](#getlayout) i [SetLayout](#setlayout), do odwrócenia układu kontekstu urządzenia, który nie dziedziczy jego układ z okna. Taka orientacja od prawej do lewej jest niezbędna w przypadku aplikacji napisanych dla kultur, takich jak arabski lub hebrajski, gdzie układ znaków nie jest standardem europejskim.

`CDC`zawiera dwa konteksty urządzenia, [m_hDC](#m_hdc) i [m_hAttribDC](#m_hattribdc), które po `CDC` utworzeniu obiektu odnoszą się do tego samego urządzenia. `CDC`kieruje wszystkie wyjściowe wywołania `m_hDC` GDI do i `m_hAttribDC`większość atrybutów wywołań GDI do . (Przykładem wywołania atrybutu `GetTextColor`jest `SetTextColor` , podczas gdy jest wywołaniem wyjściowym.)

Na przykład struktura używa tych kontekstów dwóch `CMetaFileDC` urządzeń do zaimplementowania obiektu, który będzie wysyłać dane wyjściowe do metapliku podczas odczytywania atrybutów z urządzenia fizycznego. Podgląd wydruku jest realizowany w ramach w podobny sposób. Można również użyć dwóch kontekstów urządzenia w podobny sposób w kodzie specyficznym dla aplikacji.

Istnieją chwile, kiedy mogą być potrzebne informacje `m_hDC` metryki tekstu z kontekstów zarówno i `m_hAttribDC` urządzenia. Następujące pary funkcji zapewniają tę możliwość:

|Używa m_hAttribDC|Używa m_hDC|
|-----------------------|-----------------|
|[GetTextExtent (Nieskładka GetTexta](#gettextextent)|[GetOutputTextEkstent](#getoutputtextextent)|
|[GetTabbedTextEkten](#gettabbedtextextent)|[GetOutputTabbedTextEkstent](#getoutputtabbedtextextent)|
|[GetTextMetrics (metryki GetTextMetrics)](#gettextmetrics)|[GetOutputTextMetrics (metryki getoutputtext)](#getoutputtextmetrics)|
|[GetCharWidth ( GetCharWidth )](#getcharwidth)|[GetOutputCharWidth (GetOutputCharWidth)](#getoutputcharwidth)|

Aby uzyskać `CDC`więcej informacji na temat , zobacz [Konteksty urządzeń](../../mfc/device-contexts.md).

## <a name="inheritance-hierarchy"></a>Hierarchia dziedziczenia

[Cobject](../../mfc/reference/cobject-class.md)

`CDC`

## <a name="requirements"></a>Wymagania

**Nagłówek:** afxwin.h

## <a name="cdcabortdoc"></a><a name="abortdoc"></a>CDC::AbortDoc

Kończy bieżące zadanie drukowania i usuwa wszystko, co aplikacja zapisała na urządzeniu od ostatniego wywołania funkcji elementu członkowskiego [StartDoc.](#startdoc)

```
int AbortDoc();
```

### <a name="return-value"></a>Wartość zwracana

Wartość większa lub równa 0, jeśli się powiedzie, lub wartość ujemna, jeśli wystąpił błąd. Na poniższej liście przedstawiono typowe wartości błędów i ich znaczenie:

- SP_ERROR Błąd ogólny.

- SP_OUTOFDISK Obecnie nie ma wystarczającej ilości miejsca na dysku do buforowania i nie będzie więcej miejsca.

- SP_OUTOFMEMORY Za mało pamięci jest dostępna do buforowania.

- SP_USERABORT Użytkownik zakończył zadanie za pośrednictwem Menedżera wydruku.

### <a name="remarks"></a>Uwagi

Ta funkcja elementu członkowskiego zastępuje ucieczkę drukarki ABORTDOC.

`AbortDoc`należy rozwiązać następujące czynności:

- Operacje drukowania, które nie określają funkcji przerwania przy użyciu [SetAbortProc](#setabortproc).

- Operacje drukowania, które nie osiągnęły jeszcze pierwszego wywołania ucieczki NEWFRAME lub NEXTBAND.

Jeśli aplikacja napotka błąd drukowania lub anulowaną operację drukowania, nie może podejmować próby `AbortDoc` zakończenia operacji `CDC`przy użyciu funkcji [EndDoc](#enddoc) lub element członkowski klasy . GDI automatycznie kończy operację przed zwróceniem wartości błędu.

Jeśli aplikacja wyświetla okno dialogowe umożliwiające użytkownikowi anulowanie operacji `AbortDoc` drukowania, musi zadzwonić przed zniszczeniem okna dialogowego.

Jeśli do uruchomienia zadania drukowania użyto Menedżera wydruku, wywołanie `AbortDoc` powoduje wymazanie całego zadania buforu — drukarka nie otrzymuje niczego. Jeśli Menedżer wydruku nie został użyty do uruchomienia zadania drukowania, dane mogły zostać wysłane do drukarki przed `AbortDoc` wywołaniem. W takim przypadku sterownik drukarki zresetowałby drukarkę (jeśli to możliwe) i zamknął zadanie drukowania.

### <a name="example"></a>Przykład

  Zobacz przykład [cdc::StartDoc](#startdoc).

## <a name="cdcabortpath"></a><a name="abortpath"></a>CDC::AbortPath

Zamyka i odrzuca wszystkie ścieżki w kontekście urządzenia.

```
BOOL AbortPath();
```

### <a name="return-value"></a>Wartość zwracana

Różne od zera, jeśli funkcja zakończyła się pomyślnie; w przeciwnym razie 0.

### <a name="remarks"></a>Uwagi

Jeśli w kontekście urządzenia znajduje się otwarty nawias ścieżki, nawias ścieżki jest zamknięty, a ścieżka odrzucana. Jeśli w kontekście urządzenia znajduje się zamknięta ścieżka, ścieżka zostanie odrzucona.

## <a name="cdcaddmetafilecomment"></a><a name="addmetafilecomment"></a>CDC::AddMetaFileComment

Kopiuje komentarz z bufora do określonego metapliku formatu rozszerzonego.

```
BOOL AddMetaFileComment(
    UINT nDataSize,
    const BYTE* pCommentData);
```

### <a name="parameters"></a>Parametry

*nDataSize (Rozmiar danych)*<br/>
Określa długość buforu komentarza w bajtach.

*pCommentDana*<br/>
Wskazuje bufor, który zawiera komentarz.

### <a name="return-value"></a>Wartość zwracana

Różne od zera, jeśli funkcja zakończyła się pomyślnie; w przeciwnym razie 0.

### <a name="remarks"></a>Uwagi

Komentarz może zawierać wszelkie prywatne informacje — na przykład źródło obrazu i datę jego utworzenia. Komentarz powinien zaczynać się od podpisu aplikacji, a następnie danych. Komentarze nie powinny zawierać danych specyficznych dla stanowiska. Dane specyficzne dla pozycji określają lokalizację rekordu i nie powinny być uwzględniane, ponieważ jeden metaplik może być osadzony w innym metapliku. Tej funkcji można używać tylko z ulepszonymi metaplikami.

## <a name="cdcalphablend"></a><a name="alphablend"></a>CDC::AlphaBlend

Wywołanie tej funkcji elementu członkowskiego, aby wyświetlić mapy bitowe, które mają przezroczyste lub półprzezroczyste piksele.

```
BOOL AlphaBlend(
    int xDest,
    int yDest,
    int nDestWidth,
    int nDestHeight,
    CDC* pSrcDC,
    int xSrc,
    int ySrc,
    int nSrcWidth,
    int nSrcHeight,
    BLENDFUNCTION blend);
```

### <a name="parameters"></a>Parametry

*xDest (xDest)*<br/>
Określa współrzędną x w jednostkach logicznych lewego górnego rogu prostokąta docelowego.

*yDest (właśc.*<br/>
Określa współrzędną y w jednostkach logicznych lewego górnego rogu prostokąta docelowego.

*nDestWidth (nDestWidth)*<br/>
Określa szerokość prostokąta docelowego w jednostkach logicznych.

*nDestHeight (nDestHeight)*<br/>
Określa wysokość prostokąta docelowego w jednostkach logicznych.

*pSrcDC*<br/>
Wskaźnik do kontekstu urządzenia źródłowego.

*xSrc (ks.*<br/>
Określa współrzędną x w jednostkach logicznych lewego górnego rogu prostokąta źródłowego.

*ySrc ( ySrc )*<br/>
Określa współrzędną y w jednostkach logicznych lewego górnego rogu prostokąta źródłowego.

*nSrcWidth*<br/>
Określa szerokość prostokąta źródłowego w jednostkach logicznych.

*nSrcHeight (nSrcHeight)*<br/>
Określa wysokość prostokąta źródłowego w jednostkach logicznych.

*Mieszanka*<br/>
Określa strukturę [FUNKCJI MIESZANIA.](/windows/win32/api/wingdi/ns-wingdi-blendfunction)

### <a name="return-value"></a>Wartość zwracana

PRAWDA, jeśli się powiedzie; w przeciwnym razie FALSE.

### <a name="remarks"></a>Uwagi

Aby uzyskać więcej informacji, zobacz [AlphaBlend](/windows/win32/api/wingdi/nf-wingdi-alphablend) w programie Windows SDK.

## <a name="cdcanglearc"></a><a name="anglearc"></a>CDC::AngleArc

Rysuje segment linii i łuk.

```
BOOL AngleArc(
    int x,
    int y,
    int nRadius,
    float fStartAngle,
    float fSweepAngle);
```

### <a name="parameters"></a>Parametry

*X*<br/>
Określa logiczną współrzędną x środka okręgu.

*Y*<br/>
Określa logiczną współrzędną y środka okręgu.

*nRadius (Niem.*<br/>
Określa promień okręgu w jednostkach logicznych. Ta wartość musi być dodatnia.

*fStartAngle (PoczątekAngle)*<br/>
Określa kąt początkowy w stopniach względem osi x.

*fSweepAngle*<br/>
Określa kąt wyciągnięcia po ścieżce w stopniach względem kąta początkowego.

### <a name="return-value"></a>Wartość zwracana

Nonzero jeśli się powiedzie; w przeciwnym razie 0.

### <a name="remarks"></a>Uwagi

Segment linii jest rysowany od bieżącej pozycji do początku łuku. Łuk jest rysowany wzdłuż obwodu okręgu o danym promieniu i środku. Długość łuku jest definiowana przez podane kąty rozpoczęcia i wyciągnięcia po ścieżce.

`AngleArc`przesuwa bieżącą pozycję do punktu końcowego łuku. Łuk rysowany przez tę funkcję może wydawać się eliptyczny, w zależności od bieżącego trybu transformacji i mapowania. Przed narysowaniem łuku funkcja ta rysuje segment linii od bieżącej pozycji do początku łuku. Łuk jest rysowany przez zbudowanie wyimaginowanego okręgu o określonym promieniu wokół określonego punktu środkowego. Punkt początkowy łuku jest określany przez pomiar w kierunku przeciwnym do ruchu wskazówek zegara od osi x okręgu przez liczbę stopni w kącie początkowym. Punkt końcowy znajduje się podobnie, mierząc w kierunku przeciwnym do ruchu wskazówek zegara od punktu początkowego przez liczbę stopni kąta wyciągnięcia po ścieżce.

Jeśli kąt wyciągnięcia po ścieżce jest większy niż 360 stopni, łuk jest przesuwany wiele razy. Ta funkcja rysuje linie za pomocą bieżącego pióra. Rysunek nie jest wypełniony.

## <a name="cdcarc"></a><a name="arc"></a>CDC::Łuk

Rysuje łuk eliptyczny.

```
BOOL Arc(
    int x1,
    int y1,
    int x2,
    int y2,
    int x3,
    int y3,
    int x4,
    int y4);

BOOL Arc(
    LPCRECT lpRect,
    POINT ptStart,
    POINT ptEnd);
```

### <a name="parameters"></a>Parametry

*x1*<br/>
Określa współrzędną x lewego górnego rogu prostokąta ograniczającego (w jednostkach logicznych).

*y1*<br/>
Określa współrzędną y lewego górnego rogu prostokąta ograniczającego (w jednostkach logicznych).

*x2*<br/>
Określa współrzędną x w prawym dolnym rogu prostokąta ograniczającego (w jednostkach logicznych).

*y2*<br/>
Określa współrzędną y w prawym dolnym rogu prostokąta ograniczającego (w jednostkach logicznych).

*x3*<br/>
Określa współrzędną x punktu, który definiuje punkt początkowy łuku (w jednostkach logicznych). Ten punkt nie musi leżeć dokładnie na łuku.

*3.*<br/>
Określa współrzędną y punktu, który definiuje punkt początkowy łuku (w jednostkach logicznych). Ten punkt nie musi leżeć dokładnie na łuku.

*x4*<br/>
Określa współrzędną x punktu definiującego punkt końcowy łuku (w jednostkach logicznych). Ten punkt nie musi leżeć dokładnie na łuku.

*y4*<br/>
Określa współrzędną y punktu definiującego punkt końcowy łuku (w jednostkach logicznych). Ten punkt nie musi leżeć dokładnie na łuku.

*Lprect*<br/>
Określa prostokąt ograniczający (w jednostkach logicznych). Dla tego parametru można przekazać obiekt LPRECT lub [CRect.](../../atl-mfc-shared/reference/crect-class.md)

*ptStart (początek)*<br/>
Określa współrzędne x i y punktu, który definiuje punkt początkowy łuku (w jednostkach logicznych). Ten punkt nie musi leżeć dokładnie na łuku. Dla tego parametru można przekazać strukturę [POINT](/windows/win32/api/windef/ns-windef-point) lub obiekt [CPoint.](../../atl-mfc-shared/reference/cpoint-class.md)

*ptEnd (polski)*<br/>
Określa współrzędne x i y punktu definiujące punkt końcowy łuku (w jednostkach logicznych). Ten punkt nie musi leżeć dokładnie na łuku. Można przekazać strukturę `POINT` lub `CPoint` obiekt dla tego parametru.

### <a name="return-value"></a>Wartość zwracana

Różne od zera, jeśli funkcja zakończyła się pomyślnie; w przeciwnym razie 0.

### <a name="remarks"></a>Uwagi

Łuk rysowany za pomocą funkcji jest segmentem elipsy zdefiniowanym przez określony prostokąt ograniczający.

Rzeczywisty punkt początkowy łuku jest punktem, w którym promień narysowany od środka prostokąta ograniczającego przez określony punkt początkowy przecina elipsę. Rzeczywisty punkt końcowy łuku jest punktem, w którym promień narysowany od środka prostokąta ograniczającego przez określony punkt końcowy przecina elipsę. Łuk jest rysowany w kierunku przeciwnym do ruchu wskazówek zegara. Ponieważ łuk nie jest zamkniętą postacią, nie jest wypełniony. Zarówno szerokość, jak i wysokość prostokąta muszą być większe niż 2 jednostki i mniejsze niż 32 767 jednostek.

### <a name="example"></a>Przykład

[!code-cpp[NVC_MFCDocView#29](../../mfc/codesnippet/cpp/cdc-class_1.cpp)]

## <a name="cdcarcto"></a><a name="arcto"></a>CDC::ArcTo

Rysuje łuk eliptyczny.

```
BOOL ArcTo(
    int x1,
    int y1,
    int x2,
    int y2,
    int x3,
    int y3,
    int x4,
    int y4);

BOOL ArcTo(
    LPCRECT lpRect,
    POINT ptStart,
    POINT ptEnd);
```

### <a name="parameters"></a>Parametry

*x1*<br/>
Określa współrzędną x lewego górnego rogu prostokąta ograniczającego (w jednostkach logicznych).

*y1*<br/>
Określa współrzędną y lewego górnego rogu prostokąta ograniczającego (w jednostkach logicznych).

*x2*<br/>
Określa współrzędną x w prawym dolnym rogu prostokąta ograniczającego (w jednostkach logicznych).

*y2*<br/>
Określa współrzędną y w prawym dolnym rogu prostokąta ograniczającego (w jednostkach logicznych).

*x3*<br/>
Określa współrzędną x punktu, który definiuje punkt początkowy łuku (w jednostkach logicznych). Ten punkt nie musi leżeć dokładnie na łuku.

*3.*<br/>
Określa współrzędną y punktu, który definiuje punkt początkowy łuku (w jednostkach logicznych). Ten punkt nie musi leżeć dokładnie na łuku.

*x4*<br/>
Określa współrzędną x punktu definiującego punkt końcowy łuku (w jednostkach logicznych). Ten punkt nie musi leżeć dokładnie na łuku.

*y4*<br/>
Określa współrzędną y punktu definiującego punkt końcowy łuku (w jednostkach logicznych). Ten punkt nie musi leżeć dokładnie na łuku.

*Lprect*<br/>
Określa prostokąt ograniczający (w jednostkach logicznych). Można przekazać wskaźnik do struktury danych [RECT](/windows/win32/api/windef/ns-windef-rect) lub [CRect](../../atl-mfc-shared/reference/crect-class.md) obiektu dla tego parametru.

*ptStart (początek)*<br/>
Określa współrzędne x i y punktu, który definiuje punkt początkowy łuku (w jednostkach logicznych). Ten punkt nie musi leżeć dokładnie na łuku. Dla tego parametru można przekazać strukturę danych [POINT](/windows/win32/api/windef/ns-windef-point) lub obiekt [CPoint.](../../atl-mfc-shared/reference/cpoint-class.md)

*ptEnd (polski)*<br/>
Określa współrzędne x i y punktu definiujące punkt końcowy łuku (w jednostkach logicznych). Ten punkt nie musi leżeć dokładnie na łuku. Można przekazać strukturę `POINT` danych lub `CPoint` obiekt dla tego parametru.

### <a name="return-value"></a>Wartość zwracana

Różne od zera, jeśli funkcja zakończyła się pomyślnie; w przeciwnym razie 0.

### <a name="remarks"></a>Uwagi

Ta funkcja jest `CDC::Arc`podobna do , z tą różnicą, że bieżąca pozycja jest aktualizowana. Punkty ( *x1*, *y1*) i ( *x2*, y2 ) określają prostokąt *ograniczający.* Elipsa utworzona przez dany prostokąt ograniczający definiuje krzywą łuku. Łuk rozciąga się w kierunku przeciwnym do ruchu wskazówek zegara (domyślny kierunek łuku) od punktu, w którym przecina linię promieniową od środka prostokąta ograniczającego do ( *x3*, *y3*). Łuk kończy się tam, gdzie przecina linię promieniową od środka prostokąta ograniczającego do ( *x4*, *y4*). Jeśli punkt początkowy i końcowy są takie same, rysowana jest kompletna elipsa.

Linia jest rysowana od bieżącej pozycji do punktu początkowego łuku. Jeśli nie wystąpi żaden błąd, bieżąca pozycja jest ustawiona na punkt końcowy łuku. Łuk jest rysowany za pomocą bieżącego pióra; nie jest wypełniona.

## <a name="cdcattach"></a><a name="attach"></a>CDC::Dołącz

Ta funkcja elementu członkowskiego służy do `CDC` dołączania *hDC* do obiektu.

```
BOOL Attach(HDC hDC);
```

### <a name="parameters"></a>Parametry

*Hdc*<br/>
Kontekst urządzenia z systemem Windows.

### <a name="return-value"></a>Wartość zwracana

Różne od zera, jeśli funkcja zakończyła się pomyślnie; w przeciwnym razie 0.

### <a name="remarks"></a>Uwagi

*HDC* jest przechowywany `m_hDC`zarówno w kontekście urządzenia `m_hAttribDC`wyjściowego, jak i w kontekście urządzenia atrybutu.

## <a name="cdcbeginpath"></a><a name="beginpath"></a>CDC::BeginPath

Otwiera nawias ścieżki w kontekście urządzenia.

```
BOOL BeginPath();
```

### <a name="return-value"></a>Wartość zwracana

Różne od zera, jeśli funkcja zakończyła się pomyślnie; w przeciwnym razie 0.

### <a name="remarks"></a>Uwagi

Po otwarciu nawiasu ścieżki aplikacja może rozpocząć wywoływanie funkcji rysowania GDI w celu zdefiniowania punktów, które znajdują się w ścieżce. Aplikacja może zamknąć nawias otwartej `EndPath` ścieżki, wywołując funkcję elementu członkowskiego. Gdy aplikacja `BeginPath`wywołuje, wszystkie poprzednie ścieżki są odrzucane.

Zobacz [BeginPath](/windows/win32/api/wingdi/nf-wingdi-beginpath) w zestawie Windows SDK, aby uzyskać listę funkcji rysowania definiujących punkty w ścieżce.

### <a name="example"></a>Przykład

[!code-cpp[NVC_MFCDocView#30](../../mfc/codesnippet/cpp/cdc-class_2.cpp)]

## <a name="cdcbitblt"></a><a name="bitblt"></a>CDC::BitBlt

Kopiuje mapę bitową z kontekstu urządzenia źródłowego do bieżącego kontekstu urządzenia.

```
BOOL BitBlt(
    int x,
    int y,
    int nWidth,
    int nHeight,
    CDC* pSrcDC,
    int xSrc,
    int ySrc,
    DWORD dwRop);
```

### <a name="parameters"></a>Parametry

*X*<br/>
Określa logiczną współrzędną x lewego górnego rogu prostokąta docelowego.

*Y*<br/>
Określa logiczną współrzędną y lewego górnego rogu prostokąta docelowego.

*nWidth (ww.*<br/>
Określa szerokość (w jednostkach logicznych) prostokąta docelowego i źródłowej mapy bitowej.

*nFeksja*<br/>
Określa wysokość (w jednostkach logicznych) prostokąta docelowego i źródłowej mapy bitowej.

*pSrcDC*<br/>
Wskaźnik do `CDC` obiektu, który identyfikuje kontekst urządzenia, z którego zostanie skopiowana mapa bitowa. Musi być null if *dwRop* określa operację rastrową, która nie zawiera źródła.

*xSrc (ks.*<br/>
Określa logiczną współrzędną x lewego górnego rogu źródłowej mapy bitowej.

*ySrc ( ySrc )*<br/>
Określa logiczną współrzędną y lewego górnego rogu źródłowej mapy bitowej.

*dwRop (dwRop)*<br/>
Określa operację rastrową, która ma być wykonana. Kody operacji rastrowych definiują sposób łączenia kolorów w operacjach wyjściowych, które obejmują bieżący pędzel, możliwą źródłową mapę bitową i docelową mapę bitową. Zobacz [BitBlt](/windows/win32/api/wingdi/nf-wingdi-bitblt) w zestawie Windows SDK, aby uzyskać listę kodów operacji rastrowych dla *dwRop* i ich opisów

Aby uzyskać pełną listę kodów operacji rastrowych, zobacz [Informacje o kodach operacji rastrowych](/windows/win32/gdi/raster-operation-codes) w zestawie Windows SDK.

### <a name="return-value"></a>Wartość zwracana

Różne od zera, jeśli funkcja zakończyła się pomyślnie; w przeciwnym razie 0.

### <a name="remarks"></a>Uwagi

Aplikacja może wyrównać okna lub obszary klienckie na `BitBlt` granicach bajtów, aby upewnić się, że operacje występują na prostokątach wyrównanych do bajtów. (Ustaw flagi CS_BYTEALIGNWINDOW lub CS_BYTEALIGNCLIENT podczas rejestrowania klas okien).

`BitBlt`operacje na prostokątach wyrównanych na bajecie `BitBlt` są znacznie szybsze niż operacje na prostokątach, które nie są wyrównane bajtami. Jeśli chcesz określić style klasy, takie jak wyrównanie bajtów dla własnego kontekstu urządzenia, musisz zarejestrować klasę okna, zamiast polegać na klasach Programu Microsoft Foundation, aby to zrobić za Ciebie. Użyj funkcji globalnej [AfxRegisterWndClass](../../mfc/reference/application-information-and-management.md#afxregisterwndclass).

GDI przekształca *nWidth* i *nHeight*, raz przy użyciu kontekstu urządzenia docelowego i raz przy użyciu kontekstu urządzenia źródłowego. Jeśli wynikowe zakresy nie są zgodne, GDI używa funkcji systemu Windows `StretchBlt` do kompresji lub rozciągania źródłowej mapy bitowej w razie potrzeby.

Jeśli mapy bitowe miejsca docelowego, źródła i desenia `BitBlt` nie mają tego samego formatu kolorów, funkcja konwertuje mapy bitowe źródłowe i wzorca w celu dopasowania do miejsca docelowego. Kolory pierwszego planu i tła docelowej mapy bitowej są używane w konwersji.

Gdy `BitBlt` funkcja konwertuje monochromatyczny bitmapa na kolor, ustawia białe bity (1) na kolor tła i czarne bity (0) na kolor pierwszego planu. Zostaną użyte kolory pierwszego planu i tła kontekstu urządzenia docelowego. Aby przekonwertować kolor `BitBlt` na monochromatyczny, ustawia piksele pasujące do koloru tła na biały i ustawia wszystkie inne piksele na czarne. `BitBlt`używa kolorów pierwszego planu i tła kontekstu urządzenia kolorowego do konwersji z koloru na monochromatyczny.

Należy pamiętać, że nie `BitBlt`wszystkie konteksty urządzenia obsługują . Aby sprawdzić, czy dany `BitBlt`kontekst `GetDeviceCaps` urządzenia obsługuje, użyj funkcji elementu członkowskiego i określ indeks RASTERCAPS.

### <a name="example"></a>Przykład

  Zobacz przykład [cdc::CreateCompatibleDC](#createcompatibledc).

## <a name="cdccdc"></a><a name="cdc"></a>CDC::CDC

Konstruuje `CDC` obiekt.

```
CDC();
```

## <a name="cdcchord"></a><a name="chord"></a>CDC::Akord

Rysuje akord (zamknięta postać ograniczona przecięciem elipsy i segmentu linii).

```
BOOL Chord(
    int x1,
    int y1,
    int x2,
    int y2,
    int x3,
    int y3,
    int x4,
    int y4);

BOOL Chord(
    LPCRECT lpRect,
    POINT ptStart,
    POINT ptEnd);
```

### <a name="parameters"></a>Parametry

*x1*<br/>
Określa współrzędną x lewego górnego rogu prostokąta ograniczającego akord (w jednostkach logicznych).

*y1*<br/>
Określa współrzędną y lewego górnego rogu prostokąta ograniczającego akord (w jednostkach logicznych).

*x2*<br/>
Określa współrzędną x prawego dolnego rogu prostokąta ograniczającego akord (w jednostkach logicznych).

*y2*<br/>
Określa współrzędną y prawego dolnego rogu prostokąta ograniczającego akord (w jednostkach logicznych).

*x3*<br/>
Określa współrzędną x punktu, który definiuje punkt początkowy akordu (w jednostkach logicznych).

*3.*<br/>
Określa współrzędną y punktu, który definiuje punkt początkowy akordu (w jednostkach logicznych).

*x4*<br/>
Określa współrzędną x punktu definiującego punkt końcowy akordu (w jednostkach logicznych).

*y4*<br/>
Określa współrzędną y punktu definiującego punkt końcowy akordu (w jednostkach logicznych).

*Lprect*<br/>
Określa prostokąt ograniczający (w jednostkach logicznych). Dla tego parametru można przekazać obiekt LPRECT lub [CRect.](../../atl-mfc-shared/reference/crect-class.md)

*ptStart (początek)*<br/>
Określa współrzędne x i y punktu, który definiuje punkt początkowy akordu (w jednostkach logicznych). Ten punkt nie musi leżeć dokładnie na akordzie. Można przekazać strukturę `POINT` lub `CPoint` obiekt dla tego parametru.

*ptEnd (polski)*<br/>
Określa współrzędne x i y punktu, który definiuje punkt końcowy akordu (w jednostkach logicznych). Ten punkt nie musi leżeć dokładnie na akordzie. Dla tego parametru można przekazać strukturę [POINT](/windows/win32/api/windef/ns-windef-point) lub obiekt [CPoint.](../../atl-mfc-shared/reference/cpoint-class.md)

### <a name="return-value"></a>Wartość zwracana

Różne od zera, jeśli funkcja zakończyła się pomyślnie; w przeciwnym razie 0.

### <a name="remarks"></a>Uwagi

Parametry ( *x1*, *y1*) i ( *x2*, *y2*) określają odpowiednio lewy górny i prawy dolny r. narożniki prostokąta ograniczającego elipsę, który jest częścią akordu. Parametry ( *x3*, *y3*) i ( *x4*, *y4*) określają punkty końcowe linii przecinające elipsę. Akord jest rysowany za pomocą wybranego pióra i wypełniany za pomocą wybranego pędzla.

Rysunek rysowany `Chord` przez funkcję rozciąga się do, ale nie zawiera prawego i dolnego współrzędnych. Oznacza to, że wysokość *figury wynosi y2* - *y1,* a szerokość figury *x2* - *x1*.

### <a name="example"></a>Przykład

[!code-cpp[NVC_MFCDocView#31](../../mfc/codesnippet/cpp/cdc-class_3.cpp)]

## <a name="cdcclosefigure"></a><a name="closefigure"></a>CDC::Zamknijfigurę

Zamyka otwartą postać w ścieżce.

```
BOOL CloseFigure();
```

### <a name="return-value"></a>Wartość zwracana

Różne od zera, jeśli funkcja zakończyła się pomyślnie; w przeciwnym razie 0.

### <a name="remarks"></a>Uwagi

Funkcja zamyka rysunek, rysując linię od bieżącej pozycji do pierwszego punktu rysunku (zwykle punkt `MoveTo` określony przez ostatnie wywołanie funkcji elementu członkowskiego) i łączy linie za pomocą stylu sprzężenia wiersza. Jeśli rysunek jest zamknięty `LineTo` za pomocą `CloseFigure`funkcji elementu członkowskiego zamiast , zaślepki są używane do tworzenia narożnika zamiast sprzężenia. `CloseFigure`należy wywołać tylko wtedy, gdy w kontekście urządzenia znajduje się otwarty nawias ścieżki.

Rysunek w ścieżce jest otwarty, chyba że jest jawnie zamknięty za pomocą tej funkcji. (Rysunek może być otwarty, nawet jeśli bieżący punkt i punkt początkowy rysunku są takie same). Dowolna linia lub krzywa dodana do ścieżki po `CloseFigure` rozpoczęciu nowej figury.

## <a name="cdccreatecompatibledc"></a><a name="createcompatibledc"></a>CDC::TworzeniecompatibleDC

Tworzy kontekst urządzenia pamięci, który jest zgodny z urządzeniem określonym przez *pDC*.

```
BOOL CreateCompatibleDC(CDC* pDC);
```

### <a name="parameters"></a>Parametry

*Pdc*<br/>
Wskaźnik do kontekstu urządzenia. Jeśli *pDC* ma wartość NULL, funkcja tworzy kontekst urządzenia pamięci, który jest zgodny z wyświetlaczem systemu.

### <a name="return-value"></a>Wartość zwracana

Różne od zera, jeśli funkcja zakończyła się pomyślnie; w przeciwnym razie 0.

### <a name="remarks"></a>Uwagi

Kontekst urządzenia pamięci jest blokiem pamięci reprezentującym powierzchnię wyświetlania. Może służyć do przygotowania obrazów w pamięci przed skopiowaniem ich do rzeczywistej powierzchni urządzenia zgodnego urządzenia.

Po utworzeniu kontekstu urządzenia pamięci GDI automatycznie wybiera monochromatyczne bitmapy akcji 1 na 1. Funkcje wyjściowe GDI mogą być używane z kontekstem urządzenia pamięci tylko wtedy, gdy mapa bitowa została utworzona i wybrana w tym kontekście.

Tej funkcji można używać tylko do tworzenia zgodnych kontekstów urządzeń dla urządzeń obsługujących operacje rastrowe. Zobacz [CDC::BitBlt](#bitblt) funkcji elementu członkowskiego, aby uzyskać informacje dotyczące transferów bloków bitowych między kontekstami urządzenia. Aby ustalić, czy kontekst urządzenia obsługuje operacje rastrowe, zobacz RC_BITBLT możliwości `CDC::GetDeviceCaps`rastrowe w funkcji członkowskiej .

### <a name="example"></a>Przykład

[!code-cpp[NVC_MFCDocView#32](../../mfc/codesnippet/cpp/cdc-class_4.cpp)]

## <a name="cdccreatedc"></a><a name="createdc"></a>CDC::CreateDC

Tworzy kontekst urządzenia dla określonego urządzenia.

```
BOOL CreateDC(
    LPCTSTR lpszDriverName,
    LPCTSTR lpszDeviceName,
    LPCTSTR lpszOutput,
    const void* lpInitData);
```

### <a name="parameters"></a>Parametry

*lpszDriverName*<br/>
Wskazuje ciąg zakończony zerem, który określa nazwę pliku (bez rozszerzenia) sterownika urządzenia (na przykład "EPSON"). Można również przekazać `CString` obiekt dla tego parametru.

*lpszDeviceName*<br/>
Wskazuje ciąg zakończony zerem, który określa nazwę określonego urządzenia, które ma być obsługiwane (na przykład "EPSON FX-80"). Parametr *lpszDeviceName* jest używany, jeśli moduł obsługuje więcej niż jedno urządzenie. Można również przekazać `CString` obiekt dla tego parametru.

*lpszOutput*<br/>
Wskazuje ciąg zakończony zerem, który określa nazwę pliku lub urządzenia dla fizycznego nośnika wyjściowego (portu pliku lub wyjścia). Można również przekazać `CString` obiekt dla tego parametru.

*lpInitData*<br/>
Wskazuje strukturę zawierającą `DEVMODE` dane inicjowania specyficzne dla urządzenia dla sterownika urządzenia. Funkcja `DocumentProperties` systemu Windows pobiera tę strukturę wypełnioną dla danego urządzenia. Parametr *lpInitData* musi mieć wartość NULL, jeśli sterownik urządzenia ma używać domyślnej inicjalizacji (jeśli istnieje) określonej przez użytkownika za pośrednictwem Panelu sterowania.

### <a name="return-value"></a>Wartość zwracana

Różne od zera, jeśli funkcja zakończyła się pomyślnie; w przeciwnym razie 0.

### <a name="remarks"></a>Uwagi

WYDRUK. Plik nagłówka H jest wymagany, jeśli używana jest struktura [DEVMODE.](/windows/win32/api/wingdi/ns-wingdi-devmodea)

Nazwy urządzeń są zgodne z tymi konwencjami: końcowy dwukropek (:) zalecane, ale opcjonalne. System Windows rozbiera dwukropek kończący tak, aby nazwa urządzenia kończąca się na dwukropek jest mapowana na ten sam port, co ta sama nazwa bez dwukropka. Nazwy sterowników i portów nie mogą zawierać spacji wiodących ani końcowych. Funkcji wyjściowych GDI nie można używać z kontekstami informacyjnymi.

## <a name="cdccreateic"></a><a name="createic"></a>CDC::CreateIC

Tworzy kontekst informacji dla określonego urządzenia.

```
BOOL CreateIC(
    LPCTSTR lpszDriverName,
    LPCTSTR lpszDeviceName,
    LPCTSTR lpszOutput,
    const void* lpInitData);
```

### <a name="parameters"></a>Parametry

*lpszDriverName*<br/>
Wskazuje ciąg zakończony zerem, który określa nazwę pliku (bez rozszerzenia) sterownika urządzenia (na przykład "EPSON"). Obiekt można `CString` przekazać dla tego parametru.

*lpszDeviceName*<br/>
Wskazuje ciąg zakończony zerem, który określa nazwę określonego urządzenia, które ma być obsługiwane (na przykład "EPSON FX-80"). Parametr *lpszDeviceName* jest używany, jeśli moduł obsługuje więcej niż jedno urządzenie. Obiekt można `CString` przekazać dla tego parametru.

*lpszOutput*<br/>
Wskazuje ciąg zakończony zerem, który określa nazwę pliku lub urządzenia dla fizycznego nośnika wyjściowego (pliku lub portu). Obiekt można `CString` przekazać dla tego parametru.

*lpInitData*<br/>
Wskazuje dane inicjowania specyficzne dla urządzenia dla sterownika urządzenia. Parametr *lpInitData* musi mieć wartość NULL, jeśli sterownik urządzenia ma używać domyślnej inicjalizacji (jeśli istnieje) określonej przez użytkownika za pośrednictwem Panelu sterowania. Zobacz `CreateDC` format danych dla inicjowania specyficznego dla urządzenia.

### <a name="return-value"></a>Wartość zwracana

Nonzero jeśli się powiedzie; w przeciwnym razie 0.

### <a name="remarks"></a>Uwagi

Kontekst informacji zapewnia szybki sposób, aby uzyskać informacje o urządzeniu bez tworzenia kontekstu urządzenia.

Nazwy urządzeń są zgodne z tymi konwencjami: końcowy dwukropek (:) zalecane, ale opcjonalne. System Windows rozbiera dwukropek kończący tak, aby nazwa urządzenia kończąca się na dwukropek jest mapowana na ten sam port, co ta sama nazwa bez dwukropka. Nazwy sterowników i portów nie mogą zawierać spacji wiodących ani końcowych. Funkcji wyjściowych GDI nie można używać z kontekstami informacyjnymi.

## <a name="cdcdeletedc"></a><a name="deletedc"></a>CDC::DeleteDC

Ogólnie rzecz biorąc, nie należy wywoływać tej funkcji; destruktor zrobi to za Ciebie.

```
BOOL DeleteDC();
```

### <a name="return-value"></a>Wartość zwracana

Nonzero, jeśli funkcja została ukończona pomyślnie; w przeciwnym razie 0.

### <a name="remarks"></a>Uwagi

Funkcja `DeleteDC` elementu członkowskiego usuwa konteksty urządzenia z `m_hDC` systemem Windows, które są skojarzone z bieżącym `CDC` obiektem. Jeśli `CDC` ten obiekt jest ostatnim aktywnym kontekstem urządzenia dla danego urządzenia, urządzenie jest powiadamiane i wszystkie zasoby pamięci masowej i systemowe używane przez urządzenie są zwalniane.

Aplikacja nie powinna `DeleteDC` wywoływać, jeśli obiekty zostały wybrane w kontekście urządzenia. Obiekty muszą najpierw zostać wybrane z kontekstu urządzenia przed ich usunięciem.

Aplikacja nie może usuwać kontekstu urządzenia, którego dojście zostało uzyskane przez wywołanie [CWnd::GetDC](../../mfc/reference/cwnd-class.md#getdc). Zamiast tego musi wywołać [CWnd::ReleaseDC,](../../mfc/reference/cwnd-class.md#releasedc) aby zwolnić kontekst urządzenia. [Klasy CClientDC](../../mfc/reference/cclientdc-class.md) i [CWindowDC](../../mfc/reference/cwindowdc-class.md) są dostarczane do zawijania tej funkcji.

Funkcja `DeleteDC` jest zwykle używana do usuwania kontekstów urządzeń utworzonych za pomocą [CreateDC](#createdc), [CreateIC](#createic)lub [CreateCompatibleDC](#createcompatibledc).

### <a name="example"></a>Przykład

  Zobacz przykład [CPrintDialog::GetPrinterDC](../../mfc/reference/cprintdialog-class.md#getprinterdc).

## <a name="cdcdeletetempmap"></a><a name="deletetempmap"></a>CDC::DeleteTempMap

Wywoływane automatycznie `CWinApp` przez program obsługi czasu `DeleteTempMap` bezczynności, `CDC` usuwa `FromHandle`wszystkie obiekty tymczasowe utworzone przez program `hDC`, ale nie niszczy `CDC` uchwytów kontekstu urządzenia (s) tymczasowo skojarzonych z obiektami.

```
static void PASCAL DeleteTempMap();
```

## <a name="cdcdetach"></a><a name="detach"></a>CDC::Detach

Wywołanie tej funkcji, aby `m_hDC` odłączyć `CDC` (kontekst `m_hDC` urządzenia `m_hAttribDC` wyjściowego) od obiektu i ustawić zarówno i null.

```
HDC Detach();
```

### <a name="return-value"></a>Wartość zwracana

Kontekst urządzenia z systemem Windows.

## <a name="cdcdptohimetric"></a><a name="dptohimetric"></a>CDC::DPtoHIMETRIC

Tej funkcji należy użyć, gdy rozmiary HIMETRIC są naliczane na OLE, konwertując piksele na HIMETRIC.

```
void DPtoHIMETRIC(LPSIZE lpSize) const;
```

### <a name="parameters"></a>Parametry

*lpSize (rozmiar)*<br/>
Wskazuje strukturę [SIZE](/windows/win32/api/windef/ns-windef-size) lub [obiekt CSize.](../../atl-mfc-shared/reference/csize-class.md)

### <a name="remarks"></a>Uwagi

Jeśli tryb mapowania obiektu kontekstu urządzenia jest MM_LOENGLISH, MM_HIENGLISH, MM_LOMETRIC lub MM_HIMETRIC, konwersja jest oparta na liczbie pikseli w fizycznym calu. Jeśli tryb mapowania jest jednym z innych trybów nieograniczonych (np. MM_TEXT), konwersja jest oparta na liczbie pikseli w calu logicznym.

## <a name="cdcdptolp"></a><a name="dptolp"></a>CDC::DPtoLP

Konwertuje jednostki urządzenia na jednostki logiczne.

```
void DPtoLP(
    LPPOINT lpPoints,
    int nCount = 1) const;

void DPtoLP(LPRECT lpRect) const;
void DPtoLP(LPSIZE lpSize) const;
```

### <a name="parameters"></a>Parametry

*lpPunkty*<br/>
Wskazuje tablicę struktur [POINT](/windows/win32/api/windef/ns-windef-point) lub [CPoint.](../../atl-mfc-shared/reference/cpoint-class.md)

*Ncount*<br/>
Liczba punktów w tablicy.

*Lprect*<br/>
Wskazuje strukturę [RECT](/windows/win32/api/windef/ns-windef-rect) lub [obiekt CRect.](../../atl-mfc-shared/reference/crect-class.md) Ten parametr jest używany w przypadku prostego przekonwertowania jednego prostokąta z punktów urządzenia na punkty logiczne.

*lpSize (rozmiar)*<br/>
Wskazuje strukturę [SIZE](/windows/win32/api/windef/ns-windef-size) lub [obiekt CSize.](../../atl-mfc-shared/reference/csize-class.md)

### <a name="remarks"></a>Uwagi

Funkcja mapuje współrzędne każdego punktu lub wymiar rozmiaru z układu współrzędnych urządzenia do logicznego układu współrzędnych GDI. Konwersja zależy od bieżącego trybu mapowania oraz ustawień początku i zakresu okna i rzutni urządzenia.

## <a name="cdcdraw3drect"></a><a name="draw3drect"></a>CDC::Draw3dRect

Wywołanie tej funkcji elementu członkowskiego, aby narysować trójwymiarowy prostokąt.

```
void Draw3dRect(
    LPCRECT lpRect,
    COLORREF clrTopLeft,
    COLORREF clrBottomRight);

void Draw3dRect(
    int x,
    int y,
    int cx,
    int cy,
    COLORREF clrTopLeft,
    COLORREF clrBottomRight);
```

### <a name="parameters"></a>Parametry

*Lprect*<br/>
Określa prostokąt ograniczający (w jednostkach logicznych). Można przekazać wskaźnik do struktury [RECT](/windows/win32/api/windef/ns-windef-rect) lub [CRect](../../atl-mfc-shared/reference/crect-class.md) obiektu dla tego parametru.

*clrTopNawieruł*<br/>
Określa kolor górnej i lewej strony trójwymiarowego prostokąta.

*clrBottomRight (Prawy prawy)*<br/>
Określa kolor dolnej i prawej strony trójwymiarowego prostokąta.

*X*<br/>
Określa logiczną współrzędną x lewego górnego rogu trójwymiarowego prostokąta.

*Y*<br/>
Określa logiczną współrzędną y lewego górnego rogu trójwymiarowego prostokąta.

*Cx*<br/>
Określa szerokość prostokąta trójwymiarowego.

*Cy*<br/>
Określa wysokość trójwymiarowego prostokąta.

### <a name="remarks"></a>Uwagi

Prostokąt zostanie narysowany z górnej i lewej strony w kolorze określonym przez *clrTopLeft* i dolnej i prawej stronie w kolorze określonym przez *clrBottomRight*.

### <a name="example"></a>Przykład

[!code-cpp[NVC_MFCDocView#33](../../mfc/codesnippet/cpp/cdc-class_5.cpp)]

## <a name="cdcdrawdragrect"></a><a name="drawdragrect"></a>CDC::DrawDragRect

Wywołanie tej funkcji elementu członkowskiego wielokrotnie, aby ponownie rysować prostokąt przeciągania.

```
void DrawDragRect(
    LPCRECT lpRect,
    SIZE size,
    LPCRECT lpRectLast,
    SIZE sizeLast,
    CBrush* pBrush = NULL,
    CBrush* pBrushLast = NULL);
```

### <a name="parameters"></a>Parametry

*Lprect*<br/>
Wskazuje na strukturę [RECT](/windows/win32/api/windef/ns-windef-rect) lub obiekt [CRect,](../../atl-mfc-shared/reference/crect-class.md) który określa współrzędne logiczne prostokąta — w tym przypadku położenie końcowe prostokąta jest ponownie rysowane.

*Rozmiar*<br/>
Określa przemieszczenie prostokąta z lewego górnego rogu zewnętrznej krawędzi do lewego górnego rogu wewnętrznej krawędzi (czyli grubości obramowania).

*lpRectLast*<br/>
Wskazuje na strukturę [RECT](/windows/win32/api/windef/ns-windef-rect) lub obiekt [CRect,](../../atl-mfc-shared/reference/crect-class.md) który określa współrzędne logiczne położenia prostokąta — w tym przypadku oryginalne położenie prostokąta jest ponownie rysowane.

*rozmiarLast*<br/>
Określa przemieszczenie od lewego górnego rogu zewnętrznej krawędzi do lewego górnego rogu wewnętrznej krawędzi (czyli grubości obramowania) oryginalnego prostokąta, który jest ponownie rysowany.

*pBrush (pędzel)*<br/>
Wskaźnik do obiektu pędzla. Ustaw wartość NULL, aby użyć domyślnego pędzla półtonowego.

*pBrushLast*<br/>
Wskaźnik do ostatniego używanego obiektu pędzla. Ustaw wartość NULL, aby użyć domyślnego pędzla półtonowego.

### <a name="remarks"></a>Uwagi

Nazwij to w pętli podczas próbkowania pozycji myszy, aby przekazać wizualną informację zwrotną. Podczas wywoływania `DrawDragRect`poprzedni prostokąt zostanie wymazany i zostanie narysowany nowy. Na przykład, gdy użytkownik przeciągnie prostokąt po `DrawDragRect` ekranie, usunie oryginalny prostokąt i przerysuje nowy w nowej pozycji. Domyślnie `DrawDragRect` rysuje prostokąt za pomocą pędzla półtonowego, aby wyeliminować migotanie i stworzyć wygląd płynnie poruszającego się prostokąta.

Przy pierwszym wywołaniu `DrawDragRect`parametru *lpRectLast* powinien być null.

## <a name="cdcdrawedge"></a><a name="drawedge"></a>CDC::DrawEdge

Wywołanie tej funkcji elementu członkowskiego, aby narysować krawędzie prostokąta określonego typu i stylu.

```
BOOL DrawEdge(
    LPRECT lpRect,
    UINT nEdge,
    UINT nFlags);
```

### <a name="parameters"></a>Parametry

*Lprect*<br/>
Wskaźnik do `RECT` struktury zawierającej współrzędne logiczne prostokąta.

*nEdge (wydmyć)*<br/>
Określa typ krawędzi wewnętrznej i zewnętrznej do narysowania. Ten parametr musi być kombinacją jednej flagi obramowania wewnętrznego i jednej flagi obramowania zewnętrznego. Zobacz [DrawEdge](/windows/win32/api/winuser/nf-winuser-drawedge) w windows SDK dla tabeli typów parametrów.

*nPłgi*<br/>
Flagi określające typ obramowania do narysowania. Zobacz `DrawEdge` w windows SDK dla tabeli wartości parametru. W przypadku linii ukośnych flagi BF_RECT określają punkt końcowy wektora ograniczony parametrem prostokąta.

### <a name="return-value"></a>Wartość zwracana

Nonzero jeśli się powiedzie; w przeciwnym razie 0.

## <a name="cdcdrawescape"></a><a name="drawescape"></a>CDC::DrawEscape

Uzyskuje dostęp do możliwości rysowania wyświetlacza wideo, które nie są dostępne bezpośrednio za pośrednictwem interfejsu urządzenia graficznego (GDI).

```
int DrawEscape(
    int nEscape,
    int nInputSize,
    LPCSTR lpszInputData);
```

### <a name="parameters"></a>Parametry

*pejzaż pszczeli*<br/>
Określa funkcję ucieczki, która ma być wykonywana.

*nInputSize (Rozmiar)*<br/>
Określa liczbę bajtów danych wskazywali parametr *lpszInputData.*

*lpszInputData*<br/>
Wskazuje strukturę wejściową wymaganą dla określonej ucieczki.

### <a name="return-value"></a>Wartość zwracana

Określa wynik funkcji. Większa niż zero, jeśli zakończy się pomyślnie, z wyjątkiem queryescsupport rysować escape, który sprawdza tylko implementacji; lub zero, jeśli ucieczka nie jest zaimplementowana; lub mniej niż zero, jeśli wystąpił błąd.

### <a name="remarks"></a>Uwagi

Gdy aplikacja `DrawEscape`wywołuje , dane zidentyfikowane przez *nInputSize* i *lpszInputData* są przekazywane bezpośrednio do określonego sterownika ekranu.

## <a name="cdcdrawfocusrect"></a><a name="drawfocusrect"></a>CDC::DrawFocusRect

Rysuje prostokąt w stylu używanym do wskazania, że prostokąt ma fokus.

```
void DrawFocusRect(LPCRECT lpRect);
```

### <a name="parameters"></a>Parametry

*Lprect*<br/>
Wskazuje na strukturę [RECT](/windows/win32/api/windef/ns-windef-rect) lub obiekt [CRect,](../../atl-mfc-shared/reference/crect-class.md) który określa współrzędne logiczne prostokąta, który ma zostać narysowany.

### <a name="remarks"></a>Uwagi

Ponieważ jest to funkcja logicznego XOR, wywołanie tej funkcji po raz drugi za pomocą tego samego prostokąta usuwa prostokąt z wyświetlacza. Prostokąta rysowane przez tę funkcję nie można przewinąć. Aby przewinąć obszar zawierający prostokąt narysowany przez `DrawFocusRect` tę funkcję, najpierw wywołaj, aby usunąć prostokąt `DrawFocusRect` z wyświetlacza, a następnie przewiń obszar, a następnie zadzwoń ponownie, aby narysować prostokąt w nowej pozycji.

> [!CAUTION]
> `DrawFocusRect`działa tylko w trybie MM_TEXT. W innych trybach ta funkcja nie rysuje prostokąt fokus poprawnie, ale nie zwraca wartości błędów.

## <a name="cdcdrawframecontrol"></a><a name="drawframecontrol"></a>CDC::DrawFrameControl

Wywołanie tej funkcji elementu członkowskiego, aby narysować formant ramki określonego typu i stylu.

```
BOOL DrawFrameControl(
    LPRECT lpRect,
    UINT nType,
    UINT nState);
```

### <a name="parameters"></a>Parametry

*Lprect*<br/>
Wskaźnik do `RECT` struktury zawierającej współrzędne logiczne prostokąta.

*nTyp*<br/>
Określa typ formantu klatki do rysowania. Zobacz *parametr uType* w [DrawFrameControl](/windows/win32/api/winuser/nf-winuser-drawframecontrol) w zestawie Windows SDK, aby uzyskać listę możliwych wartości tego parametru.

*nPaństwo*<br/>
Określa początkowy stan formantu ramki. Może być jedną lub więcej wartości opisanych dla `DrawFrameControl` parametru *uState* w windows SDK. Użyj *wartości nState* DFCS_ADJUSTRECT, aby dostosować prostokąt ograniczający, aby wykluczyć otaczającą krawędź przycisku.

### <a name="return-value"></a>Wartość zwracana

Nonzero jeśli się powiedzie; w przeciwnym razie 0.

### <a name="remarks"></a>Uwagi

W kilku przypadkach *nState* zależy od *parametru nType.* Na poniższej liście przedstawiono relację między czterema wartościami *nType* a *nState*:

- DFC_BUTTON

  - DFCS_BUTTON3STATE przycisk trójstanowy

  - pole wyboru DFCS_BUTTONCHECK

  - przycisk DFCS_BUTTONPUSH

  - Przycisk DFCS_BUTTONRADIO Radia

  - DFCS_BUTTONRADIOIMAGE Obraz dla przycisku radiowego (nonsquare potrzebuje obrazu)

  - maska DFCS_BUTTONRADIOMASK do przycisku radiowego (nonsquare potrzebuje maski)

- DFC_CAPTION

  - DFCS_CAPTIONCLOSE przycisk Zamknij

  - Przycisk Pomoc DFCS_CAPTIONHELP

  - przycisk DFCS_CAPTIONMAX Maksymalizuj

  - przycisk DFCS_CAPTIONMIN Minimalizuj

  - Przycisk przywracanie DFCS_CAPTIONRESTORE

- DFC_MENU

  - strzałka DFCS_MENUARROW Podmenu

  - DFCS_MENUBULLET Pocisk

  - DFCS_MENUCHECK Znacznik wyboru

- DFC_SCROLL

  - pasek przewijania pola DFCS_SCROLLCOMBOBOX Combo

  - DFCS_SCROLLDOWN strzałka w dół paska przewijania

  - DFCS_SCROLLLEFT strzałka w lewo paska przewijania

  - DFCS_SCROLLRIGHT strzałka w prawo paska przewijania

  - DFCS_SCROLLSIZEGRIP Uchwyt rozmiar w prawym dolnym rogu okna

  - DFCS_SCROLLUP strzałka w górę paska przewijania

### <a name="example"></a>Przykład

Ten kod rysuje uchwyt wielkości w prawym dolnym rogu okna. Jest odpowiedni dla `OnPaint` obsługi okna dialogowego, które nie ma stylów i zwykle nie zawiera innych formantów (takich jak pasek stanu), które mogą nadać mu chwytak rozmiaru.

[!code-cpp[NVC_MFCDocView#34](../../mfc/codesnippet/cpp/cdc-class_6.cpp)]

## <a name="cdcdrawicon"></a><a name="drawicon"></a>CDC::DrawIcon

Rysuje ikonę na urządzeniu reprezentowanym przez bieżący `CDC` obiekt.

```
BOOL DrawIcon(
    int x,
    int y,
    HICON hIcon);

BOOL DrawIcon(
    POINT point,
    HICON hIcon);
```

### <a name="parameters"></a>Parametry

*X*<br/>
Określa logiczną współrzędną x lewego górnego rogu ikony.

*Y*<br/>
Określa logiczną współrzędną y lewego górnego rogu ikony.

*hIcon (własówce)*<br/>
Identyfikuje uchwyt ikony, która ma zostać narysowana.

*Punkt*<br/>
Określa logiczne współrzędne x i y w lewym górnym rogu ikony. Dla tego parametru można przekazać strukturę [POINT](/windows/win32/api/windef/ns-windef-point) lub obiekt [CPoint.](../../atl-mfc-shared/reference/cpoint-class.md)

### <a name="return-value"></a>Wartość zwracana

Nonzero, jeśli funkcja została ukończona pomyślnie; w przeciwnym razie 0.

### <a name="remarks"></a>Uwagi

Funkcja umieszcza lewy górny róg ikony w miejscu określonym przez *x* i *y*. Lokalizacja podlega bieżącemu trybowi mapowania kontekstu urządzenia.

Zasób ikony musi być wcześniej `CWinApp::LoadIcon`załadowany przy użyciu funkcji , `CWinApp::LoadStandardIcon`lub `CWinApp::LoadOEMIcon`. Tryb `MM_TEXT` mapowania musi być wybrany przed użyciem tej funkcji.

### <a name="example"></a>Przykład

  Zobacz przykład [CWnd::IsIconic](../../mfc/reference/cwnd-class.md#isiconic).

## <a name="cdcdrawstate"></a><a name="drawstate"></a>CDC::DrawPaństwo

Wywołanie tej funkcji elementu członkowskiego, aby wyświetlić obraz i zastosować efekt wizualny, aby wskazać stan, taki jak stan wyłączony lub domyślny.

> [!NOTE]
> Dla wszystkich stanów *nFlag* z wyjątkiem DSS_NORMAL obraz jest konwertowany na monochromatyczny przed zastosowaniem efektu wizualnego.

```
BOOL DrawState(
    CPoint pt,
    CSize size,
    HBITMAP hBitmap,
    UINT nFlags,
    HBRUSH hBrush = NULL);

BOOL DrawState(
    CPoint pt,
    CSize size,
    CBitmap* pBitmap,
    UINT nFlags,
    CBrush* pBrush = NULL);

BOOL DrawState(
    CPoint pt,
    CSize size,
    HICON hIcon,
    UINT nFlags,
    HBRUSH hBrush = NULL);

BOOL DrawState(
    CPoint pt,
    CSize size,
    HICON hIcon,
    UINT nFlags,
    CBrush* pBrush = NULL);

BOOL DrawState(
    CPoint pt,
    CSize size,
    LPCTSTR lpszText,
    UINT nFlags,
    BOOL bPrefixText = TRUE,
    int nTextLen = 0,
    HBRUSH hBrush = NULL);

BOOL DrawState(
    CPoint pt,
    CSize size,
    LPCTSTR lpszText,
    UINT nFlags,
    BOOL bPrefixText = TRUE,
    int nTextLen = 0,
    CBrush* pBrush = NULL);

BOOL DrawState(
    CPoint pt,
    CSize size,
    DRAWSTATEPROC lpDrawProc,
    LPARAM lData,
    UINT nFlags,
    HBRUSH hBrush = NULL);

BOOL DrawState(
    CPoint pt,
    CSize size,
    DRAWSTATEPROC lpDrawProc,
    LPARAM lData,
    UINT nFlags,
    CBrush* pBrush = NULL);
```

### <a name="parameters"></a>Parametry

*Pt*<br/>
Określa lokalizację obrazu.

*Rozmiar*<br/>
Określa rozmiar obrazu.

*hBitmapa*<br/>
Dojście do mapy bitowej.

*nPłgi*<br/>
Flagi określające typ i stan obrazu. Zobacz [DrawState](/windows/win32/api/winuser/nf-winuser-drawstatew) w windows SDK dla możliwych *nFlags* typów i stanów.

*hBrush (pędzel)*<br/>
Uchwyt do pędzla.

*pBitmapa*<br/>
Wskaźnik do obiektu CBitmap.

*pBrush (pędzel)*<br/>
Wskaźnik do obiektu CBrush.

*hIcon (własówce)*<br/>
Dojście do ikony.

*lpszText (tekst)*<br/>
Wskaźnik do tekstu.

*bPrefixText*<br/>
Tekst, który może zawierać akcelerator mnemonic. Parametr *lData* określa adres ciągu, a parametr *nTextLen* określa długość. Jeśli *nTextLen* jest 0, ciąg zakłada się, że kończy się zerem.

*nTextLen (nTextLen)*<br/>
Długość ciągu tekstowego wskazywionego przez *lpszText*. Jeśli *nTextLen* jest 0, ciąg zakłada się, że kończy się zerem.

*lpDrawProc*<br/>
Wskaźnik do funkcji wywołania zwrotnego używanej do renderowania obrazu. Ten parametr jest wymagany, jeśli typ obrazu w *nFlags* jest DST_COMPLEX. Jest to opcjonalne i może mieć wartość NULL, jeśli typ obrazu jest DST_TEXT. Dla wszystkich innych typów obrazów ten parametr jest ignorowany. Aby uzyskać więcej informacji na temat funkcji wywołania zwrotnego, zobacz [DrawStateProc](/windows/win32/api/winuser/nc-winuser-drawstateproc) funkcji w windows SDK.

*lDana*<br/>
Określa informacje o obrazie. Znaczenie tego parametru zależy od typu obrazu.

### <a name="return-value"></a>Wartość zwracana

Nonzero jeśli się powiedzie; w przeciwnym razie 0.

## <a name="cdcdrawtext"></a><a name="drawtext"></a>CDC::DrawTekst

Wywołanie tej funkcji elementu członkowskiego, aby sformatować tekst w danym prostokącie. Aby określić dodatkowe opcje formatowania, użyj [programu CDC::DrawTextEx](#drawtextex).

```
virtual int DrawText(
    LPCTSTR lpszString,
    int nCount,
    LPRECT lpRect,
    UINT nFormat);

int DrawText(
    const CString& str,
    LPRECT lpRect,
    UINT nFormat);
```

### <a name="parameters"></a>Parametry

*lpszString*<br/>
Wskazuje ciąg do rysowania. Jeśli *nCount* jest -1, ciąg musi być zakończone zerem.

*Ncount*<br/>
Określa liczbę znaków w ciągu. Jeśli *nCount* wynosi -1, zakłada się, że *lpszString* jest długim `DrawText` wskaźnikiem do ciągu zakończonego zerem i automatycznie oblicza liczbę znaków.

*Lprect*<br/>
Wskazuje strukturę [RECT](/windows/win32/api/windef/ns-windef-rect) lub obiekt [CRect,](../../atl-mfc-shared/reference/crect-class.md) który zawiera prostokąt (we współrzędnych logicznych), w którym tekst ma być sformatowany.

*Str*<br/>
Obiekt [CString,](../../atl-mfc-shared/reference/cstringt-class.md) który zawiera określone znaki do narysowania.

*nFormat*<br/>
Określa metodę formatowania tekstu. Może to być dowolna kombinacja wartości opisanych dla parametru *uFormat* w [DrawText](/windows/win32/api/winuser/nf-winuser-drawtext) w windows SDK. (połączyć za pomocą operatora or bitowego):

> [!NOTE]
> Niektóre kombinacje flag *uFormat* może spowodować, że przekazany ciąg zostanie zmodyfikowany. Za pomocą DT_MODIFYSTRING z DT_END_ELLIPSIS lub DT_PATH_ELLIPSIS może spowodować ciąg do zmodyfikowanie, powodując potwierdzenia w `CString` zastąpienia. Wartości DT_CALCRECT, DT_EXTERNALLEADING, DT_INTERNAL, DT_NOCLIP i DT_NOPREFIX nie mogą być używane z DT_TABSTOP wartością.

### <a name="return-value"></a>Wartość zwracana

Wysokość tekstu, jeśli funkcja zakończy się pomyślnie.

### <a name="remarks"></a>Uwagi

Formatuje tekst, rozwijając karty w odpowiednie spacje, wyrównując tekst do lewej, prawej lub środka danego prostokąta i rozbijając tekst na linie, które mieszczą się w danym prostokącie. Typ formatowania jest określony przez *nFormat*.

Ta funkcja elementu członkowskiego używa wybranej czcionki, koloru tekstu i koloru tła kontekstu urządzenia do rysowania tekstu. O ile nie jest używany `DrawText` DT_NOCLIP format, przycina tekst tak, aby tekst nie pojawiał się poza danym prostokątem. Zakłada się, że wszystkie formatowanie ma wiele wierszy, chyba że podano format DT_SINGLELINE.

Jeśli wybrana czcionka jest zbyt duża dla `DrawText` określonego prostokąta, funkcja elementu członkowskiego nie próbuje zastąpić mniejszej czcionki.

Jeśli DT_CALCRECT flaga jest określona, prostokąt określony przez *lpRect* zostaną zaktualizowane w celu odzwierciedlenia szerokości i wysokości potrzebne do rysowania tekstu.

Jeśli ustawiono flagę wyrównania tekstu TA_UPDATECP (patrz [CDC::SetTextAlign),](#settextalign) `DrawText` tekst będzie wyświetlany od bieżącej pozycji, a nie po lewej stronie danego prostokąta. `DrawText`nie zawija tekstu po ustawieniu flagi TA_UPDATECP (czyli flaga DT_WORDBREAK nie będzie miała wpływu).

Kolor tekstu może być ustawiony przez [CDC::SetTextColor](#settextcolor).

## <a name="cdcdrawtextex"></a><a name="drawtextex"></a>CDC::DrawTextEx

Formatuje tekst w danym prostokącie.

```
virtual int DrawTextEx(
    LPTSTR lpszString,
    int nCount,
    LPRECT lpRect,
    UINT nFormat,
    LPDRAWTEXTPARAMS lpDTParams);

int DrawTextEx(
    const CString& str,
    LPRECT lpRect,
    UINT nFormat,
    LPDRAWTEXTPARAMS lpDTParams);
```

### <a name="parameters"></a>Parametry

*lpszString*<br/>
Wskazuje ciąg do rysowania. Jeśli *nCount* jest -1, ciąg musi być null zakończone.

*Ncount*<br/>
Określa liczbę znaków w ciągu. Jeśli *nCount* wynosi -1, zakłada się, że *lpszString* jest długim `DrawText` wskaźnikiem do ciągu zakończonego zerem i automatycznie oblicza liczbę znaków.

*Lprect*<br/>
Wskazuje strukturę [RECT](/windows/win32/api/windef/ns-windef-rect) lub obiekt [CRect,](../../atl-mfc-shared/reference/crect-class.md) który zawiera prostokąt (we współrzędnych logicznych), w którym tekst ma być sformatowany.

*Str*<br/>
Obiekt [CString,](../../atl-mfc-shared/reference/cstringt-class.md) który zawiera określone znaki do narysowania.

*nFormat*<br/>
Określa metodę formatowania tekstu. Może to być dowolna kombinacja wartości opisanych dla parametru *uFormat* w [DrawText](/windows/win32/api/winuser/nf-winuser-drawtext) w windows SDK. (Połącz za pomocą operatora **OR** bitowego):

> [!NOTE]
> Niektóre kombinacje flag *uFormat* może spowodować, że przekazany ciąg zostanie zmodyfikowany. Za pomocą DT_MODIFYSTRING z DT_END_ELLIPSIS lub DT_PATH_ELLIPSIS może spowodować ciąg do zmodyfikowanie, powodując potwierdzenia w `CString` zastąpienia. Wartości DT_CALCRECT, DT_EXTERNALLEADING, DT_INTERNAL, DT_NOCLIP i DT_NOPREFIX nie mogą być używane z DT_TABSTOP wartością.

*lpDTParams*<br/>
Wskaźnik do struktury [DRAWTEXTPARAMS,](/windows/win32/api/winuser/ns-winuser-drawtextparams) która określa dodatkowe opcje formatowania. Ten parametr może mieć wartość NULL.

### <a name="remarks"></a>Uwagi

Formatuje tekst, rozwijając karty w odpowiednie spacje, wyrównując tekst do lewej, prawej lub środka danego prostokąta i rozbijając tekst na linie, które mieszczą się w danym prostokącie. Typ formatowania jest określony przez *nFormat* i *lpDTParams*. Aby uzyskać więcej informacji, zobacz [CDC::DrawText](#drawtext) i [DrawTextEx](/windows/win32/api/winuser/nf-winuser-drawtextexw) w windows SDK.

Kolor tekstu może być ustawiony przez [CDC::SetTextColor](#settextcolor).

## <a name="cdcellipse"></a><a name="ellipse"></a>CDC::Elipsa

Rysuje elipsę.

```
BOOL Ellipse(
    int x1,
    int y1,
    int x2,
    int y2);

BOOL Ellipse(LPCRECT lpRect);
```

### <a name="parameters"></a>Parametry

*x1*<br/>
Określa logiczną współrzędną x lewego górnego rogu prostokąta ograniczającego elipsy.

*y1*<br/>
Określa logiczną współrzędną y lewego górnego rogu prostokąta ograniczającego elipsy.

*x2*<br/>
Określa logiczną współrzędną x w prawym dolnym rogu prostokąta ograniczającego elipsy.

*y2*<br/>
Określa logiczną współrzędną y w prawym dolnym rogu prostokąta ograniczającego elipsy.

*Lprect*<br/>
Określa prostokąt ograniczający elipsy. Można również przekazać [CRect](../../atl-mfc-shared/reference/crect-class.md) obiektu dla tego parametru.

### <a name="return-value"></a>Wartość zwracana

Różne od zera, jeśli funkcja zakończyła się pomyślnie; w przeciwnym razie 0.

### <a name="remarks"></a>Uwagi

Środek elipsy jest środkiem prostokąta ograniczającego określonego przez *x1*, *y1*, *x2*i *y2*lub *lpRect*. Elipsa jest rysowana za pomocą bieżącego pióra, a jej wnętrze jest wypełnione bieżącą szczotką.

Rysunek rysowany przez tę funkcję rozciąga się do prawej i dolnej współrzędnych, ale nie obejmuje. Oznacza to, że wysokość *figury wynosi y2* - *y1,* a szerokość figury *x2* - *x1*.

Jeśli szerokość lub wysokość prostokąta ograniczającego wynosi 0, nie jest rysowana elipsa.

## <a name="cdcenddoc"></a><a name="enddoc"></a>CDC::EndDoc

Kończy zadanie drukowania rozpoczęte wywołaniem funkcji elementu członkowskiego [StartDoc.](#startdoc)

```
int EndDoc();
```

### <a name="return-value"></a>Wartość zwracana

Większa lub równa 0, jeśli funkcja zakończy się pomyślnie, lub wartość ujemna, jeśli wystąpił błąd.

### <a name="remarks"></a>Uwagi

Ta funkcja elementu członkowskiego zastępuje błąd drukarki ENDDOC i powinien zostać wywołany natychmiast po zakończeniu pomyślnego zadania drukowania.

Jeśli aplikacja napotka błąd drukowania lub anulowaną operację drukowania, nie może `EndDoc` próbować zakończyć operacji przy użyciu programu [AbortDoc](#abortdoc). GDI automatycznie kończy operację przed zwróceniem wartości błędu.

Tej funkcji nie należy używać wewnątrz metaplików.

### <a name="example"></a>Przykład

  Zobacz przykład [cdc::StartDoc](#startdoc).

## <a name="cdcendpage"></a><a name="endpage"></a>CDC::EndPage

Informuje urządzenie, że aplikacja zakończyła pisanie na stronie.

```
int EndPage();
```

### <a name="return-value"></a>Wartość zwracana

Większa lub równa 0, jeśli funkcja zakończy się pomyślnie, lub wartość ujemna, jeśli wystąpił błąd.

### <a name="remarks"></a>Uwagi

Ta funkcja elementu członkowskiego jest zwykle używana do kierowania sterownika urządzenia, aby przejść do nowej strony.

Ta funkcja elementu członkowskiego zastępuje ucieczkę drukarki NEWFRAME. W przeciwieństwie do NEWFRAME, ta funkcja jest zawsze wywoływana po wydrukowaniu strony.

### <a name="example"></a>Przykład

  Zobacz przykład [cdc::StartDoc](#startdoc).

## <a name="cdcendpath"></a><a name="endpath"></a>CDC::Ścieżka końcowa

Zamyka nawias ścieżki i wybiera ścieżkę zdefiniowaną przez nawias w kontekście urządzenia.

```
BOOL EndPath();
```

### <a name="return-value"></a>Wartość zwracana

Różne od zera, jeśli funkcja zakończyła się pomyślnie; w przeciwnym razie 0.

### <a name="example"></a>Przykład

  Zobacz przykład [cdc::BeginPath](#beginpath).

## <a name="cdcenumobjects"></a><a name="enumobjects"></a>CDC::EnumObjects

Wylicza pióra i pędzle dostępne w kontekście urządzenia.

```
int EnumObjects(
    int nObjectType,
    int (CALLBACK* lpfn)(
    LPVOID,
    LPARAM),
    LPARAM lpData);
```

### <a name="parameters"></a>Parametry

*nTypek*<br/>
Określa typ obiektu. Może mieć wartości OBJ_BRUSH lub OBJ_PEN.

*lpfn*<br/>
Jest adres wystąpienia procedury funkcji wywołania zwrotnego dostarczone przez aplikację. Zobacz sekcję "Uwagi" poniżej.

*lpData*<br/>
Wskazuje dane dostarczone przez aplikację. Dane są przekazywane do funkcji wywołania zwrotnego wraz z informacjami o obiekcie.

### <a name="return-value"></a>Wartość zwracana

Określa ostatnią wartość zwróconą przez [funkcję wywołania zwrotnego](callback-functions-used-by-mfc.md#enum_objects). Jego znaczenie jest zdefiniowane przez użytkownika.

### <a name="remarks"></a>Uwagi

Dla każdego obiektu danego typu funkcja wywołania zwrotnego, który przekazujesz jest wywoływana z informacjami dla tego obiektu. System wywołuje funkcję wywołania zwrotnego, dopóki nie ma więcej obiektów lub funkcja wywołania zwrotnego zwraca 0.

Należy zauważyć, że nowe funkcje programu Microsoft Visual C++ `EnumObjects`umożliwiają korzystanie ze zwykłej funkcji jako funkcji przekazywanej do programu . Adres przekazany `EnumObjects` do jest wskaźnikiem do funkcji eksportowane z **EXPORT** i konwencji wywołania Pascal. W aplikacjach w trybie ochrony nie trzeba tworzyć tej funkcji za pomocą funkcji Windows MakeProcInstance ani zwalniać funkcji po użyciu funkcji Systemu Windows FreeProcInstance.

Nie trzeba również eksportować nazwę funkcji w **instrukcji EXPORTS** w pliku definicji modułu aplikacji. Zamiast tego można użyć modyfikatora funkcji **EKSPORT,** jak w

**int CALLBACK EXPORT** AFunction **(LPSTR,** **LPSTR);**

, aby spowodować, że kompilator emituje odpowiedni rekord eksportu do eksportu według nazwy bez aliasowania. Działa to w większości potrzeb. W niektórych szczególnych przypadkach, takich jak eksportowanie funkcji przez porządkowanie lub aliasowanie eksportu, nadal należy użyć instrukcji **EXPORTS** w pliku definicji modułu.

Do kompilowania programów microsoft foundation zwykle należy użyć opcji kompilatora /GA i /GEs. Opcja kompilatora /Gw nie jest używana z klasami Programu Microsoft Foundation. (Jeśli używasz funkcji `MakeProcInstance`systemu Windows, należy jawnie rzutować zwrócony wskaźnik funkcji z FARPROC do typu wymaganego w tym interfejsie API.) Interfejsy rejestracji wywołania zwrotnego są teraz bezpieczne dla typu (należy przekazać w wskaźniku funkcji, który wskazuje odpowiedni rodzaj funkcji dla określonego wywołania zwrotnego).

Należy również zauważyć, że wszystkie funkcje wywołania zwrotnego muszą zalewkować wyjątki programu Microsoft Foundation przed powrotem do systemu Windows, ponieważ wyjątki nie mogą być generowane przez granice wywołania zwrotnego. Aby uzyskać więcej informacji na temat wyjątków, zobacz artykuł [Wyjątki](../../mfc/exception-handling-in-mfc.md).

### <a name="example"></a>Przykład

[!code-cpp[NVC_MFCDocView#35](../../mfc/codesnippet/cpp/cdc-class_7.cpp)]

## <a name="cdcescape"></a><a name="escape"></a>CDC::Ucieczka

Ta funkcja elementu członkowskiego jest praktycznie przestarzała dla programowania Win32.

```
virtual int Escape(
    int nEscape,
    int nCount,
    LPCSTR lpszInData,
    LPVOID lpOutData);

int Escape(
    int nEscape,
    int nInputSize,
    LPCSTR lpszInputData,
    int nOutputSize,
    LPSTR lpszOutputData);
```

### <a name="parameters"></a>Parametry

*pejzaż pszczeli*<br/>
Określa funkcję ucieczki, która ma być wykonywana.

Aby uzyskać pełną listę funkcji ucieczki, zobacz [Escape](/windows/win32/api/wingdi/nf-wingdi-escape) w zestawie Windows SDK.

*Ncount*<br/>
Określa liczbę bajtów danych wskazywali przez *lpszInData*.

*lpszInData*<br/>
Wskazuje strukturę danych wejściowych wymaganych do tej ucieczki.

*lpOutData*<br/>
Wskazuje na strukturę, która ma odbierać dane wyjściowe z tej ucieczki. Parametr *lpOutData* ma wartość NULL, jeśli nie są zwracane żadne dane.

*nInputSize (Rozmiar)*<br/>
Określa liczbę bajtów danych wskazywali parametr *lpszInputData.*

*lpszInputData*<br/>
Wskazuje strukturę wejściową wymaganą dla określonej ucieczki.

*nOutputSize (Rozmiar nieprzejmuszy)*<br/>
Określa liczbę bajtów danych wskazywali parametr *lpszOutputData.*

*lpszOutputData*<br/>
Wskazuje na strukturę, która odbiera dane wyjściowe z tej ucieczki. Ten parametr powinien mieć wartość NULL, jeśli nie są zwracane żadne dane.

### <a name="return-value"></a>Wartość zwracana

Wartość dodatnia jest zwracana, jeśli funkcja zakończy się pomyślnie, z wyjątkiem queryescsupport ucieczki, który sprawdza tylko implementacji. Zero jest zwracany, jeśli escape nie jest zaimplementowana. Wartość ujemna jest zwracana, jeśli wystąpił błąd. Poniżej przedstawiono typowe wartości błędów:

- SP_ERROR Błąd ogólny.

- SP_OUTOFDISK Obecnie nie ma wystarczającej ilości miejsca na dysku do buforowania i nie będzie więcej miejsca.

- SP_OUTOFMEMORY Za mało pamięci jest dostępna do buforowania.

- SP_USERABORT Użytkownik zakończył zadanie za pośrednictwem Menedżera wydruku.

### <a name="remarks"></a>Uwagi

Z oryginalnych escapes drukarki, tylko QUERYESCSUPPORT jest obsługiwany dla aplikacji Win32. Wszystkie inne urządzenia typu escapes są przestarzałe i są obsługiwane tylko w celu zapewnienia zgodności z aplikacjami 16-bitowymi.

W przypadku programowania `CDC` w win32 udostępnia teraz sześć funkcji członkowskich, które zastępują odpowiednie dane z drukarki:

- [CDC::AbortDoc](#abortdoc)

- [CDC::EndDoc](#enddoc)

- [CDC::EndPage](#endpage)

- [CDC::SetAbortProc](#setabortproc)

- [CDC::StartDoc](#startdoc)

- [CDC::Strona startowa](#startpage)

Ponadto [CDC::GetDeviceCaps](#getdevicecaps) obsługuje indeksy Win32, które zastępują inne dane z pracy drukarki. Aby uzyskać więcej informacji, zobacz [GetDeviceCaps](/windows/win32/api/wingdi/nf-wingdi-getdevicecaps) w usłudze Windows SDK.

Ta funkcja elementu członkowskiego umożliwia aplikacjom dostęp do obiektów określonego urządzenia, które nie są bezpośrednio dostępne za pośrednictwem interfejsu GDI.

Użyj pierwszej wersji, jeśli aplikacja używa wstępnie zdefiniowanych wartości ucieczki. Użyj drugiej wersji, jeśli aplikacja definiuje prywatne wartości ucieczki. Zobacz [ExtEscape](/windows/win32/api/wingdi/nf-wingdi-extescape) w windows SDK, aby uzyskać więcej informacji na temat drugiej wersji.

## <a name="cdcexcludecliprect"></a><a name="excludecliprect"></a>CDC::ExcludeClipRect

Tworzy nowy obszar przycinania, który składa się z istniejącego regionu przycinania minus określony prostokąt.

```
int ExcludeClipRect(
    int x1,
    int y1,
    int x2,
    int y2);

int ExcludeClipRect(LPCRECT lpRect);
```

### <a name="parameters"></a>Parametry

*x1*<br/>
Określa logiczną współrzędną x lewego górnego rogu prostokąta.

*y1*<br/>
Określa logiczną współrzędną y lewego górnego rogu prostokąta.

*x2*<br/>
Określa logiczną współrzędną x w prawym dolnym rogu prostokąta.

*y2*<br/>
Określa logiczną współrzędną y w prawym dolnym rogu prostokąta.

*Lprect*<br/>
Określa prostokąt. Może być `CRect` również obiektem.

### <a name="return-value"></a>Wartość zwracana

Określa typ nowego regionu przycinania. Może to być dowolna z następujących wartości:

- COMPLEXREGION Region ma nakładające się granice.

- BŁĄD Żaden region nie został utworzony.

- NULLREGION Region jest pusty.

- SIMPLEREGION Region nie ma nakładających się granic.

### <a name="remarks"></a>Uwagi

Szerokość prostokąta, określona przez wartość bezwzględną *x2* - *x1,* nie może przekraczać 32 767 jednostek. Ten limit dotyczy również wysokości prostokąta.

## <a name="cdcexcludeupdatergn"></a><a name="excludeupdatergn"></a>CDC::ExcludeUpdateRgn

Zapobiega rysowaniu w nieprawidłowych obszarach okna, wykluczając zaktualizowany region w oknie `CDC` z regionu przycinania skojarzonego z obiektem.

```
int ExcludeUpdateRgn(CWnd* pWnd);
```

### <a name="parameters"></a>Parametry

*Pwnd*<br/>
Wskazuje obiekt okna, którego okno jest aktualizowane.

### <a name="return-value"></a>Wartość zwracana

Typ regionu wykluczonego. Może to być jedna z następujących wartości:

- COMPLEXREGION Region ma nakładające się granice.

- BŁĄD Żaden region nie został utworzony.

- NULLREGION Region jest pusty.

- SIMPLEREGION Region nie ma nakładających się granic.

## <a name="cdcextfloodfill"></a><a name="extfloodfill"></a>CDC::ExtFloodFill

Wypełnia obszar powierzchni wyświetlacza bieżącą szczotką.

```
BOOL ExtFloodFill(
    int x,
    int y,
    COLORREF crColor,
    UINT nFillType);
```

### <a name="parameters"></a>Parametry

*X*<br/>
Określa logiczną współrzędną x punktu, w którym rozpoczyna się wypełnianie.

*Y*<br/>
Określa logiczną współrzędną y punktu, w którym rozpoczyna się wypełnianie.

*CrColor ( kolor)*<br/>
Określa kolor granicy lub obszaru, który ma zostać wypełniony. Interpretacja *crColor* zależy od wartości *nFillType*.

*nFillType (Typ wypełnienia)*<br/>
Określa typ wypełniania powodziowego do wykonania. Musi to być jedną z następujących wartości:

- FLOODFILLBORDER Obszar wypełnienia jest ograniczony kolorem określonym przez *crColor*. Ten styl jest identyczny `FloodFill`z wypełnieniem wykonywanym przez program .

- FLOODFILLSURFACE Obszar wypełnienia jest definiowany przez kolor określony przez *crColor*. Napełnianie jest kontynuowane na zewnątrz we wszystkich kierunkach, o ile napotkany jest kolor. Ten styl jest przydatny do wypełniania obszarów wielokolorowymi granicami.

### <a name="return-value"></a>Wartość zwracana

Nonzero, jeśli funkcja zakończy się pomyślnie; w przeciwnym razie 0, jeśli wypełnienie nie może być zakończone, jeśli dany punkt ma kolor granicy określony przez *crColor* (jeśli FLOODFILLBORDER został poproszony), jeśli dany punkt nie ma koloru określonego przez *crColor* (jeśli floodfillsurface zażądano), lub jeśli punkt jest poza obszarem przycinania.

### <a name="remarks"></a>Uwagi

Ta funkcja elementu członkowskiego `FloodFill` oferuje większą elastyczność niż dlatego, że można określić typ wypełnienia w *pliku nFillType*.

Jeśli *nFillType* jest ustawiony na FLOODFILLBORDER, przyjmuje się, że obszar jest całkowicie ograniczony kolorem określonym przez *crColor*. Funkcja rozpoczyna się w punkcie określonym przez *x* i *y* i wypełnia we wszystkich kierunkach do granicy koloru.

Jeśli *nFillType* jest ustawiona na FLOODFILLSURFACE, funkcja rozpoczyna się w punkcie określonym przez *x* i y i jest *kontynuowana* we wszystkich kierunkach, wypełniając wszystkie sąsiednie obszary zawierające kolor określony przez *crColor*.

Obsługują `ExtFloodFill`tylko konteksty i urządzenia z urządzeniami pamięci i urządzeniami obsługującymi technologię wyświetlania rastrowego. Aby uzyskać więcej informacji, zobacz [GetDeviceCaps](#getdevicecaps) funkcji elementu członkowskiego.

## <a name="cdcexttextout"></a><a name="exttextout"></a>CDC::ExtTextOut

Wywołanie tej funkcji elementu członkowskiego, aby napisać ciąg znaków w obrębie prostokątnego regionu przy użyciu aktualnie wybranej czcionki.

```
virtual BOOL ExtTextOut(
    int x,
    int y,
    UINT nOptions,
    LPCRECT lpRect,
    LPCTSTR lpszString,
    UINT nCount,
    LPINT lpDxWidths);

BOOL ExtTextOut(
    int x,
    int y,
    UINT nOptions,
    LPCRECT lpRect,
    const CString& str,
    LPINT lpDxWidths);
```

### <a name="parameters"></a>Parametry

*X*<br/>
Określa logiczną współrzędną x komórki znaków dla pierwszego znaku w określonym ciągu.

*Y*<br/>
Określa logiczną współrzędną y górnej części komórki znaku dla pierwszego znaku w określonym ciągu.

*nOpcje*<br/>
Określa typ prostokąta. Ten parametr może być jedną, obie lub żadna z następujących wartości:

- ETO_CLIPPED Określa, że tekst jest przycięty do prostokąta.

- ETO_OPAQUE Określa, że bieżący kolor tła wypełnia prostokąt. (Bieżący kolor tła można ustawić i zbadać za pomocą funkcji elementów członkowskich [SetBkColor](#setbkcolor) i [GetBkColor).](#getbkcolor)

*Lprect*<br/>
Wskazuje strukturę [RECT,](/windows/win32/api/windef/ns-windef-rect) która określa wymiary prostokąta. Ten parametr może mieć wartość NULL. Można również przekazać [CRect](../../atl-mfc-shared/reference/crect-class.md) obiektu dla tego parametru.

*lpszString*<br/>
Wskazuje określony ciąg znaków, który ma zostać narysowany. Można również przekazać [CString](../../atl-mfc-shared/reference/cstringt-class.md) obiektu dla tego parametru.

*Ncount*<br/>
Określa liczbę znaków w ciągu.

*lpDxWidths*<br/>
Wskazuje tablicę wartości wskazującą odległość między początkowymi sąsiadującymi komórkami znaków. Na przykład *jednostki logiczne lpDxWidths*[ *i*] oddzielą początki komórki znakowej *i* komórki znakowej *i* + 1. Jeśli *lpDxWidths* ma `ExtTextOut` wartość NULL, używa domyślnych odstępów między znakami.

*Str*<br/>
Obiekt, `CString` który zawiera określone znaki do narysowania.

### <a name="return-value"></a>Wartość zwracana

Różne od zera, jeśli funkcja zakończyła się pomyślnie; w przeciwnym razie 0.

### <a name="remarks"></a>Uwagi

Prostokątny obszar może być nieprzezroczysty (wypełniony bieżącym kolorem tła) i może być regionem przycinania.

Jeśli *nOptions* jest 0 i *lpRect* jest NULL, funkcja zapisuje tekst w kontekście urządzenia bez użycia prostokątnego regionu. Domyślnie, funkcja nie używa ani nie aktualizuje bieżącej pozycji. Jeśli aplikacja musi zaktualizować bieżącą pozycję `ExtTextOut`podczas wywoływania, `CDC` aplikacja może wywołać funkcję członkowną [SetTextAlign](#settextalign) z *nFlags* ustawiony na TA_UPDATECP. Gdy ta flaga jest ustawiona, system Windows `ExtTextOut` ignoruje *x* i *y* w kolejnych wywołaniach i zamiast tego używa bieżącej pozycji. Gdy aplikacja używa TA_UPDATECP do aktualizacji bieżącej `ExtTextOut` pozycji, ustawia bieżącą pozycję albo na końcu poprzedniego wiersza tekstu lub na pozycję określoną przez ostatni element tablicy wskazywionej przez *lpDxWidths*, w zależności od tego, która z tych wartości jest większa.

## <a name="cdcfillpath"></a><a name="fillpath"></a>CDC::FillPath

Zamyka wszystkie otwarte figury w bieżącej ścieżce i wypełnia wnętrze ścieżki za pomocą bieżącego pędzla i trybu wypełniania wielokątów.

```
BOOL FillPath();
```

### <a name="return-value"></a>Wartość zwracana

Różne od zera, jeśli funkcja zakończyła się pomyślnie; w przeciwnym razie 0.

### <a name="remarks"></a>Uwagi

Po wypełnieniu jego wnętrza ścieżka jest odrzucana z kontekstu urządzenia.

## <a name="cdcfillrect"></a><a name="fillrect"></a>CDC::FillRect

Wywołanie tej funkcji elementu członkowskiego, aby wypełnić dany prostokąt za pomocą określonego pędzla.

```
void FillRect(
    LPCRECT lpRect,
    CBrush* pBrush);
```

### <a name="parameters"></a>Parametry

*Lprect*<br/>
Wskazuje strukturę [RECT,](/windows/win32/api/windef/ns-windef-rect) która zawiera współrzędne logiczne prostokąta, który ma zostać wypełniony. Można również przekazać [CRect](../../atl-mfc-shared/reference/crect-class.md) obiektu dla tego parametru.

*pBrush (pędzel)*<br/>
Identyfikuje pędzel używany do wypełnienia prostokąta.

### <a name="remarks"></a>Uwagi

Funkcja wypełnia pełny prostokąt, łącznie z lewą i górną krawędzią, ale nie wypełnia prawej i dolnej krawędzi.

Pędzel musi być tworzony przy użyciu funkcji członkowskich [CBrush](../../mfc/reference/cbrush-class.md) [CreateHatchBrush](../../mfc/reference/cbrush-class.md#createhatchbrush), [CreatePatternBrush](../../mfc/reference/cbrush-class.md#createpatternbrush)i [CreateSolidBrush](../../mfc/reference/cbrush-class.md#createsolidbrush)lub pobrany przez funkcję `GetStockObject` Windows.

Podczas wypełniania określonego prostokąta, `FillRect` nie obejmuje prostokąta po prawej i dolnej stronie. GDI wypełnia prostokąt do prawej kolumny i dolnego wiersza, ale nie zawiera, niezależnie od bieżącego trybu mapowania. `FillRect`porównuje wartości `top`, `bottom`, `left`i `right` elementów członkowskich określonego prostokąta. Jeśli `bottom` jest mniejsza lub `top`równa `right` , lub jeśli `left`jest mniejsza lub równa , prostokąt nie jest rysowany.

`FillRect`jest podobny do [CDC::FillSolidRect](#fillsolidrect); jednak `FillRect` przyjmuje pędzel i dlatego może być używany do wypełnienia prostokąta jednolitym kolorem, kolorem roztrząsanym, kreskowanym pędzlem lub wzorem. `FillSolidRect`używa tylko kolorów jednolitych (oznaczonych parametrem COLORREF). `FillRect`zwykle jest wolniejszy niż `FillSolidRect`.

## <a name="cdcfillrgn"></a><a name="fillrgn"></a>CDC::FillRgn

Wypełnia obszar określony przez *pRgn* pędzlem określonym przez *pBrush*.

```
BOOL FillRgn(
    CRgn* pRgn,
    CBrush* pBrush);
```

### <a name="parameters"></a>Parametry

*pRgn*<br/>
Wskaźnik do regionu do wypełnienia. Współrzędne dla danego regionu są określone w jednostkach logicznych.

*pBrush (pędzel)*<br/>
Identyfikuje pędzel, który ma być użyty do wypełnienia regionu.

### <a name="return-value"></a>Wartość zwracana

Różne od zera, jeśli funkcja zakończyła się pomyślnie; w przeciwnym razie 0.

### <a name="remarks"></a>Uwagi

Pędzel musi być utworzony `CBrush` przy `CreateHatchBrush`użyciu `CreatePatternBrush` `CreateSolidBrush`funkcji członkowskich , `GetStockObject`, lub być pobierane przez .

### <a name="example"></a>Przykład

  Zobacz przykład [CRgn::CreateRoundRectRgn](../../mfc/reference/crgn-class.md#createroundrectrgn).

## <a name="cdcfillsolidrect"></a><a name="fillsolidrect"></a>CDC::FillSolidRect

Wywołanie tej funkcji elementu członkowskiego, aby wypełnić dany prostokąt określonym jednolitym kolorem.

```
void FillSolidRect(
    LPCRECT lpRect,
    COLORREF clr);

void FillSolidRect(
    int x,
    int y,
    int cx,
    int cy,
    COLORREF clr);
```

### <a name="parameters"></a>Parametry

*Lprect*<br/>
Określa prostokąt ograniczający (w jednostkach logicznych). Można przekazać wskaźnik do struktury danych [RECT](/windows/win32/api/windef/ns-windef-rect) `CRect` lub obiekt dla tego parametru.

*clr (w tym)* Określa kolor, który ma być używany do wypełnienia prostokąta.

*X*<br/>
Określa logiczną współrzędną x lewego górnego rogu prostokąta.

*Y*<br/>
Określa logiczną współrzędną y lewego górnego rogu prostokąta docelowego.

*Cx*<br/>
Określa szerokość prostokąta.

*Cy*<br/>
Określa wysokość prostokąta.

### <a name="remarks"></a>Uwagi

`FillSolidRect`jest bardzo podobny do [CDC::FillRect](#fillrect); jednak `FillSolidRect` używa tylko jednolitych kolorów (wskazanych przez `FillRect` parametr COLORREF), podczas gdy przyjmuje pędzel i dlatego może być używany do wypełnienia prostokąta jednolitym kolorem, kolorem roztrząsanym, kreskowanym pędzlem lub wzorem. `FillSolidRect`zwykle jest `FillRect`szybszy niż .

> [!NOTE]
> Podczas wywoływania `FillSolidRect`kolor tła, który został wcześniej ustawiony za pomocą [SetBkColor,](#setbkcolor)jest ustawiony na kolor wskazany przez *clr*.

## <a name="cdcflattenpath"></a><a name="flattenpath"></a>CDC::Spłaszczyć

Przekształca wszystkie krzywe w ścieżce wybranej w bieżącym kontekście urządzenia i zamienia każdą krzywą w sekwencję linii.

```
BOOL FlattenPath();
```

### <a name="return-value"></a>Wartość zwracana

Różne od zera, jeśli funkcja zakończyła się pomyślnie; w przeciwnym razie 0.

## <a name="cdcfloodfill"></a><a name="floodfill"></a>CDC::FloodFill

Wypełnia obszar powierzchni wyświetlacza bieżącą szczotką.

```
BOOL FloodFill(
    int x,
    int y,
    COLORREF crColor);
```

### <a name="parameters"></a>Parametry

*X*<br/>
Określa logiczną współrzędną x punktu, w którym rozpoczyna się wypełnianie.

*Y*<br/>
Określa logiczną współrzędną y punktu, w którym rozpoczyna się wypełnianie.

*CrColor ( kolor)*<br/>
Określa kolor granicy.

### <a name="return-value"></a>Wartość zwracana

Nonzero, jeśli funkcja zakończy się pomyślnie; w przeciwnym razie 0 jest zwracany, jeśli wypełnienie nie może być zakończone, dany punkt ma kolor granicy określony przez *crColor*lub punkt znajduje się poza regionem przycinania.

### <a name="remarks"></a>Uwagi

Przyjmuje się, że obszar ten jest ograniczony zgodnie z *crColor*. Funkcja `FloodFill` rozpoczyna się w punkcie określonym przez *x* i y i jest *kontynuowana* we wszystkich kierunkach do granicy koloru.

Tylko konteksty urządzenia pamięci i urządzenia obsługujące technologię `FloodFill` wyświetlania rastrowego obsługują funkcję elementu członkowskiego. Aby uzyskać informacje na temat możliwości `GetDeviceCaps` RC_BITBLT, zobacz funkcję elementu członkowskiego.

Funkcja `ExtFloodFill` zapewnia podobną możliwość, ale większą elastyczność.

## <a name="cdcframerect"></a><a name="framerect"></a>CDC::FrameRect

Rysuje obramowanie wokół prostokąta określonego przez *lpRect*.

```
void FrameRect(
    LPCRECT lpRect,
    CBrush* pBrush);
```

### <a name="parameters"></a>Parametry

*Lprect*<br/>
Wskazuje na strukturę [RECT](/windows/win32/api/windef/ns-windef-rect) lub obiekt [CRect,](../../atl-mfc-shared/reference/crect-class.md) który zawiera współrzędne logiczne lewego górnego i prawego dolnego rogu prostokąta. Można również przekazać `CRect` obiekt dla tego parametru.

*pBrush (pędzel)*<br/>
Identyfikuje pędzel, który ma być używany do kadrowania prostokąta.

### <a name="remarks"></a>Uwagi

Funkcja używa danego pędzla do rysowania obramowania. Szerokość i wysokość obramowania jest zawsze 1 jednostką logiczną.

Jeśli współrzędna `bottom` prostokąta jest mniejsza `top`lub `right` równa , lub `left`jeśli jest mniejsza lub równa , prostokąt nie jest rysowany.

Obramowanie `FrameRect` rysowane przez znajduje się w `Rectangle` tej samej pozycji co `Rectangle` obramowanie narysowane przez funkcję elementu członkowskiego przy użyciu tych samych współrzędnych (jeśli używa pióra o szerokości 1 jednostki logicznej). Wnętrze prostokąta nie jest wypełnione `FrameRect`przez .

## <a name="cdcframergn"></a><a name="framergn"></a>CDC::Framergn

Rysuje obramowanie wokół regionu określonego przez *pRgn* za pomocą pędzla określonego przez *pBrush*.

```
BOOL FrameRgn(
    CRgn* pRgn,
    CBrush* pBrush,
    int nWidth,
    int nHeight);
```

### <a name="parameters"></a>Parametry

*pRgn*<br/>
Wskazuje obiekt `CRgn` identyfikujący region, który ma zostać ujęty w obramowanie. Współrzędne dla danego regionu są określone w jednostkach logicznych.

*pBrush (pędzel)*<br/>
Wskazuje obiekt `CBrush` identyfikujący pędzel, który ma być użyty do narysowania obramowania.

*nWidth (ww.*<br/>
Określa szerokość obramowania w pionowych pociągnięciach pędzla w jednostkach urządzenia.

*nFeksja*<br/>
Określa wysokość obramowania w poziomych pociągnięciach pędzla w jednostkach urządzenia.

### <a name="return-value"></a>Wartość zwracana

Różne od zera, jeśli funkcja zakończyła się pomyślnie; w przeciwnym razie 0.

### <a name="example"></a>Przykład

  Zobacz przykład [CRgn::CombineRgn](../../mfc/reference/crgn-class.md#combinergn).

## <a name="cdcfromhandle"></a><a name="fromhandle"></a>CDC::OdHandle

Zwraca wskaźnik do `CDC` obiektu, gdy podane dojście do kontekstu urządzenia.

```
static CDC* PASCAL FromHandle(HDC hDC);
```

### <a name="parameters"></a>Parametry

*Hdc*<br/>
Zawiera dojście do kontekstu urządzenia z systemem Windows.

### <a name="return-value"></a>Wartość zwracana

Wskaźnik może być tymczasowy i nie powinien być przechowywany poza natychmiastowym użyciem.

### <a name="remarks"></a>Uwagi

Jeśli `CDC` obiekt nie jest dołączony do uchwytu, tworzony i dołączany jest obiekt tymczasowy. `CDC`

### <a name="example"></a>Przykład

  Zobacz przykład [CPrintDialog::GetPrinterDC](../../mfc/reference/cprintdialog-class.md#getprinterdc).

## <a name="cdcgetarcdirection"></a><a name="getarcdirection"></a>CDC::Kierunek GetArc

Zwraca bieżący kierunek łuku dla kontekstu urządzenia.

```
int GetArcDirection() const;
```

### <a name="return-value"></a>Wartość zwracana

Określa bieżący kierunek łuku, jeśli zakończy się pomyślnie. Poniżej znajdują się prawidłowe wartości zwracane:

- AD_COUNTERCLOCKWISE łuki i prostokąty rysowane w kierunku przeciwnym do ruchu wskazówek zegara.

- AD_CLOCKWISE łuki i prostokąty rysowane zgodnie z ruchem wskazówek zegara.

Jeśli wystąpi błąd, zwracana wartość wynosi zero.

### <a name="remarks"></a>Uwagi

Funkcje łuku i prostokąta używają kierunku łuku.

## <a name="cdcgetaspectratiofilter"></a><a name="getaspectratiofilter"></a>CDC::GetAspectRatioFilter

Pobiera ustawienie dla bieżącego filtru proporcji obrazu.

```
CSize GetAspectRatioFilter() const;
```

### <a name="return-value"></a>Wartość zwracana

Obiekt `CSize` reprezentujący współczynnik proporcji używany przez bieżący filtr współczynnika proporcji.

### <a name="remarks"></a>Uwagi

Współczynnik proporcji to współczynnik utworzony przez szerokość i wysokość piksela urządzenia. Informacje o współczynniku proporcji urządzenia są używane podczas tworzenia, zaznaczania i wyświetlania czcionek. System Windows udostępnia specjalny filtr, filtr proporcji obrazu, aby wybrać czcionki przeznaczone dla określonego współczynnika proporcji ze wszystkich dostępnych czcionek. Filtr używa współczynnika proporcji `SetMapperFlags` określonego przez funkcję elementu członkowskiego.

## <a name="cdcgetbkcolor"></a><a name="getbkcolor"></a>CDC::GetBkColor

Zwraca bieżący kolor tła.

```
COLORREF GetBkColor() const;
```

### <a name="return-value"></a>Wartość zwracana

Wartość koloru RGB.

### <a name="remarks"></a>Uwagi

Jeśli tryb tła jest NIEPRZEZROCZYSTY, system używa koloru tła do wypełniania przerw w stylizowanych liniach, odstępów między kreskowanymi liniami w pędzlach i tła w komórkach znaków. System używa również koloru tła podczas konwertowania bitmap między kolorami i monochromatycznymi kontekstami urządzeń.

## <a name="cdcgetbkmode"></a><a name="getbkmode"></a>CDC::GetBkMode

Zwraca tryb tła.

```
int GetBkMode() const;
```

### <a name="return-value"></a>Wartość zwracana

Bieżący tryb tła, który może być nieprzezroczysty lub przezroczysty.

### <a name="remarks"></a>Uwagi

Tryb tła określa, czy system usuwa istniejące kolory tła na powierzchni rysunku przed rysowaniem tekstu, kreskowanych pędzli lub dowolnego stylu pióra, który nie jest linią ciągłą.

## <a name="cdcgetboundsrect"></a><a name="getboundsrect"></a>CDC::GetBoundsRect

Zwraca bieżący skumulowany prostokąt ograniczający dla określonego kontekstu urządzenia.

```
UINT GetBoundsRect(
    LPRECT lpRectBounds,
    UINT flags);
```

### <a name="parameters"></a>Parametry

*lpRectBounds (lpRectBounds)*<br/>
Wskazuje bufor, który otrzyma bieżący prostokąt ograniczający. Prostokąt jest zwracany we współrzędnych logicznych.

*flagi*<br/>
Określa, czy prostokąt ograniczający ma zostać wyczyszczony po jego zwróceniu. Ten parametr powinien być zerowy lub ustawiony na następującą wartość:

- DCB_RESET Wymusza usunięcie prostokąta ograniczającego po jego zwrocie.

### <a name="return-value"></a>Wartość zwracana

Określa bieżący stan prostokąta ograniczającego, jeśli funkcja zakończy się pomyślnie. Może to być kombinacja następujących wartości:

- DCB_ACCUMULATE nagromadzenie prostokąta ograniczającego.

- DCB_RESET Prostokąt ograniczający jest pusty.

- DCB_SET Prostokąt ograniczający nie jest pusty.

- DCB_ENABLE Akumulacja granic jest wł.

- DCB_DISABLE Akumulacja granic jest wyłączona.

## <a name="cdcgetbrushorg"></a><a name="getbrushorg"></a>CDC::GetBrushOrg

Pobiera początek (w jednostkach urządzenia) pędzla aktualnie wybranego dla kontekstu urządzenia.

```
CPoint GetBrushOrg() const;
```

### <a name="return-value"></a>Wartość zwracana

Bieżące pochodzenie pędzla (w jednostkach urządzenia) jako obiektu [CPoint.](../../atl-mfc-shared/reference/cpoint-class.md)

### <a name="remarks"></a>Uwagi

Początkowe pochodzenie pędzla wynosi (0,0) obszaru klienta. Zwracana wartość określa ten punkt w jednostkach urządzenia względem początku okna pulpitu.

## <a name="cdcgetcharacterplacement"></a><a name="getcharacterplacement"></a>CDC::GetCharacterPlacement

Pobiera różne typy informacji na ciąg znaków.

```
DWORD GetCharacterPlacement(
    LPCTSTR lpString,
    int nCount,
    int nMaxExtent,
    LPGCP_RESULTS lpResults,
    DWORD dwFlags) const;

DWORD GetCharacterPlacement(
    CString& str,
    int nMaxExtent,
    LPGCP_RESULTS lpResults,
    DWORD dwFlags) const;
```

### <a name="parameters"></a>Parametry

*lpString (lpString)*<br/>
Wskaźnik do ciągu znaków do przetworzenia.

*Ncount*<br/>
Określa długość ciągu. Dla wersji ANSI jest to liczba bajtów, a dla funkcji Unicode jest to liczba WORD. Aby uzyskać więcej informacji, zobacz [GetCharacterPlacement](/windows/win32/api/wingdi/nf-wingdi-getcharacterplacementw).

*nMaxExtent (Polski)*<br/>
Określa maksymalny zasięg (w jednostkach logicznych), na który jest przetwarzany ciąg. Znaki, które w przypadku przetworzenia mogłyby przekroczyć ten zakres, są ignorowane. Obliczenia dla wszelkich wymaganych tablic porządkowych lub glifów mają zastosowanie tylko do dołączonych znaków. Ten parametr jest używany tylko wtedy, gdy wartość GCP_MAXEXTENT jest określona w parametrze *dwFlags.* Ponieważ funkcja przetwarza ciąg wejściowy, każdy znak i jego zasięg jest dodawany do danych wyjściowych, zasięgu i innych tablic tylko wtedy, gdy całkowity zakres nie przekroczył jeszcze wartości maksymalnej. Po osiągnięciu limitu przetwarzanie zostanie zatrzymane.

*lpWyniki*<br/>
Wskaźnik do [GCP_Results](/windows/win32/api/wingdi/ns-wingdi-gcp_resultsw) struktury, która odbiera wyniki funkcji.

*Dwflags*<br/>
Określa sposób przetwarzania ciągu do wymaganych tablic. Ten parametr może być jedną lub kilkoma wartościami wymienionymi w sekcji *dwFlags* w temacie [GetCharacterPlacement.](/windows/win32/api/wingdi/nf-wingdi-getcharacterplacementw)

*Str*<br/>
Wskaźnik do [CString](../../atl-mfc-shared/reference/cstringt-class.md) obiektu do przetworzenia.

### <a name="return-value"></a>Wartość zwracana

Jeśli funkcja powiedzie się, zwracana wartość jest szerokość i wysokość ciągu w jednostkach logicznych.

Jeśli funkcja nie powiedzie się, zwracana wartość wynosi zero.

### <a name="remarks"></a>Uwagi

Ta funkcja elementu członkowskiego emuluje funkcjonalność funkcji [GetCharacterPlacement](/windows/win32/api/wingdi/nf-wingdi-getcharacterplacementw), zgodnie z opisem w windows SDK.

## <a name="cdcgetcharabcwidths"></a><a name="getcharabcwidths"></a>CDC::GetCharABCWidths

Pobiera szerokości kolejnych znaków w określonym zakresie z bieżącej czcionki TrueType.

```
BOOL GetCharABCWidths(
    UINT nFirstChar,
    UINT nLastChar,
    LPABC lpabc) const;

BOOL GetCharABCWidths(
    UINT nFirstChar,
    UINT nLastChar,
    LPABCFLOAT lpABCF) const;
```

### <a name="parameters"></a>Parametry

*nFirstChar (Powierz)*<br/>
Określa pierwszy znak w zakresie znaków z bieżącej czcionki, dla której zwracane są szerokości znaków.

*nLastChar (OstatniChar)*<br/>
Określa ostatni znak w zakresie znaków z bieżącej czcionki, dla której zwracane są szerokości znaków.

*lpabc ( lpabc )*<br/>
Wskazuje tablicę struktur [ABC,](/windows/win32/api/wingdi/ns-wingdi-abc) które otrzymują szerokości znaków po powrocie funkcji. Ta tablica musi zawierać `ABC` co najmniej tyle struktur, ile znaków w zakresie określonym przez parametry *nFirstChar* i *nLastChar.*

*lpABCF*<br/>
Wskazuje bufor dostarczony przez aplikację z tablicą struktur [ABCFLOAT,](/windows/win32/api/wingdi/ns-wingdi-abcfloat) aby odbierać szerokości znaków po powrocie funkcji. Szerokości zwracane przez tę funkcję są w formacie zmiennoprzecinkowym IEEE.

### <a name="return-value"></a>Wartość zwracana

Różne od zera, jeśli funkcja zakończyła się pomyślnie; w przeciwnym razie 0.

### <a name="remarks"></a>Uwagi

Szerokości są zwracane w jednostkach logicznych. Ta funkcja jest pomyślna tylko z czcionkami TrueType.

Rasteryzator TrueType zapewnia odstępy między znakami "ABC" po wybraniu określonego rozmiaru punktu. Odstępy "A" to odległość dodana do bieżącej pozycji przed umieszczeniem glifu. Odstęp "B" to szerokość czarnej części glifu. Odstępy "C" są dodawane do bieżącej pozycji, aby uwzględnić biały znak po prawej stronie glifów. Całkowita zaawansowana szerokość jest podana przez A + B + C.

Gdy `GetCharABCWidths` funkcja elementu członkowskiego pobiera ujemne szerokości "A" lub "C" dla znaku, ten znak zawiera podwisły lub wysięg.

Aby przekonwertować szerokości ABC na jednostki projektu czcionki, aplikacja `lfHeight` powinna utworzyć czcionkę, której wysokość (określona `ntmSizeEM` w członku struktury [LOGFONT)](/windows/win32/api/wingdi/ns-wingdi-logfontw) jest równa wartości przechowywanej w członku struktury [NEWTEXTMETRIC.](/windows/win32/api/wingdi/ns-wingdi-newtextmetricw) (Wartość `ntmSizeEM` elementu członkowskiego można pobrać, wywołując funkcję [EnumFontFamilies](/windows/win32/api/wingdi/nf-wingdi-enumfontfamiliesw) Windows).

Szerokości abc znaku domyślnego są używane dla znaków, które znajdują się poza zakresem aktualnie wybranej czcionki.

Aby pobrać szerokości znaków w czcionkach innych niż TrueType, aplikacje powinny używać funkcji [GetCharWidth](/windows/win32/api/wingdi/nf-wingdi-getcharwidthw) Windows.

## <a name="cdcgetcharabcwidthsi"></a><a name="getcharabcwidthsi"></a>CDC::GetCharABCWidthsI

Pobiera szerokości w jednostkach logicznych kolejnych indeksów glifów w określonym zakresie z bieżącej czcionki TrueType.

```
BOOL GetCharABCWidthsI(
    UINT giFirst,
    UINT cgi,
    LPWORD pgi,
    LPABC lpabc) const;
```

### <a name="parameters"></a>Parametry

*giFirst ( giFirst )*<br/>
Określa pierwszy indeks glifów w grupie kolejnych indeksów glifów z bieżącej czcionki. Ten parametr jest używany tylko wtedy, gdy parametr *pgi* ma wartość NULL.

*Grafika komputerowa*<br/>
Określa liczbę indeksów glifów.

*Pgi*<br/>
Wskaźnik do tablicy zawierającej indeksy glifów. Jeśli wartość jest NULL, zamiast tego używany jest parametr *giFirst.* Parametr *cgi* określa liczbę indeksów glifów w tej tablicy.

*lpabc ( lpabc )*<br/>
Wskaźnik do tablicy struktur [ABC](/windows/win32/api/wingdi/ns-wingdi-abc) odbierających szerokości znaków. Ta tablica musi zawierać `ABC` co najmniej tyle struktur, ile istnieją indeksy glifów określone przez parametr *cgi.*

### <a name="return-value"></a>Wartość zwracana

Różne od zera, jeśli funkcja zakończyła się pomyślnie; w przeciwnym razie 0.

### <a name="remarks"></a>Uwagi

Ta funkcja elementu członkowskiego emuluje funkcjonalność funkcji [GetCharABCWidthsI](/windows/win32/api/wingdi/nf-wingdi-getcharabcwidthsi), zgodnie z opisem w windows SDK.

## <a name="cdcgetcharwidth"></a><a name="getcharwidth"></a>CDC::GetCharWidth

Pobiera szerokości poszczególnych znaków w kolejnej grupie znaków z `m_hAttribDC`bieżącej czcionki, używając kontekstu urządzenia wejściowego.

```
BOOL GetCharWidth(
    UINT nFirstChar,
    UINT nLastChar,
    LPINT lpBuffer) const;

BOOL GetCharWidth(
    UINT nFirstChar,
    UINT nLastChar,
    float* lpFloatBuffer) const;
```

### <a name="parameters"></a>Parametry

*nFirstChar (Powierz)*<br/>
Określa pierwszy znak w kolejnej grupie znaków w bieżącej czcionce.

*nLastChar (OstatniChar)*<br/>
Określa ostatni znak w kolejnej grupie znaków w bieżącej czcionce.

*lpBuffer (lpBuffer)*<br/>
Wskazuje bufor, który będzie odbierał wartości szerokości dla kolejnej grupy znaków w bieżącej czcionce.

*lpFloatBuffer*<br/>
Wskazuje bufor, aby odbierać szerokości znaków. Zwrócone szerokości są w 32-bitowym formacie zmiennoprzecinkowym IEEE. (Szerokości są mierzone wzdłuż linii bazowej znaków).

### <a name="return-value"></a>Wartość zwracana

Różne od zera, jeśli funkcja zakończyła się pomyślnie; w przeciwnym razie 0.

### <a name="remarks"></a>Uwagi

Na przykład jeśli *nFirstChar* identyfikuje literę "a", a *nLastChar* identyfikuje literę "z", funkcja pobiera szerokości wszystkich małych liter.

Funkcja przechowuje wartości w buforze wskazywu przez *lpBuffer*. Ten bufor musi być wystarczająco duży, aby pomieścić wszystkie szerokości. Oznacza to, że musi być co najmniej 26 wpisów w podanym przykładzie.

Jeśli znak w kolejnej grupie znaków nie istnieje w określonej czcionce, zostanie przypisana wartość szerokości znaku domyślnego.

## <a name="cdcgetcharwidthi"></a><a name="getcharwidthi"></a>CDC::GetCharWidthI

Pobiera szerokości, we współrzędnych logicznych, kolejnych indeksów glifów w określonym zakresie od bieżącej czcionki.

```
BOOL GetCharWidthI(
    UINT giFirst,
    UINT cgi,
    LPWORD pgi,
    LPINT lpBuffer) const;
```

### <a name="parameters"></a>Parametry

*giFirst ( giFirst )*<br/>
Określa pierwszy indeks glifów w grupie kolejnych indeksów glifów z bieżącej czcionki. Ten parametr jest używany tylko wtedy, gdy parametr *pgi* ma wartość NULL.

*Grafika komputerowa*<br/>
Określa liczbę indeksów glifów.

*Pgi*<br/>
Wskaźnik do tablicy zawierającej indeksy glifów. Jeśli wartość jest NULL, zamiast tego używany jest parametr *giFirst.* Parametr *cgi* określa liczbę indeksów glifów w tej tablicy.

*lpBuffer (lpBuffer)*<br/>
Wskaźnik do buforu, który odbiera szerokości.

### <a name="return-value"></a>Wartość zwracana

Różne od zera, jeśli funkcja zakończyła się pomyślnie; w przeciwnym razie 0.

### <a name="remarks"></a>Uwagi

Ta funkcja elementu członkowskiego emuluje funkcjonalność funkcji [GetCharWidthI](/windows/win32/api/wingdi/nf-wingdi-getcharwidthi), zgodnie z opisem w windows SDK.

## <a name="cdcgetclipbox"></a><a name="getclipbox"></a>CDC::GetClipBox

Pobiera wymiary najściślejszego prostokąta ograniczającego wokół bieżącej granicy przycinania.

```
virtual int GetClipBox(LPRECT lpRect) const;
```

### <a name="parameters"></a>Parametry

*Lprect*<br/>
Wskazuje na strukturę [RECT](/windows/win32/api/windef/ns-windef-rect) lub obiekt [CRect,](../../atl-mfc-shared/reference/crect-class.md) który ma odbierać wymiary prostokąta.

### <a name="return-value"></a>Wartość zwracana

Typ regionu przycinania. Może to być dowolna z następujących wartości:

- OBSZAR TNĄCEJ OGROM MA nakładające się obramowania.

- BŁĄD Kontekst urządzenia jest nieprawidłowy.

- Region przycinania NULLREGION jest pusty.

- Region prostego przycinania nie ma nakładających się obramowań.

### <a name="remarks"></a>Uwagi

Wymiary są kopiowane do buforu wskazanego przez *lpRect*.

## <a name="cdcgetcoloradjustment"></a><a name="getcoloradjustment"></a>CDC::GetColorAdjustment

Pobiera wartości dopasowania kolorów dla kontekstu urządzenia.

```
BOOL GetColorAdjustment(LPCOLORADJUSTMENT lpColorAdjust) const;
```

### <a name="parameters"></a>Parametry

*lpColorAdjust*<br/>
Wskazuje strukturę danych [COLORADJUSTMENT,](/windows/win32/api/wingdi/ns-wingdi-coloradjustment) aby otrzymać wartości dopasowania kolorów.

### <a name="return-value"></a>Wartość zwracana

Różne od zera, jeśli funkcja zakończyła się pomyślnie; w przeciwnym razie 0.

## <a name="cdcgetcurrentbitmap"></a><a name="getcurrentbitmap"></a>CDC::GetCurrentBitmap

Zwraca wskaźnik do aktualnie `CBitmap` zaznaczonego obiektu.

```
CBitmap* GetCurrentBitmap() const;
```

### <a name="return-value"></a>Wartość zwracana

Wskaźnik do `CBitmap` obiektu, jeśli zakończy się pomyślnie; w przeciwnym razie NULL.

### <a name="remarks"></a>Uwagi

Ta funkcja elementu członkowskiego może zwracać obiekty tymczasowe.

## <a name="cdcgetcurrentbrush"></a><a name="getcurrentbrush"></a>CDC::GetCurrentBrush

Zwraca wskaźnik do aktualnie `CBrush` zaznaczonego obiektu.

```
CBrush* GetCurrentBrush() const;
```

### <a name="return-value"></a>Wartość zwracana

Wskaźnik do `CBrush` obiektu, jeśli zakończy się pomyślnie; w przeciwnym razie NULL.

### <a name="remarks"></a>Uwagi

Ta funkcja elementu członkowskiego może zwracać obiekty tymczasowe.

## <a name="cdcgetcurrentfont"></a><a name="getcurrentfont"></a>CDC::GetCurrentFont

Zwraca wskaźnik do aktualnie `CFont` zaznaczonego obiektu.

```
CFont* GetCurrentFont() const;
```

### <a name="return-value"></a>Wartość zwracana

Wskaźnik do `CFont` obiektu, jeśli zakończy się pomyślnie; w przeciwnym razie NULL.

### <a name="remarks"></a>Uwagi

Ta funkcja elementu członkowskiego może zwracać obiekty tymczasowe.

## <a name="cdcgetcurrentpalette"></a><a name="getcurrentpalette"></a>CDC::GetCurrentPalette

Zwraca wskaźnik do aktualnie `CPalette` zaznaczonego obiektu.

```
CPalette* GetCurrentPalette() const;
```

### <a name="return-value"></a>Wartość zwracana

Wskaźnik do `CPalette` obiektu, jeśli zakończy się pomyślnie; w przeciwnym razie NULL.

### <a name="remarks"></a>Uwagi

Ta funkcja elementu członkowskiego może zwracać obiekty tymczasowe.

## <a name="cdcgetcurrentpen"></a><a name="getcurrentpen"></a>CDC::GetCurrentPen

Zwraca wskaźnik do aktualnie `CPen` zaznaczonego obiektu.

```
CPen* GetCurrentPen() const;
```

### <a name="return-value"></a>Wartość zwracana

Wskaźnik do `CPen` obiektu, jeśli zakończy się pomyślnie; w przeciwnym razie NULL.

### <a name="remarks"></a>Uwagi

Ta funkcja elementu członkowskiego może zwracać obiekty tymczasowe.

## <a name="cdcgetcurrentposition"></a><a name="getcurrentposition"></a>CDC::GetCurrentPosition

Pobiera bieżącą pozycję (we współrzędnych logicznych).

```
CPoint GetCurrentPosition() const;
```

### <a name="return-value"></a>Wartość zwracana

Bieżąca pozycja `CPoint` jako obiekt.

### <a name="remarks"></a>Uwagi

Bieżącą pozycję można ustawić `MoveTo` za pomocą funkcji elementu członkowskiego.

## <a name="cdcgetdcbrushcolor"></a><a name="getdcbrushcolor"></a>CDC::GetDCBrushColor

Pobiera bieżący kolor pędzla.

```
COLORREF GetDCBrushColor() const;
```

### <a name="return-value"></a>Wartość zwracana

Jeśli funkcja powiedzie się, zwracana wartość jest [colorref](/windows/win32/gdi/colorref) wartość dla bieżącego koloru pędzla.

Jeśli funkcja nie powiedzie się, zwracana wartość jest CLR_INVALID.

### <a name="remarks"></a>Uwagi

Ta funkcja elementu członkowskiego emuluje funkcjonalność funkcji [GetDCBrushColor](/windows/win32/api/wingdi/nf-wingdi-getdcbrushcolor), zgodnie z opisem w windows SDK.

## <a name="cdcgetdcpencolor"></a><a name="getdcpencolor"></a>CDC::GetDCPenColor

Pobiera bieżący kolor pióra.

```
COLORREF GetDCPenColor() const;
```

### <a name="return-value"></a>Wartość zwracana

Jeśli funkcja powiedzie się, zwracana wartość jest [colorref](/windows/win32/gdi/colorref) wartość dla bieżącego koloru pióra.

Jeśli funkcja nie powiedzie się, zwracana wartość jest CLR_INVALID.

### <a name="remarks"></a>Uwagi

Ta funkcja elementu członkowskiego korzysta z funkcji Win32 [GetDCPenColor](/windows/win32/api/wingdi/nf-wingdi-getdcpencolor), zgodnie z opisem w windows SDK.

## <a name="cdcgetdevicecaps"></a><a name="getdevicecaps"></a>CDC::GetDeviceCaps

Pobiera szeroki zakres informacji specyficznych dla urządzenia o urządzeniu wyświetlającym.

```
int GetDeviceCaps(int nIndex) const;
```

### <a name="parameters"></a>Parametry

*Nindex*<br/>
Określa typ danych do zwrócenia. Zobacz [GetDeviceCaps](/windows/win32/api/wingdi/nf-wingdi-getdevicecaps) w zestawie Windows SDK, aby uzyskać listę wartości.

### <a name="return-value"></a>Wartość zwracana

Wartość żądanej funkcji, jeśli funkcja zakończy się pomyślnie.

### <a name="example"></a>Przykład

  Zobacz przykład [CPrintDialog::GetDefaults](../../mfc/reference/cprintdialog-class.md#getdefaults).

## <a name="cdcgetfontdata"></a><a name="getfontdata"></a>CDC::GetFontData

Pobiera informacje o metrykach czcionek ze skalowalnego pliku czcionek.

```
DWORD GetFontData(
    DWORD dwTable,
    DWORD dwOffset,
    LPVOID lpData,
    DWORD cbData) const;
```

### <a name="parameters"></a>Parametry

*dwTable (tabela)*<br/>
Określa nazwę tabeli metryk, która ma zostać zwrócona. Ten parametr może być jedną z tabel metrycznych udokumentowanych w specyfikacji plików czcionek TrueType opublikowanej przez firmę Microsoft Corporation. Jeśli ten parametr wynosi 0, informacje są pobierane począwszy od początku pliku czcionki.

*dwOffset (zestaw)*<br/>
Określa przesunięcie od początku tabeli, przy którym należy rozpocząć pobieranie informacji. Jeśli ten parametr jest 0, informacje są pobierane począwszy od początku tabeli określonej przez *dwTable* parametru. Jeśli ta wartość jest większa lub równa rozmiarowi tabeli, `GetFontData` zwraca wartość 0.

*lpData*<br/>
Wskazuje bufor, który będzie otrzymywać informacje o czcionce. Jeśli ta wartość ma wartość NULL, funkcja zwraca rozmiar buforu wymagany dla danych czcionki określonych w parametrze *dwTable.*

*Cbdata*<br/>
Określa długość w bajtach informacji, które mają zostać pobrane. Jeśli ten parametr ma `GetFontData` wartość 0, zwraca rozmiar danych określonych w parametrze *dwTable.*

### <a name="return-value"></a>Wartość zwracana

Określa liczbę bajtów zwracanych w buforze wskazywu przez *lpData,* jeśli funkcja zakończy się pomyślnie; w przeciwnym razie -1.

### <a name="remarks"></a>Uwagi

Informacje do pobrania jest identyfikowany przez określenie przesunięcia do pliku czcionki i długość informacji do zwrócenia.

Aplikacja może czasami `GetFontData` użyć funkcji elementu członkowskiego do zapisania czcionki TrueType z dokumentem. W tym celu aplikacja określa, czy czcionka może być osadzona, a następnie pobiera cały plik czcionki, określając 0 dla parametrów *dwTable*, *dwOffset*i *cbData.*

Aplikacje można określić, czy czcionka `otmfsType` może być osadzona, sprawdzając element członkowski [outlinetextmetric](/windows/win32/api/wingdi/ns-wingdi-outlinetextmetricw) struktury. Jeśli bit 1 `otmfsType` jest ustawiony, osadzanie nie jest dozwolone dla czcionki. Jeśli bit 1 jest przezroczysty, czcionka może być osadzona. Jeśli bit 2 jest ustawiony, osadzanie jest tylko do odczytu.

Jeśli aplikacja próbuje użyć tej funkcji do pobierania informacji dla czcionki non-TrueType, funkcja `GetFontData` elementu członkowskiego zwraca wartość -1.

## <a name="cdcgetfontlanguageinfo"></a><a name="getfontlanguageinfo"></a>CDC::GetFontLanguageInfo

Zwraca informacje o aktualnie wybranej czcionce dla określonego kontekstu wyświetlania.

```
DWORD GetFontLanguageInfo() const;
```

### <a name="return-value"></a>Wartość zwracana

Zwracana wartość identyfikuje charakterystyki aktualnie wybranej czcionki. Aby uzyskać pełną listę możliwych wartości, zobacz [GetFontLanguageInfo](/windows/win32/api/wingdi/nf-wingdi-getfontlanguageinfo).

### <a name="remarks"></a>Uwagi

Ta funkcja elementu członkowskiego emuluje funkcjonalność funkcji [GetFontLanguageInfo](/windows/win32/api/wingdi/nf-wingdi-getfontlanguageinfo), zgodnie z opisem w windows SDK.

## <a name="cdcgetglyphoutline"></a><a name="getglyphoutline"></a>CDC::GetglyphOutline

Pobiera krzywą konspektu lub mapę bitową dla znaku konspektu w bieżącej czcionce.

```
DWORD GetGlyphOutline(
    UINT nChar,
    UINT nFormat,
    LPGLYPHMETRICS lpgm,
    DWORD cbBuffer,
    LPVOID lpBuffer,
    const MAT2* lpmat2) const;
```

### <a name="parameters"></a>Parametry

*Nchar*<br/>
Określa znak, dla którego informacje mają być zwracane.

*nFormat*<br/>
Określa format, w jakim funkcja ma zwracać informacje. Może to być jedna z następujących wartości lub 0:

|Wartość|Znaczenie|
|-----------|-------------|
|GGO_BITMAP|Zwraca mapę bitową glifów. Po powrocie funkcji bufor wskazywowany przez *lpBuffer* zawiera bitmapę 1-bitową na piksel, której wiersze rozpoczynają się od granic dwusłownych.|
|GGO_NATIVE|Zwraca punkty danych krzywej w natywnym formacie rasteryzatora przy użyciu jednostek urządzenia. Po określeniu tej wartości wszelkie transformacje określone w *lpmat2* są ignorowane.|

Gdy wartość *nFormat* jest 0, funkcja wypełnia strukturę [GLIPHMETRICS,](/windows/win32/api/wingdi/ns-wingdi-glyphmetrics) ale nie zwraca danych glifów konspektu.

*lpgm*<br/>
Wskazuje strukturę GLIPHMETRICS, która opisuje położenie glifów w komórce znaków.

*cbBuffer (budynek)*<br/>
Określa rozmiar buforu, do którego funkcja kopiuje informacje o znaku konspektu. Jeśli ta wartość wynosi 0, a parametr *nFormat* jest wartością GGO_BITMAP lub GGO_NATIVE, funkcja zwraca wymagany rozmiar buforu.

*lpBuffer (lpBuffer)*<br/>
Wskazuje bufor, do którego funkcja kopiuje informacje o znaku konspektu. Jeśli *nFormat* określa wartość GGO_NATIVE, informacje są kopiowane w postaci struktur TTPOLYGONHEADER i TTPOLYCURVE. Jeśli ta wartość ma wartość NULL, a *nFormat* jest wartością GGO_BITMAP lub GGO_NATIVE, funkcja zwraca wymagany rozmiar buforu.

*lpmat2*<br/>
Wskazuje strukturę [MAT2,](/windows/win32/api/wingdi/ns-wingdi-mat2) która zawiera macierz transformacji dla znaku. Ten parametr nie może być null, nawet wtedy, gdy wartość GGO_NATIVE jest określona dla *nFormat*.

### <a name="return-value"></a>Wartość zwracana

Rozmiar w bajtach buforu wymaganego dla pobranych informacji, jeśli *cbBuffer* jest 0 lub *lpBuffer* jest NULL. W przeciwnym razie jest to wartość dodatnia, jeśli funkcja zakończy się pomyślnie, lub -1, jeśli występuje błąd.

### <a name="remarks"></a>Uwagi

Aplikacja może obracać znaki pobierane w formacie bitmapowym, określając macierz transformacji 2 na 2 w strukturze wskazywionej przez *lpmat2*.

Kontur glifa jest zwracany jako seria konturów. Każdy kontur jest definiowany przez strukturę [TTPOLYGONHEADER,](/windows/win32/api/wingdi/ns-wingdi-ttpolygonheader) po której następuje tyle `TTPOLYCURVE` struktur, ile jest wymagane do jego opisania. Wszystkie punkty są zwracane jako struktury [POINTFX](/windows/win32/api/wingdi/ns-wingdi-pointfx) i reprezentują pozycje bezwzględne, a nie względne ruchy. Punktem wyjścia podanym `pfxStart` przez element struktury [TTPOLYGONHEADER](/windows/win32/api/wingdi/ns-wingdi-ttpolygonheader) jest punkt, w którym rozpoczyna się kontur konturu. Struktury [TTPOLYCURVE,](/windows/win32/api/wingdi/ns-wingdi-ttpolycurve) które następują, mogą być rekordami polilinii lub splajnem. Rekordy polilinii to seria punktów; linie narysowane między punktami opisują zarys znaku. Rekordy splajnu reprezentują krzywe kwadratowe używane przez TrueType (czyli kwadratowe b-splajny).

## <a name="cdcgetgraphicsmode"></a><a name="getgraphicsmode"></a>CDC::GetGraphicsMode

Pobiera bieżący tryb grafiki dla określonego kontekstu urządzenia.

```
int GetGraphicsMode() const;
```

### <a name="return-value"></a>Wartość zwracana

Zwraca bieżący tryb graficzny po sukcesie. Aby uzyskać listę wartości, które ta metoda może zwrócić, zobacz [GetGraphicsMode](/windows/win32/api/wingdi/nf-wingdi-getgraphicsmode).

Zwraca wartość 0 w przypadku awarii.

Aby uzyskać rozszerzone informacje o błędzie, zadzwoń [do GetLastError](/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror).

### <a name="remarks"></a>Uwagi

Ta metoda zawija funkcję [GetGraphicsMode](/windows/win32/api/wingdi/nf-wingdi-getgraphicsmode)funkcji interfejsu GDI systemu Windows .

## <a name="cdcgethalftonebrush"></a><a name="gethalftonebrush"></a>CDC::GetHalftoneBrush

Wywołanie tej funkcji elementu członkowskiego, aby pobrać pędzel półtonowy.

```
static CBrush* PASCAL GetHalftoneBrush();
```

### <a name="return-value"></a>Wartość zwracana

Wskaźnik do `CBrush` obiektu, jeśli zakończy się pomyślnie; w przeciwnym razie NULL.

### <a name="remarks"></a>Uwagi

Pędzel półtonowy pokazuje piksele, które są na przemian kolorami pierwszego planu i tła, aby utworzyć roztrząsany deseń. Poniżej przedstawiono przykład roztrząsanego wzoru utworzonego przez pędzel półtonowy.

![Szczegóły roztrząsanego pociągnięcia piórem](../../mfc/reference/media/vc318s1.gif "Szczegóły roztrząsanego pociągnięcia piórem")

## <a name="cdcgetkerningpairs"></a><a name="getkerningpairs"></a>CDC::GetKerningPary

Pobiera pary kerningu znaków dla czcionki, która jest aktualnie wybrana w określonym kontekście urządzenia.

```
int GetKerningPairs(
    int nPairs,
    LPKERNINGPAIR lpkrnpair) const;
```

### <a name="parameters"></a>Parametry

*nPary*<br/>
Określa liczbę struktur [KERNINGPAIR](/windows/win32/api/wingdi/ns-wingdi-kerningpair) wskazywali przez *lpkrnpair*. Funkcja nie będzie kopiować więcej par kerningu niż określony przez *nPairs*.

*lpkrnpair*<br/>
Wskazuje tablicę `KERNINGPAIR` struktur, które odbierają pary kerningowe po powrocie funkcji. Ta tablica musi zawierać co najmniej tyle struktur, ile określono w *nPairs*. Jeśli ten parametr ma wartość NULL, funkcja zwraca całkowitą liczbę par kerningu dla czcionki.

### <a name="return-value"></a>Wartość zwracana

Określa liczbę pobranych par kerningu lub całkowitą liczbę par kerningu w czcionce, jeśli funkcja zakończy się pomyślnie. Zero jest zwracany, jeśli funkcja nie powiedzie się lub nie ma żadnych par kerning dla czcionki.

## <a name="cdcgetlayout"></a><a name="getlayout"></a>CDC::GetLayout

Wywołanie tej funkcji elementu członkowskiego, aby określić układ tekstu i grafiki dla kontekstu urządzenia, takich jak drukarka lub metaplik.

```
DWORD GetLayout() const;
```

### <a name="return-value"></a>Wartość zwracana

Jeśli zakończy się pomyślnie, flagi układu dla bieżącego kontekstu urządzenia. W przeciwnym razie GDI_ERROR. Aby uzyskać informacje o błądach rozszerzonych, zadzwoń do [GetLastError](/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror). Aby uzyskać listę flag układu, zobacz [CDC::SetLayout](#setlayout).

### <a name="remarks"></a>Uwagi

Domyślny układ jest od lewej do prawej.

## <a name="cdcgetmapmode"></a><a name="getmapmode"></a>CDC::GetMapMode

Pobiera bieżący tryb mapowania.

```
int GetMapMode() const;
```

### <a name="return-value"></a>Wartość zwracana

Tryb mapowania.

### <a name="remarks"></a>Uwagi

Opis trybów mapowania można znaleźć `SetMapMode` w funkcji elementu członkowskiego.

> [!NOTE]
> Jeśli wywołasz [SetLayout,](#setlayout) aby zmienić układ DC `SetLayout` na układ od prawej do lewej, automatycznie zmieni tryb mapowania na MM_ISOTROPIC. W związku z tym `GetMapMode` każde kolejne wezwanie do powrotu MM_ISOTROPIC.

## <a name="cdcgetmiterlimit"></a><a name="getmiterlimit"></a>CDC::GetMiterLimit

Zwraca limit ścięcie dla kontekstu urządzenia.

```
float GetMiterLimit() const;
```

### <a name="return-value"></a>Wartość zwracana

Różne od zera, jeśli funkcja zakończyła się pomyślnie; w przeciwnym razie 0.

### <a name="remarks"></a>Uwagi

Limit do wiązania jest używany podczas rysowania linii geometrycznych, które mają sprzężenia ścięcie.

## <a name="cdcgetnearestcolor"></a><a name="getnearestcolor"></a>CDC::GetNearestColor

Zwraca jednolity kolor, który najlepiej pasuje do określonego koloru logicznego.

```
COLORREF GetNearestColor(COLORREF crColor) const;
```

### <a name="parameters"></a>Parametry

*CrColor ( kolor)*<br/>
Określa kolor, który ma być dopasowany.

### <a name="return-value"></a>Wartość zwracana

Wartość koloru RGB (czerwony, zielony, niebieski), która definiuje kolor jednolity najbliżej wartości *crColor,* którą urządzenie może reprezentować.

### <a name="remarks"></a>Uwagi

Dane urządzenie musi być w stanie reprezentować ten kolor.

## <a name="cdcgetoutlinetextmetrics"></a><a name="getoutlinetextmetrics"></a>CDC::GetOutlineTextMetrics

Pobiera informacje metryki dla czcionek TrueType.

```
UINT GetOutlineTextMetrics(
    UINT cbData,
    LPOUTLINETEXTMETRIC lpotm) const;
```

### <a name="parameters"></a>Parametry

*lpotm (lpotm)*<br/>
Wskazuje tablicę struktur [OUTLINETEXTMETRIC.](/windows/win32/api/wingdi/ns-wingdi-outlinetextmetricw) Jeśli ten parametr ma wartość NULL, funkcja zwraca rozmiar buforu wymaganego dla pobranych danych metryk.

*Cbdata*<br/>
Określa rozmiar w bajtach buforu, do którego są zwracane informacje.

*lpotm (lpotm)*<br/>
Wskazuje na `OUTLINETEXTMETRIC` strukturę. Jeśli ten parametr ma wartość NULL, funkcja zwraca rozmiar buforu wymaganego dla pobranych informacji metrycznych.

### <a name="return-value"></a>Wartość zwracana

Różne od zera, jeśli funkcja zakończyła się pomyślnie; w przeciwnym razie 0.

### <a name="remarks"></a>Uwagi

Struktura [OUTLINETEXTMETRIC](/windows/win32/api/wingdi/ns-wingdi-outlinetextmetricw) zawiera większość informacji metrycznych czcionek dostarczanych z formatem TrueType, w tym strukturę [TEXTMETRIC.](/windows/win32/api/wingdi/ns-wingdi-textmetricw) Ostatnie cztery elementy `OUTLINETEXTMETRIC` członkowskie struktury są wskaźniki do ciągów. Aplikacje należy przydzielić miejsce dla tych ciągów oprócz miejsca wymaganego dla innych elementów członkowskich. Ponieważ nie ma limitu narzuconego przez system rozmiaru ciągów, najprostszą metodą przydzielania pamięci jest pobranie wymaganego rozmiaru przez określenie `GetOutlineTextMetrics` wartości NULL dla *lpotm* w pierwszym wywołaniu funkcji.

## <a name="cdcgetoutputcharwidth"></a><a name="getoutputcharwidth"></a>CDC::GetOutputCharWidth

Używa kontekstu `m_hDC`urządzenia wyjściowego i pobiera szerokości poszczególnych znaków w kolejnej grupie znaków z bieżącej czcionki.

```
BOOL GetOutputCharWidth(
    UINT nFirstChar,
    UINT nLastChar,
    LPINT lpBuffer) const;
```

### <a name="parameters"></a>Parametry

*nFirstChar (Powierz)*<br/>
Określa pierwszy znak w kolejnej grupie znaków w bieżącej czcionce.

*nLastChar (OstatniChar)*<br/>
Określa ostatni znak w kolejnej grupie znaków w bieżącej czcionce.

*lpBuffer (lpBuffer)*<br/>
Wskazuje bufor, który będzie odbierał wartości szerokości dla kolejnej grupy znaków w bieżącej czcionce.

### <a name="return-value"></a>Wartość zwracana

Różne od zera, jeśli funkcja zakończyła się pomyślnie; w przeciwnym razie 0.

### <a name="remarks"></a>Uwagi

Na przykład jeśli *nFirstChar* identyfikuje literę "a", a *nLastChar* identyfikuje literę "z", funkcja pobiera szerokości wszystkich małych liter.

Funkcja przechowuje wartości w buforze wskazywu przez *lpBuffer*. Ten bufor musi być wystarczająco duży, aby pomieścić wszystkie szerokości; oznacza to, że musi być co najmniej 26 wpisów w podanym przykładzie.

Jeśli znak w kolejnej grupie znaków nie istnieje w określonej czcionce, zostanie przypisana wartość szerokości znaku domyślnego.

## <a name="cdcgetoutputtabbedtextextent"></a><a name="getoutputtabbedtextextent"></a>CDC::GetOutputTabbedTextEkten

Wywołanie tej funkcji elementu członkowskiego, aby obliczyć szerokość i wysokość ciągu znaków przy użyciu [m_hDC](#m_hdc), kontekstu urządzenia wyjściowego.

```
CSize GetOutputTabbedTextExtent(
    LPCTSTR lpszString,
    int nCount,
    int nTabPositions,
    LPINT lpnTabStopPositions) const;

CSize GetOutputTabbedTextExtent(
    const CString& str,
    int nTabPositions,
    LPINT lpnTabStopPositions) const;
```

### <a name="parameters"></a>Parametry

*lpszString*<br/>
Wskazuje ciąg znaków, który ma być mierzony. Można również przekazać [CString](../../atl-mfc-shared/reference/cstringt-class.md) obiektu dla tego parametru.

*Ncount*<br/>
Określa [długość ciągu](/windows/win32/gdi/specifying-length-of-text-output-string) wskazywania przez *lpszString*.

*nNazyty*<br/>
Określa liczbę pozycji tabulatora w tablicy wskazywania przez *lpnTabStopPositions*.

*lpnTabStopPositions*<br/>
Wskazuje tablicę liczby całkowitych zawierającą pozycje tabulatora w jednostkach logicznych. Tabulatory muszą być sortowane w kolejności rosnącej; najmniejsza wartość x powinna być pierwszym elementem w tablicy. Karty wsteczne nie są dozwolone.

*Str*<br/>
Obiekt `CString` zawierający określone znaki, które mają być mierzone.

### <a name="return-value"></a>Wartość zwracana

Wymiary ciągu (w jednostkach logicznych) w obiekcie [CSize.](../../atl-mfc-shared/reference/csize-class.md)

### <a name="remarks"></a>Uwagi

Jeśli ciąg zawiera jeden lub więcej znaków karty, szerokość ciągu jest oparta na tabulatorach określonych przez *lpnTabStopPositions*. Funkcja używa aktualnie wybranej czcionki do obliczania wymiarów ciągu.

Bieżący obszar przycinania nie odsuń `GetOutputTabbedTextExtent` szerokości i wysokości zwróconej przez funkcję.

Ponieważ niektóre urządzenia nie umieszczają znaków w regularnych tablicach komórek (oznacza to, że kernują znaki), suma zakresów znaków w ciągu może nie być równa zakresowi ciągu.

Jeśli *nTabPositions* jest 0 i *lpnTabStopPositions* jest NULL, karty są rozwijane do ośmiu średnich szerokości znaków. Jeśli *nTabPositions* jest 1, tabulatorów zostanie oddzielona przez odległość określoną przez pierwszą wartość w tablicy, do której *lpnTabStopPositions* punktów. Jeśli *lpnTabStopPositions* wskazuje więcej niż jedną wartość, tabulator jest ustawiany dla każdej wartości w tablicy, do liczby określonej przez *nTabPositions*.

## <a name="cdcgetoutputtextextent"></a><a name="getoutputtextextent"></a>CDC::GetOutputTextEkstent

Wywołanie tej funkcji elementu członkowskiego, aby użyć kontekstu urządzenia wyjściowego, [m_hDC](#m_hdc)i obliczyć szerokość i wysokość wiersza tekstu, przy użyciu bieżącej czcionki.

```
CSize GetOutputTextExtent(
    LPCTSTR lpszString,
    int nCount) const;

CSize GetOutputTextExtent(const CString& str) const;
```

### <a name="parameters"></a>Parametry

*lpszString*<br/>
Wskazuje ciąg znaków. Można również przekazać [CString](../../atl-mfc-shared/reference/cstringt-class.md) obiektu dla tego parametru.

*Ncount*<br/>
Określa [długość ciągu](/windows/win32/gdi/specifying-length-of-text-output-string) wskazywania przez *lpszString*.

*Str*<br/>
Obiekt `CString` zawierający określone znaki, które mają być mierzone.

### <a name="return-value"></a>Wartość zwracana

Wymiary ciągu (w jednostkach logicznych) zwrócone w [obiekcie CSize.](../../atl-mfc-shared/reference/csize-class.md)

### <a name="remarks"></a>Uwagi

Bieżący obszar przycinania nie wpływa na `GetOutputTextExtent`szerokość i wysokość zwracaną przez program .

Ponieważ niektóre urządzenia nie umieszczają znaków w regularnych tablicach komórek (oznacza to, że przeprowadzają kerning), suma zakresów znaków w ciągu może nie być równa zakresowi ciągu.

## <a name="cdcgetoutputtextmetrics"></a><a name="getoutputtextmetrics"></a>CDC::GetOutputTextMetrics

Pobiera metryki dla bieżącej `m_hDC`czcionki przy użyciu kontekstu urządzenia wyjściowego.

```
BOOL GetOutputTextMetrics(LPTEXTMETRIC lpMetrics) const;
```

### <a name="parameters"></a>Parametry

*lpMetrics (lpMetrics)*<br/>
Wskazuje na [textmetric](/windows/win32/api/wingdi/ns-wingdi-textmetricw) struktury, która odbiera metryki.

### <a name="return-value"></a>Wartość zwracana

Różne od zera, jeśli funkcja zakończyła się pomyślnie; w przeciwnym razie 0.

## <a name="cdcgetpath"></a><a name="getpath"></a>CDC::GetPath

Pobiera współrzędne definiujące punkty końcowe linii i punkty kontrolne krzywych znalezione w ścieżce wybranej w kontekście urządzenia.

```
int GetPath(
    LPPOINT lpPoints,
    LPBYTE lpTypes,
    int nCount) const;
```

### <a name="parameters"></a>Parametry

*lpPunkty*<br/>
Wskazuje tablicę [POINT](/windows/win32/api/windef/ns-windef-point) struktur danych POINT `CPoint` lub obiektów, w których są umieszczane punkty końcowe linii i punkty kontrolne krzywej.

*lpTyty*<br/>
Wskazuje tablicę bajtów, w której są umieszczane typy wierzchołków. Wartości są jedną z następujących wartości:

- PT_MOVETO Określa, że odpowiedni punkt w *lpPoints* rozpoczyna rozłączną figurę.

- PT_LINETO Określa, że poprzedni punkt i odpowiadający mu punkt w *punktach lpPoints* są punktami końcowymi wiersza.

- PT_BEZIERTO Określa, że odpowiedni punkt w *punktach lppoints* jest punktem kontrolnym lub punktem końcowym dla krzywej Bziera.

typy PT_BEZIERTO zawsze występują w zestawach trzech. Punkt na ścieżce bezpośrednio poprzedzającej je definiuje punkt początkowy krzywej Bziera. Pierwsze dwa punkty PT_BEZIERTO są punktami kontrolnymi, a trzeci punkt PT_BEZIERTO jest punktem końcowym (jeśli zakodowane na twardo).

   Typ PT_LINETO lub PT_BEZIERTO może być połączony z następującą flagą (za pomocą operatora bitowego **OR),** aby wskazać, że odpowiedni punkt jest ostatnim punktem na rysunku i że rysunek powinien zostać zamknięty:

- PT_CLOSEFIGURE Określa, że rysunek jest automatycznie zamykany po narysowaniu odpowiedniej linii lub krzywej. Rysunek jest zamykany przez narysowanie linii od punktu końcowego linii lub krzywej do punktu odpowiadającego ostatniemu PT_MOVETO.

*Ncount*<br/>
Określa całkowitą liczbę struktur danych [POINT,](/windows/win32/api/windef/ns-windef-point) które mogą być umieszczane w *tablicy lpPoints.* Ta wartość musi być taka sama jak liczba bajtów, które mogą być umieszczone w *tablicy lpTypes.*

### <a name="return-value"></a>Wartość zwracana

Jeśli parametr *nCount* niezerowy, liczba punktów wyliczona. Jeśli *nCount* wynosi 0, całkowita liczba punktów `GetPath` w ścieżce (i zapisuje nic do buforów). Jeśli *nCount* jest niezerowy i jest mniejsza niż liczba punktów w ścieżce, zwracana wartość wynosi -1.

### <a name="remarks"></a>Uwagi

Kontekst urządzenia musi zawierać zamkniętą ścieżkę. Punkty ścieżki są zwracane we współrzędnych logicznych. Punkty są przechowywane w ścieżce we `GetPath` współrzędnych urządzenia, więc zmienia punkty ze współrzędnych urządzenia na współrzędne logiczne przy użyciu odwrotności bieżącej transformacji. Funkcja `FlattenPath` elementu członkowskiego może `GetPath`być wywoływana przed , aby przekonwertować wszystkie krzywe w ścieżce na segmenty linii.

### <a name="example"></a>Przykład

  Zobacz przykład [cdc::BeginPath](#beginpath).

## <a name="cdcgetpixel"></a><a name="getpixel"></a>CDC::GetPixel

Pobiera wartość koloru RGB piksela w punkcie określonym przez *x* i *y*.

```
COLORREF GetPixel(
    int x,
    int y) const;

COLORREF GetPixel(POINT point) const;
```

### <a name="parameters"></a>Parametry

*X*<br/>
Określa logiczną współrzędną x badanego punktu.

*Y*<br/>
Określa logiczną współrzędną y badanego punktu.

*Punkt*<br/>
Określa logiczne współrzędne x- i y badanego punktu.

### <a name="return-value"></a>Wartość zwracana

Dla każdej wersji funkcji wartość koloru RGB dla koloru danego punktu. Jest -1, jeśli współrzędne nie określają punktu w regionie przycinania.

### <a name="remarks"></a>Uwagi

Punkt musi znajdować się w regionie przycinania. Jeśli punkt nie znajduje się w regionie przycinania, funkcja nie ma wpływu i zwraca -1.

Nie wszystkie urządzenia `GetPixel` obsługują tę funkcję. Aby uzyskać więcej informacji, zobacz RC_BITBLT możliwości rastrowe w ramach funkcji członkowskiej [GetDeviceCaps.](#getdevicecaps)

Funkcja `GetPixel` elementu członkowskiego ma dwa formularze. Pierwsza przyjmuje dwie wartości współrzędnych; drugi przyjmuje strukturę [POINT](/windows/win32/api/windef/ns-windef-point) lub [CPoint.](../../atl-mfc-shared/reference/cpoint-class.md)

## <a name="cdcgetpolyfillmode"></a><a name="getpolyfillmode"></a>CDC::GetPolyFillMode

Pobiera bieżący tryb wypełniania wielokątów.

```
int GetPolyFillMode() const;
```

### <a name="return-value"></a>Wartość zwracana

Bieżący tryb wypełniony wielokątami, ALTERNATE lub KRĘTY, jeśli funkcja zakończy się pomyślnie.

### <a name="remarks"></a>Uwagi

Opis `SetPolyFillMode` trybów wypełniania wielokątów można znaleźć w funkcji elementu członkowskiego.

## <a name="cdcgetrop2"></a><a name="getrop2"></a>CDC::GetROP2

Pobiera bieżący tryb rysowania.

```
int GetROP2() const;
```

### <a name="return-value"></a>Wartość zwracana

Tryb rysowania. Aby uzyskać listę wartości trybu rysowania, zobacz funkcję `SetROP2` elementu członkowskiego.

### <a name="remarks"></a>Uwagi

Tryb rysowania określa sposób łączenia kolorów pióra i wnętrza wypełnionych obiektów z kolorem znajdującym się już na powierzchni wyświetlacza.

## <a name="cdcgetsafehdc"></a><a name="getsafehdc"></a>CDC::GetSafeHdc

Wywołanie tej funkcji elementu członkowskiego, aby uzyskać [m_hDC](#m_hdc), kontekst urządzenia wyjściowego.

```
HDC GetSafeHdc() const;
```

### <a name="return-value"></a>Wartość zwracana

Dojście kontekstu urządzenia.

### <a name="remarks"></a>Uwagi

Ta funkcja elementu członkowskiego działa również ze wskaźnikami null.

## <a name="cdcgetstretchbltmode"></a><a name="getstretchbltmode"></a>CDC::GetStretchBltMode

Pobiera bieżący tryb rozciągania mapy bitowej.

```
int GetStretchBltMode() const;
```

### <a name="return-value"></a>Wartość zwracana

Zwracana wartość określa bieżący tryb rozciągania mapy bitowej — STRETCH_ANDSCANS, STRETCH_DELETESCANS lub STRETCH_ORSCANS — jeśli funkcja zakończy się pomyślnie.

### <a name="remarks"></a>Uwagi

Tryb rozciągania mapy bitowej definiuje sposób usuwania informacji z map bitowych `StretchBlt` rozciągniętych lub kompresowanych przez funkcję elementu członkowskiego.

Tryby STRETCH_ANDSCANS i STRETCH_ORSCANS są zwykle używane do zachowywania pikseli pierwszego planu w monochromatycznych mapach bitowych. Tryb STRETCH_DELETESCANS jest zwykle używany do zachowania koloru w kolorowych mapach bitowych.

## <a name="cdcgettabbedtextextent"></a><a name="gettabbedtextextent"></a>CDC::GetTabbedTextEkten

Wywołanie tej funkcji elementu członkowskiego, aby obliczyć szerokość i wysokość ciągu znaków przy użyciu [m_hAttribDC](#m_hattribdc), kontekstu urządzenia atrybutu.

```
CSize GetTabbedTextExtent(
    LPCTSTR lpszString,
    int nCount,
    int nTabPositions,
    LPINT lpnTabStopPositions) const;

CSize GetTabbedTextExtent(
    const CString& str,
    int nTabPositions,
    LPINT lpnTabStopPositions) const;
```

### <a name="parameters"></a>Parametry

*lpszString*<br/>
Wskazuje ciąg znaków. Można również przekazać [CString](../../atl-mfc-shared/reference/cstringt-class.md) obiektu dla tego parametru.

*Ncount*<br/>
Określa [długość ciągu](/windows/win32/gdi/specifying-length-of-text-output-string) wskazywania przez *lpszString*.

*nNazyty*<br/>
Określa liczbę pozycji tabulatora w tablicy wskazywania przez *lpnTabStopPositions*.

*lpnTabStopPositions*<br/>
Wskazuje tablicę liczby całkowitych zawierającą pozycje tabulatora w jednostkach logicznych. Tabulatory muszą być sortowane w kolejności rosnącej; najmniejsza wartość x powinna być pierwszym elementem w tablicy. Karty wsteczne nie są dozwolone.

*Str*<br/>
Obiekt, `CString` który zawiera określone znaki do narysowania.

### <a name="return-value"></a>Wartość zwracana

Wymiary ciągu (w jednostkach logicznych) w obiekcie [CSize.](../../atl-mfc-shared/reference/csize-class.md)

### <a name="remarks"></a>Uwagi

Jeśli ciąg zawiera jeden lub więcej znaków karty, szerokość ciągu jest oparta na tabulatorach określonych przez *lpnTabStopPositions*. Funkcja używa aktualnie wybranej czcionki do obliczania wymiarów ciągu.

Bieżący obszar przycinania nie odsuń `GetTabbedTextExtent` szerokości i wysokości zwróconej przez funkcję.

Ponieważ niektóre urządzenia nie umieszczają znaków w regularnych tablicach komórek (oznacza to, że kernują znaki), suma zakresów znaków w ciągu może nie być równa zakresowi ciągu.

Jeśli *nTabPositions* jest 0 i *lpnTabStopPositions* jest NULL, karty są rozwijane do ośmiu razy średniej szerokości znaku. Jeśli *nTabPositions* jest 1, tabulatorów zostanie oddzielona przez odległość określoną przez pierwszą wartość w tablicy, do której *lpnTabStopPositions* punktów. Jeśli *lpnTabStopPositions* wskazuje więcej niż jedną wartość, tabulator jest ustawiany dla każdej wartości w tablicy, do liczby określonej przez *nTabPositions*.

## <a name="cdcgettextalign"></a><a name="gettextalign"></a>CDC::GetTextAlign

Pobiera stan flagi wyrównania tekstu dla kontekstu urządzenia.

```
UINT GetTextAlign() const;
```

### <a name="return-value"></a>Wartość zwracana

Stan flagi wyrównania tekstu. Zwracana wartość jest jedną lub kilkoma z następujących wartości:

- TA_BASELINE Określa wyrównanie osi x i linii bazowej wybranej czcionki w prostokątze obwiedni.

- TA_BOTTOM Określa wyrównanie osi x i dolnej części prostokąta ograniczającego.

- TA_CENTER Określa wyrównanie osi y i środka prostokąta ograniczającego.

- TA_LEFT Określa wyrównanie osi y i lewej strony prostokąta ograniczającego.

- TA_NOUPDATECP Określa, że bieżąca pozycja nie jest aktualizowana.

- TA_RIGHT Określa wyrównanie osi y i prawej strony prostokąta ograniczającego.

- TA_TOP Określa wyrównanie osi x i górnej części prostokąta ograniczającego.

- TA_UPDATECP Określa, że bieżąca pozycja jest aktualizowana.

### <a name="remarks"></a>Uwagi

Flagi wyrównania tekstu określają, jak funkcje `TextOut` i `ExtTextOut` element członkowski wyrównują ciąg tekstu w stosunku do punktu początkowego ciągu. Flagi wyrównania tekstu nie muszą być flagami jednobitowymi i mogą być równe 0. Aby sprawdzić, czy flaga jest ustawiona, aplikacja powinna wykonać następujące kroki:

1. Zastosuj operator or bitowym do flagi i powiązanych z nią flag, pogrupowanych w następujący sposób:

   - TA_LEFT, TA_CENTER i TA_RIGHT

   - TA_BASELINE, TA_BOTTOM i TA_TOP

   - TA_NOUPDATECP i TA_UPDATECP

1. Zastosuj operator bitowy-AND do wyniku i `GetTextAlign`wartości zwracanej .

1. Test pod kątem równości tego wyniku i flagi.

## <a name="cdcgettextcharacterextra"></a><a name="gettextcharacterextra"></a>CDC::GetTextCharacterExtra

Pobiera bieżące ustawienie dla ilości odstępów międzyzachakami.

```
int GetTextCharacterExtra() const;
```

### <a name="return-value"></a>Wartość zwracana

Ilość odstępów międzycharakterowych.

### <a name="remarks"></a>Uwagi

GDI dodaje te odstępy do każdego znaku, w tym znaków przerwania, gdy zapisuje wiersz tekstu do kontekstu urządzenia.

Wartość domyślna dla kwoty odstępów międzycharakterowych wynosi 0.

## <a name="cdcgettextcolor"></a><a name="gettextcolor"></a>CDC::GetTextColor

Pobiera bieżący kolor tekstu.

```
COLORREF GetTextColor() const;
```

### <a name="return-value"></a>Wartość zwracana

Bieżący kolor tekstu jako wartość koloru RGB.

### <a name="remarks"></a>Uwagi

Kolor tekstu jest kolorem pierwszego planu znaków rysowanych przy użyciu funkcji członkowskich wyjścia tekstu GDI [TextOut](#textout), [ExtTextOut](#exttextout)i [TabbedTextOut](#tabbedtextout).

## <a name="cdcgettextextent"></a><a name="gettextextent"></a>CDC::GetTextExtent

Wywołanie tej funkcji elementu członkowskiego, aby obliczyć szerokość i wysokość wiersza tekstu przy użyciu bieżącej czcionki w celu określenia wymiarów.

```
CSize GetTextExtent(
    LPCTSTR lpszString,
    int nCount) const;

CSize GetTextExtent(const CString& str) const;
```

### <a name="parameters"></a>Parametry

*lpszString*<br/>
Wskazuje ciąg znaków. Można również przekazać [CString](../../atl-mfc-shared/reference/cstringt-class.md) obiektu dla tego parametru.

*Ncount*<br/>
Określa liczbę znaków w ciągu.

*Str*<br/>
Obiekt, `CString` który zawiera określone znaki.

### <a name="return-value"></a>Wartość zwracana

Wymiary ciągu (w jednostkach logicznych) w obiekcie [CSize.](../../atl-mfc-shared/reference/csize-class.md)

### <a name="remarks"></a>Uwagi

Informacje są pobierane z [m_hAttribDC](#m_hattribdc), kontekstu urządzenia atrybutu.

Domyślnie `GetTextExtent` przyjmuje się, że tekst, dla którego pobiera wymiar jest ustawiony wzdłuż linii poziomej (oznacza to, że wychwyt wynosi 0). W przypadku tworzenia czcionki określającej wychwyt niezerowy, należy przekonwertować kąt tekstu jawnie, aby uzyskać wymiary ciągu.

Bieżący obszar przycinania nie wpływa na `GetTextExtent`szerokość i wysokość zwracaną przez program .

Ponieważ niektóre urządzenia nie umieszczają znaków w regularnych tablicach komórek (oznacza to, że przeprowadzają kerning), suma zakresów znaków w ciągu może nie być równa zakresowi ciągu.

## <a name="cdcgettextextentexpointi"></a><a name="gettextextentexpointi"></a>CDC::GetTextExtentExPointI

Pobiera liczbę znaków w określonym ciągu, który zmieści się w określonym miejscu i wypełnia tablicę zakresem tekstu dla każdego z tych znaków.

```
BOOL GetTextExtentExPointI(
    LPWORD pgiIn,
    int cgi,
    int nMaxExtent,
    LPINT lpnFit,
    LPINT alpDx,
    LPSIZE lpSize) const;
```

### <a name="parameters"></a>Parametry

*pgiIn ( pgiIn )*<br/>
Wskaźnik do tablicy indeksów glifów, dla których zakresy mają być pobierane.

*Grafika komputerowa*<br/>
Określa liczbę glifów w tablicy wskazywalnej przez *pgiIn*.

*nMaxExtent (Polski)*<br/>
Określa maksymalną dopuszczalną szerokość sformatowanego ciągu w jednostkach logicznych.

*lpnDopas dopasuj*<br/>
Wskaźnik do liczby całkowitej, która odbiera liczbę maksymalnej liczby znaków, które zmieszczą się w przestrzeni określonej przez *nMaxExtent*. Gdy *lpnFit* ma wartość NULL, *nMaxExtent* jest ignorowany.

*alpDx ( alpDx )*<br/>
Wskaźnik do tablicy liczby całkowitych, która odbiera częściowe zakresy glifów. Każdy element w tablicy daje odległość, w jednostkach logicznych, między początkiem tablicy indeksów glifów a jednym z glifów, który mieści się w przestrzeni określonej przez *nMaxExtent*. Chociaż ta tablica powinna mieć co najmniej tyle elementów, co indeksy glifów określone przez *cgi,* funkcja wypełnia tablicę zakresami tylko dla tylu indeksów glifów, ile jest określonych przez *lpnFit*. Jeśli *lpnDx* ma wartość NULL, funkcja nie oblicza częściowych szerokości ciągu.

*lpSize (rozmiar)*<br/>
Wskaźnik do [struktury SIZE,](/windows/win32/api/windef/ns-windef-size) która odbiera wymiary tablicy indeksów glifów w jednostkach logicznych. Ta wartość nie może być null.

### <a name="return-value"></a>Wartość zwracana

Różne od zera, jeśli funkcja zakończyła się pomyślnie; w przeciwnym razie 0.

### <a name="remarks"></a>Uwagi

Ta funkcja elementu członkowskiego emuluje funkcjonalność funkcji [GetTextExtentExPointI](/windows/win32/api/wingdi/nf-wingdi-gettextextentexpointi), zgodnie z opisem w windows SDK.

## <a name="cdcgettextextentpointi"></a><a name="gettextextentpointi"></a>CDC::GetTextExtentPointI

Pobiera szerokość i wysokość określonej tablicy indeksów glifów.

```
BOOL GetTextExtentPointI(
    LPWORD pgiIn,
    int cgi,
    LPSIZE lpSize) const;
```

### <a name="parameters"></a>Parametry

*pgiIn ( pgiIn )*<br/>
Wskaźnik do tablicy indeksów glifów, dla których zakresy mają być pobierane.

*Grafika komputerowa*<br/>
Określa liczbę glifów w tablicy wskazywalnej przez *pgiIn*.

*lpSize (rozmiar)*<br/>
Wskaźnik do [struktury SIZE,](/windows/win32/api/windef/ns-windef-size) która odbiera wymiary tablicy indeksów glifów w jednostkach logicznych. Ta wartość nie może być null.

### <a name="return-value"></a>Wartość zwracana

Różne od zera, jeśli funkcja zakończyła się pomyślnie; w przeciwnym razie 0.

### <a name="remarks"></a>Uwagi

Ta funkcja elementu członkowskiego emuluje funkcjonalność funkcji [GetTextExtentPointI](/windows/win32/api/wingdi/nf-wingdi-gettextextentpointi), zgodnie z opisem w windows SDK.

## <a name="cdcgettextface"></a><a name="gettextface"></a>CDC::GetTextFace

Wywołanie tej funkcji elementu członkowskiego, aby skopiować nazwę czcionki bieżącej czcionki do buforu.

```
int GetTextFace(
    int nCount,
    LPTSTR lpszFacename) const;

int GetTextFace(CString& rString) const;
```

### <a name="parameters"></a>Parametry

*Ncount*<br/>
Określa rozmiar buforu (w bajtach). Jeśli nazwa kroju pisma jest dłuższa niż liczba bajtów określona przez ten parametr, nazwa jest obcinana.

*lpszNazeń*<br/>
Wskazuje bufor dla nazwy kroju pisma.

*rString*<br/>
Odwołanie do [CString](../../atl-mfc-shared/reference/cstringt-class.md) obiektu.

### <a name="return-value"></a>Wartość zwracana

Liczba bajtów skopiowanych do buforu, z wyłączeniem kończącego się znaku null. Jest 0, jeśli wystąpi błąd.

### <a name="remarks"></a>Uwagi

Nazwa kroju pisma jest kopiowana jako ciąg zakończony z wartością null.

## <a name="cdcgettextmetrics"></a><a name="gettextmetrics"></a>CDC::GetTextMetrics

Pobiera metryki dla bieżącej czcionki przy użyciu kontekstu urządzenia atrybutu.

```
BOOL GetTextMetrics(LPTEXTMETRIC lpMetrics) const;
```

### <a name="parameters"></a>Parametry

*lpMetrics (lpMetrics)*<br/>
Wskazuje na [textmetric](/windows/win32/api/wingdi/ns-wingdi-textmetricw) struktury, która odbiera metryki.

### <a name="return-value"></a>Wartość zwracana

Różne od zera, jeśli funkcja zakończyła się pomyślnie; w przeciwnym razie 0.

## <a name="cdcgetviewportext"></a><a name="getviewportext"></a>CDC::GetViewportext

Pobiera zakresy x i y rzutni kontekstu urządzenia.

```
CSize GetViewportExt() const;
```

### <a name="return-value"></a>Wartość zwracana

Zakresy x i y (w jednostkach `CSize` urządzenia) jako obiekt.

## <a name="cdcgetviewportorg"></a><a name="getviewportorg"></a>CDC::GetViewportOrg

Pobiera współrzędne x i y pochodzenia rzutni skojarzonej z kontekstem urządzenia.

```
CPoint GetViewportOrg() const;
```

### <a name="return-value"></a>Wartość zwracana

Początek rzutni (we współrzędnych `CPoint` urządzenia) jako obiektu.

## <a name="cdcgetwindow"></a><a name="getwindow"></a>CDC::GetWindow

Zwraca okno skojarzone z kontekstem urządzenia wyświetlającego.

```
CWnd* GetWindow() const;
```

### <a name="return-value"></a>Wartość zwracana

Wskaźnik do `CWnd` obiektu, jeśli zakończy się pomyślnie; w przeciwnym razie NULL.

### <a name="remarks"></a>Uwagi

Jest to funkcja zaawansowana. Na przykład ta funkcja elementu członkowskiego może nie zwracać okna widoku podczas drukowania lub podglądu wydruku. Zawsze zwraca okno skojarzone z wyjściem. Funkcje wyjściowe, które używają danego kontrolera domeny wyciągnąć w tym oknie.

## <a name="cdcgetwindowext"></a><a name="getwindowext"></a>CDC::GetWindowExt

Pobiera zakresy x i y okna skojarzone z kontekstem urządzenia.

```
CSize GetWindowExt() const;
```

### <a name="return-value"></a>Wartość zwracana

Zakresy x i y (w jednostkach `CSize` logicznych) jako obiekt.

## <a name="cdcgetwindoworg"></a><a name="getwindoworg"></a>CDC::GetWindowOrg

Pobiera współrzędne x i y pochodzenia okna skojarzonego z kontekstem urządzenia.

```
CPoint GetWindowOrg() const;
```

### <a name="return-value"></a>Wartość zwracana

Początek okna (we współrzędnych `CPoint` logicznych) jako obiektu.

## <a name="cdcgetworldtransform"></a><a name="getworldtransform"></a>CDC::GetWorldTransform

Pobiera bieżącą przestrzeń świata do transformacji przestrzeni strony.

```
BOOL GetWorldTransform(XFORM& rXform) const;
```

### <a name="parameters"></a>Parametry

*rXform*<br/>
Odwołanie do struktury [XFORM,](/windows/win32/api/wingdi/ns-wingdi-xform) która odbiera bieżącą przestrzeń świata do transformacji przestrzeni strony.

### <a name="return-value"></a>Wartość zwracana

Zwraca wartość niezerową na sukces.

Zwraca wartość 0 w przypadku awarii.

Aby uzyskać rozszerzone informacje o błędzie, zadzwoń [do GetLastError](/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror).

### <a name="remarks"></a>Uwagi

Ta metoda zawija funkcję Windows GDI [GetWorldTransform](/windows/win32/api/wingdi/nf-wingdi-getworldtransform).

## <a name="cdcgradientfill"></a><a name="gradientfill"></a>CDC::GradientFill

Wywołanie tej funkcji elementu członkowskiego, aby wypełnić prostokąt i trójkąt struktur kolorem, który płynnie zanika z jednej strony na drugą.

```
BOOL GradientFill(
    TRIVERTEX* pVertices,
    ULONG nVertices,
    void* pMesh,
    ULONG nMeshElements,
    DWORD dwMode);
```

### <a name="parameters"></a>Parametry

*pVertices*<br/>
Wskaźnik do tablicy struktur [TRIVERTEX,](/windows/win32/api/wingdi/ns-wingdi-trivertex) które z każdym definiują wierzchołek trójkąta.

*nVertices*<br/>
Liczba wierzchołków.

*pMesh (własówce)*<br/>
Tablica [struktur GRADIENT_TRIANGLE](/windows/win32/api/wingdi/ns-wingdi-gradient_triangle) w trybie trójkątnym lub tablica struktur [GRADIENT_RECT](/windows/win32/api/wingdi/ns-wingdi-gradient_rect) w trybie prostokąta.

*nMeshElements ( MeshElements )*<br/>
Liczba elementów (trójkątów lub prostokątów) w *pMesh*.

*dwMode (tryb)*<br/>
Określa tryb wypełnienia gradientowego. Aby uzyskać listę możliwych wartości, zobacz [GradientFill](/windows/win32/api/wingdi/nf-wingdi-gradientfill) w zestawie Windows SDK.

### <a name="return-value"></a>Wartość zwracana

PRAWDA, jeśli się powiedzie; w przeciwnym razie FALSE.

### <a name="remarks"></a>Uwagi

Aby uzyskać więcej `GradientFill` informacji, zobacz w windows SDK.

## <a name="cdcgraystring"></a><a name="graystring"></a>CDC::GrayString

Rysuje wygaszony (szary) tekst w danym miejscu, zapisując tekst w mapie bitowej pamięci, ściemniając mapę bitową, a następnie kopiując mapę bitową na ekran.

```
virtual BOOL GrayString(
    CBrush* pBrush,
    BOOL (CALLBACK* lpfnOutput)(
    HDC,
    LPARAM,
    int),
    LPARAM lpData,
    int nCount,
    int x,
    int y,
    int nWidth,
    int nHeight);
```

### <a name="parameters"></a>Parametry

*pBrush (pędzel)*<br/>
Identyfikuje pędzel, który ma być używany do ściemniania (siwienie).

*lpfnOutput*<br/>
Określa adres wystąpienia procedury funkcji wywołania zwrotnego dostarczonej przez aplikację, która będzie rysować ciąg. Aby uzyskać więcej informacji, zobacz `OutputFunc` opis [funkcji wywołania zwrotnego](callback-functions-used-by-mfc.md#graystring)systemu Windows . Jeśli ten parametr ma wartość NULL, `TextOut` system używa funkcji systemu Windows do rysowania ciągu, a *lpData* jest uważany za długi wskaźnik do ciągu znaków, który ma być wyjściowy.

*lpData*<br/>
Określa wskaźnik dalekiego wskaźnika do danych, które mają być przekazywane do funkcji wyjściowej. Jeśli *lpfnOutput* ma wartość NULL, *lpData* musi być długi wskaźnik do ciągu, który ma być wyjściowy.

*Ncount*<br/>
Określa liczbę znaków, które mają być wyprowadzane. Jeśli ten parametr wynosi `GrayString` 0, oblicza długość ciągu (przy założeniu, że *lpData* jest wskaźnikiem do ciągu). Jeśli *nCount* wynosi 1, a funkcja wskazywana przez *lpfnOutput* zwraca wartość 0, obraz jest wyświetlany, ale nie wyszarzony.

*X*<br/>
Określa logiczną współrzędną x położenia początkowego prostokąta, który otacza ciąg.

*Y*<br/>
Określa logiczną współrzędną y położenia początkowego prostokąta, który otacza ciąg.

*nWidth (ww.*<br/>
Określa szerokość (w jednostkach logicznych) prostokąta, który otacza ciąg. Jeśli *nWidth* wynosi `GrayString` 0, oblicza szerokość obszaru, przy założeniu, że *lpData* jest wskaźnikiem do ciągu.

*nFeksja*<br/>
Określa wysokość (w jednostkach logicznych) prostokąta, który otacza ciąg. Jeśli *nHeight* wynosi `GrayString` 0, oblicza wysokość obszaru, przy założeniu, że *lpData* jest wskaźnikiem do ciągu.

### <a name="return-value"></a>Wartość zwracana

Niezerowe, jeśli ciąg jest rysowany, lub `TextOut` 0, jeśli funkcja lub funkcja wyjściowa dostarczona przez aplikację zwróciła 0 lub jeśli nie było wystarczającej ilości pamięci, aby utworzyć mapę bitową pamięci do ściemniania.

### <a name="remarks"></a>Uwagi

Funkcja przyciemnia tekst niezależnie od zaznaczonego pędzla i tła. Funkcja `GrayString` elementu członkowskiego używa aktualnie wybranej czcionki. Przed użyciem tej funkcji należy wybrać tryb mapowania MM_TEXT.

Aplikacja może rysować wygaszone (wyszarzone) ciągi znaków na `GrayString` urządzeniach obsługujących jednolity szary kolor bez wywoływania funkcji elementu członkowskiego. COLOR_GRAYTEXT koloru systemu jest kolorem systemu z litą szarością używanym do rysowania wyłączonego tekstu. Aplikacja może wywołać funkcję systemu Windows, `GetSysColor` aby pobrać wartość koloru COLOR_GRAYTEXT. Jeśli kolor jest inny niż 0 (czarny), `SetTextColor` aplikacja może wywołać funkcję elementu członkowskiego, aby ustawić kolor tekstu na wartość koloru, a następnie narysować ciąg bezpośrednio. Jeśli pobrany kolor jest czarny, `GrayString` aplikacja musi wywołać przyciemnienie (szary) tekst.

Jeśli *lpfnOutput* ma wartość NULL, GDI używa funkcji [Windows TextOut,](/windows/win32/api/wingdi/nf-wingdi-textoutw) a *lpData* jest uważany za daleki wskaźnik do znaku, który ma być wyjściowy. Jeśli znaki, które mają być dane `TextOut` wyjściowe nie mogą być obsługiwane przez funkcję elementu członkowskiego (na przykład ciąg jest przechowywany jako bitmapa), aplikacja musi dostarczyć własną funkcję wyjściową.

Należy również zauważyć, że wszystkie funkcje wywołania zwrotnego muszą zalewkować wyjątki programu Microsoft Foundation przed powrotem do systemu Windows, ponieważ wyjątki nie mogą być generowane przez granice wywołania zwrotnego. Aby uzyskać więcej informacji na temat wyjątków, zobacz artykuł [Wyjątki](../../mfc/exception-handling-in-mfc.md).

Funkcja wywołania zwrotnego przekazana do `GrayString` musi używać konwencji wywołującej `__stdcall` i musi być eksportowana za pomocą `__declspec`programu .

Gdy struktura jest w trybie podglądu, wywołanie `GrayString` funkcji `TextOut` elementu członkowskiego jest tłumaczone na wywołanie, a funkcja wywołania zwrotnego nie jest wywoływana.

## <a name="cdchimetrictodp"></a><a name="himetrictodp"></a>CDC::HIMETRICtoDP

Tej funkcji należy używać podczas konwertowania rozmiarów HIMETRIC z OLE na piksele.

```
void HIMETRICtoDP(LPSIZE lpSize) const;
```

### <a name="parameters"></a>Parametry

*lpSize (rozmiar)*<br/>
Wskazuje strukturę [SIZE](/windows/win32/api/windef/ns-windef-size) lub [obiekt CSize.](../../atl-mfc-shared/reference/csize-class.md)

### <a name="remarks"></a>Uwagi

Jeśli tryb mapowania obiektu kontekstu urządzenia jest MM_LOENGLISH, MM_HIENGLISH, MM_LOMETRIC lub MM_HIMETRIC, konwersja jest oparta na liczbie pikseli w calu fizycznym. Jeśli tryb mapowania jest jednym z innych trybów nieograniczonych (np. MM_TEXT), konwersja jest oparta na liczbie pikseli w calu logicznym.

## <a name="cdchimetrictolp"></a><a name="himetrictolp"></a>CDC::HIMETRICtoLP

Wywołanie tej funkcji, aby przekonwertować jednostki HIMETRIC na jednostki logiczne.

```
void HIMETRICtoLP(LPSIZE lpSize) const;
```

### <a name="parameters"></a>Parametry

*lpSize (rozmiar)*<br/>
Wskazuje strukturę [SIZE](/windows/win32/api/windef/ns-windef-size) lub [obiekt CSize.](../../atl-mfc-shared/reference/csize-class.md)

### <a name="remarks"></a>Uwagi

Tej funkcji należy używać, gdy otrzymujesz rozmiary HIMETRIC z OLE i chcesz przekonwertować je na naturalny tryb mapowania aplikacji.

Konwersja jest realizowana przez najpierw konwertowanie jednostek HIMETRIC na piksele, a następnie konwertowanie tych jednostek na jednostki logiczne przy użyciu bieżących jednostek mapowania kontekstu urządzenia. Należy zauważyć, że zakres okna urządzenia i rzutni wpłynie na wynik.

## <a name="cdcintersectcliprect"></a><a name="intersectcliprect"></a>CDC::IntersectClipRect

Tworzy nowy obszar przycinania, tworząc przecięcie bieżącego regionu i prostokąta określonego przez *x1*, *y1*, *x2*i *y2*.

```
int IntersectClipRect(
    int x1,
    int y1,
    int x2,
    int y2);

int IntersectClipRect(LPCRECT lpRect);
```

### <a name="parameters"></a>Parametry

*x1*<br/>
Określa logiczną współrzędną x lewego górnego rogu prostokąta.

*y1*<br/>
Określa logiczną współrzędną y lewego górnego rogu prostokąta.

*x2*<br/>
Określa logiczną współrzędną x w prawym dolnym rogu prostokąta.

*y2*<br/>
Określa logiczną współrzędną y w prawym dolnym rogu prostokąta.

*Lprect*<br/>
Określa prostokąt. Można przekazać `CRect` obiekt lub wskaźnik do `RECT` struktury dla tego parametru.

### <a name="return-value"></a>Wartość zwracana

Typ nowego regionu przycinania. Może to być jedna z następujących wartości:

- COMPLEXREGION Nowy obszar przycinania ma nakładające się obramowania.

- BŁĄD Kontekst urządzenia jest nieprawidłowy.

- NULLREGION Nowy region przycinania jest pusty.

- SIMPLEREGION Nowy obszar przycinania nie ma nakładających się obramowań.

### <a name="remarks"></a>Uwagi

GDI przycina wszystkie kolejne dane wyjściowe, aby zmieścić się w nowej granicy. Szerokość i wysokość nie może przekraczać 32 767.

## <a name="cdcinvertrect"></a><a name="invertrect"></a>CDC::Invertrect

Odwraca zawartość danego prostokąta.

```
void InvertRect(LPCRECT lpRect);
```

### <a name="parameters"></a>Parametry

*Lprect*<br/>
Wskazuje na `RECT` to, że zawiera współrzędne logiczne prostokąta, który ma zostać odwrócony. Można również przekazać `CRect` obiekt dla tego parametru.

### <a name="remarks"></a>Uwagi

Inwersja jest logiczną operacją NOT i odwraca bity każdego piksela. Na wyświetlaczach monochromatywnych funkcja sprawia, że białe piksele są czarne i czarne piksele białe. Na wyświetlaczach kolorów odwrócenie zależy od sposobu generowania kolorów na wyświetlaczu. Wywołanie `InvertRect` dwa razy z tego samego prostokąta przywraca wyświetlacz do poprzednich kolorów.

Jeśli prostokąt jest pusty, nic nie jest rysowane.

### <a name="example"></a>Przykład

[!code-cpp[NVC_MFCDocView#36](../../mfc/codesnippet/cpp/cdc-class_8.cpp)]

## <a name="cdcinvertrgn"></a><a name="invertrgn"></a>CDC::Invertrgn

Odwraca kolory w regionie określonym przez *pRgn*.

```
BOOL InvertRgn(CRgn* pRgn);
```

### <a name="parameters"></a>Parametry

*pRgn*<br/>
Identyfikuje region, który ma zostać odwrócony. Współrzędne dla regionu są określone w jednostkach logicznych.

### <a name="return-value"></a>Wartość zwracana

Różne od zera, jeśli funkcja zakończyła się pomyślnie; w przeciwnym razie 0.

### <a name="remarks"></a>Uwagi

Na wyświetlaczach monochromatywnych funkcja sprawia, że białe piksele są czarne i czarne piksele białe. Na wyświetlaczach kolorów odwrócenie zależy od sposobu generowania kolorów na wyświetlaczu.

## <a name="cdcisprinting"></a><a name="isprinting"></a>CDC::IsPrinting

Określa, czy kontekst urządzenia jest używany do drukowania.

```
BOOL IsPrinting() const;
```

### <a name="return-value"></a>Wartość zwracana

Niezerowe, `CDC` jeśli obiekt jest kontrolerem domeny drukarki; w przeciwnym razie 0.

## <a name="cdclineto"></a><a name="lineto"></a>CDC::LineTo

Rysuje linię od bieżącej pozycji do punktu określonego przez *x* i *y* (lub *punkt).*

```
BOOL LineTo(
    int x,
    int y);

BOOL LineTo(POINT point);
```

### <a name="parameters"></a>Parametry

*X*<br/>
Określa logiczną współrzędną x punktu końcowego dla wiersza.

*Y*<br/>
Określa logiczną współrzędną y punktu końcowego dla wiersza.

*Punkt*<br/>
Określa punkt końcowy wiersza. Można przekazać strukturę `POINT` lub `CPoint` obiekt dla tego parametru.

### <a name="return-value"></a>Wartość zwracana

Niezerowe, jeśli linia jest rysowana; w przeciwnym razie 0.

### <a name="remarks"></a>Uwagi

Linia jest rysowana wybranym piórem. Bieżąca pozycja jest *ustawiona*na x , *y* lub *do punktu*.

### <a name="example"></a>Przykład

  Zobacz przykład [CRect::CenterPoint](../../atl-mfc-shared/reference/crect-class.md#centerpoint).

## <a name="cdclptodp"></a><a name="lptodp"></a>CDC::LPtoDP

Konwertuje jednostki logiczne na jednostki urządzenia.

```
void LPtoDP(
    LPPOINT lpPoints,
    int nCount = 1) const;

void LPtoDP(LPRECT lpRect) const;
void LPtoDP(LPSIZE lpSize) const;
```

### <a name="parameters"></a>Parametry

*lpPunkty*<br/>
Wskazuje tablicę punktów. Każdy punkt w tablicy jest strukturą [POINT](/windows/win32/api/windef/ns-windef-point) lub [CPoint.](../../atl-mfc-shared/reference/cpoint-class.md)

*Ncount*<br/>
Liczba punktów w tablicy.

*Lprect*<br/>
Wskazuje strukturę [RECT](/windows/win32/api/windef/ns-windef-rect) lub [obiekt CRect.](../../atl-mfc-shared/reference/crect-class.md) Ten parametr jest używany w przypadku wspólnego mapowania prostokąta z jednostek logicznych do urządzeń.

*lpSize (rozmiar)*<br/>
Wskazuje strukturę [SIZE](/windows/win32/api/windef/ns-windef-size) lub [obiekt CSize.](../../atl-mfc-shared/reference/csize-class.md)

### <a name="remarks"></a>Uwagi

Funkcja mapuje współrzędne każdego punktu lub wymiary o rozmiarze z logicznego układu współrzędnych GDI do układu współrzędnych urządzenia. Konwersja zależy od bieżącego trybu mapowania oraz ustawień początku i zakresu okna i rzutni urządzenia.

Współrzędne punktów x- i y są 2-bajtowymi liczbami całkowitymi w zakresie od -32 768 do 32 767. W przypadkach, gdy tryb mapowania spowodowałoby wartości większe niż te limity, system ustawia wartości odpowiednio na -32,768 i 32,767.

## <a name="cdclptohimetric"></a><a name="lptohimetric"></a>CDC::LPtoHIMETRIC

Wywołanie tej funkcji w celu konwersji jednostek logicznych na jednostki HIMETRIC.

```
void LPtoHIMETRIC(LPSIZE lpSize) const;
```

### <a name="parameters"></a>Parametry

*lpSize (rozmiar)*<br/>
Wskazuje na `SIZE` strukturę `CSize` lub obiekt.

### <a name="remarks"></a>Uwagi

Tej funkcji należy używać podczas podawania rozmiarów HIMETRIC do OLE, konwersji z trybu mapowania naturalnego aplikacji. Należy zauważyć, że zakres okna urządzenia i rzutni wpłynie na wynik.

Konwersja jest realizowana przez najpierw konwertowanie jednostek logicznych na piksele przy użyciu bieżących jednostek mapowania kontekstu urządzenia, a następnie konwertowanie tych jednostek na jednostki HIMETRIC.

## <a name="cdcm_hattribdc"></a><a name="m_hattribdc"></a>CDC::m_hAttribDC

Kontekst urządzenia atrybutu `CDC` dla tego obiektu.

```
HDC m_hAttribDC;
```

### <a name="remarks"></a>Uwagi

Domyślnie ten kontekst urządzenia `m_hDC`jest równy . Ogólnie rzecz `CDC` biorąc wywołania GDI, które żądają informacji z kontekstu urządzenia, są kierowane do `m_hAttribDC`. Zobacz opis klasy [CDC,](../../mfc/reference/cdc-class.md) aby uzyskać więcej informacji na temat korzystania z tych dwóch kontekstów urządzenia.

## <a name="cdcm_hdc"></a><a name="m_hdc"></a>CDC::m_hDC

Kontekst urządzenia wyjściowego `CDC` dla tego obiektu.

```
HDC m_hDC;
```

### <a name="remarks"></a>Uwagi

Domyślnie `m_hDC` jest równa `m_hAttribDC`, inny kontekst `CDC`urządzenia zawinięty przez . Ogólnie rzecz `CDC` biorąc wywołania GDI, `m_hDC` które tworzą dane wyjściowe przejść do kontekstu urządzenia. Można zainicjować `m_hDC` `m_hAttribDC` i wskazać różne urządzenia. Zobacz opis klasy [CDC,](../../mfc/reference/cdc-class.md) aby uzyskać więcej informacji na temat korzystania z tych dwóch kontekstów urządzenia.

## <a name="cdcmaskblt"></a><a name="maskblt"></a>CDC::MaskBlt

Łączy dane kolorów dla źródłowych i docelowych map bitowych przy użyciu danej maski i operacji rastrowej.

```
BOOL MaskBlt(
    int x,
    int y,
    int nWidth,
    int nHeight,
    CDC* pSrcDC,
    int xSrc,
    int ySrc,
    CBitmap& maskBitmap,
    int xMask,
    int yMask,
    DWORD dwRop);
```

### <a name="parameters"></a>Parametry

*X*<br/>
Określa logiczną współrzędną x lewego górnego rogu prostokąta docelowego.

*Y*<br/>
Określa logiczną współrzędną y lewego górnego rogu prostokąta docelowego.

*nWidth (ww.*<br/>
Określa szerokość prostokąta docelowego i źródłowej mapy bitowej w jednostkach logicznych.

*nFeksja*<br/>
Określa wysokość w jednostkach logicznych prostokąta docelowego i źródłowej mapy bitowej.

*pSrcDC*<br/>
Identyfikuje kontekst urządzenia, z którego ma być kopiowana mapa bitowa. Musi być zero, jeśli *dwRop* parametr określa operację rastrową, która nie zawiera źródła.

*xSrc (ks.*<br/>
Określa logiczną współrzędną x lewego górnego rogu źródłowej mapy bitowej.

*ySrc ( ySrc )*<br/>
Określa logiczną współrzędną y lewego górnego rogu źródłowej mapy bitowej.

*maskaBitmapa*<br/>
Identyfikuje mapę bitową maski monochromatyczne w połączeniu z bitmapą kolorów w kontekście urządzenia źródłowego.

*Maska x*<br/>
Określa odsunięcie piksela poziomego dla mapy bitowej maski określonej przez parametr *maskBitmap.*

*yMask (yMask)*<br/>
Określa przesunięcie piksela pionowego dla mapy bitowej maski określonej przez parametr *maskBitmap.*

*dwRop (dwRop)*<br/>
Określa zarówno kody operacji rastrowych pierwszego planu, jak i tła, których funkcja używa do sterowania kombinacją danych źródłowych i docelowych. Kod operacji rastrowej tła jest przechowywany w wysokim bajcie wysokiego wyrazu tej wartości; pierwszy plan kod operacji rastrowej jest przechowywany w niskim bajcie wysokiego wyrazu tej wartości; niskie słowo tej wartości jest ignorowane i powinno wynosić zero. Makro MAKEROP4 tworzy takie kombinacje kodów operacji rastrowych pierwszego planu i tła rastrowego. Zobacz uwagi sekcji do dyskusji na pierwszym planie i tła w kontekście tej funkcji. Zobacz `BitBlt` funkcję elementu członkowskiego, aby uzyskać listę typowych kodów operacji rastrowych.

### <a name="return-value"></a>Wartość zwracana

Różne od zera, jeśli funkcja zakończyła się pomyślnie; w przeciwnym razie 0.

### <a name="remarks"></a>Uwagi

Wartość 1 w masce określona przez *maskęBitmapa* wskazuje, że w tej lokalizacji należy zastosować kod operacji rastrowej pierwszego planu określony przez *dwRop.* Wartość 0 w masce wskazuje, że kod operacji rastrowej tła określony przez *dwRop* powinien być stosowany w tej lokalizacji. Jeśli operacje rastrowe wymagają źródła, prostokąt maski musi obejmować prostokąt źródłowy. Jeśli tak nie jest, funkcja zakończy się niepowodzeniem. Jeśli operacje rastrowe nie wymagają źródła, prostokąt maski musi obejmować prostokąt docelowy. Jeśli tak nie jest, funkcja zakończy się niepowodzeniem.

Jeśli transformacja obrotu lub ścinania obowiązuje w kontekście urządzenia źródłowego, gdy ta funkcja jest wywoływana, wystąpi błąd. Jednak inne typy przekształceń są dozwolone.

Jeśli formaty kolorów źródłowych, wzorcowych i docelowych map bitowych różnią się, ta funkcja konwertuje format wzoru lub źródła lub oba formaty, aby dopasować format docelowy. Jeśli mapa bitowa maski nie jest monochromatycznym bitmapą, występuje błąd. Podczas rejestrowania rozszerzonego metapliku występuje błąd (a funkcja zwraca wartość 0), jeśli kontekst urządzenia źródłowego identyfikuje kontekst urządzenia z rozszerzonym metaplikem. Nie wszystkie `MaskBlt`urządzenia obsługują . Aplikacja powinna `GetDeviceCaps` wywołać, aby ustalić, czy urządzenie obsługuje tę funkcję. Jeśli nie podano mapy bitowej maski, `BitBlt`ta funkcja zachowuje się dokładnie tak, jak , używając kodu operacji rastrowej pierwszego planu. Przesuń piksel w mapie bitmapy maski do punktu (0,0) w pliku bitowym kontekstu urządzenia źródłowego. Jest to przydatne w przypadkach, w których mapa bitowa maski zawiera zestaw masek; aplikacja może łatwo zastosować dowolny z nich do zadania maskowania, dostosowując przesunięcia pikseli `MaskBlt`i rozmiary prostokątów wysyłane do .

## <a name="cdcmodifyworldtransform"></a><a name="modifyworldtransform"></a>CDC::ModifyWorldTransform

Zmienia transformację świata dla kontekstu urządzenia przy użyciu określonego trybu.

```
BOOL ModifyWorldTransform(
    const XFORM& rXform,
    DWORD iMode);
```

### <a name="parameters"></a>Parametry

*rXform*<br/>
Odwołanie do struktury [XFORM](/windows/win32/api/wingdi/ns-wingdi-xform) używane do modyfikowania transformacji świata dla danego kontekstu urządzenia.

*iMode*<br/>
Określa, jak dane transformacji modyfikuje bieżącej transformacji świata. Aby uzyskać listę wartości, które ten parametr może podjąć, zobacz [ModifyWorldTransform](/windows/win32/api/wingdi/nf-wingdi-modifyworldtransform).

### <a name="return-value"></a>Wartość zwracana

Zwraca wartość niezerową na sukces.

Zwraca wartość 0 w przypadku awarii.

Aby uzyskać rozszerzone informacje o błędzie, zadzwoń [do GetLastError](/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror).

### <a name="remarks"></a>Uwagi

Ta metoda zawija funkcję GDI systemu Windows [ModifyWorldTransform](/windows/win32/api/wingdi/nf-wingdi-modifyworldtransform).

## <a name="cdcmoveto"></a><a name="moveto"></a>CDC::MoveTo

Przenosi bieżącą pozycję do punktu określonego przez *x* i *y* (lub *według punktu*).

```
CPoint MoveTo(
    int x,
    int y);

CPoint MoveTo(POINT point);
```

### <a name="parameters"></a>Parametry

*X*<br/>
Określa logiczną współrzędną x nowego położenia.

*Y*<br/>
Określa logiczną współrzędną y nowego położenia.

*Punkt*<br/>
Określa nową pozycję. Można przekazać strukturę `POINT` lub `CPoint` obiekt dla tego parametru.

### <a name="return-value"></a>Wartość zwracana

Współrzędne x i y poprzedniej `CPoint` pozycji jako obiektu.

### <a name="example"></a>Przykład

  Zobacz przykład [CRect::CenterPoint](../../atl-mfc-shared/reference/crect-class.md#centerpoint).

## <a name="cdcoffsetcliprgn"></a><a name="offsetcliprgn"></a>CDC::OffsetCliprgn

Przenosi obszar przycinania kontekstu urządzenia o określone przesunięcia.

```
int OffsetClipRgn(
    int x,
    int y);

int OffsetClipRgn(SIZE size);
```

### <a name="parameters"></a>Parametry

*X*<br/>
Określa liczbę jednostek logicznych do przesunienia w lewo lub w prawo.

*Y*<br/>
Określa liczbę jednostek logicznych do przesunienia w górę lub w dół.

*Rozmiar*<br/>
Określa kwotę do przesunięcia.

### <a name="return-value"></a>Wartość zwracana

Typ nowego regionu. Może to być jedna z następujących wartości:

- OBSZAR TNĄCEJ OGROM MA nakładające się obramowania.

- BŁĄD Kontekst urządzenia jest nieprawidłowy.

- Region przycinania NULLREGION jest pusty.

- Region prostego przycinania nie ma nakładających się obramowań.

### <a name="remarks"></a>Uwagi

Funkcja przesuwa jednostki regionu *x* wzdłuż osi x i *y* wzdłuż osi y.

## <a name="cdcoffsetviewportorg"></a><a name="offsetviewportorg"></a>CDC::OffsetViewportOrg

Modyfikuje współrzędne początku rzutni względem współrzędnych bieżącego początku rzutni.

```
virtual CPoint OffsetViewportOrg(
    int nWidth,
    int nHeight);
```

### <a name="parameters"></a>Parametry

*nWidth (ww.*<br/>
Określa liczbę jednostek urządzenia, które mają być dodane do współrzędnej x bieżącego źródła.

*nFeksja*<br/>
Określa liczbę jednostek urządzenia, które mają być dodane do współrzędnej y bieżącego początku.

### <a name="return-value"></a>Wartość zwracana

Poprzedni początek rzutni (we współrzędnych urządzenia) jako obiekt. `CPoint`

## <a name="cdcoffsetwindoworg"></a><a name="offsetwindoworg"></a>CDC::OffsetWindowOrg

Modyfikuje współrzędne początku okna względem współrzędnych bieżącego początku okna.

```
CPoint OffsetWindowOrg(
    int nWidth,
    int nHeight);
```

### <a name="parameters"></a>Parametry

*nWidth (ww.*<br/>
Określa liczbę jednostek logicznych, które mają być dodane do współrzędnej x bieżącego pochodzenia.

*nFeksja*<br/>
Określa liczbę jednostek logicznych, które mają być dodane do współrzędnej y bieżącego pochodzenia.

### <a name="return-value"></a>Wartość zwracana

Początek poprzedniego okna (we współrzędnych logicznych) jako obiekt. `CPoint`

## <a name="cdcoperator-hdc"></a><a name="operator_hdc"></a>CDC::operator HDC

Ten operator służy do pobierania dojścia kontekstu `CDC` urządzenia obiektu.

```
operator HDC() const;
```

### <a name="return-value"></a>Wartość zwracana

Jeśli się powiedzie, dojście obiektu kontekstu urządzenia; w przeciwnym razie NULL.

### <a name="remarks"></a>Uwagi

Dojścia można używać do bezpośredniego wywoływania interfejsów API systemu Windows.

## <a name="cdcpaintrgn"></a><a name="paintrgn"></a>CDC::PaintRgn

Wypełnia region określony przez *pRgn* za pomocą bieżącego pędzla.

```
BOOL PaintRgn(CRgn* pRgn);
```

### <a name="parameters"></a>Parametry

*pRgn*<br/>
Identyfikuje region do wypełnienia. Współrzędne dla danego regionu są określone w jednostkach logicznych.

### <a name="return-value"></a>Wartość zwracana

Różne od zera, jeśli funkcja zakończyła się pomyślnie; w przeciwnym razie 0.

## <a name="cdcpatblt"></a><a name="patblt"></a>CDC::PatBlt

Tworzy wzór bitowy na urządzeniu.

```
BOOL PatBlt(
    int x,
    int y,
    int nWidth,
    int nHeight,
    DWORD dwRop);
```

### <a name="parameters"></a>Parametry

*X*<br/>
Określa logiczną współrzędną x lewego górnego rogu prostokąta, który ma odbierać szyk.

*Y*<br/>
Określa logiczną współrzędną y lewego górnego rogu prostokąta, który ma otrzymać szyk.

*nWidth (ww.*<br/>
Określa szerokość (w jednostkach logicznych) prostokąta, który ma odbierać szyk.

*nFeksja*<br/>
Określa wysokość (w jednostkach logicznych) prostokąta, który ma odbierać szyk.

*dwRop (dwRop)*<br/>
Określa kod operacji rastrowej. Kody operacji rastrowych (ROPs) definiują sposób łączenia kolorów w operacjach wyjściowych, które obejmują bieżący pędzel, możliwą źródłową mapę bitową i docelową mapę bitową. Ten parametr może być jedną z następujących wartości:

- PATCOPY Kopiuje wzorzec do docelowej mapy bitowej.

- PATINVERT Łączy docelową mapę bitową ze wzorem przy użyciu operatora XOR logicznego.

- DSTINVERT Odwraca docelową mapę bitową.

- CZERŃ Zmienia kolor na czarny.

- BIEL Zmienia kolor na biały.

### <a name="return-value"></a>Wartość zwracana

Różne od zera, jeśli funkcja zakończyła się pomyślnie; w przeciwnym razie 0.

### <a name="remarks"></a>Uwagi

Wzór jest kombinacją wybranego pędzla i wzoru już na urządzeniu. Kod operacji rastrowej określony przez *dwRop* definiuje sposób łączenia wzorców. Operacje rastrowe wymienione dla tej funkcji są ograniczonym podzbiorem pełnych 256 trójskładnikowych kodów rastrowych; w szczególności nie można użyć kodu operacji rastrowej, który odnosi się do źródła.

Nie wszystkie konteksty `PatBlt` urządzenia obsługują tę funkcję. Aby ustalić, czy `PatBlt`kontekst urządzenia `GetDeviceCaps` obsługuje, należy wywołać funkcję elementu członkowskiego z indeksem RASTERCAPS i sprawdzić wartość zwracaną flagi RC_BITBLT.

## <a name="cdcpie"></a><a name="pie"></a>CDC::Pie

Rysuje klin w kształcie koła, rysując łuk eliptyczny, którego środek i dwa punkty końcowe są połączone liniami.

```
BOOL Pie(
    int x1,
    int y1,
    int x2,
    int y2,
    int x3,
    int y3,
    int x4,
    int y4);

BOOL Pie(
    LPCRECT lpRect,
    POINT ptStart,
    POINT ptEnd);
```

### <a name="parameters"></a>Parametry

*x1*<br/>
Określa współrzędną x lewego górnego rogu prostokąta ograniczającego (w jednostkach logicznych).

*y1*<br/>
Określa współrzędną y lewego górnego rogu prostokąta ograniczającego (w jednostkach logicznych).

*x2*<br/>
Określa współrzędną x w prawym dolnym rogu prostokąta ograniczającego (w jednostkach logicznych).

*y2*<br/>
Określa współrzędną y w prawym dolnym rogu prostokąta ograniczającego (w jednostkach logicznych).

*x3*<br/>
Określa współrzędną x punktu początkowego łuku (w jednostkach logicznych). Ten punkt nie musi leżeć dokładnie na łuku.

*3.*<br/>
Określa współrzędną y punktu początkowego łuku (w jednostkach logicznych). Ten punkt nie musi leżeć dokładnie na łuku.

*x4*<br/>
Określa współrzędną x punktu końcowego łuku (w jednostkach logicznych). Ten punkt nie musi leżeć dokładnie na łuku.

*y4*<br/>
Określa współrzędną y punktu końcowego łuku (w jednostkach logicznych). Ten punkt nie musi leżeć dokładnie na łuku.

*Lprect*<br/>
Określa prostokąt ograniczający. Można przekazać `CRect` obiekt lub wskaźnik do `RECT` struktury dla tego parametru.

*ptStart (początek)*<br/>
Określa punkt początkowy łuku. Ten punkt nie musi leżeć dokładnie na łuku. Dla tego parametru można przekazać strukturę [POINT](/windows/win32/api/windef/ns-windef-point) lub obiekt [CPoint.](../../atl-mfc-shared/reference/cpoint-class.md)

*ptEnd (polski)*<br/>
Określa punkt końcowy łuku. Ten punkt nie musi leżeć dokładnie na łuku. Można przekazać strukturę `POINT` lub `CPoint` obiekt dla tego parametru.

### <a name="return-value"></a>Wartość zwracana

Różne od zera, jeśli funkcja zakończyła się pomyślnie; w przeciwnym razie 0.

### <a name="remarks"></a>Uwagi

Środek łuku jest środkiem prostokąta ograniczającego określonego przez *x1*, *y1*, *x2*i *y2* (lub *przez lpRect*). Punkty początkowe i końcowe łuku są określone przez *x3*, *y3*, *x4*i *y4* (lub przez *ptStart* i *ptEnd*).

Łuk jest rysowany wybranym piórem, poruszając się w kierunku przeciwnym do ruchu wskazówek zegara. Dwie dodatkowe linie są rysowane z każdego punktu końcowego do środka łuku. Obszar w kształcie koła jest wypełniony bieżącym pędzlem. Jeśli *x3* jest równa *x4* i *y3* równa *y4*, wynik jest elipsa z pojedynczą linią od środka elipsy do punktu ( *x3*, *y3*) lub ( *x4*, *y4*).

Rysunek narysowany przez tę funkcję rozciąga się do prawej i dolnej współrzędnych, ale nie zawiera jej prawą i dolną. Oznacza to, że wysokość *figury wynosi y2* - *y1,* a szerokość figury *x2* - *x1*. Zarówno szerokość, jak i wysokość prostokąta ograniczającego muszą być większe niż 2 jednostki i mniejsze niż 32 767 jednostek.

### <a name="example"></a>Przykład

[!code-cpp[NVC_MFCDocView#37](../../mfc/codesnippet/cpp/cdc-class_9.cpp)]

## <a name="cdcplaymetafile"></a><a name="playmetafile"></a>CDC::PlayMetaFile

Odtwarza zawartość określonego metapliku w kontekście urządzenia.

```
BOOL PlayMetaFile(HMETAFILE hMF);

BOOL PlayMetaFile(
    HENHMETAFILE hEnhMetaFile,
    LPCRECT lpBounds);
```

### <a name="parameters"></a>Parametry

*Hmf*<br/>
Identyfikuje metaplik do odtworzonego.

*hEnhMetaFile*<br/>
Identyfikuje ulepszony metaplik.

*lpBounds (Obfity)*<br/>
Wskazuje na `RECT` strukturę `CRect` lub obiekt zawierający współrzędne prostokąta ograniczającego używanego do wyświetlania obrazu. Współrzędne są określone w jednostkach logicznych.

### <a name="return-value"></a>Wartość zwracana

Różne od zera, jeśli funkcja zakończyła się pomyślnie; w przeciwnym razie 0.

### <a name="remarks"></a>Uwagi

Metaplik można odtwarzać dowolną liczbę razy.

Druga wersja `PlayMetaFile` wyświetla obraz zapisany w danym rozszerzonym formacie metaplik. Gdy aplikacja wywołuje drugą `PlayMetaFile`wersję programu , System Windows używa ramki obrazu w nagłówku enhanced-metafile do mapowania obrazu na prostokąt wskazany przez parametr *lpBounds.* (Ten obraz może być ścięta lub obrócony przez `PlayMetaFile`ustawienie transformacji świata w urządzeniu wyjściowym przed wywołaniem .) Punkty wzdłuż krawędzi prostokąta są uwzględniane na rysunku. Ulepszony obraz metapliku można przyciąć, definiując obszar przycinania w urządzeniu wyjściowym przed oddaniem ulepszonego metapliku.

Jeśli ulepszony metaplik zawiera opcjonalną paletę, aplikacja może osiągnąć spójne kolory, konfigurując paletę kolorów na urządzeniu wyjściowym przed wywołaniem drugiej wersji programu `PlayMetaFile`. Aby pobrać paletę opcjonalną, `GetEnhMetaFilePaletteEntries` użyj funkcji Systemu Windows. Ulepszony metaplik można osadzać w nowo utworzonym ulepszonym metapliku, wywołując drugą wersję `PlayMetaFile` i odtwarzając ulepszony metaplik źródłowy w kontekście urządzenia dla nowego ulepszonego metapliku.

Stany kontekstu urządzenia wyjściowego są zachowywane przez tę funkcję. Ta funkcja usuwa dowolny obiekt utworzony, ale nieunieuszczony w rozszerzonym metapliku. Aby zatrzymać tę funkcję, aplikacja `CancelDC` może wywołać funkcję systemu Windows z innego wątku, aby zakończyć operację. W takim przypadku funkcja zwraca zero.

## <a name="cdcplgblt"></a><a name="plgblt"></a>CDC::PlgBlt

Wykonuje transfer bloku bitowego bitów bitów danych kolorów z określonego prostokąta w kontekście urządzenia źródłowego do określonego równoległoboku w danym kontekście urządzenia.

```
BOOL PlgBlt(
    LPPOINT lpPoint,
    CDC* pSrcDC,
    int xSrc,
    int ySrc,
    int nWidth,
    int nHeight,
    CBitmap& maskBitmap,
    int xMask,
    int yMask);
```

### <a name="parameters"></a>Parametry

*lpPoint (punkt z punktu widzenia*<br/>
Wskazuje tablicę trzech punktów w przestrzeni logicznej, która identyfikuje trzy rogi równoległoboku docelowego. Lewy górny róg prostokąta źródłowego jest mapowany na pierwszy punkt w tej tablicy, prawy górny róg do drugiego punktu w tej tablicy, a lewy dolny róg do trzeciego punktu. Prawy dolny róg prostokąta źródłowego jest mapowany na niejawny czwarty punkt w równoległoboku.

*pSrcDC*<br/>
Identyfikuje kontekst urządzenia źródłowego.

*xSrc (ks.*<br/>
Określa współrzędną x w jednostkach logicznych lewego górnego rogu prostokąta źródłowego.

*ySrc ( ySrc )*<br/>
Określa współrzędną y w jednostkach logicznych lewego górnego rogu prostokąta źródłowego.

*nWidth (ww.*<br/>
Określa szerokość prostokąta źródłowego w jednostkach logicznych.

*nFeksja*<br/>
Określa wysokość prostokąta źródłowego w jednostkach logicznych.

*maskaBitmapa*<br/>
Identyfikuje opcjonalną monochromatyczny bitmapę, która służy do maskowania kolorów prostokąta źródłowego.

*Maska x*<br/>
Określa współrzędną x lewego górnego rogu monochromatycznej mapy bitowej.

*yMask (yMask)*<br/>
Określa współrzędną y lewego górnego rogu monochromatycznej mapy bitowej.

### <a name="return-value"></a>Wartość zwracana

Różne od zera, jeśli funkcja zakończyła się pomyślnie; w przeciwnym razie 0.

### <a name="remarks"></a>Uwagi

Jeśli dany uchwyt maski bitowej identyfikuje prawidłową monochromatyczny bitmapę, funkcja używa tej mapy bitowej do maskowania bitów danych kolorów z prostokąta źródłowego.

Czwarty wierzchołek równoległoboku (D) jest definiowany przez traktowanie pierwszych trzech punktów (A, B i C) jako wektorów i obliczeń D = B + C - A.

Jeśli maska bitowa istnieje, wartość 1 w masce wskazuje, że kolor piksela źródłowego powinien zostać skopiowany do miejsca docelowego. Wartość 0 w masce wskazuje, że nie można zmienić docelowego koloru piksela.

Jeśli prostokąt maski jest mniejszy niż prostokąty źródłowe i docelowe, funkcja replikuje deseń maski.

Skalowanie, translacji i odbicia przekształcenia są dozwolone w kontekście urządzenia źródłowego; jednak przekształcenia obrotu i ścinania nie są. Jeśli mapa bitowa maski nie jest monochromatycznym bitmapą, występuje błąd. Tryb rozciągania kontekstu urządzenia docelowego służy do określania sposobu rozciągania lub kompresowania pikseli, jeśli jest to konieczne. Podczas rejestrowania rozszerzonego metapliku występuje błąd, jeśli kontekst urządzenia źródłowego identyfikuje kontekst urządzenia z rozszerzoną metapliką.

Współrzędne miejsca przeznaczenia są przekształcane zgodnie z kontekstem urządzenia docelowego; współrzędne źródła są przekształcane zgodnie z kontekstem urządzenia źródłowego. Jeśli transformacja źródła ma obrót lub ścinanie, zwracany jest błąd. Jeśli prostokąty docelowe i źródłowe nie mają `PlgBlt` tego samego formatu koloru, konwertuje prostokąt źródłowy, aby dopasować prostokąt docelowy. Nie wszystkie `PlgBlt`urządzenia obsługują . Aby uzyskać więcej informacji, zobacz opis RC_BITBLT możliwości rastrowych w funkcji `CDC::GetDeviceCaps` elementu członkowskiego.

Jeśli konteksty urządzenia źródłowego i docelowego reprezentują niezgodne urządzenia, `PlgBlt` zwraca błąd.

## <a name="cdcpolybezier"></a><a name="polybezier"></a>CDC::PolyBezier

Rysuje jeden lub więcej splajnów Bziera.

```
BOOL PolyBezier(
    const POINT* lpPoints,
    int nCount);
```

### <a name="parameters"></a>Parametry

*lpPunkty*<br/>
Wskazuje tablicę struktur danych [POINT,](/windows/win32/api/windef/ns-windef-point) które zawierają punkty końcowe i punkty kontrolne splajnu(-ów).

*Ncount*<br/>
Określa liczbę punktów w tablicy *lpPoints.* Ta wartość musi być jeden więcej niż trzy razy liczba splajnów do narysowania, ponieważ każdy splajn Bzier wymaga dwóch punktów kontrolnych i punktu końcowego, a początkowy splajn wymaga dodatkowego punktu początkowego.

### <a name="return-value"></a>Wartość zwracana

Różne od zera, jeśli funkcja zakończyła się pomyślnie; w przeciwnym razie 0.

### <a name="remarks"></a>Uwagi

Ta funkcja rysuje sześcienne splajny Bziera przy użyciu punktów końcowych i punktów kontrolnych określonych przez parametr *lpPoints.* Pierwszy splajn jest rysowany od pierwszego punktu do czwartego punktu przy użyciu drugiego i trzeciego punktu jako punktów kontrolnych. Każdy kolejny splajn w sekwencji wymaga dokładnie trzech kolejnych punktów: punkt końcowy poprzedniego splajnu jest używany jako punkt początkowy, kolejne dwa punkty w sekwencji są punktami kontrolnymi, a trzeci jest punktem końcowym.

Bieżąca pozycja nie jest używana `PolyBezier` ani aktualizowana przez funkcję. Rysunek nie jest wypełniony. Ta funkcja rysuje linie za pomocą bieżącego pióra.

## <a name="cdcpolybezierto"></a><a name="polybezierto"></a>CDC::PolyBezierTo

Rysuje jeden lub więcej splajnów Bziera.

```
BOOL PolyBezierTo(
    const POINT* lpPoints,
    int nCount);
```

### <a name="parameters"></a>Parametry

*lpPunkty*<br/>
Wskazuje tablicę struktur danych [POINT,](/windows/win32/api/windef/ns-windef-point) która zawiera punkty końcowe i punkty kontrolne.

*Ncount*<br/>
Określa liczbę punktów w tablicy *lpPoints.* Ta wartość musi być trzykrotnie większa od liczby splajnów do narysowania, ponieważ każdy splajn Bziera wymaga dwóch punktów kontrolnych i punktu końcowego.

### <a name="return-value"></a>Wartość zwracana

Różne od zera, jeśli funkcja zakończyła się pomyślnie; w przeciwnym razie 0.

### <a name="remarks"></a>Uwagi

Ta funkcja rysuje sześcienne splajny Bziera przy użyciu punktów kontrolnych określonych przez parametr *lpPoints.* Pierwszy splajn jest rysowany z bieżącej pozycji do trzeciego punktu przy użyciu dwóch pierwszych punktów jako punktów kontrolnych. Dla każdego kolejnego splajnu funkcja potrzebuje dokładnie trzech kolejnych punktów i używa punktu końcowego poprzedniego splajnu jako punktu początkowego następnego. `PolyBezierTo`przesuwa bieżącą pozycję do punktu końcowego ostatniego splajnu Bziera. Rysunek nie jest wypełniony. Ta funkcja rysuje linie za pomocą bieżącego pióra.

### <a name="example"></a>Przykład

  Zobacz przykład [cdc::BeginPath](#beginpath).

## <a name="cdcpolydraw"></a><a name="polydraw"></a>CDC::PolyDraw

Rysuje zestaw segmentów linii i splajnów Bziera.

```
BOOL PolyDraw(
    const POINT* lpPoints,
    const BYTE* lpTypes,
    int nCount);
```

### <a name="parameters"></a>Parametry

*lpPunkty*<br/>
Wskazuje tablicę struktur danych [POINT,](/windows/win32/api/windef/ns-windef-point) która zawiera punkty końcowe dla każdego segmentu linii oraz punkty końcowe i punkty kontrolne dla każdego splajnu Bziera.

*lpTyty*<br/>
Wskazuje tablicę określającą sposób użycia każdego punktu w *tablicy lpPoints.* Wartości mogą być jedną z następujących wartości:

- PT_MOVETO Określa, że ten punkt rozpoczyna rozłączną figurę. Ten punkt staje się nową bieżącą pozycją.

- PT_LINETO Określa, że wiersz ma być rysowany z bieżącej pozycji do tego punktu, który następnie staje się nową bieżącą pozycją.

- PT_BEZIERTO Określa, że ten punkt jest punktem kontrolnym lub punktem końcowym splajnu Bziera.

typy PT_BEZIERTO zawsze występują w zestawach trzech. Bieżąca pozycja określa punkt początkowy splajnu Bziera. Pierwsze dwa punkty PT_BEZIERTO są punktami kontrolnymi, a trzeci punkt PT_BEZIERTO jest punktem końcowym. Punkt końcowy staje się nową bieżącą pozycją. Jeśli nie ma trzech kolejnych punktów PT_BEZIERTO, powoduje błąd.

   Typ PT_LINETO lub PT_BEZIERTO można połączyć z następującą stałą za pomocą operatora bitowego OR, aby wskazać, że odpowiedni punkt jest ostatnim punktem na rysunku, a rysunek jest zamknięty:

- PT_CLOSEFIGURE Określa, że rysunek jest automatycznie zamykany po zakończeniu PT_LINETO lub PT_BEZIERTO typu dla tego punktu. Linia jest rysowana od tego punktu do najnowszej PT_MOVETO lub `MoveTo` punktu.

   Ta flaga jest połączona z typem PT_LINETO dla wiersza lub z PT_BEZIERTO typem punktu końcowego dla splajnu Bziera, używając operatora **or** bitowego. Bieżąca pozycja jest ustawiona na punkt końcowy wiersza zamknięcia.

*Ncount*<br/>
Określa całkowitą liczbę punktów w *tablicy lpPoints,* taką samą jak liczba bajtów w *tablicy lpTypes.*

### <a name="return-value"></a>Wartość zwracana

Różne od zera, jeśli funkcja zakończyła się pomyślnie; w przeciwnym razie 0.

### <a name="remarks"></a>Uwagi

Ta funkcja może służyć do rysowania rozłącznych `CDC::MoveTo`liczb `CDC::LineTo`zamiast `CDC::PolyBezierTo` kolejnych wywołań do , i funkcji członkowskich. Linie i splajny są rysowane za pomocą bieżącego pióra, a liczby nie są wypełniane. Jeśli istnieje aktywna ścieżka uruchomiona `CDC::BeginPath` przez `PolyDraw` wywołanie funkcji elementu członkowskiego, dodaje do ścieżki. Punkty zawarte w *tablicy lpPoints* i *lpTypes* `CDC::MoveTo`wskazują, czy każdy `CDC::LineTo`punkt `CDC::BezierTo` jest częścią , a , lub operacji. Możliwe jest również zamknięcie danych liczbowych. Ta funkcja aktualizuje bieżącą pozycję.

### <a name="example"></a>Przykład

  Zobacz przykład [cdc::BeginPath](#beginpath).

## <a name="cdcpolygon"></a><a name="polygon"></a>CDC::Polygon

Rysuje wielokąt składający się z dwóch lub więcej punktów (wierzchołków) połączonych liniami za pomocą bieżącego pióra.

```
BOOL Polygon(
    LPPOINT lpPoints,
    int nCount);
```

### <a name="parameters"></a>Parametry

*lpPunkty*<br/>
Wskazuje tablicę punktów określającą wierzchołki wielokąta. Każdy punkt w tablicy jest strukturą `POINT` lub obiektem. `CPoint`

*Ncount*<br/>
Określa liczbę wierzchołków w tablicy.

### <a name="return-value"></a>Wartość zwracana

Różne od zera, jeśli funkcja zakończyła się pomyślnie; w przeciwnym razie 0.

### <a name="remarks"></a>Uwagi

System zamyka wielokąt automatycznie, jeśli to konieczne, rysując linię od ostatniego wierzchołka do pierwszego.

Bieżący tryb wypełniania wielokątów można pobrać `GetPolyFillMode` lub `SetPolyFillMode` ustawić za pomocą funkcji i elementów członkowskich.

### <a name="example"></a>Przykład

[!code-cpp[NVC_MFCDocView#38](../../mfc/codesnippet/cpp/cdc-class_10.cpp)]

## <a name="cdcpolyline"></a><a name="polyline"></a>CDC::Polilina

Rysuje zestaw segmentów linii łączących punkty określone przez *lpPoints*.

```
BOOL Polyline(
    LPPOINT lpPoints,
    int nCount);
```

### <a name="parameters"></a>Parametry

*lpPunkty*<br/>
Wskazuje tablicę `POINT` struktur lub `CPoint` obiektów, które mają być połączone.

*Ncount*<br/>
Określa liczbę punktów w tablicy. Ta wartość musi wynosić co najmniej 2.

### <a name="return-value"></a>Wartość zwracana

Różne od zera, jeśli funkcja zakończyła się pomyślnie; w przeciwnym razie 0.

### <a name="remarks"></a>Uwagi

Linie są rysowane od pierwszego punktu do kolejnych punktów za pomocą bieżącego pióra. W `LineTo` przeciwieństwie do `Polyline` funkcji elementu członkowskiego funkcja nie używa ani nie aktualizuje bieżącej pozycji.

Aby uzyskać więcej informacji, zobacz [PolyLine](/windows/win32/api/wingdi/nf-wingdi-polyline) w windows SDK.

## <a name="cdcpolylineto"></a><a name="polylineto"></a>CDC::PolylineTo

Rysuje jedną lub więcej linii prostych.

```
BOOL PolylineTo(
    const POINT* lpPoints,
    int nCount);
```

### <a name="parameters"></a>Parametry

*lpPunkty*<br/>
Wskazuje tablicę struktur danych [POINT,](/windows/win32/api/windef/ns-windef-point) która zawiera wierzchołki linii.

*Ncount*<br/>
Określa liczbę punktów w tablicy.

### <a name="return-value"></a>Wartość zwracana

Różne od zera, jeśli funkcja zakończyła się pomyślnie; w przeciwnym razie 0.

### <a name="remarks"></a>Uwagi

Linia jest rysowana z bieżącej pozycji do pierwszego punktu określonego przez parametr *lpPoints* przy użyciu bieżącego pióra. Dla każdego dodatkowego wiersza funkcja rysuje się od punktu końcowego poprzedniego wiersza do następnego punktu określonego przez *lpPoints*. `PolylineTo`przesuwa bieżącą pozycję do punktu końcowego ostatniej linii. Jeśli segmenty linii narysowane przez tę funkcję tworzą postać zamkniętą, rysunek nie jest wypełniony.

## <a name="cdcpolypolygon"></a><a name="polypolygon"></a>CDC::PolyPolygon

Tworzy dwa lub więcej wielokątów, które są wypełnione przy użyciu bieżącego trybu wypełniania wielokątów.

```
BOOL PolyPolygon(
    LPPOINT lpPoints,
    LPINT lpPolyCounts,
    int nCount);
```

### <a name="parameters"></a>Parametry

*lpPunkty*<br/>
Wskazuje tablicę `POINT` struktur lub `CPoint` obiektów definiujących wierzchołki wielokątów.

*lpPolyCounts*<br/>
Wskazuje tablicę liczb całkowitych, z których każda określa liczbę punktów w jednym z wielokątów w *tablicy lpPoints.*

*Ncount*<br/>
Liczba wpisów w *tablicy lpPolyCounts.* Liczba ta określa liczbę wielokątów do wylosuniania. Ta wartość musi wynosić co najmniej 2.

### <a name="return-value"></a>Wartość zwracana

Różne od zera, jeśli funkcja zakończyła się pomyślnie; w przeciwnym razie 0.

### <a name="remarks"></a>Uwagi

Wielokąty mogą być rozłączne lub nakładające się.

Każdy wielokąt określony w `PolyPolygon` wywołaniu funkcji musi być zamknięty. W przeciwieństwie do wielokątów utworzonych przez funkcję `Polygon` `PolyPolygon` elementu członkowskiego wielokąty utworzone przez nie są zamykane automatycznie.

Funkcja tworzy dwa lub więcej wielokątów. Aby utworzyć pojedynczy wielokąt, aplikacja `Polygon` powinna używać funkcji elementu członkowskiego.

Bieżący tryb wypełniania wielokątów można pobrać `GetPolyFillMode` lub `SetPolyFillMode` ustawić za pomocą funkcji i elementów członkowskich.

## <a name="cdcpolypolyline"></a><a name="polypolyline"></a>CDC::Polipolilina

Rysuje wiele serii połączonych segmentów linii.

```
BOOL PolyPolyline(
    const POINT* lpPoints,
    const DWORD* lpPolyPoints,
    int nCount);
```

### <a name="parameters"></a>Parametry

*lpPunkty*<br/>
Wskazuje tablicę struktur, która zawiera wierzchołki polilinii. Polilinie są określane kolejno.

*lpPolyPunkty*<br/>
Wskazuje tablicę zmiennych określającą liczbę punktów w *tablicy lpPoints* dla odpowiedniego wielokąta. Każdy wpis musi być większy lub równy 2.

*Ncount*<br/>
Określa całkowitą liczbę zliczeń w *tablicy lpPolyPoints.*

### <a name="return-value"></a>Wartość zwracana

Różne od zera, jeśli funkcja zakończyła się pomyślnie; w przeciwnym razie 0.

### <a name="remarks"></a>Uwagi

Segmenty linii są rysowane za pomocą bieżącego pióra. Liczby utworzone przez segmenty nie są wypełniane. Bieżąca pozycja nie jest używana ani aktualizowana przez tę funkcję.

## <a name="cdcptvisible"></a><a name="ptvisible"></a>CDC: :Pniewidoczne

Określa, czy dany punkt znajduje się w regionie przycinania kontekstu urządzenia.

```
virtual BOOL PtVisible(
    int x,
    int y) const;

BOOL PtVisible(POINT point) const;
```

### <a name="parameters"></a>Parametry

*X*<br/>
Określa logiczną współrzędną x punktu.

*Y*<br/>
Określa logiczną współrzędną punktu.

*Punkt*<br/>
Określa punkt do zaewidencjonowania współrzędnych logicznych. Można przekazać strukturę `POINT` lub `CPoint` obiekt dla tego parametru.

### <a name="return-value"></a>Wartość zwracana

Niezerowe, jeśli określony punkt znajduje się w regionie przycinania; w przeciwnym razie 0.

## <a name="cdcqueryabort"></a><a name="queryabort"></a>CDC::QueryAbort

Wywołuje funkcję przerwania zainstalowaną przez funkcję elementu członkowskiego [SetAbortProc](#setabortproc) dla aplikacji drukowania i pyta, czy drukowanie powinno zostać zakończone.

```
BOOL QueryAbort() const;
```

### <a name="return-value"></a>Wartość zwracana

Zwracana wartość jest niezerowa, jeśli drukowanie powinno być kontynuowane lub jeśli nie ma procedury przerwania. Jest 0, jeśli zadanie drukowania powinno zostać zakończone. Zwracana wartość jest dostarczana przez funkcję przerwania.

## <a name="cdcrealizepalette"></a><a name="realizepalette"></a>CDC::RealizePalette

Mapuje wpisy z bieżącej palety logicznej do palety systemowej.

```
UINT RealizePalette();
```

### <a name="return-value"></a>Wartość zwracana

Wskazuje, ile wpisów w palecie logicznej zostało zamapowanych na różne wpisy w palecie systemowej. Reprezentuje to liczbę wpisów, które ta funkcja ponownie mapowane w celu uwzględnienia zmian w palecie systemowej, ponieważ paleta logiczna została ostatnio zrealizowana.

### <a name="remarks"></a>Uwagi

Logiczna paleta kolorów działa jako bufor między aplikacjami intensywnie korzystającymi z kolorów a systemem, umożliwiając aplikacji używanie tylu kolorów, ile potrzeba, bez zakłócania własnych wyświetlanych kolorów lub kolorów wyświetlanych przez inne okna.

Gdy okno ma fokus `RealizePalette`wejściowy i wywołuje, system Windows zapewnia, że w oknie zostaną wyświetlone wszystkie żądane kolory, do maksymalnej liczby jednocześnie dostępnej na ekranie. System Windows wyświetla również kolory, które nie zostały znalezione w palecie okna, dopasowując je do dostępnych kolorów.

Ponadto system Windows dopasowuje kolory wymagane przez nieaktywne okna, które wywołują funkcję tak ściśle, jak to możliwe, do dostępnych kolorów. Znacznie zmniejsza to niepożądane zmiany kolorów wyświetlanych w nieaktywnych oknach.

## <a name="cdcrectangle"></a><a name="rectangle"></a>CDC::Prostokąt

Rysuje prostokąt za pomocą bieżącego pióra.

```
BOOL Rectangle(
    int x1,
    int y1,
    int x2,
    int y2);

BOOL Rectangle(LPCRECT lpRect);
```

### <a name="parameters"></a>Parametry

*x1*<br/>
Określa współrzędną x lewego górnego rogu prostokąta (w jednostkach logicznych).

*y1*<br/>
Określa współrzędną y lewego górnego rogu prostokąta (w jednostkach logicznych).

*x2*<br/>
Określa współrzędną x w prawym dolnym rogu prostokąta (w jednostkach logicznych).

*y2*<br/>
Określa współrzędną y w prawym dolnym rogu prostokąta (w jednostkach logicznych).

*Lprect*<br/>
Określa prostokąt w jednostkach logicznych. Można przekazać `CRect` obiekt lub wskaźnik do `RECT` struktury dla tego parametru.

### <a name="return-value"></a>Wartość zwracana

Różne od zera, jeśli funkcja zakończyła się pomyślnie; w przeciwnym razie 0.

### <a name="remarks"></a>Uwagi

Wnętrze prostokąta jest wypełnione za pomocą bieżącego pędzla.

Prostokąt rozciąga się do, ale nie obejmuje, prawe i dolne współrzędne. Oznacza to, że wysokość prostokąta wynosi *y2* - *y1,* a szerokość prostokąta to *x2* - *x1*. Zarówno szerokość, jak i wysokość prostokąta muszą być większe niż 2 jednostki i mniejsze niż 32 767 jednostek.

### <a name="example"></a>Przykład

[!code-cpp[NVC_MFCDocView#39](../../mfc/codesnippet/cpp/cdc-class_11.cpp)]

## <a name="cdcrectvisible"></a><a name="rectvisible"></a>CDC::RectVisible

Określa, czy dowolna część danego prostokąta znajduje się w obrębie regionu przycinania kontekstu wyświetlania.

```
virtual BOOL RectVisible(LPCRECT lpRect) const;
```

### <a name="parameters"></a>Parametry

*Lprect*<br/>
Wskazuje na `RECT` strukturę `CRect` lub obiekt zawierający współrzędne logiczne określonego prostokąta.

### <a name="return-value"></a>Wartość zwracana

Niezerowe, jeśli dowolna część danego prostokąta znajduje się w obrębie regionu przycinania; w przeciwnym razie 0.

## <a name="cdcreleaseattribdc"></a><a name="releaseattribdc"></a>CDC::ReleaseAttribDC

Wywołanie tej funkcji `m_hAttribDC` elementu członkowskiego, aby ustawić wartość NULL.

```
virtual void ReleaseAttribDC();
```

### <a name="remarks"></a>Uwagi

Nie powoduje `Detach` to wystąpienia. Tylko kontekst urządzenia wyjściowego jest `CDC` dołączony do obiektu i tylko można go odłączyć.

## <a name="cdcreleaseoutputdc"></a><a name="releaseoutputdc"></a>CDC::ReleaseOutputDC

Wywołanie tej funkcji `m_hDC` elementu członkowskiego, aby ustawić element członkowski na NULL.

```
virtual void ReleaseOutputDC();
```

### <a name="remarks"></a>Uwagi

Tej funkcji elementu członkowskiego nie można wywołać, `CDC` gdy kontekst urządzenia wyjściowego jest dołączony do obiektu. Użyj `Detach` funkcji elementu członkowskiego, aby odłączyć kontekst urządzenia wyjściowego.

## <a name="cdcresetdc"></a><a name="resetdc"></a>CDC::ResetDC

Wywołanie tej funkcji elementu członkowskiego, `CDC` aby zaktualizować kontekst urządzenia opakowane przez obiekt.

```
BOOL ResetDC(const DEVMODE* lpDevMode);
```

### <a name="parameters"></a>Parametry

*lpDevMode (lpDevMode)*<br/>
Wskaźnik do struktury `DEVMODE` systemu Windows.

### <a name="return-value"></a>Wartość zwracana

Różne od zera, jeśli funkcja zakończyła się pomyślnie; w przeciwnym razie 0.

### <a name="remarks"></a>Uwagi

Kontekst urządzenia jest aktualizowany na podstawie `DEVMODE` informacji określonych w strukturze systemu Windows. Ta funkcja elementu członkowskiego resetuje tylko kontekst urządzenia atrybutu.

Aplikacja zazwyczaj używa funkcji `ResetDC` elementu członkowskiego, gdy `WM_DEVMODECHANGE` okno przetwarza komunikat. Za pomocą tej funkcji elementu członkowskiego można również zmienić orientację papieru lub pojemników na papier podczas drukowania dokumentu.

Tej funkcji elementu członkowskiego nie można użyć do zmiany nazwy sterownika, nazwy urządzenia lub portu wyjściowego. Gdy użytkownik zmieni nazwę połączenia portu lub urządzenia, należy usunąć oryginalny kontekst urządzenia i utworzyć nowy kontekst urządzenia z nowymi informacjami.

Przed wywołaniem tej funkcji elementu członkowskiego należy upewnić się, że wszystkie obiekty (inne niż obiekty giełdowe), które zostały wybrane w kontekście urządzenia, zostały wybrane.

## <a name="cdcrestoredc"></a><a name="restoredc"></a>CDC::RestoreDC

Przywraca kontekst urządzenia do poprzedniego stanu zidentyfikowanego przez *nSavedDC*.

```
virtual BOOL RestoreDC(int nSavedDC);
```

### <a name="parameters"></a>Parametry

*nSavedDC*<br/>
Określa kontekst urządzenia, który ma zostać przywrócony. Może to być wartość zwracana przez poprzednie `SaveDC` wywołanie funkcji. Jeśli *nSavedDC* jest -1, ostatnio zapisany kontekst urządzenia zostanie przywrócony.

### <a name="return-value"></a>Wartość zwracana

Niezerowe, jeśli określony kontekst został przywrócony; w przeciwnym razie 0.

### <a name="remarks"></a>Uwagi

`RestoreDC`przywraca kontekst urządzenia przez popping informacji o stanie ze `SaveDC` stosu utworzonego przez wcześniejsze wywołania funkcji elementu członkowskiego.

Stos może zawierać informacje o stanie dla kilku kontekstów urządzenia. Jeśli kontekst określony przez *nSavedDC* nie znajduje się `RestoreDC` w górnej części stosu, usuwa wszystkie informacje o stanie między kontekstem urządzenia określonym przez *nSavedDC* i górnej części stosu. Usunięte informacje zostaną utracone.

## <a name="cdcroundrect"></a><a name="roundrect"></a>CDC::Roundrect

Rysuje prostokąt z zaokrąglonymi narożnikami za pomocą bieżącego pióra.

```
BOOL RoundRect(
    int x1,
    int y1,
    int x2,
    int y2,
    int x3,
    int y3);

BOOL RoundRect(
    LPCRECT lpRect,
    POINT point);
```

### <a name="parameters"></a>Parametry

*x1*<br/>
Określa współrzędną x lewego górnego rogu prostokąta (w jednostkach logicznych).

*y1*<br/>
Określa współrzędną y lewego górnego rogu prostokąta (w jednostkach logicznych).

*x2*<br/>
Określa współrzędną x w prawym dolnym rogu prostokąta (w jednostkach logicznych).

*y2*<br/>
Określa współrzędną y w prawym dolnym rogu prostokąta (w jednostkach logicznych).

*x3*<br/>
Określa szerokość elipsy używanej do rysowania zaokrąglonych narożników (w jednostkach logicznych).

*3.*<br/>
Określa wysokość elipsy używanej do rysowania zaokrąglonych narożników (w jednostkach logicznych).

*Lprect*<br/>
Określa prostokąt ograniczający w jednostkach logicznych. Można przekazać `CRect` obiekt lub wskaźnik do `RECT` struktury dla tego parametru.

*Punkt*<br/>
Współrzędna x *punktu* określa szerokość elipsy do rysowania zaokrąglonych narożników (w jednostkach logicznych). Współrzędna y *punktu* określa wysokość elipsy do rysowania zaokrąglonych narożników (w jednostkach logicznych). Można przekazać strukturę `POINT` lub `CPoint` obiekt dla tego parametru.

### <a name="return-value"></a>Wartość zwracana

Różne od zera, jeśli funkcja zakończyła się pomyślnie; w przeciwnym razie 0.

### <a name="remarks"></a>Uwagi

Wnętrze prostokąta jest wypełnione za pomocą bieżącego pędzla.

Rysunek, który rysuje ta funkcja, rozciąga się do prawej i dolnej współrzędnych. Oznacza to, że wysokość *figury wynosi y2* - *y1,* a szerokość figury *x2* - *x1*. Zarówno wysokość, jak i szerokość prostokąta ograniczającego muszą być większe niż 2 jednostki i mniejsze niż 32 767 jednostek.

### <a name="example"></a>Przykład

[!code-cpp[NVC_MFCDocView#40](../../mfc/codesnippet/cpp/cdc-class_12.cpp)]

## <a name="cdcsavedc"></a><a name="savedc"></a>CDC::SaveDC

Zapisuje bieżący stan kontekstu urządzenia, kopiując informacje o stanie (takie jak region przycinania, wybrane obiekty i tryb mapowania) do stosu kontekstu obsługiwanego przez system Windows.

```
virtual int SaveDC();
```

### <a name="return-value"></a>Wartość zwracana

Liczba całkowita identyfikującya zapisany kontekst urządzenia. Jest 0, jeśli wystąpi błąd. Tej wartości zwracanej można przywrócić kontekst `RestoreDC`urządzenia przez wywołanie .

### <a name="remarks"></a>Uwagi

Zapisany kontekst urządzenia można później `RestoreDC`przywrócić za pomocą programu .

`SaveDC`można użyć dowolną liczbę razy, aby zapisać dowolną liczbę stanów kontekstu urządzenia.

## <a name="cdcscaleviewportext"></a><a name="scaleviewportext"></a>CDC::SkalaViewportext

Modyfikuje zakresy rzutni względem bieżących wartości.

```
virtual CSize ScaleViewportExt(
    int xNum,
    int xDenom,
    int yNum,
    int yDenom);
```

### <a name="parameters"></a>Parametry

*xNum*<br/>
Określa kwotę, przez którą należy pomnożyć bieżący zakres x.

*xDenom (*<br/>
Określa kwotę, przez którą należy podzielić wynik pomnożenia bieżącego zakresu x przez wartość parametru *xNum.*

*yNum*<br/>
Określa kwotę, przez którą należy pomnożyć bieżący zakres y.

*yDenom (yDenom)*<br/>
Określa kwotę, przez którą należy podzielić wynik pomnożenia bieżącego zakresu y przez wartość parametru *yNum.*

### <a name="return-value"></a>Wartość zwracana

Poprzednie zakresy rzutni (w jednostkach `CSize` urządzeń) jako obiekt.

### <a name="remarks"></a>Uwagi

Formuły są zapisywane w następujący sposób:

`xNewVE = ( xOldVE * xNum ) / xDenom`

`yNewVE = ( yOldVE * yNum ) / yDenom`

Nowe zakresy rzutni są obliczane przez pomnożenie bieżących zakresów przez dany licznik, a następnie podzielenie przez dany mianownik.

## <a name="cdcscalewindowext"></a><a name="scalewindowext"></a>CDC::ScaleWindowExt

Modyfikuje zakresy okien względem bieżących wartości.

```
virtual CSize ScaleWindowExt(
    int xNum,
    int xDenom,
    int yNum,
    int yDenom);
```

### <a name="parameters"></a>Parametry

*xNum*<br/>
Określa kwotę, przez którą należy pomnożyć bieżący zakres x.

*xDenom (*<br/>
Określa kwotę, przez którą należy podzielić wynik pomnożenia bieżącego zakresu x przez wartość parametru *xNum.*

*yNum*<br/>
Określa kwotę, przez którą należy pomnożyć bieżący zakres y.

*yDenom (yDenom)*<br/>
Określa kwotę, przez którą należy podzielić wynik pomnożenia bieżącego zakresu y przez wartość parametru *yNum.*

### <a name="return-value"></a>Wartość zwracana

Poprzednie zakresy okna (w jednostkach `CSize` logicznych) jako obiekt.

### <a name="remarks"></a>Uwagi

Formuły są zapisywane w następujący sposób:

`xNewWE = ( xOldWE * xNum ) / xDenom`

`yNewWE = ( yOldWE * yNum ) / yDenom`

Nowe zakresy okien są obliczane przez pomnożenie bieżących zakresów przez dany licznik, a następnie podzielenie przez dany mianownik.

## <a name="cdcscrolldc"></a><a name="scrolldc"></a>CDC::ScrollDC

Przewija prostokąt bitów w poziomie i pionie.

```
BOOL ScrollDC(
    int dx,
    int dy,
    LPCRECT lpRectScroll,
    LPCRECT lpRectClip,
    CRgn* pRgnUpdate,
    LPRECT lpRectUpdate);
```

### <a name="parameters"></a>Parametry

*Dx*<br/>
Określa liczbę poziomych jednostek przewijania.

*Dy*<br/>
Określa liczbę jednostek przewijania w pionie.

*lpRectScroll*<br/>
Wskazuje strukturę `RECT` `CRect` lub obiekt zawierający współrzędne przewijania prostokąta.

*lpRectClip (lpRectClip)*<br/>
Wskazuje na `RECT` strukturę lub `CRect` obiekt zawierający współrzędne prostokąta przycinającego. Gdy ten prostokąt jest mniejszy niż oryginalny, na który wskazuje *lpRectScroll,* przewijanie odbywa się tylko w mniejszym prostokącie.

*pRgnUpdate (pRgnUpdate)*<br/>
Identyfikuje region odkryty przez proces przewijania. Funkcja `ScrollDC` definiuje ten region; niekoniecznie jest to prostokąt.

*lpRectUpdate*<br/>
Wskazuje strukturę `RECT` `CRect` lub obiekt, który odbiera współrzędne prostokąta, który ogranicza przewijanie regionu aktualizacji. Jest to największy prostokątny obszar, który wymaga ponownego malowania. Wartości w strukturze lub obiekcie, gdy zwraca funkcję są we współrzędnych klienta, niezależnie od trybu mapowania dla danego kontekstu urządzenia.

### <a name="return-value"></a>Wartość zwracana

Nonzero, jeśli przewijanie jest wykonywane; w przeciwnym razie 0.

### <a name="remarks"></a>Uwagi

Jeśli *lpRectUpdate* ma wartość NULL, system Windows nie oblicza prostokąta aktualizacji. Jeśli zarówno *pRgnUpdate* i *lpRectUpdate* mają wartość NULL, system Windows nie oblicza regionu aktualizacji. Jeśli *pRgnUpdate* nie ma wartości NULL, system Windows zakłada, że zawiera prawidłowy wskaźnik `ScrollDC` do regionu odkryte przez proces przewijania (zdefiniowane przez funkcję elementu członkowskiego). Region aktualizacji zwrócony w *lpRectUpdate* można przekazać do, `CWnd::InvalidateRgn` jeśli jest to wymagane.

Aplikacja powinna używać `ScrollWindow` funkcji elementu `CWnd` członkowskiego klasy, gdy jest to konieczne do przewijania całego obszaru klienta okna. W przeciwnym razie `ScrollDC`należy użyć .

## <a name="cdcselectclippath"></a><a name="selectclippath"></a>CDC::SelectClipPath

Wybiera bieżącą ścieżkę jako region przycinania dla kontekstu urządzenia, łącząc nowy region z dowolnym istniejącym regionem przycinania przy użyciu określonego trybu.

```
BOOL SelectClipPath(int nMode);
```

### <a name="parameters"></a>Parametry

*nMode*<br/>
Określa sposób użycia ścieżki. Dozwolone są następujące wartości:

- RGN_AND Nowy obszar przycinania obejmuje przecięcie (nakładające się obszary) bieżącego regionu przycinania i bieżącą ścieżkę.

- RGN_COPY Nowy region przycinania jest bieżącą ścieżką.

- RGN_DIFF Nowy region przycinania obejmuje obszary bieżącego regionu przycinania, a obszary bieżącej ścieżki są wykluczone.

- RGN_OR Nowy region przycinania obejmuje unię (połączone obszary) bieżącego regionu przycinania i bieżącą ścieżkę.

- RGN_XOR Nowy region przycinania obejmuje unię bieżącego regionu przycinania i bieżącej ścieżki, ale bez nakładających się obszarów.

### <a name="return-value"></a>Wartość zwracana

Różne od zera, jeśli funkcja zakończyła się pomyślnie; w przeciwnym razie 0.

### <a name="remarks"></a>Uwagi

Zidentyfikowany kontekst urządzenia musi zawierać zamkniętą ścieżkę.

## <a name="cdcselectcliprgn"></a><a name="selectcliprgn"></a>CDC::SelectCliprgn

Wybiera dany region jako bieżący region przycinania dla kontekstu urządzenia.

```
int SelectClipRgn(CRgn* pRgn);

int SelectClipRgn(
    CRgn* pRgn,
    int nMode);
```

### <a name="parameters"></a>Parametry

*pRgn*<br/>
Identyfikuje region, który ma zostać wybrany.

- W przypadku pierwszej wersji tej funkcji, jeśli ta wartość jest NULL, cały obszar klienta jest zaznaczony, a dane wyjściowe są nadal przycinane do okna.

- Dla drugiej wersji tej funkcji ten uchwyt może być NULL tylko wtedy, gdy określono tryb RGN_COPY.

*nMode*<br/>
Określa operację, która ma zostać wykonana. Musi to być jedna z następujących wartości:

- RGN_AND Nowy region przycinania łączy nakładające się obszary bieżącego regionu przycinania i regionu oznaczonego przez *pRgn*.

- RGN_COPY Nowy region wycinka jest kopią regionu wskazanego przez *pRgn*. Jest to funkcjonalność jest identyczna `SelectClipRgn`z pierwszą wersją programu . Jeśli region identyfikowany przez *pRgn* ma wartość NULL, nowy region przycinania staje się domyślnym regionem przycinania (regionem zerowym).

- RGN_DIFF Nowy region przycinania łączy obszary bieżącego regionu przycinania z obszarami wyłączonymi z regionu wskazanego przez *pRgn*.

- RGN_OR Nowy region przycinania łączy bieżący region przycinania i region identyfikowany przez *pRgn*.

- RGN_XOR Nowy region przycinania łączy bieżący region przycinania i region identyfikowany przez *pRgn,* ale wyklucza wszelkie nakładające się obszary.

### <a name="return-value"></a>Wartość zwracana

Typ regionu. Może to być dowolna z następujących wartości:

- COMPLEXREGION Nowy obszar przycinania ma nakładające się obramowania.

- BŁĄD Kontekst urządzenia lub region jest nieprawidłowy.

- NULLREGION Nowy region przycinania jest pusty.

- SIMPLEREGION Nowy obszar przycinania nie ma nakładających się obramowań.

### <a name="remarks"></a>Uwagi

Używana jest tylko kopia wybranego regionu. Sam region można wybrać dla dowolnej liczby innych kontekstów urządzenia lub można go usunąć.

Funkcja zakłada, że współrzędne dla danego regionu są określone w jednostkach urządzenia. Niektóre urządzenia drukarki obsługują dane wyjściowe tekstu w wyższej rozdzielczości niż dane wyjściowe grafiki w celu zachowania precyzji potrzebnej do wyrażania metryk tekstu. Urządzenia te zgłaszają jednostki urządzenia w wyższej rozdzielczości, czyli w jednostkach tekstowych. Urządzenia te skalują współrzędne grafiki tak, aby kilka zgłoszonych jednostek urządzenia było mapowanych tylko na 1 jednostkę graficzną. `SelectClipRgn` Funkcję należy zawsze wywoływać przy użyciu jednostek tekstowych.

Aplikacje, które muszą podjąć skalowanie obiektów graficznych w GDI można użyć getscalingfactor ucieczki drukarki do określenia współczynnika skalowania. Ten współczynnik skalowania wpływa na przycinanie. Jeśli region jest używany do przycinania grafiki, GDI dzieli współrzędne przez współczynnik skalowania. Jeśli region jest używany do przycinania tekstu, GDI nie powoduje dopasowania skalowania. Współczynnik skalowania 1 powoduje, że współrzędne mają być podzielone przez 2; współczynnik skalowania 2 powoduje, że współrzędne są podzielone przez 4; i tak dalej.

## <a name="cdcselectobject"></a><a name="selectobject"></a>CDC::SelectObject

Wybiera obiekt w kontekście urządzenia.

```
CPen* SelectObject(CPen* pPen);
CBrush* SelectObject(CBrush* pBrush);
virtual CFont* SelectObject(CFont* pFont);
CBitmap* SelectObject(CBitmap* pBitmap);
int SelectObject(CRgn* pRgn);
CGdiObject* SelectObject(CGdiObject* pObject);
```

### <a name="parameters"></a>Parametry

*pPen*<br/>
Wskaźnik do obiektu [CPen](../../mfc/reference/cpen-class.md) do wyboru.

*pBrush (pędzel)*<br/>
Wskaźnik do [obiektu CBrush](../../mfc/reference/cbrush-class.md) do wyboru.

*pFont (pFont)*<br/>
Wskaźnik do obiektu [CFont](../../mfc/reference/cfont-class.md) do wyboru.

*pBitmapa*<br/>
Wskaźnik do obiektu [CBitmap](../../mfc/reference/cbitmap-class.md) do zaznaczenia.

*pRgn*<br/>
Wskaźnik do obiektu [CRgn](../../mfc/reference/crgn-class.md) do wyboru.

*Pobject*<br/>
Wskaźnik do obiektu [CGdiObject](../../mfc/reference/cgdiobject-class.md) do zaznaczenia.

### <a name="return-value"></a>Wartość zwracana

Wskaźnik do zastępowany obiekt. Jest to wskaźnik do obiektu jednej z `CGdiObject`klas pochodnych `CPen`, takich jak , w zależności od wersji funkcji jest używany. Zwracana wartość jest NULL, jeśli występuje błąd. Ta funkcja może zwrócić wskaźnik do obiektu tymczasowego. Ten obiekt tymczasowy jest prawidłowy tylko podczas przetwarzania jednej wiadomości systemu Windows. Aby uzyskać więcej informacji, zobacz `CGdiObject::FromHandle`.

Wersja funkcji elementu członkowskiego, która przyjmuje parametr regionu `SelectClipRgn` wykonuje to samo zadanie, co funkcja elementu członkowskiego. Jego zwracana wartość może być dowolną z następujących czynności:

- COMPLEXREGION Nowy obszar przycinania ma nakładające się obramowania.

- BŁĄD Kontekst urządzenia lub region jest nieprawidłowy.

- NULLREGION Nowy region przycinania jest pusty.

- SIMPLEREGION Nowy obszar przycinania nie ma nakładających się obramowań.

### <a name="remarks"></a>Uwagi

Klasa `CDC` zawiera pięć wersji wyspecjalizowanych dla określonych rodzajów obiektów GDI, w tym piór, pędzli, czcionek, map bitowych i regionów. Nowo wybrany obiekt zastępuje poprzedni obiekt tego samego typu. Na przykład, jeśli *pObject* ogólnej `SelectObject` wersji wskazuje na [obiekt CPen,](../../mfc/reference/cpen-class.md) funkcja zastępuje bieżące pióro piórem określonym przez *pObject*.

Aplikacja może wybrać bitmapę tylko w kontekstach urządzenia pamięci i tylko w jednym kontekście urządzenia pamięci naraz. Format mapy bitowej musi być monochromatyczny lub zgodny z kontekstem urządzenia; jeśli tak nie `SelectObject` jest, zwraca błąd.

W systemie Windows 3.1 `SelectObject` lub nowszym funkcja zwraca tę samą wartość, niezależnie od tego, czy jest używana w metapliku, czy nie. W poprzednich wersjach `SelectObject` systemu Windows zwrócono wartość niezerową dla powodzenia i 0 dla awarii, gdy był używany w metapliku.

## <a name="cdcselectpalette"></a><a name="selectpalette"></a>CDC::SelectPalette

Wybiera paletę logiczną określoną przez *pPalette* jako wybrany obiekt palety kontekstu urządzenia.

```
CPalette* SelectPalette(
    CPalette* pPalette,
    BOOL bForceBackground);
```

### <a name="parameters"></a>Parametry

*pPalette (ppalette)*<br/>
Identyfikuje paletę logiczną, która ma zostać wybrana. Ta paleta musi już zostać `CPalette` utworzona za pomocą funkcji członkowskiej [CreatePalette](../../mfc/reference/cpalette-class.md#createpalette).

*bForceBackground (Na terenie)*<br/>
Określa, czy paleta logiczna jest wymuszona jako paleta tła. Jeśli *bForceBackground* jest niezerowy, wybrana paleta jest zawsze paletą tła, niezależnie od tego, czy okno ma fokus wejściowy. Jeśli *bForceBackground* jest 0 i kontekst urządzenia jest dołączony do okna, paleta logiczna jest paleta pierwszego planu, gdy okno ma fokus wejściowy.

### <a name="return-value"></a>Wartość zwracana

Wskaźnik do `CPalette` obiektu identyfikującego paletę logiczną zastąpiona paletą określoną przez *pPalette*. Jest null, jeśli występuje błąd.

### <a name="remarks"></a>Uwagi

Nowa paleta staje się obiektem palety używanym przez GDI do sterowania kolorami wyświetlanymi w kontekście urządzenia i zastępuje poprzednią paletę.

Aplikacja może wybrać paletę logiczną w więcej niż jednym kontekście urządzenia. Jednak zmiany w palecie logicznej będą miały wpływ na wszystkie konteksty urządzeń, dla których jest zaznaczona. Jeśli aplikacja wybierze paletę w więcej niż jednym kontekście urządzenia, wszystkie konteksty urządzenia muszą należeć do tego samego urządzenia fizycznego.

## <a name="cdcselectstockobject"></a><a name="selectstockobject"></a>CDC::SelectStockObject

Wybiera obiekt [CGdiObject,](../../mfc/reference/cgdiobject-class.md) który odpowiada jednemu ze wstępnie zdefiniowanych piór, pędzli lub czcionek.

```
virtual CGdiObject* SelectStockObject(int nIndex);
```

### <a name="parameters"></a>Parametry

*Nindex*<br/>
Określa żądany rodzaj obiektu giełdowego. Może to być jedna z następujących wartości:

- BLACK_BRUSH Czarna szczotka.

- DKGRAY_BRUSH ciemnoszary pędzel.

- GRAY_BRUSH Szary pędzel.

- HOLLOW_BRUSH Szczotka Hollow.

- LTGRAY_BRUSH jasnoszary pędzel.

- NULL_BRUSH pędzel zerowy.

- WHITE_BRUSH Biały pędzel.

- BLACK_PEN Czarny długopis.

- NULL_PEN Pióro zerowe.

- WHITE_PEN Pióro białe.

- ANSI_FIXED_FONT stała czcionka systemowa ANSI.

- ANSI_VAR_FONT czcionkę systemową zmiennej ANSI.

- DEVICE_DEFAULT_FONT czcionka zależna od urządzenia.

- OEM_FIXED_FONT czcionka stała zależna od OEM.

- SYSTEM_FONT Czcionka systemowa. Domyślnie system Windows używa czcionki systemowej do rysowania menu, kontrolek okien dialogowych i innego tekstu. Najlepiej jednak nie polegać na SYSTEM_FONT, aby uzyskać czcionkę używaną przez okna dialogowe i okna. Zamiast tego należy `SystemParametersInfo` użyć funkcji z parametrem SPI_GETNONCLIENTMETRICS, aby pobrać bieżącą czcionkę. `SystemParametersInfo`uwzględnia bieżący motyw i zawiera informacje o czcionkach dla podpisów, menu i okien dialogowych wiadomości.

- SYSTEM_FIXED_FONT Czcionka systemowa o stałej szerokości używana w systemie Windows przed wersją 3.0. Ten obiekt jest dostępny dla zgodności z wcześniejszymi wersjami systemu Windows.

- DEFAULT_PALETTE Domyślna paleta kolorów. Ta paleta składa się z 20 statycznych kolorów w palecie systemowej.

### <a name="return-value"></a>Wartość zwracana

Wskaźnik do `CGdiObject` obiektu, który został zastąpiony, jeśli funkcja zakończy się pomyślnie. Rzeczywisty obiekt wskazał jest [CPen](../../mfc/reference/cpen-class.md), [CBrush](../../mfc/reference/cbrush-class.md)lub [CFont](../../mfc/reference/cfont-class.md) obiektu. Jeśli wywołanie nie powiedzie się, zwracana wartość to NULL.

## <a name="cdcsetabortproc"></a><a name="setabortproc"></a>CDC::SetAbortProc

Instaluje procedurę przerwania zadania drukowania.

```
int SetAbortProc(BOOL (CALLBACK* lpfn)(HDC, int));
```

### <a name="parameters"></a>Parametry

*lpfn*<br/>
Wskaźnik do funkcji przerwania, aby zainstalować jako procedurę przerwania. Aby uzyskać więcej informacji na temat funkcji wywołania zwrotnego, zobacz [Funkcja wywołania zwrotnego dla CDC::SetAbortProc](callback-functions-used-by-mfc.md#setabortproc).

### <a name="return-value"></a>Wartość zwracana

Określa wynik `SetAbortProc` funkcji. Niektóre z następujących wartości są bardziej prawdopodobne niż inne, ale wszystkie są możliwe.

- SP_ERROR Błąd ogólny.

- SP_OUTOFDISK Obecnie nie ma wystarczającej ilości miejsca na dysku do buforowania i nie będzie więcej miejsca.

- SP_OUTOFMEMORY Za mało pamięci jest dostępna do buforowania.

- SP_USERABORT Użytkownik zakończył zadanie za pośrednictwem Menedżera wydruku.

### <a name="remarks"></a>Uwagi

Jeśli aplikacja ma zezwolić na anulowanie zadania drukowania podczas buforowania, musi ustawić funkcję przerwania przed rozpoczęciem zadania drukowania za pomocą funkcji elementu członkowskiego [StartDoc.](#startdoc) Menedżer wydruku wywołuje funkcję przerwania podczas buforowania, aby umożliwić aplikacji anulowanie zadania drukowania lub przetworzenie warunków braku miejsca na dysku. Jeśli nie ustawiono żadnej funkcji przerwania, zadanie drukowania zakończy się niepowodzeniem, jeśli nie ma wystarczającej ilości miejsca na dysku do buforowania.

Należy zauważyć, że funkcje programu Microsoft Visual C++ `SetAbortProc`upraszczają tworzenie funkcji wywołania zwrotnego przekazanych do programu . Adres przekazany do `EnumObjects` funkcji elementu członkowskiego jest wskaźnikiem `__declspec(dllexport)` do `__stdcall` funkcji eksportowane z i z konwencji wywołującej.

Nie trzeba również eksportować nazwę funkcji w **instrukcji EXPORTS** w pliku definicji modułu aplikacji. Zamiast tego można użyć modyfikatora funkcji **EKSPORT,** jak w

**BOOL CALLBACK EXPORT** AFunction( **HDC**, `int` **);**

, aby spowodować, że kompilator emituje odpowiedni rekord eksportu do eksportu według nazwy bez aliasowania. Działa to w większości potrzeb. W niektórych szczególnych przypadkach, takich jak eksportowanie funkcji przez porządkowanie lub aliasowanie eksportu, nadal należy użyć instrukcji **EXPORTS** w pliku definicji modułu.

Interfejsy rejestracji wywołania zwrotnego są teraz bezpieczne dla typu (należy przekazać w wskaźniku funkcji, który wskazuje odpowiedni rodzaj funkcji dla określonego wywołania zwrotnego).

Należy również zauważyć, że wszystkie funkcje wywołania zwrotnego muszą zalewkować wyjątki programu Microsoft Foundation przed powrotem do systemu Windows, ponieważ wyjątki nie mogą być generowane przez granice wywołania zwrotnego. Aby uzyskać więcej informacji na temat wyjątków, zobacz artykuł [Wyjątki](../../mfc/exception-handling-in-mfc.md).

## <a name="cdcsetarcdirection"></a><a name="setarcdirection"></a>CDC::Kierunek Ustawiania eksc.

Ustawia kierunek rysowania, który ma być używany dla funkcji łuku i prostokąta.

```
int SetArcDirection(int nArcDirection);
```

### <a name="parameters"></a>Parametry

*nArcKierunkow*<br/>
Określa nowy kierunek łuku. Ten parametr może być jedną z następujących wartości:

- AD_COUNTERCLOCKWISE rysunki rysowane w kierunku przeciwnym do ruchu wskazówek zegara.

- AD_CLOCKWISE Rysunki rysowane zgodnie z ruchem wskazówek zegara.

### <a name="return-value"></a>Wartość zwracana

Określa stary kierunek łuku, jeśli zakończy się pomyślnie; w przeciwnym razie 0.

### <a name="remarks"></a>Uwagi

Domyślnym kierunkiem jest przeciwnie do ruchu wskazówek zegara. Funkcja `SetArcDirection` określa kierunek, w którym rysowane są następujące funkcje:

|Arc|Kołowy|
|---------|---------|
|`ArcTo`|`Rectangle`|
|`Chord`|`RoundRect`|
|`Ellipse`||

## <a name="cdcsetattribdc"></a><a name="setattribdc"></a>CDC::SetAttribDC

Wywołanie tej funkcji, aby ustawić `m_hAttribDC`kontekst urządzenia atrybutu, .

```
virtual void SetAttribDC(HDC hDC);
```

### <a name="parameters"></a>Parametry

*Hdc*<br/>
Kontekst urządzenia z systemem Windows.

### <a name="remarks"></a>Uwagi

Ta funkcja elementu członkowskiego nie dołącza `CDC` kontekstu urządzenia do obiektu. Tylko kontekst urządzenia wyjściowego `CDC` jest dołączony do obiektu.

## <a name="cdcsetbkcolor"></a><a name="setbkcolor"></a>CDC::SetBkColor

Ustawia bieżący kolor tła na określony kolor.

```
virtual COLORREF SetBkColor(COLORREF crColor);
```

### <a name="parameters"></a>Parametry

*CrColor ( kolor)*<br/>
Określa nowy kolor tła.

### <a name="return-value"></a>Wartość zwracana

Poprzedni kolor tła jako wartość koloru RGB. Jeśli wystąpi błąd, zwracana wartość wynosi 0x800000000.

### <a name="remarks"></a>Uwagi

Jeśli tryb tła jest NIEPRZEZROCZYSTY, system używa koloru tła do wypełniania przerw w stylizowanych liniach, odstępów między kreskowanymi liniami w pędzlach i tła w komórkach znaków. System używa również koloru tła podczas konwertowania bitmap między kolorami i monochromatycznymi kontekstami urządzeń.

Jeśli urządzenie nie może wyświetlić określonego koloru, system ustawia kolor tła na najbliższy kolor fizyczny.

## <a name="cdcsetbkmode"></a><a name="setbkmode"></a>CDC::SetBkMode

Ustawia tryb tła.

```
int SetBkMode(int nBkMode);
```

### <a name="parameters"></a>Parametry

*nBkMode (nBkMode)*<br/>
Określa tryb, który ma być ustawiony. Ten parametr może być jedną z następujących wartości:

- Tło OPAQUE jest wypełnione bieżącym kolorem tła przed narysowaniem tekstu, kreskowanego pędzla lub pióra. Jest to domyślny tryb tła.

- PRZEZROCZYSTE tło nie jest zmieniane przed rysowaniem.

### <a name="return-value"></a>Wartość zwracana

Poprzedni tryb tła.

### <a name="remarks"></a>Uwagi

Tryb tła określa, czy system usuwa istniejące kolory tła na powierzchni rysunku przed rysowaniem tekstu, kreskowanych pędzli lub dowolnego stylu pióra, który nie jest linią ciągłą.

### <a name="example"></a>Przykład

  Zobacz przykład [CWnd::OnCtlColor](../../mfc/reference/cwnd-class.md#onctlcolor).

## <a name="cdcsetboundsrect"></a><a name="setboundsrect"></a>CDC::SetBoundsRect

Steruje akumulacją informacji ograniczających prostokąta dla określonego kontekstu urządzenia.

```
UINT SetBoundsRect(
    LPCRECT lpRectBounds,
    UINT flags);
```

### <a name="parameters"></a>Parametry

*lpRectBounds (lpRectBounds)*<br/>
Wskazuje strukturę `RECT` `CRect` lub obiekt, który jest używany do ustawiania prostokąta ograniczającego. Wymiary prostokąta są podane we współrzędnych logicznych. Ten parametr może mieć wartość NULL.

*flagi*<br/>
Określa sposób łączenia nowego prostokąta z skumulowanym prostokątem. Ten parametr może być kombinacją następujących wartości:

- DCB_ACCUMULATE Dodaj prostokąt określony przez *lpRectBounds* do prostokąta ograniczającego (przy użyciu operacji unii prostokąta).

- DCB_DISABLE Wyłącz akumulację granic.

- DCB_ENABLE Włącz akumulację granic. (Domyślne ustawienie akumulacji granic jest wyłączone).

### <a name="return-value"></a>Wartość zwracana

Bieżący stan prostokąta ograniczającego, jeśli funkcja zakończy się pomyślnie. Podobnie jak *flagi*, zwracana wartość może być kombinacją **wartości DCB_:**

- DCB_ACCUMULATE Prostokąt ograniczający nie jest pusty. Ta wartość będzie zawsze ustawiona.

- DCB_DISABLE akumulacja granic jest wyłączona.

- DCB_ENABLE akumulacja granic jest wł..

### <a name="remarks"></a>Uwagi

System Windows może utrzymywać prostokąt ograniczający dla wszystkich operacji rysowania. Ten prostokąt może być wyszukiwany i resetowany przez aplikację. Granice rysunku są przydatne do unieważniania pamięci podręcznych map bitowych.

## <a name="cdcsetbrushorg"></a><a name="setbrushorg"></a>CDC::SetBrushOrg

Określa początek, który GDI przypisze do następnego pędzla, który aplikacja wybiera w kontekście urządzenia.

```
CPoint SetBrushOrg(
    int x,
    int y);

CPoint SetBrushOrg(POINT point);
```

### <a name="parameters"></a>Parametry

*X*<br/>
Określa współrzędną x (w jednostkach urządzeń) nowego źródła. Ta wartość musi znajdować się w zakresie 0-7.

*Y*<br/>
Określa współrzędną y (w jednostkach urządzeń) nowego początku układu współrzędnych. Ta wartość musi znajdować się w zakresie 0-7.

*Punkt*<br/>
Określa współrzędne x i y nowego źródła. Każda wartość musi znajdować się w zakresie 0-7. Można przekazać strukturę `POINT` lub `CPoint` obiekt dla tego parametru.

### <a name="return-value"></a>Wartość zwracana

Poprzednie pochodzenie pędzla w jednostkach urządzenia.

### <a name="remarks"></a>Uwagi

Domyślne współrzędne początku pędzla to (0, 0). Aby zmienić początek pędzla, `UnrealizeObject` należy `CBrush` wywołać `SetBrushOrg`funkcję obiektu, `SelectObject` wywołać , a następnie wywołać funkcję elementu członkowskiego, aby wybrać pędzel w kontekście urządzenia.

Nie należy `SetBrushOrg` używać `CBrush` z obiektami magazynowymi.

## <a name="cdcsetcoloradjustment"></a><a name="setcoloradjustment"></a>CDC::SetColorAdjustment

Ustawia wartości dopasowania kolorów dla kontekstu urządzenia przy użyciu określonych wartości.

```
BOOL SetColorAdjustment(const COLORADJUSTMENT* lpColorAdjust);
```

### <a name="parameters"></a>Parametry

*lpColorAdjust*<br/>
Wskazuje strukturę danych [COLORADJUSTMENT](/windows/win32/api/wingdi/ns-wingdi-coloradjustment) zawierającą wartości dopasowania kolorów.

### <a name="return-value"></a>Wartość zwracana

Nonzero jeśli się powiedzie; w przeciwnym razie 0.

### <a name="remarks"></a>Uwagi

Wartości dopasowania kolorów służą do dostosowywania koloru wejściowego źródłowej `CDC::StretchBlt` mapy bitowej dla wywołań funkcji elementu członkowskiego po ustawieniu trybu HALFTONE.

## <a name="cdcsetdcbrushcolor"></a><a name="setdcbrushcolor"></a>CDC::SetDCBrushColor

Ustawia kolor pędzla bieżącego kontekstu urządzenia (DC) na określoną wartość koloru.

```
COLORREF SetDCBrushColor(COLORREF crColor);
```

### <a name="parameters"></a>Parametry

*CrColor ( kolor)*<br/>
Określa nowy kolor pędzla.

### <a name="return-value"></a>Wartość zwracana

Jeśli funkcja powiedzie się, zwracana wartość określa poprzedni kolor pędzla DC jako wartość COLORREF.

Jeśli funkcja nie powiedzie się, zwracana wartość jest CLR_INVALID.

### <a name="remarks"></a>Uwagi

Ta metoda emuluje funkcjonalność funkcji [SetDCBrushColor](/windows/win32/api/wingdi/nf-wingdi-setdcbrushcolor), zgodnie z opisem w zestawie Windows SDK.

## <a name="cdcsetdcpencolor"></a><a name="setdcpencolor"></a>CDC::SetDCPenColor

Ustawia bieżący kolor pióra kontekstu urządzenia (DC) na określoną wartość koloru.

```
COLORREF SetDCPenColor(COLORREF crColor);
```

### <a name="parameters"></a>Parametry

*CrColor ( kolor)*<br/>
Określa nowy kolor pióra.

### <a name="return-value"></a>Wartość zwracana

Różne od zera, jeśli funkcja zakończyła się pomyślnie; w przeciwnym razie 0.

### <a name="remarks"></a>Uwagi

Ta funkcja elementu członkowskiego wykorzystuje funkcję Win32 [SetDCPenColor](/windows/win32/api/wingdi/nf-wingdi-setdcpencolor), zgodnie z opisem w zestawie Windows SDK.

## <a name="cdcsetgraphicsmode"></a><a name="setgraphicsmode"></a>CDC::SetGraphicsMode

Ustawia tryb grafiki dla określonego kontekstu urządzenia.

```
int SetGraphicsMode(int iMode);
```

### <a name="parameters"></a>Parametry

*iMode*<br/>
Określa tryb graficzny. Aby uzyskać listę wartości, które ten parametr może przyjmować, zobacz [SetGraphicsMode](/windows/win32/api/wingdi/nf-wingdi-setgraphicsmode).

### <a name="return-value"></a>Wartość zwracana

Zwraca stary tryb graficzny na sukces.

Zwraca wartość 0 w przypadku awarii. Aby uzyskać rozszerzone informacje o błędzie, zadzwoń [do GetLastError](/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror).

### <a name="remarks"></a>Uwagi

Ta metoda zawija funkcję Windows GDI [SetGraphicsMode](/windows/win32/api/wingdi/nf-wingdi-setgraphicsmode).

## <a name="cdcsetlayout"></a><a name="setlayout"></a>CDC::SetLayout

Wywołanie tej funkcji elementu członkowskiego, aby zmienić układ tekstu i grafiki dla kontekstu urządzenia od prawej do lewej, standardowy układ dla kultur, takich jak arabski i hebrajski.

```
DWORD SetLayout(DWORD dwLayout);
```

### <a name="parameters"></a>Parametry

*dwLayout*<br/>
Układ kontekstu urządzenia i flagi sterujące mapy bitowej. Może to być kombinacja następujących wartości.

|Wartość|Znaczenie|
|-----------|-------------|
|LAYOUT_BITMAPORIENTATIONPRESERVED|Wyłącza wszelkie odbicia dla wywołań [CDC::BitBlt](#bitblt) i [CDC::StretchBlt](#stretchblt).|
|LAYOUT_RTL|Ustawia domyślny układ poziomy na prawy do lewej.|
|LAYOUT_LTR|Ustawia domyślny układ do lewej do prawej.|

### <a name="return-value"></a>Wartość zwracana

Jeśli się powiedzie, poprzedni układ kontekstu urządzenia.

Jeśli się nie powiedzie, GDI_ERROR. Aby uzyskać rozszerzone informacje o błędzie, zadzwoń [do GetLastError](/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror).

### <a name="remarks"></a>Uwagi

Normalnie nie można `SetLayout` wywołać okna. Zamiast tego można sterować układem od prawej do lewej w oknie, ustawiając [style rozszerzonego okna,](../../mfc/reference/styles-used-by-mfc.md#extended-window-styles) takie jak WS_EX_RTLREADING. Kontekst urządzenia, taki jak drukarka lub metaplik, nie dziedziczy tego układu. Jedynym sposobem ustawienia kontekstu urządzenia dla układu od prawej `SetLayout`do lewej jest wywołanie .

Jeśli wywołasz **SetLayout(LAYOUT_RTL),** `SetLayout` automatycznie zmieni tryb mapowania na MM_ISOTROPIC. W rezultacie kolejne wywołanie [GetMapMode](#getmapmode) zwróci MM_ISOTROPIC zamiast MM_TEXT.

W niektórych przypadkach, na przykład w przypadku wielu map bitowych, można zachować układ od lewej do prawej. W takich przypadkach renderuj `BitBlt` `StretchBlt`obraz przez wywołanie lub , a następnie ustaw flagę sterującą mapy bitowej dla *dwLayout,* aby LAYOUT_BITMAPORIENTATIONPRESERVED.

Po zmianie układu z flagą LAYOUT_RTL flagi zwykle określające prawo lub lewo są odwrócone. Aby uniknąć nieporozumień, można zdefiniować alternatywne nazwy dla standardowych flag. Aby uzyskać listę sugerowanych alternatywnych nazw flag, zobacz [SetLayout](/windows/win32/api/wingdi/nf-wingdi-setlayout) w zestawie Windows SDK.

## <a name="cdcsetmapmode"></a><a name="setmapmode"></a>CDC::SetMapMode

Ustawia tryb mapowania.

```
virtual int SetMapMode(int nMapMode);
```

### <a name="parameters"></a>Parametry

*tryb nMapMode*<br/>
Określa nowy tryb mapowania. Może to być jedna z następujących wartości:

- MM_ANISOTROPIC Jednostki logiczne są konwertowane na dowolne jednostki z dowolnie skalowanymi osiami. Ustawienie trybu mapowania na MM_ANISOTROPIC nie powoduje zmiany bieżącego okna ani ustawień rzutni. Aby zmienić jednostki, orientację i skalowanie, wywołaj funkcje członkowskie [SetWindowExt](#setwindowext) i [SetViewportExt.](#setviewportext)

- MM_HIENGLISH Każda jednostka logiczna jest konwertowana na 0,001 cala. Dodatni x jest po prawej stronie; dodatni y jest w górę.

- MM_HIMETRIC Każda jednostka logiczna jest konwertowana na 0,01 milimetra. Dodatni x jest po prawej stronie; dodatni y jest w górę.

- MM_ISOTROPIC jednostki logiczne są konwertowane na dowolne jednostki z równo skalowanymi osiami; oznacza to, że 1 jednostka wzdłuż osi x jest równa 1 jednostce wzdłuż osi y. Użyj `SetWindowExt` funkcji `SetViewportExt` i elementów członkowskich, aby określić żądane jednostki i orientację osi. GDI dokonuje regulacji w razie potrzeby, aby upewnić się, że jednostki x i y pozostają tego samego rozmiaru.

- MM_LOENGLISH Każda jednostka logiczna jest konwertowana na 0,01 cala. Dodatni x jest po prawej stronie; dodatni y jest w górę.

- MM_LOMETRIC Każda jednostka logiczna jest konwertowana na 0,1 milimetra. Dodatni x jest po prawej stronie; dodatni y jest w górę.

- MM_TEXT Każda jednostka logiczna jest konwertowana na 1 piksel urządzenia. Dodatni x jest po prawej stronie; dodatni y jest w dół.

- MM_TWIPS Każda jednostka logiczna jest konwertowana na 1/20 punktu. (Ponieważ punkt wynosi 1/72 cala, twip wynosi 1/1440 cala.) Dodatni x jest po prawej stronie; dodatni y jest w górę.

### <a name="return-value"></a>Wartość zwracana

Poprzedni tryb mapowania.

### <a name="remarks"></a>Uwagi

Tryb mapowania definiuje jednostkę miary używaną do konwersji jednostek logicznych na jednostki urządzenia; określa również orientację osi x i y urządzenia. GDI używa trybu mapowania do konwersji współrzędnych logicznych na odpowiednie współrzędne urządzenia. Tryb MM_TEXT umożliwia aplikacjom pracę w pikselach urządzenia, gdzie 1 jednostka jest równa 1 pikselowi. Fizyczny rozmiar piksela różni się w zależności od urządzenia.

Tryby MM_HIENGLISH, MM_HIMETRIC, MM_LOENGLISH, MM_LOMETRIC i MM_TWIPS są przydatne w zastosowaniach, które muszą być rysowane w jednostkach fizycznie znaczących (takich jak cale lub milimetry). Tryb MM_ISOTROPIC zapewnia proporcje 1:1, co jest przydatne, gdy ważne jest zachowanie dokładnego kształtu obrazu. Tryb MM_ANISOTROPIC umożliwia niezależną regulację współrzędnych x i y.

> [!NOTE]
> Jeśli wywołasz [SetLayout,](#setlayout) aby zmienić układ DC (kontekst `SetLayout` urządzenia) na układ od prawej do lewej, automatycznie zmienisz tryb mapowania na MM_ISOTROPIC.

### <a name="example"></a>Przykład

  Zobacz przykład [CView::OnPrepareDC](../../mfc/reference/cview-class.md#onpreparedc).

## <a name="cdcsetmapperflags"></a><a name="setmapperflags"></a>CDC::SetMapperFlags

Zmienia metodę używaną przez mapera czcionek podczas konwertowania czcionki logicznej na czcionkę fizyczną.

```
DWORD SetMapperFlags(DWORD dwFlag);
```

### <a name="parameters"></a>Parametry

*dwFlag (żużel)*<br/>
Określa, czy maper czcionek próbuje dopasować wysokość i szerokość aspektu czcionki do urządzenia. Gdy ta wartość jest ASPECT_FILTERING, maper wybiera tylko czcionki, których aspekt x i aspekt y dokładnie odpowiadają czcionkom określonego urządzenia.

### <a name="return-value"></a>Wartość zwracana

Poprzednia wartość flagi mapera czcionek.

### <a name="remarks"></a>Uwagi

Aplikacja może `SetMapperFlags` spowodować, że maper czcionek próbuje wybrać tylko czcionkę fizyczną, która dokładnie odpowiada proporcjom określonego urządzenia.

Aplikacja, która używa tylko czcionek `SetMapperFlags` rastrowych, może korzystać z tej funkcji, aby upewnić się, że czcionka wybrana przez mapera czcionek jest atrakcyjna i czytelna na określonym urządzeniu. Aplikacje korzystające z czcionek skalowalnych `SetMapperFlags`(TrueType) zazwyczaj nie używają .

Jeśli żadna czcionka fizyczna nie ma współczynnika proporcji zgodnego ze specyfikacją czcionki logicznej, GDI wybiera nowy współczynnik proporcji i wybiera czcionkę odpowiadającą temu nowemu współczynnikowi proporcji.

## <a name="cdcsetmiterlimit"></a><a name="setmiterlimit"></a>CDC::SetMiterLimit

Ustawia limit długości sprzężeń ścięcie dla kontekstu urządzenia.

```
BOOL SetMiterLimit(float fMiterLimit);
```

### <a name="parameters"></a>Parametry

*fMiterLimit*<br/>
Określa nowy limit ścięcie dla kontekstu urządzenia.

### <a name="return-value"></a>Wartość zwracana

Różne od zera, jeśli funkcja zakończyła się pomyślnie; w przeciwnym razie 0.

### <a name="remarks"></a>Uwagi

Długość ścięcia jest definiowana jako odległość od przecięcia ścian linii po wewnętrznej stronie sprzężenia do przecięcia ścian linii na zewnątrz sprzężenia. Granica dokońcowego jest maksymalnym dozwolonym stosunkiem długości ścięcia do szerokości linii. Domyślny limit ścięcie wynosi 10,0.

## <a name="cdcsetoutputdc"></a><a name="setoutputdc"></a>CDC::SetOutputDC

Wywołanie tej funkcji elementu członkowskiego, `m_hDC`aby ustawić kontekst urządzenia wyjściowego, .

```
virtual void SetOutputDC(HDC hDC);
```

### <a name="parameters"></a>Parametry

*Hdc*<br/>
Kontekst urządzenia z systemem Windows.

### <a name="remarks"></a>Uwagi

Ta funkcja elementu członkowskiego można wywołać tylko wtedy, `CDC` gdy kontekst urządzenia nie został dołączony do obiektu. Ta funkcja `m_hDC` elementu członkowskiego ustawia, ale `CDC` nie dołącza kontekstu urządzenia do obiektu.

## <a name="cdcsetpixel"></a><a name="setpixel"></a>CDC::SetPixel

Ustawia piksel w określonym punkcie do najbliższego przybliżenia koloru określonego przez *crColor*.

```
COLORREF SetPixel(
    int x,
    int y,
    COLORREF crColor);

COLORREF SetPixel(
    POINT point,
    COLORREF crColor);
```

### <a name="parameters"></a>Parametry

*X*<br/>
Określa logiczną współrzędną x punktu, który ma zostać ustawiony.

*Y*<br/>
Określa logiczną współrzędną y punktu, który ma zostać ustawiony.

*CrColor ( kolor)*<br/>
Wartość RGB COLORREF określająca kolor używany do malowania punktu. Opis tej wartości można znaleźć w pliku [COLORREF](/windows/win32/gdi/colorref) w programie Windows SDK.

*Punkt*<br/>
Określa logiczne współrzędne x i y punktu, który ma zostać ustawiony. Można przekazać strukturę `POINT` lub `CPoint` obiekt dla tego parametru.

### <a name="return-value"></a>Wartość zwracana

Wartość RGB dla koloru, który jest rzeczywiście malowany. Ta wartość może się różnić od tej określonej przez *crColor,* jeśli używane jest przybliżenie tego koloru. Jeśli funkcja nie powiedzie się (jeśli punkt znajduje się poza regionem przycinania), zwracana wartość wynosi -1.

### <a name="remarks"></a>Uwagi

Punkt musi znajdować się w regionie przycinania. Jeśli punkt nie znajduje się w regionie przycinania, funkcja nic nie robi.

Nie wszystkie urządzenia `SetPixel` obsługują tę funkcję. Aby ustalić, czy `SetPixel`urządzenie `GetDeviceCaps` obsługuje, należy wywołać funkcję elementu członkowskiego z indeksem RASTERCAPS i sprawdzić wartość zwracaną flagi RC_BITBLT.

## <a name="cdcsetpixelv"></a><a name="setpixelv"></a>CDC::SetPixelv

Ustawia piksel w określonych współrzędnych na najbliższe przybliżenie określonego koloru.

```
BOOL SetPixelV(
    int x,
    int y,
    COLORREF crColor);

BOOL SetPixelV(
    POINT point,
    COLORREF crColor);
```

### <a name="parameters"></a>Parametry

*X*<br/>
Określa współrzędną x w jednostkach logicznych punktu, który ma zostać ustawiony.

*Y*<br/>
Określa współrzędną y w jednostkach logicznych punktu, który ma zostać ustawiony.

*CrColor ( kolor)*<br/>
Określa kolor, który ma być używany do malowania punktu.

*Punkt*<br/>
Określa logiczne współrzędne x i y punktu, który ma zostać ustawiony. Dla tego parametru można przekazać strukturę danych [POINT](/windows/win32/api/windef/ns-windef-point) lub obiekt [CPoint.](../../atl-mfc-shared/reference/cpoint-class.md)

### <a name="return-value"></a>Wartość zwracana

Różne od zera, jeśli funkcja zakończyła się pomyślnie; w przeciwnym razie 0.

### <a name="remarks"></a>Uwagi

Punkt musi znajdować się zarówno w okolicy przycinania, jak i widocznej części powierzchni urządzenia. Nie wszystkie urządzenia obsługują funkcję elementu członkowskiego. Aby uzyskać więcej informacji, zobacz RC_BITBLT `CDC::GetDeviceCaps` możliwości w funkcji elementu członkowskiego. `SetPixelV`jest szybszy niż `SetPixel` dlatego, że nie musi zwracać wartości koloru punktu rzeczywiście malowane.

## <a name="cdcsetpolyfillmode"></a><a name="setpolyfillmode"></a>CDC::SetPolyFillMode

Ustawia tryb wypełniania wielokątów.

```
int SetPolyFillMode(int nPolyFillMode);
```

### <a name="parameters"></a>Parametry

*nPolyFillMode (Polski)*<br/>
Określa nowy tryb napełniania. Wartość ta może być alternatywna lub nawijana. Domyślnym trybem ustawionym w systemie Windows jest ALTERNATE.

### <a name="return-value"></a>Wartość zwracana

Poprzedni tryb napełniania, jeśli zakończy się pomyślnie; w przeciwnym razie 0.

### <a name="remarks"></a>Uwagi

Gdy tryb wypełniania wielokątów jest alternatywny, system wypełnia obszar między nieparzystymi i parzystymi bokami wielokątów w każdej linii skanowania. Oznacza to, że system wypełnia obszar między pierwszą i drugą stroną, między trzecią i czwartą stroną i tak dalej. Ten tryb jest domyślny.

Gdy tryb wypełniania wielokąta jest KRĘTY, system używa kierunku, w którym rysowano figurę, aby określić, czy wypełnić obszar. Każdy segment linii w wielokąt jest rysowany w kierunku zgodnym z ruchem wskazówek zegara lub w kierunku przeciwnym do ruchu wskazówek zegara. Za każdym razem, gdy wyimaginowana linia rysowana z zamkniętego obszaru na zewnątrz figury przechodzi przez segment linii zgodnie z ruchem wskazówek zegara, liczba jest zwiększana. Gdy linia przechodzi przez segment linii przeciwnej do ruchu wskazówek zegara, liczba jest zmniejszana. Obszar jest wypełniany, jeśli liczba jest niezerowa, gdy linia osiągnie zewnętrzną część rysunku.

## <a name="cdcsetrop2"></a><a name="setrop2"></a>CDC::SetROP2

Ustawia bieżący tryb rysowania.

```
int SetROP2(int nDrawMode);
```

### <a name="parameters"></a>Parametry

*nDrawMode (nDrawMode)*<br/>
Określa nowy tryb rysowania. Może to być dowolna z następujących wartości:

- R2_BLACK Pixel jest zawsze czarny.

- R2_WHITE Pixel jest zawsze biały.

- R2_NOP Pixel pozostaje niezmieniony.

- R2_NOT Pixel jest odwrotnością koloru ekranu.

- R2_COPYPEN Pixel to kolor pióra.

- R2_NOTCOPYPEN Pixel jest odwrotnością koloru pióra.

- R2_MERGEPENNOT Pixel to kombinacja koloru pióra i odwrotności koloru ekranu (końcowy piksel = (NIE piksel ekranu) LUB pióro).

- R2_MASKPENNOT Pixel to kombinacja kolorów wspólnych zarówno dla pióra, jak i odwrotności ekranu (piksel końcowy = (NIE piksel ekranu) i pióro).

- R2_MERGENOTPEN Pixel to kombinacja koloru ekranu i odwrotności koloru pióra (piksel końcowy = (NIE pióro) LUB piksel ekranu).

- R2_MASKNOTPEN Pixel to kombinacja kolorów wspólnych zarówno dla ekranu, jak i odwrotności pióra (piksel końcowy = (NIE pióro) i piksel ekranu).

- R2_MERGEPEN Pixel to połączenie koloru pióra i koloru ekranu (końcowy piksel = pióro lub piksel ekranu).

- R2_NOTMERGEPEN Pixel jest odwrotnością koloru R2_MERGEPEN (końcowy piksel = NIE (pióro LUB piksel ekranu)).

- R2_MASKPEN Pixel to kombinacja kolorów wspólnych zarówno dla pióra, jak i ekranu (końcowy piksel = pióro i piksel ekranu).

- R2_NOTMASKPEN Pixel jest odwrotnością koloru R2_MASKPEN (końcowy piksel = NIE (pióro i piksel ekranu)).

- R2_XORPEN Pixel to kombinacja kolorów, które znajdują się w piórze lub na ekranie, ale nie w obu (piksel końcowy = piksel ekranu XOR pióra).

- R2_NOTXORPEN Pixel jest odwrotnością koloru R2_XORPEN (końcowy piksel = NIE (pióro XOR piksel ekranu)).

### <a name="return-value"></a>Wartość zwracana

Poprzedni tryb rysowania.

Może to być dowolna z wartości podanych w sdk systemu Windows.

### <a name="remarks"></a>Uwagi

Tryb rysowania określa sposób łączenia kolorów pióra i wnętrza wypełnionych obiektów z kolorem znajdującym się już na powierzchni wyświetlacza.

Tryb rysowania jest przeznaczony tylko dla urządzeń rastrowych; nie dotyczy urządzeń wektorowych. Tryby rysowania są binarnymi kodami operacji rastrowych reprezentującymi wszystkie możliwe kombinacje logiczne dwóch zmiennych, przy użyciu operatorów binarnych AND, OR i XOR (exclusive OR) i operacji jednoarzędnej NOT.

## <a name="cdcsetstretchbltmode"></a><a name="setstretchbltmode"></a>CDC::SetStretchBltMode

Ustawia tryb rozciągania bitmapy `StretchBlt` dla funkcji elementu członkowskiego.

```
int SetStretchBltMode(int nStretchMode);
```

### <a name="parameters"></a>Parametry

*nStretchMode (Tryb nStretchMode)*<br/>
Określa tryb rozciągania. Może to być dowolna z następujących wartości:

|Wartość|Opis|
|-----------|-----------------|
|BLACKONWHITE (CZARNY, BIAŁEK)|Wykonuje operację logiczną i przy użyciu wartości kolorów dla wyeliminowanych i istniejących pikseli. Jeśli mapa bitowa jest monochromatycznym bitmapą, ten tryb zachowuje czarne piksele kosztem białych pikseli.|
|KOLORBARKOWY|Usuwa piksele. Ten tryb usuwa wszystkie wyeliminowane linie pikseli bez próby zachowania ich informacji.|
|Półtonów|Mapuje piksele z prostokąta źródłowego na bloki pikseli w prostokącie docelowej. Średni kolor nad docelowym blokiem pikseli jest zbliżony do koloru pikseli źródłowych.|
||Po ustawieniu trybu rozciągania HALFTONE aplikacja musi wywołać funkcję Win32 [SetBrushOrgEx,](/windows/win32/api/wingdi/nf-wingdi-setbrushorgex) aby ustawić początek pędzla. Jeśli to się nie uda, występuje niewspółosiowość pędzla.|
|STRETCH_ANDSCANS|**Windows 95/98**: Tak samo jak BLACKONWHITE|
|STRETCH_DELETESCANS|**Windows 95/98**: Tak samo jak COLORONCOLOR|
|STRETCH_HALFTONE|**Windows 95/98**: Tak samo jak HALFTONE.|
|STRETCH_ORSCANS|**Windows 95/98**: Tak samo jak WHITEONBLACK|
|BIAŁYBLACK|Wykonuje operację logiczną LUB przy użyciu wartości kolorów dla wyeliminowanych i istniejących pikseli. Jeśli mapa bitowa jest monochromatycznym bitmapą, ten tryb zachowuje białe piksele kosztem czarnych pikseli.|

### <a name="return-value"></a>Wartość zwracana

Poprzedni tryb rozciągania. Może być STRETCH_ANDSCANS, STRETCH_DELETESCANS lub STRETCH_ORSCANS.

### <a name="remarks"></a>Uwagi

Tryb rozciągania mapy bitowej definiuje sposób usuwania informacji z map bitowych, które są kompresowane przy użyciu funkcji.

Tryby BLACKONWHITE (STRETCH_ANDSCANS) i WHITEONBLACK (STRETCH_ORSCANS) są zwykle używane do zachowania pikseli pierwszego planu w monochromatycznych mapach bitowych. Tryb COLORONCOLOR (STRETCH_DELETESCANS) jest zwykle używany do zachowania koloru w kolorowych mapach bitowych.

Tryb HALFTONE wymaga więcej przetwarzania obrazu źródłowego niż pozostałe trzy tryby; jest wolniejszy niż inne, ale produkuje obrazy wyższej jakości. Należy również `SetBrushOrgEx` pamiętać, że należy wywołać po ustawieniu trybu HALFTONE, aby uniknąć niewspółosiowości pędzla.

Dodatkowe tryby rozciągania mogą być również dostępne w zależności od możliwości sterownika urządzenia.

## <a name="cdcsettextalign"></a><a name="settextalign"></a>CDC::SetTextAlign

Ustawia flagi wyrównania tekstu.

```
UINT SetTextAlign(UINT nFlags);
```

### <a name="parameters"></a>Parametry

*nPłgi*<br/>
Określa flagi wyrównania tekstu. Flagi określają relację między punktem a prostokątem, który ogranicza tekst. Punkt może być bieżącym położeniem lub współrzędnymi określonymi przez funkcję wyjścia tekstu. Prostokąt, który ogranicza tekst, jest definiowany przez sąsiednie komórki znaków w ciągu tekstowym. Parametr *nFlags* może być jedną lub kilkoma flagami z następujących trzech kategorii. Wybierz tylko jedną flagę z każdej kategorii. Pierwsza kategoria wpływa na wyrównanie tekstu w kierunku x:

- TA_CENTER Wyrównuje punkt z poziomym środkiem prostokąta ograniczającego.

- TA_LEFT Wyrównuje punkt z lewą stroną prostokąta ograniczającego. Jest to ustawienie domyślne.

- TA_RIGHT Wyrównuje punkt z prawą stroną prostokąta ograniczającego.

Druga kategoria wpływa na wyrównanie tekstu w kierunku y:

- TA_BASELINE Wyrównuje punkt z linią bazową wybranej czcionki.

- TA_BOTTOM Wyrównuje punkt z dolną częścią prostokąta ograniczającego.

- TA_TOP Wyrównuje punkt z górną częścią prostokąta ograniczającego. Jest to ustawienie domyślne.

Trzecia kategoria określa, czy bieżąca pozycja jest aktualizowana podczas pisania tekstu:

- TA_NOUPDATECP Nie aktualizuje bieżącej pozycji po każdym wywołaniu funkcji wyjścia tekstowego. Jest to ustawienie domyślne.

- TA_UPDATECP Aktualizuje bieżącą pozycję x po każdym wywołaniu funkcji wyjścia tekstowego. Nowe położenie znajduje się po prawej stronie prostokąta ograniczającego dla tekstu. Gdy ta flaga jest ustawiona, współrzędne określone w wywołaniach `TextOut` funkcji elementu członkowskiego są ignorowane.

### <a name="return-value"></a>Wartość zwracana

Poprzednie ustawienie wyrównania tekstu, jeśli się powiedzie. Bajt niskiego rzędu zawiera ustawienie poziome, a bajt wysokiego rzędu zawiera ustawienie pionowe; w przeciwnym razie 0.

### <a name="remarks"></a>Uwagi

`TextOut` Funkcje `ExtTextOut` i element członkowski używają tych flag podczas umieszczania ciągu tekstu na wyświetlaczu lub urządzeniu. Flagi określają relację między określonym punktem a prostokątem, który ogranicza tekst. Współrzędne tego punktu są `TextOut` przekazywane jako parametry do funkcji elementu członkowskiego. Prostokąt, który ogranicza tekst, jest tworzony przez sąsiednie komórki znaków w ciągu tekstowym.

## <a name="cdcsettextcharacterextra"></a><a name="settextcharacterextra"></a>CDC::SetTextCharacterExtra

Ustawia ilość odstępów międzycharakterowych.

```
int SetTextCharacterExtra(int nCharExtra);
```

### <a name="parameters"></a>Parametry

*nCharExtra*<br/>
Określa ilość dodatkowego miejsca (w jednostkach logicznych), która ma zostać dodana do każdego znaku. Jeśli bieżący tryb `MM_TEXT`mapowania nie jest , *nCharExtra* jest przekształcany i zaokrąglany do najbliższego piksela.

### <a name="return-value"></a>Wartość zwracana

Ilość poprzedniego odstępu międzycharakterowego.

### <a name="remarks"></a>Uwagi

GDI dodaje te odstępy do każdego znaku, w tym znaków przerwania, gdy zapisuje wiersz tekstu do kontekstu urządzenia. Wartość domyślna dla kwoty odstępów międzycharakterowych wynosi 0.

## <a name="cdcsettextcolor"></a><a name="settextcolor"></a>CDC::SetTextColor

Ustawia kolor tekstu na określony kolor.

```
virtual COLORREF SetTextColor(COLORREF crColor);
```

### <a name="parameters"></a>Parametry

*CrColor ( kolor)*<br/>
Określa kolor tekstu jako wartość koloru RGB.

### <a name="return-value"></a>Wartość zwracana

Wartość RGB dla poprzedniego koloru tekstu.

### <a name="remarks"></a>Uwagi

System użyje tego koloru tekstu podczas pisania tekstu do tego kontekstu urządzenia, a także podczas konwertowania map bitowych między kolorem a monochromatycznymi kontekstami urządzeń.

Jeśli urządzenie nie może reprezentować określonego koloru, system ustawia kolor tekstu na najbliższy kolor fizyczny. Kolor tła dla znaku jest `SetBkColor` `SetBkMode` określony przez funkcje i element członkowski.

### <a name="example"></a>Przykład

  Zobacz przykład [CWnd::OnCtlColor](../../mfc/reference/cwnd-class.md#onctlcolor).

## <a name="cdcsettextjustification"></a><a name="settextjustification"></a>CDC::SetTextJustification

Dodaje spację do znaków podziału w ciągu.

```
int SetTextJustification(
    int nBreakExtra,
    int nBreakCount);
```

### <a name="parameters"></a>Parametry

*nBreakExtra*<br/>
Określa całkowitą dodatkową przestrzeń, która ma zostać dodana do wiersza tekstu (w jednostkach logicznych). Jeśli bieżący tryb `MM_TEXT`mapowania nie jest, wartość podana przez ten parametr jest konwertowana na bieżący tryb mapowania i zaokrąglana do najbliższej jednostki urządzenia.

*nBreakCount (Liczba przerw)*<br/>
Określa liczbę znaków przerwania w wierszu.

### <a name="return-value"></a>Wartość zwracana

Jeden, jeśli funkcja zakończy się pomyślnie; w przeciwnym razie 0.

### <a name="remarks"></a>Uwagi

Aplikacja może używać `GetTextMetrics` funkcji elementu członkowskiego do pobierania znaku przerwania czcionki.

Po `SetTextJustification` wywołaniu funkcji elementu członkowskiego wywołanie funkcji tekstowego `TextOut`wyjściowego (na przykład) równomiernie rozdziela określone dodatkowe miejsce między określoną liczbę znaków przerwania. Znak przerwania jest zwykle znakiem spacji (ASCII 32), ale może być zdefiniowany przez czcionkę jako inny znak.

Funkcja `GetTextExtent` elementu członkowskiego jest `SetTextJustification`zwykle używana z programem . `GetTextExtent`oblicza szerokość danej linii przed wyrównaniem. Aplikacja może określić ilość miejsca do określenia w parametrze *nBreakExtra,* odejmując wartość zwróconą przez `GetTextExtent` szerokość ciągu po wyrównaniu.

Funkcja `SetTextJustification` może służyć do wyrównywania linii, która zawiera wiele przebiegów w różnych czcionkach. W takim przypadku wiersz musi zostać utworzony fragmentaryczne przez wyrównanie i zapisywanie każdego uruchomienia oddzielnie.

Ponieważ podczas wyrównywania mogą wystąpić błędy zaokrąglania, system zachowuje uruchomiony termin błędu definiujący bieżący błąd. Podczas wyrównywania wiersza, który zawiera wiele przebiegów, `GetTextExtent` automatycznie używa tego terminu błędu, gdy oblicza zakres następnego uruchomienia. Dzięki temu funkcja wyjścia tekstu mieszać błąd do nowego uruchomienia.

Po wyrównaniu każdego wiersza ten termin błędu musi zostać wyczyszczony, aby zapobiec włączeniu go do następnego wiersza. Termin można wyczyścić, `SetTextJustification` wywołując z *nBreakExtra* ustawioną na 0.

## <a name="cdcsetviewportext"></a><a name="setviewportext"></a>CDC::SetViewportExt

Ustawia zakresy x- i y rzutni kontekstu urządzenia.

```
virtual CSize SetViewportExt(
    int cx,
    int cy);

CSize SetViewportExt(SIZE size);
```

### <a name="parameters"></a>Parametry

*Cx*<br/>
Określa zasięg x rzutni (w jednostkach urządzeń).

*Cy*<br/>
Określa zakres y rzutni (w jednostkach urządzeń).

*Rozmiar*<br/>
Określa zakresy x i y rzutni (w jednostkach urządzeń).

### <a name="return-value"></a>Wartość zwracana

Poprzednie zakresy rzutni jako [obiektu CSize.](../../atl-mfc-shared/reference/csize-class.md) W przypadku wystąpienia błędu współrzędne x i `CSize` y zwróconego obiektu są ustawione na 0.

### <a name="remarks"></a>Uwagi

Rzutnia wraz z oknem kontekstu urządzenia definiuje sposób mapowania punktów GDI w logicznym układzie współrzędnych do punktów w układzie współrzędnych rzeczywistego urządzenia. Innymi słowy definiują sposób konwertowania współrzędnych logicznych na współrzędne urządzenia.

Po ustawieniu następujących trybów mapowania wywołania `SetWindowExt` i `SetViewportExt` są ignorowane:

|MM_HIENGLISH|MM_LOMETRIC|
|-------------------|------------------|
|MM_HIMETRIC|MM_TEXT|
|MM_LOENGLISH|MM_TWIPS|

Gdy jest ustawiony tryb MM_ISOTROPIC, aplikacja musi `SetWindowExt` wywołać funkcję `SetViewportExt`elementu członkowskiego, zanim wywoła .

### <a name="example"></a>Przykład

  Zobacz przykład [CView::OnPrepareDC](../../mfc/reference/cview-class.md#onpreparedc).

## <a name="cdcsetviewportorg"></a><a name="setviewportorg"></a>CDC::SetViewportOrg

Ustawia początek rzutni kontekstu urządzenia.

```
virtual CPoint SetViewportOrg(
    int x,
    int y);

CPoint SetViewportOrg(POINT point);
```

### <a name="parameters"></a>Parametry

*X*<br/>
Określa współrzędną x (w jednostkach urządzeń) początku rzutni. Wartość musi mieszczeć się w zakresie układu współrzędnych urządzenia.

*Y*<br/>
Określa współrzędną y (w jednostkach urządzeń) początku rzutni. Wartość musi mieszczeć się w zakresie układu współrzędnych urządzenia.

*Punkt*<br/>
Określa początek rzutni. Wartości muszą mieszczeć się w zakresie układu współrzędnych urządzenia. Można przekazać strukturę `POINT` lub `CPoint` obiekt dla tego parametru.

### <a name="return-value"></a>Wartość zwracana

Poprzednie źródło widoku (we współrzędnych `CPoint` urządzenia) jako obiektu.

### <a name="remarks"></a>Uwagi

Rzutnia wraz z oknem kontekstu urządzenia definiuje sposób mapowania punktów GDI w logicznym układzie współrzędnych do punktów w układzie współrzędnych rzeczywistego urządzenia. Innymi słowy definiują sposób konwertowania współrzędnych logicznych na współrzędne urządzenia.

Początek rzutni oznacza punkt w układzie współrzędnych urządzenia, do którego GDI mapuje początek okna, punkt w logicznym układzie współrzędnych określony przez funkcję `SetWindowOrg` elementu członkowskiego. GDI mapuje wszystkie inne punkty, postępując zgodnie z tym samym procesem wymaganym do mapowania początku okna na początek rzutni. Na przykład wszystkie punkty w okręgu wokół punktu w początkowej masie początkowej okna będą znajdować się w okręgu wokół punktu w początkowej rzutni. Podobnie wszystkie punkty w wierszu, który przechodzi przez początek okna będzie w wierszu, który przechodzi przez początek rzutni.

### <a name="example"></a>Przykład

  Zobacz przykład [CView::OnPrepareDC](../../mfc/reference/cview-class.md#onpreparedc).

## <a name="cdcsetwindowext"></a><a name="setwindowext"></a>CDC::SetWindowExt

Ustawia zakresy x i y okna skojarzone z kontekstem urządzenia.

```
virtual CSize SetWindowExt(
    int cx,
    int cy);

CSize SetWindowExt(SIZE size);
```

### <a name="parameters"></a>Parametry

*Cx*<br/>
Określa zakres x (w jednostkach logicznych) okna.

*Cy*<br/>
Określa zakres y (w jednostkach logicznych) okna.

*Rozmiar*<br/>
Określa zakresy x i y (w jednostkach logicznych) okna.

### <a name="return-value"></a>Wartość zwracana

Poprzednie zakresy okna (w jednostkach logicznych) jako obiektu. `CSize` Jeśli wystąpi błąd, współrzędne x i `CSize` y zwracanego obiektu są ustawione na 0.

### <a name="remarks"></a>Uwagi

Okno wraz z rzutnią kontekstu urządzenia definiuje sposób mapowania punktów GDI w logicznym układzie współrzędnych do punktów w układzie współrzędnych urządzenia.

Po ustawieniu następujących trybów mapowania wywołania `SetWindowExt` i `SetViewportExt` funkcje są ignorowane:

- MM_HIENGLISH

- MM_HIMETRIC

- MM_LOENGLISH

- MM_LOMETRIC

- MM_TEXT

- MM_TWIPS

Gdy jest ustawiony tryb MM_ISOTROPIC, aplikacja musi `SetWindowExt` wywołać `SetViewportExt`funkcję elementu członkowskiego przed wywołaniem .

### <a name="example"></a>Przykład

  Zobacz przykład [CView::OnPrepareDC](../../mfc/reference/cview-class.md#onpreparedc).

## <a name="cdcsetwindoworg"></a><a name="setwindoworg"></a>CDC::SetWindowOrg

Ustawia początek okna kontekstu urządzenia.

```
CPoint SetWindowOrg(
    int x,
    int y);

CPoint SetWindowOrg(POINT point);
```

### <a name="parameters"></a>Parametry

*X*<br/>
Określa logiczną współrzędną x nowego źródła okna.

*Y*<br/>
Określa logiczną współrzędną y nowego źródła okna.

*Punkt*<br/>
Określa współrzędne logiczne nowego źródła okna. Można przekazać strukturę `POINT` lub `CPoint` obiekt dla tego parametru.

### <a name="return-value"></a>Wartość zwracana

Poprzednie źródło okna jako `CPoint` obiektu.

### <a name="remarks"></a>Uwagi

Okno wraz z rzutnią kontekstu urządzenia definiuje sposób mapowania punktów GDI w logicznym układzie współrzędnych do punktów w układzie współrzędnych urządzenia.

Początek okna oznacza punkt w logicznym układzie współrzędnych, z którego GDI mapuje początek rzutni, punkt w układzie współrzędnych urządzenia określony przez `SetWindowOrg` funkcję. GDI mapuje wszystkie inne punkty, postępując zgodnie z tym samym procesem wymaganym do mapowania początku okna na początek rzutni. Na przykład wszystkie punkty w okręgu wokół punktu w początkowej masie początkowej okna będą znajdować się w okręgu wokół punktu w początkowej rzutni. Podobnie wszystkie punkty w wierszu, który przechodzi przez początek okna będzie w wierszu, który przechodzi przez początek rzutni.

## <a name="cdcsetworldtransform"></a><a name="setworldtransform"></a>CDC::SetWorldTransform

Ustawia dwuwymiarową transformację liniową między przestrzenią świata a przestrzenią strony dla określonego kontekstu urządzenia. Transformacja ta może służyć do skalowania, obracania, ścinania lub tłumaczenia danych wyjściowych grafiki.

```
BOOL SetWorldTransform(const XFORM& rXform);
```

### <a name="parameters"></a>Parametry

*rXform*<br/>
Odwołanie do struktury [XFORM,](/windows/win32/api/wingdi/ns-wingdi-xform) która zawiera dane transformacji.

### <a name="return-value"></a>Wartość zwracana

Zwraca wartość niezerową na sukces.

Zwraca wartość 0 w przypadku awarii.

Aby uzyskać rozszerzone informacje o błędzie, zadzwoń [do GetLastError](/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror).

### <a name="remarks"></a>Uwagi

Ta metoda zawija funkcję Windows GDI [SetWorldTransform](/windows/win32/api/wingdi/nf-wingdi-setworldtransform).

## <a name="cdcstartdoc"></a><a name="startdoc"></a>CDC::StartDoc

Informuje sterownik urządzenia, że rozpoczyna się nowe zadanie `StartPage` `EndPage` drukowania i że wszystkie kolejne i `EndDoc` wywołania powinny być buforowane w ramach tego samego zadania, dopóki nie zostanie wywołanie.

```
int StartDoc(LPDOCINFO lpDocInfo);
int StartDoc(LPCTSTR lpszDocName);
```

### <a name="parameters"></a>Parametry

*lpDocInfo*<br/>
Wskazuje strukturę [DOCINFO](/windows/win32/api/wingdi/ns-wingdi-docinfow) zawierającą nazwę pliku dokumentu i nazwę pliku wyjściowego.

*lpszDocName*<br/>
Wskaźnik do ciągu zawierającego nazwę pliku dokumentu.

### <a name="return-value"></a>Wartość zwracana

Jeśli funkcja powiedzie się, zwracana wartość jest większa niż zero. Ta wartość jest identyfikatorem zadania drukowania dokumentu.

Jeśli funkcja nie powiedzie się, zwracana wartość jest mniejsza lub równa zero.

### <a name="remarks"></a>Uwagi

Dzięki temu dokumenty dłuższe niż jedna strona nie będą przeplatane z innymi zadaniami.

W systemie Windows w wersji 3.1 lub nowszej ta funkcja zastępuje ucieczkę drukarki STARTDOC. Użycie tej funkcji gwarantuje, że dokumenty zawierające więcej niż jedną stronę nie są przeplatane z innymi zadaniami drukowania.

`StartDoc`nie należy stosować wewnątrz metaplików.

### <a name="example"></a>Przykład

Ten fragment kodu pobiera drukarkę domyślną, otwiera zadanie drukowania i buforuje jedną stronę z "Hello, World!" na nim. Ponieważ tekst wydrukowany przez ten kod nie jest skalowany do jednostek logicznych drukarki, tekst wyjściowy może być tak małymi literami, że wynik jest nieczytelny. Funkcje skalowania CDC, `SetMapMode` `SetViewportOrg`takie `SetWindowExt`jak , i , mogą być używane do naprawy skalowania.

[!code-cpp[NVC_MFCDocView#41](../../mfc/codesnippet/cpp/cdc-class_13.cpp)]

## <a name="cdcstartpage"></a><a name="startpage"></a>CDC::Strona startowa

Wywołanie tej funkcji elementu członkowskiego, aby przygotować sterownik drukarki do odbierania danych.

```
int StartPage();
```

### <a name="return-value"></a>Wartość zwracana

Większa lub równa 0, jeśli funkcja zakończy się pomyślnie, lub wartość ujemna, jeśli wystąpił błąd.

### <a name="remarks"></a>Uwagi

`StartPage`zastępuje newframe i bandinfo ucieka.

Aby uzyskać przegląd sekwencji wywołań drukowania, zobacz Funkcję elementu członkowskiego [StartDoc.](#startdoc)

System wyłącza `ResetDC` funkcję elementu członkowskiego `StartPage` `EndPage`między wywołaniami do i .

### <a name="example"></a>Przykład

  Zobacz przykład [cdc::StartDoc](#startdoc).

## <a name="cdcstretchblt"></a><a name="stretchblt"></a>CDC::Rozciągnięcie

Kopiuje mapę bitową z prostokąta źródłowego do prostokąta docelowego, w razie potrzeby rozciągając ją lub zmniejszając, aby dopasować ją do wymiarów prostokąta docelowego.

```
BOOL StretchBlt(
    int x,
    int y,
    int nWidth,
    int nHeight,
    CDC* pSrcDC,
    int xSrc,
    int ySrc,
    int nSrcWidth,
    int nSrcHeight,
    DWORD dwRop);
```

### <a name="parameters"></a>Parametry

*X*<br/>
Określa współrzędną x (w jednostkach logicznych) lewego górnego rogu prostokąta docelowego.

*Y*<br/>
Określa współrzędną y (w jednostkach logicznych) lewego górnego rogu prostokąta docelowego.

*nWidth (ww.*<br/>
Określa szerokość (w jednostkach logicznych) prostokąta docelowego.

*nFeksja*<br/>
Określa wysokość (w jednostkach logicznych) prostokąta docelowego.

*pSrcDC*<br/>
Określa kontekst urządzenia źródłowego.

*xSrc (ks.*<br/>
Określa współrzędną x (w jednostkach logicznych) lewego górnego rogu prostokąta źródłowego.

*ySrc ( ySrc )*<br/>
Określa współrzędną y (w jednostkach logicznych) lewego górnego rogu prostokąta źródłowego.

*nSrcWidth*<br/>
Określa szerokość (w jednostkach logicznych) prostokąta źródłowego.

*nSrcHeight (nSrcHeight)*<br/>
Określa wysokość (w jednostkach logicznych) prostokąta źródłowego.

*dwRop (dwRop)*<br/>
Określa operację rastrową, która ma być wykonana. Kody operacji rastrowych definiują, jak interfejs GDI łączy kolory w operacjach wyjściowych, które obejmują aktualny pędzel, możliwą źródłową mapę bitową i docelową mapę bitową. Ten parametr może przybierać jedną z następujących wartości:

- CZERŃ Zmienia kolor na czarny.

- DSTINVERT Odwraca docelową mapę bitową.

- MERGECOPY Łączy wzorzec i źródłową mapę bitową za pomocą operatora logicznego AND.

- MERGEPAINT Łączy odwróconą źródłową mapę bitową z docelową mapą bitową przy użyciu operatora boolean OR.

- NOTSRCCOPY Kopiuje odwróconą źródłową mapę bitową do miejsca docelowego.

- NOTSRCERASE Odwraca wynik łączenia docelowych i źródłowych map bitowych przy użyciu operatora boolean OR.

- PATCOPY Kopiuje wzorzec do docelowej mapy bitowej.

- PATINVERT Łączy docelową mapę bitową ze wzorcem przy użyciu operatora XOR logicznego.

- PATPAINT Łączy odwróconą źródłową mapę bitową ze wzorcem za pomocą operatora boolean OR. Łączy wynik tej operacji z docelową mapą bitową za pomocą operatora logicznego OR.

- SRCAND Łączy piksele docelowych i źródłowych map bitowych przy użyciu operatora logicznego AND.

- SRCCOPY Kopiuje źródłową mapę bitową do docelowej mapy bitowej.

- SRCERASE Odwraca docelową mapę bitową i łączy wynik z źródłową mapą bitową przy użyciu operatora logicznego AND.

- SRCINVERT Łączy piksele docelowych i źródłowych map bitowych przy użyciu operatora logicznego XOR.

- SRCPAINT Łączy piksele docelowych i źródłowych map bitowych przy użyciu operatora boolean OR.

- BIEL Zmienia kolor na biały.

### <a name="return-value"></a>Wartość zwracana

Różne od zera, jeśli mapa bitowa jest rysowana; w przeciwnym razie 0.

### <a name="remarks"></a>Uwagi

Funkcja używa trybu rozciągania kontekstu urządzenia docelowego `SetStretchBltMode`(ustawionego przez), aby określić sposób rozciągania lub kompresowania mapy bitowej.

Funkcja `StretchBlt` przenosi mapę bitową z urządzenia źródłowego podanego przez *pSrcDC* do urządzenia docelowego reprezentowanego przez obiekt kontekstu urządzenia, którego funkcja elementu członkowskiego jest wywoływana. Parametry *xSrc*, *ySrc*, *nSrcWidth*i *nSrcHeight* definiują lewy górny róg i wymiary prostokąta źródłowego. Parametry *x*, *y*, *nWidth*i *nHeight* dają lewy górny róg i wymiary prostokąta docelowego. Operacja rastrowa określona przez *dwRop* definiuje sposób łączenia źródłowej mapy bitowej i bitów już na urządzeniu docelowym.

Funkcja `StretchBlt` tworzy lustrzane odbicie mapy bitowej, jeśli różnią się to oznaczenia *nSrcWidth* i *nWidth* lub *nSrcHeight* i *nHeight.* Jeśli *nSrcWidth* i *nWidth* mają różne znaki, funkcja tworzy lustrzane odbicie mapy bitowej wzdłuż osi x. Jeśli *nSrcHeight* i *nHeight* mają różne znaki, funkcja tworzy lustrzane odbicie mapy bitowej wzdłuż osi y.

Funkcja `StretchBlt` rozciąga lub kompresuje źródłową mapę bitową w pamięci, a następnie kopiuje wynik do miejsca docelowego. Jeśli deseń ma być połączony z wynikiem, nie jest łączony, dopóki rozciągnięta źródłowa mapa bitowa nie zostanie skopiowana do miejsca docelowego. Jeśli jest używany pędzel, jest to wybrany pędzel w kontekście urządzenia docelowego. Współrzędne miejsca przeznaczenia są przekształcane zgodnie z kontekstem urządzenia docelowego; współrzędne źródła są przekształcane zgodnie z kontekstem urządzenia źródłowego.

Jeśli mapy bitowe miejsca docelowego, źródła i desenia `StretchBlt` nie mają tego samego formatu kolorów, konwertuje mapy bitowe źródłowe i wzorca w celu dopasowania do docelowych map bitowych. Kolory pierwszego planu i tła kontekstu urządzenia docelowego są używane do konwersji.

Jeśli `StretchBlt` musi przekonwertować monochromatyczny bitmapy na kolor, ustawia białe bity (1) do koloru tła i czarne bity (0) do koloru pierwszego planu. Aby przekonwertować kolor na monochromatyczny, ustawia piksele, które odpowiadają kolorowi tła, na biały (1), a wszystkie inne piksele ustawia na czarny (0). Używane są kolory pierwszego planu i tła kontekstu urządzenia z kolorem.

Nie wszystkie urządzenia `StretchBlt` obsługują tę funkcję. Aby ustalić, czy `StretchBlt`urządzenie `GetDeviceCaps` obsługuje, należy wywołać funkcję elementu członkowskiego z indeksem RASTERCAPS i sprawdzić wartość zwracaną flagi RC_STRETCHBLT.

## <a name="cdcstrokeandfillpath"></a><a name="strokeandfillpath"></a>CDC::StrokeAndFillPath

Zamyka wszystkie otwarte figury w ścieżce, obrysowuje kontur ścieżki za pomocą bieżącego pióra i wypełnia jej wnętrze za pomocą bieżącego pędzla.

```
BOOL StrokeAndFillPath();
```

### <a name="return-value"></a>Wartość zwracana

Różne od zera, jeśli funkcja zakończyła się pomyślnie; w przeciwnym razie 0.

### <a name="remarks"></a>Uwagi

Kontekst urządzenia musi zawierać zamkniętą ścieżkę. Funkcja `StrokeAndFillPath` elementu członkowskiego ma taki sam efekt jak zamykanie wszystkich otwartych figur w ścieżce i głaskanie i wypełnianie ścieżki oddzielnie, z tą różnicą, że wypełniony region nie będzie nakładał się na obszar obrysowany, nawet jeśli pióro jest szerokie.

## <a name="cdcstrokepath"></a><a name="strokepath"></a>CDC::StrokePath

Renderuje określoną ścieżkę przy użyciu bieżącego pióra.

```
BOOL StrokePath();
```

### <a name="return-value"></a>Wartość zwracana

Różne od zera, jeśli funkcja zakończyła się pomyślnie; w przeciwnym razie 0.

### <a name="remarks"></a>Uwagi

Kontekst urządzenia musi zawierać zamkniętą ścieżkę.

## <a name="cdctabbedtextout"></a><a name="tabbedtextout"></a>CDC::KartaTextOut

Wywołanie tej funkcji elementu członkowskiego, aby napisać ciąg znaków w określonej lokalizacji, rozwijając karty do wartości określonych w tablicy pozycji tabulatora.

```
virtual CSize TabbedTextOut(
    int x,
    int y,
    LPCTSTR lpszString,
    int nCount,
    int nTabPositions,
    LPINT lpnTabStopPositions,
    int nTabOrigin);

CSize TabbedTextOut(
    int x,
    int y,
    const CString& str,
    int nTabPositions,
    LPINT lpnTabStopPositions,
    int nTabOrigin);
```

### <a name="parameters"></a>Parametry

*X*<br/>
Określa logiczną współrzędną x punktu początkowego ciągu.

*Y*<br/>
Określa logiczną współrzędną y punktu początkowego ciągu.

*lpszString*<br/>
Wskazuje ciąg znaków do narysowania. Można przekazać wskaźnik do tablicy znaków lub [CString](../../atl-mfc-shared/reference/cstringt-class.md) obiektu dla tego parametru.

*Ncount*<br/>
Określa [długość ciągu](/windows/win32/gdi/specifying-length-of-text-output-string) wskazywania przez *lpszString*.

*nNazyty*<br/>
Określa liczbę wartości w tablicy pozycji tabulatora.

*lpnTabStopPositions*<br/>
Wskazuje tablicę zawierającą pozycje tabulatora (w jednostkach logicznych). Tabulatory muszą być sortowane w kolejności rosnącej; najmniejsza wartość x powinna być pierwszym elementem w tablicy.

*nTabOrigin*<br/>
Określa współrzędną x pozycji początkowej, od której karty są rozwinięte (w jednostkach logicznych).

*Str*<br/>
Obiekt, `CString` który zawiera określone znaki.

### <a name="return-value"></a>Wartość zwracana

Wymiary ciągu (w jednostkach logicznych) jako `CSize` obiektu.

### <a name="remarks"></a>Uwagi

Tekst jest zapisywany w aktualnie zaznaczonej czcionce. Jeśli *nTabPositions* jest 0 i *lpnTabStopPositions* jest NULL, karty są rozwijane do ośmiu razy średniej szerokości znaku.

Jeśli *nTabPositions* jest 1, tabulatorów są oddzielone przez odległość określoną przez pierwszą wartość w *lpnTabStopPositions* tablicy. Jeśli tablica *lpnTabStopPositions* zawiera więcej niż jedną wartość, dla każdej wartości w tablicy jest ustawiany tabulator, do liczby określonej przez *nTabPositions*. Parametr *nTabOrigin* umożliwia aplikacji wywołanie `TabbedTextOut` funkcji kilka razy dla pojedynczego wiersza. Jeśli aplikacja wywołuje funkcję więcej niż jeden raz z *nTabOrigin* ustawioną na tę samą wartość za każdym razem, funkcja rozwija wszystkie karty względem pozycji określonej przez *nTabOrigin*.

Domyślnie, funkcja nie używa ani nie aktualizuje bieżącej pozycji. Jeśli aplikacja musi zaktualizować bieżącą pozycję podczas wywoływania funkcji, aplikacja może wywołać funkcję elementu członkowskiego [SetTextAlign](#settextalign) z *nFlags* ustawionym na TA_UPDATECP. Gdy ta flaga jest ustawiona, system Windows ignoruje `TabbedTextOut`parametry *x* i *y* w kolejnych wywołaniach , używając zamiast tego bieżącej pozycji.

## <a name="cdctextout"></a><a name="textout"></a>CDC::TextOut

Zapisuje ciąg znaków w określonej lokalizacji przy użyciu aktualnie wybranej czcionki.

```
virtual BOOL TextOut(
    int x,
    int y,
    LPCTSTR lpszString,
    int nCount);

BOOL TextOut(
    int x,
    int y,
    const CString& str);
```

### <a name="parameters"></a>Parametry

*X*<br/>
Określa logiczną współrzędną x punktu początkowego tekstu.

*Y*<br/>
Określa logiczną współrzędną y punktu początkowego tekstu.

*lpszString*<br/>
Wskazuje ciąg znaków do rysowania.

*Ncount*<br/>
Określa liczbę znaków w ciągu.

*Str*<br/>
Obiekt `CString` zawierający znaki, które mają zostać narysowane.

### <a name="return-value"></a>Wartość zwracana

Różne od zera, jeśli funkcja zakończyła się pomyślnie; w przeciwnym razie 0.

### <a name="remarks"></a>Uwagi

Początki znaków są w lewym górnym rogu komórki znaków. Domyślnie, funkcja nie używa ani nie aktualizuje bieżącej pozycji.

Jeśli aplikacja musi zaktualizować bieżącą pozycję `TextOut`podczas wywoływania, `SetTextAlign` aplikacja może wywołać funkcję elementu członkowskiego z *nFlags* ustawiony na TA_UPDATECP. Gdy ta flaga jest ustawiona, system Windows ignoruje `TextOut`parametry *x* i *y* w kolejnych wywołaniach , używając zamiast tego bieżącej pozycji.

### <a name="example"></a>Przykład

  Zobacz przykład [cdc::BeginPath](#beginpath).

## <a name="cdctransparentblt"></a><a name="transparentblt"></a>CDC::TransparentBlt

Wywołanie tej funkcji elementu członkowskiego, aby przenieść blok bitowy danych kolorów, który odpowiada prostokąt pikseli z kontekstu urządzenia źródłowego, do kontekstu urządzenia docelowego.

```
BOOL TransparentBlt(
    int xDest,
    int yDest,
    int nDestWidth,
    int nDestHeight,
    CDC* pSrcDC,
    int xSrc,
    int ySrc,
    int nSrcWidth,
    int nSrcHeight,
    UINT clrTransparent);
```

### <a name="parameters"></a>Parametry

*xDest (xDest)*<br/>
Określa współrzędną x w jednostkach logicznych lewego górnego rogu prostokąta docelowego.

*yDest (właśc.*<br/>
Określa współrzędną y w jednostkach logicznych lewego górnego rogu prostokąta docelowego.

*nDestWidth (nDestWidth)*<br/>
Określa szerokość prostokąta docelowego w jednostkach logicznych.

*nDestHeight (nDestHeight)*<br/>
Określa wysokość prostokąta docelowego w jednostkach logicznych.

*pSrcDC*<br/>
Wskaźnik do kontekstu urządzenia źródłowego.

*xSrc (ks.*<br/>
Określa współrzędną x w jednostkach logicznych prostokąta źródłowego.

*ySrc ( ySrc )*<br/>
Określa współrzędną y w jednostkach logicznych prostokąta źródłowego.

*nSrcWidth*<br/>
Określa szerokość prostokąta źródłowego w jednostkach logicznych.

*nSrcHeight (nSrcHeight)*<br/>
Określa wysokość prostokąta źródłowego w jednostkach logicznych.

*clrPrzezroczysty*<br/>
Kolor RGB w źródłowej mapie bitowej, aby traktować jako przezroczysty.

### <a name="return-value"></a>Wartość zwracana

PRAWDA, jeśli się powiedzie; w przeciwnym razie FALSE.

### <a name="remarks"></a>Uwagi

`TransparentBlt`pozwala na przejrzystość; oznacza to, że kolor RGB wskazany przez *clrTransparent* jest przezroczysty dla transferu.

Aby uzyskać więcej informacji, zobacz [TransparentBlt](/windows/win32/api/wingdi/nf-wingdi-transparentblt) w windows SDK.

## <a name="cdcupdatecolors"></a><a name="updatecolors"></a>CDC::UpdateColors

Aktualizuje obszar klienta kontekstu urządzenia, dopasowując bieżące kolory w obszarze klienta do palety systemowej w zależności od piksela.

```
void UpdateColors();
```

### <a name="remarks"></a>Uwagi

Nieaktywne okno ze zrealizowaną paletą logiczną może wywołać `UpdateColors` jako alternatywę dla ponownego rysowania obszaru klienta po zmianie palety systemowej.

Aby uzyskać więcej informacji na temat używania palet kolorów, zobacz [UpdateColors](/windows/win32/api/wingdi/nf-wingdi-updatecolors) w programie Windows SDK.

Funkcja `UpdateColors` elementu członkowskiego zazwyczaj aktualizuje obszar klienta szybciej niż ponowne rysowanie obszaru. Ponieważ jednak funkcja wykonuje translację kolorów na podstawie koloru każdego piksela przed zmianą palety systemowej, każde wywołanie tej funkcji powoduje utratę pewnej dokładności kolorów.

## <a name="cdcwidenpath"></a><a name="widenpath"></a>CDC::Ścieżka poszerzyć

Ponownie definiuje bieżącą ścieżkę jako obszar, który zostałby pomalowany, gdyby ścieżka została obrysowana za pomocą pióra aktualnie wybranego w kontekście urządzenia.

```
BOOL WidenPath();
```

### <a name="return-value"></a>Wartość zwracana

Różne od zera, jeśli funkcja zakończyła się pomyślnie; w przeciwnym razie 0.

### <a name="remarks"></a>Uwagi

Ta funkcja jest skuteczna tylko wtedy, gdy bieżące pióro jest piórem geometrycznym utworzonym przez drugą wersję funkcji `CreatePen` elementu członkowskiego lub jeśli pióro jest tworzone z pierwszą wersją `CreatePen` i ma szerokość, w jednostkach urządzenia, większą niż 1. Kontekst urządzenia musi zawierać zamkniętą ścieżkę. Wszelkie krzywe Bziera w ścieżce są konwertowane na sekwencje linii prostych przybliżających poszerzone krzywe. W związku z tym nie krzywe Bzier pozostają w ścieżce po `WidenPath` jest wywoływana.

## <a name="see-also"></a>Zobacz też

[Klasa CObject](../../mfc/reference/cobject-class.md)<br/>
[Wykres hierarchii](../../mfc/hierarchy-chart.md)<br/>
[Klasa CPaintDC](../../mfc/reference/cpaintdc-class.md)<br/>
[Klasa CWindowDC](../../mfc/reference/cwindowdc-class.md)<br/>
[Klasa CClientDC](../../mfc/reference/cclientdc-class.md)<br/>
[Klasa CMetaFileDC](../../mfc/reference/cmetafiledc-class.md)

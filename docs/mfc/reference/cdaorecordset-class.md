---
title: Cdaorecordset — klasa | Dokumentacja firmy Microsoft
ms.custom: ''
ms.date: 11/04/2016
ms.technology:
- cpp-mfc
ms.topic: reference
f1_keywords:
- CDaoRecordset
- AFXDAO/CDaoRecordset
- AFXDAO/CDaoRecordset::CDaoRecordset
- AFXDAO/CDaoRecordset::AddNew
- AFXDAO/CDaoRecordset::CanAppend
- AFXDAO/CDaoRecordset::CanBookmark
- AFXDAO/CDaoRecordset::CancelUpdate
- AFXDAO/CDaoRecordset::CanRestart
- AFXDAO/CDaoRecordset::CanScroll
- AFXDAO/CDaoRecordset::CanTransact
- AFXDAO/CDaoRecordset::CanUpdate
- AFXDAO/CDaoRecordset::Close
- AFXDAO/CDaoRecordset::Delete
- AFXDAO/CDaoRecordset::DoFieldExchange
- AFXDAO/CDaoRecordset::Edit
- AFXDAO/CDaoRecordset::FillCache
- AFXDAO/CDaoRecordset::Find
- AFXDAO/CDaoRecordset::FindFirst
- AFXDAO/CDaoRecordset::FindLast
- AFXDAO/CDaoRecordset::FindNext
- AFXDAO/CDaoRecordset::FindPrev
- AFXDAO/CDaoRecordset::GetAbsolutePosition
- AFXDAO/CDaoRecordset::GetBookmark
- AFXDAO/CDaoRecordset::GetCacheSize
- AFXDAO/CDaoRecordset::GetCacheStart
- AFXDAO/CDaoRecordset::GetCurrentIndex
- AFXDAO/CDaoRecordset::GetDateCreated
- AFXDAO/CDaoRecordset::GetDateLastUpdated
- AFXDAO/CDaoRecordset::GetDefaultDBName
- AFXDAO/CDaoRecordset::GetDefaultSQL
- AFXDAO/CDaoRecordset::GetEditMode
- AFXDAO/CDaoRecordset::GetFieldCount
- AFXDAO/CDaoRecordset::GetFieldInfo
- AFXDAO/CDaoRecordset::GetFieldValue
- AFXDAO/CDaoRecordset::GetIndexCount
- AFXDAO/CDaoRecordset::GetIndexInfo
- AFXDAO/CDaoRecordset::GetLastModifiedBookmark
- AFXDAO/CDaoRecordset::GetLockingMode
- AFXDAO/CDaoRecordset::GetName
- AFXDAO/CDaoRecordset::GetParamValue
- AFXDAO/CDaoRecordset::GetPercentPosition
- AFXDAO/CDaoRecordset::GetRecordCount
- AFXDAO/CDaoRecordset::GetSQL
- AFXDAO/CDaoRecordset::GetType
- AFXDAO/CDaoRecordset::GetValidationRule
- AFXDAO/CDaoRecordset::GetValidationText
- AFXDAO/CDaoRecordset::IsBOF
- AFXDAO/CDaoRecordset::IsDeleted
- AFXDAO/CDaoRecordset::IsEOF
- AFXDAO/CDaoRecordset::IsFieldDirty
- AFXDAO/CDaoRecordset::IsFieldNull
- AFXDAO/CDaoRecordset::IsFieldNullable
- AFXDAO/CDaoRecordset::IsOpen
- AFXDAO/CDaoRecordset::Move
- AFXDAO/CDaoRecordset::MoveFirst
- AFXDAO/CDaoRecordset::MoveLast
- AFXDAO/CDaoRecordset::MoveNext
- AFXDAO/CDaoRecordset::MovePrev
- AFXDAO/CDaoRecordset::Open
- AFXDAO/CDaoRecordset::Requery
- AFXDAO/CDaoRecordset::Seek
- AFXDAO/CDaoRecordset::SetAbsolutePosition
- AFXDAO/CDaoRecordset::SetBookmark
- AFXDAO/CDaoRecordset::SetCacheSize
- AFXDAO/CDaoRecordset::SetCacheStart
- AFXDAO/CDaoRecordset::SetCurrentIndex
- AFXDAO/CDaoRecordset::SetFieldDirty
- AFXDAO/CDaoRecordset::SetFieldNull
- AFXDAO/CDaoRecordset::SetFieldValue
- AFXDAO/CDaoRecordset::SetFieldValueNull
- AFXDAO/CDaoRecordset::SetLockingMode
- AFXDAO/CDaoRecordset::SetParamValue
- AFXDAO/CDaoRecordset::SetParamValueNull
- AFXDAO/CDaoRecordset::SetPercentPosition
- AFXDAO/CDaoRecordset::Update
- AFXDAO/CDaoRecordset::m_bCheckCacheForDirtyFields
- AFXDAO/CDaoRecordset::m_nFields
- AFXDAO/CDaoRecordset::m_nParams
- AFXDAO/CDaoRecordset::m_pDAORecordset
- AFXDAO/CDaoRecordset::m_pDatabase
- AFXDAO/CDaoRecordset::m_strFilter
- AFXDAO/CDaoRecordset::m_strSort
dev_langs:
- C++
helpviewer_keywords:
- CDaoRecordset [MFC], CDaoRecordset
- CDaoRecordset [MFC], AddNew
- CDaoRecordset [MFC], CanAppend
- CDaoRecordset [MFC], CanBookmark
- CDaoRecordset [MFC], CancelUpdate
- CDaoRecordset [MFC], CanRestart
- CDaoRecordset [MFC], CanScroll
- CDaoRecordset [MFC], CanTransact
- CDaoRecordset [MFC], CanUpdate
- CDaoRecordset [MFC], Close
- CDaoRecordset [MFC], Delete
- CDaoRecordset [MFC], DoFieldExchange
- CDaoRecordset [MFC], Edit
- CDaoRecordset [MFC], FillCache
- CDaoRecordset [MFC], Find
- CDaoRecordset [MFC], FindFirst
- CDaoRecordset [MFC], FindLast
- CDaoRecordset [MFC], FindNext
- CDaoRecordset [MFC], FindPrev
- CDaoRecordset [MFC], GetAbsolutePosition
- CDaoRecordset [MFC], GetBookmark
- CDaoRecordset [MFC], GetCacheSize
- CDaoRecordset [MFC], GetCacheStart
- CDaoRecordset [MFC], GetCurrentIndex
- CDaoRecordset [MFC], GetDateCreated
- CDaoRecordset [MFC], GetDateLastUpdated
- CDaoRecordset [MFC], GetDefaultDBName
- CDaoRecordset [MFC], GetDefaultSQL
- CDaoRecordset [MFC], GetEditMode
- CDaoRecordset [MFC], GetFieldCount
- CDaoRecordset [MFC], GetFieldInfo
- CDaoRecordset [MFC], GetFieldValue
- CDaoRecordset [MFC], GetIndexCount
- CDaoRecordset [MFC], GetIndexInfo
- CDaoRecordset [MFC], GetLastModifiedBookmark
- CDaoRecordset [MFC], GetLockingMode
- CDaoRecordset [MFC], GetName
- CDaoRecordset [MFC], GetParamValue
- CDaoRecordset [MFC], GetPercentPosition
- CDaoRecordset [MFC], GetRecordCount
- CDaoRecordset [MFC], GetSQL
- CDaoRecordset [MFC], GetType
- CDaoRecordset [MFC], GetValidationRule
- CDaoRecordset [MFC], GetValidationText
- CDaoRecordset [MFC], IsBOF
- CDaoRecordset [MFC], IsDeleted
- CDaoRecordset [MFC], IsEOF
- CDaoRecordset [MFC], IsFieldDirty
- CDaoRecordset [MFC], IsFieldNull
- CDaoRecordset [MFC], IsFieldNullable
- CDaoRecordset [MFC], IsOpen
- CDaoRecordset [MFC], Move
- CDaoRecordset [MFC], MoveFirst
- CDaoRecordset [MFC], MoveLast
- CDaoRecordset [MFC], MoveNext
- CDaoRecordset [MFC], MovePrev
- CDaoRecordset [MFC], Open
- CDaoRecordset [MFC], Requery
- CDaoRecordset [MFC], Seek
- CDaoRecordset [MFC], SetAbsolutePosition
- CDaoRecordset [MFC], SetBookmark
- CDaoRecordset [MFC], SetCacheSize
- CDaoRecordset [MFC], SetCacheStart
- CDaoRecordset [MFC], SetCurrentIndex
- CDaoRecordset [MFC], SetFieldDirty
- CDaoRecordset [MFC], SetFieldNull
- CDaoRecordset [MFC], SetFieldValue
- CDaoRecordset [MFC], SetFieldValueNull
- CDaoRecordset [MFC], SetLockingMode
- CDaoRecordset [MFC], SetParamValue
- CDaoRecordset [MFC], SetParamValueNull
- CDaoRecordset [MFC], SetPercentPosition
- CDaoRecordset [MFC], Update
- CDaoRecordset [MFC], m_bCheckCacheForDirtyFields
- CDaoRecordset [MFC], m_nFields
- CDaoRecordset [MFC], m_nParams
- CDaoRecordset [MFC], m_pDAORecordset
- CDaoRecordset [MFC], m_pDatabase
- CDaoRecordset [MFC], m_strFilter
- CDaoRecordset [MFC], m_strSort
ms.assetid: 2322067f-1027-4662-a5d7-aa2fc7488630
author: mikeblome
ms.author: mblome
ms.workload:
- cplusplus
ms.openlocfilehash: 603cd1658af417dfbb7f2d8aa8022275e866a706
ms.sourcegitcommit: 76b7653ae443a2b8eb1186b789f8503609d6453e
ms.translationtype: MT
ms.contentlocale: pl-PL
ms.lasthandoff: 05/04/2018
---
# <a name="cdaorecordset-class"></a>Cdaorecordset — klasa
Reprezentuje zestaw rekordów wybrane źródła danych.  
  
## <a name="syntax"></a>Składnia  
  
```  
class CDaoRecordset : public CObject  
```  
  
## <a name="members"></a>Elementy członkowskie  
  
### <a name="public-constructors"></a>Konstruktory publiczne  
  
|Nazwa|Opis|  
|----------|-----------------|  
|[CDaoRecordset::CDaoRecordset](#cdaorecordset)|Konstruuje `CDaoRecordset` obiektu.|  
  
### <a name="public-methods"></a>Metody publiczne  
  
|Nazwa|Opis|  
|----------|-----------------|  
|[CDaoRecordset::AddNew](#addnew)|Przygotowuje do dodawania nowego rekordu. Wywołanie [aktualizacji](#update) przeprowadzenie operacji dodawania.|  
|[CDaoRecordset::CanAppend](#canappend)|Zwraca wartość niezerową, jeśli można dodać nowych rekordów do zestawu rekordów za pomocą [AddNew](#addnew) funkcję elementu członkowskiego.|  
|[CDaoRecordset::CanBookmark](#canbookmark)|Zwraca wartość niezerową, jeśli zestaw rekordów obsługuje zakładki.|  
|[CDaoRecordset::CancelUpdate](#cancelupdate)|Anuluje wszystkie oczekujące aktualizacje z powodu [Edytuj](#edit) lub [AddNew](#addnew) operacji.|  
|[CDaoRecordset::CanRestart](#canrestart)|Zwraca różną od zera, jeśli [Requery](#requery) można wywołać ponowne uruchomienie zapytania w zestawie rekordów.|  
|[CDaoRecordset::CanScroll](#canscroll)|Zwraca wartość niezerową, jeśli można przewijać rekordy.|  
|[CDaoRecordset::CanTransact](#cantransact)|Zwraca wartość niezerową, jeśli źródło danych obsługuje transakcji.|  
|[CDaoRecordset::CanUpdate](#canupdate)|Zwraca wartość niezerową, jeśli można zaktualizować zestawu rekordów (możesz dodać, zaktualizować lub usunąć rekordy).|  
|[CDaoRecordset::Close](#close)|Zamyka zestawu rekordów.|  
|[CDaoRecordset::Delete](#delete)|Usuwa rekord bieżący w zestawie. Należy jawnie przewiń do innego rekordu, po usunięciu.|  
|[CDaoRecordset::DoFieldExchange](#dofieldexchange)|Wywoływane w celu wymiany danych (w obu kierunkach) między elementy członkowskie danych pola zestawu rekordów i odpowiedniego rekordu w źródle danych. Implementuje DAO rekord wymiana pól (DFX).|  
|[CDaoRecordset::Edit](#edit)|Przygotowuje się do zmian dla bieżącego rekordu. Wywołanie **aktualizacji** przeprowadzenie edycji.|  
|[CDaoRecordset::FillCache](#fillcache)|Wypełnienie wszystkich lub częścią lokalnej pamięci podręcznej dla obiekt zestawu rekordów, który zawiera dane ze źródła danych ODBC.|  
|[CDaoRecordset::Find](#find)|Lokalizuje najpierw następnej lokalizacji poprzedniej lub ostatniego określonego ciągu w dynamicznego zestawu rekordów, które spełniają określone kryteria i sprawia, że służące do rejestrowania bieżącego rekordu.|  
|[CDaoRecordset::FindFirst](#findfirst)|Znajduje pierwszy rekord w dynamicznego lub zestaw rekordów typu migawka, która spełnia określone kryteria, a sprawia, że służące do rejestrowania bieżącego rekordu.|  
|[CDaoRecordset::FindLast](#findlast)|Znajduje ostatni rekord w dynamicznego lub zestaw rekordów typu migawka, która spełnia określone kryteria, a sprawia, że służące do rejestrowania bieżącego rekordu.|  
|[CDaoRecordset::FindNext](#findnext)|Lokalizuje następnego rekordu w dynamicznego lub zestaw rekordów typu migawka, która spełnia określone kryteria, a sprawia, że służące do rejestrowania bieżącego rekordu.|  
|[CDaoRecordset::FindPrev](#findprev)|Lokalizuje poprzedniego rekordu w dynamicznego lub zestaw rekordów typu migawka, która spełnia określone kryteria, a sprawia, że służące do rejestrowania bieżącego rekordu.|  
|[CDaoRecordset::GetAbsolutePosition](#getabsoluteposition)|Zwraca numer bieżącego rekordu obiektu zestawu rekordów.|  
|[CDaoRecordset::GetBookmark](#getbookmark)|Zwraca wartość reprezentującą zakładkę do rekordu.|  
|[CDaoRecordset::GetCacheSize](#getcachesize)|Zwraca wartość określającą liczbę rekordów w zestawie rekordów dynamicznego zawierający dane lokalnie pamięci podręcznej ze źródła danych ODBC.|  
|[CDaoRecordset::GetCacheStart](#getcachestart)|Zwraca wartość określającą zakładki pierwszy rekord w zestawie rekordów w pamięci podręcznej.|  
|[CDaoRecordset::GetCurrentIndex](#getcurrentindex)|Zwraca `CString` zawierający nazwę indeksu najbardziej ostatnio używane na indeksowanych, typ tabeli `CDaoRecordset`.|  
|[CDaoRecordset::GetDateCreated](#getdatecreated)|Zwraca datę i godzinę, w tabeli podstawowej odpowiadającego `CDaoRecordset` obiekt został utworzony|  
|[CDaoRecordset::GetDateLastUpdated](#getdatelastupdated)|Zwraca datę i godzinę ostatniej zmiany wprowadzone w projekcie podstawowy w tabeli podstawowej `CDaoRecordset` obiektu.|  
|[CDaoRecordset::GetDefaultDBName](#getdefaultdbname)|Zwraca nazwę domyślnego źródła danych.|  
|[CDaoRecordset::GetDefaultSQL](#getdefaultsql)|Wywołuje się, by pobrać domyślny ciąg SQL do wykonania.|  
|[CDaoRecordset::GetEditMode](#geteditmode)|Zwraca wartość, która wskazuje stan edycji dla bieżącego rekordu.|  
|[CDaoRecordset::GetFieldCount](#getfieldcount)|Zwraca wartość reprezentującą liczbę pól w zestawie rekordów.|  
|[CDaoRecordset::GetFieldInfo](#getfieldinfo)|Zwraca określonych rodzajów informacji o polach w zestawie rekordów.|  
|[CDaoRecordset::GetFieldValue](#getfieldvalue)|Zwraca wartość pola w zestawie rekordów.|  
|[CDaoRecordset::GetIndexCount](#getindexcount)|Pobiera liczbę indeksów w tabeli podstawowej zestawu rekordów.|  
|[CDaoRecordset::GetIndexInfo](#getindexinfo)|Zwraca różne rodzaje informacji o indeksie.|  
|[CDaoRecordset::GetLastModifiedBookmark](#getlastmodifiedbookmark)|Używany do określenia najbardziej ostatnio dodane lub zaktualizowane rekordu.|  
|[CDaoRecordset::GetLockingMode](#getlockingmode)|Zwraca wartość, która wskazuje typ blokady jest włączona, podczas edycji.|  
|[CDaoRecordset::GetName](#getname)|Zwraca `CString` zawierającą nazwę zestawu rekordów.|  
|[CDaoRecordset::GetParamValue](#getparamvalue)|Pobiera bieżącą wartość określonego parametru przechowywane w obiekcie źródłowym zostały DAOParameter.|  
|[CDaoRecordset::GetPercentPosition](#getpercentposition)|Zwraca pozycję bieżącego rekordu jako procent całkowitej liczby rekordów.|  
|[CDaoRecordset::GetRecordCount](#getrecordcount)|Zwraca liczbę rekordów dostępne w obiekcie zestawu rekordów.|  
|[CDaoRecordset::GetSQL](#getsql)|Pobiera ciąg SQL używana do wybierania rekordów dla zestawu rekordów.|  
|[CDaoRecordset::GetType](#gettype)|Wywołuje się, aby określić typ zestaw rekordów: typ tabeli, dynamicznego lub typu migawka.|  
|[CDaoRecordset::GetValidationRule](#getvalidationrule)|Zwraca `CString` zawierające wartość, która weryfikuje dane wprowadzoną w polu.|  
|[CDaoRecordset::GetValidationText](#getvalidationtext)|Pobiera tekst, który jest wyświetlany, gdy reguła walidacji nie został spełniony.|  
|[CDaoRecordset::IsBOF](#isbof)|Zwraca wartość niezerową, jeśli zestaw rekordów ma zostać umieszczony przed pierwszy rekord. Brak bieżącego rekordu.|  
|[CDaoRecordset::IsDeleted](#isdeleted)|Zwraca wartość niezerową, jeśli zestaw rekordów jest ustawiony na usunięty rekord.|  
|[CDaoRecordset::IsEOF](#iseof)|Zwraca wartość niezerową, jeśli zestaw rekordów zawiera została ustawiona za ostatni rekord. Brak bieżącego rekordu.|  
|[CDaoRecordset::IsFieldDirty](#isfielddirty)|Zwraca wartość niezerową, jeśli określone pole bieżącego rekordu została zmieniona.|  
|[CDaoRecordset::IsFieldNull](#isfieldnull)|Zwraca wartość niezerową, jeśli określone pole bieżącego rekordu ma wartość Null (o wartości).|  
|[CDaoRecordset::IsFieldNullable](#isfieldnullable)|Zwraca wartość niezerową, jeśli określone pole bieżącego rekordu można ustawić wartości null (o wartości).|  
|[CDaoRecordset::IsOpen](#isopen)|Zwraca różną od zera, jeśli [Otwórz](#open) wcześniej została wywołana.|  
|[CDaoRecordset::Move](#move)|Umieszcza zestaw rekordów do określonej liczby rekordów z bieżącego rekordu w żadnym kierunku.|  
|[CDaoRecordset::MoveFirst](#movefirst)|Określa położenie bieżącego rekordu na pierwszy rekord w zestawie rekordów.|  
|[CDaoRecordset::MoveLast](#movelast)|Określa położenie bieżącego rekordu na ostatni rekord w zestawie rekordów.|  
|[CDaoRecordset::MoveNext](#movenext)|Określa położenie bieżącego rekordu na następnego rekordu w zestawie rekordów.|  
|[CDaoRecordset::MovePrev](#moveprev)|Określa położenie bieżącego rekordu na poprzedniego rekordu w zestawie rekordów.|  
|[CDaoRecordset::Open](#open)|Tworzy nowy zestaw rekordów z tabeli, dynamicznego lub migawek.|  
|[CDaoRecordset::Requery](#requery)|Uruchamia kwerendy w zestawie rekordów ponownie, aby odświeżyć wybranych rekordów.|  
|[CDaoRecordset::Seek](#seek)|Lokalizuje rekordu w obiekcie zestaw rekordów typu indeksowanej tabeli spełniającego określone kryteria dla bieżącego indeksu i sprawia, że służące do rejestrowania bieżącego rekordu.|  
|[CDaoRecordset::SetAbsolutePosition](#setabsoluteposition)|Ustawia numer bieżącego rekordu obiektu zestawu rekordów.|  
|[CDaoRecordset::SetBookmark](#setbookmark)|Umieszcza zestawu rekordów na rekord zawierający zakładką.|  
|[CDaoRecordset::SetCacheSize](#setcachesize)|Ustawia wartość określającą liczbę rekordów w zestawie rekordów dynamicznego zawierający dane lokalnie pamięci podręcznej ze źródła danych ODBC.|  
|[CDaoRecordset::SetCacheStart](#setcachestart)|Ustawia wartość określającą zakładki pierwszy rekord w zestawie rekordów w pamięci podręcznej.|  
|[CDaoRecordset::SetCurrentIndex](#setcurrentindex)|Wywołuje się, by ustawić indeksu na zestaw rekordów typu tabeli.|  
|[CDaoRecordset::SetFieldDirty](#setfielddirty)|Oznacza określonego pola w bieżącym rekordem, ponieważ zmianie.|  
|[CDaoRecordset::SetFieldNull](#setfieldnull)|Ustawia wartość określonego pola w rekordzie bieżącej wartości null (o wartości).|  
|[CDaoRecordset::SetFieldValue](#setfieldvalue)|Ustawia wartość pola w zestawie rekordów.|  
|[CDaoRecordset::SetFieldValueNull](#setfieldvaluenull)|Ustawia wartość pola w zestawie rekordów na wartość Null. (o wartości).|  
|[CDaoRecordset::SetLockingMode](#setlockingmode)|Ustawia wartość, która określa typ blokowaniem obowiązywać podczas edycji.|  
|[CDaoRecordset::SetParamValue](#setparamvalue)|Ustawia bieżącą wartość określonego parametru przechowywane w obiekcie źródłowym zostały DAOParameter|  
|[CDaoRecordset::SetParamValueNull](#setparamvaluenull)|Ustawia bieżącą wartość określonego parametru na wartość Null (o wartości).|  
|[CDaoRecordset::SetPercentPosition](#setpercentposition)|Ustawia położenie bieżącego rekordu do lokalizacji odpowiadający procent całkowitej liczby rekordów w zestawie rekordów.|  
|[CDaoRecordset::Update](#update)|Kończy `AddNew` lub **Edytuj** operacji zapisując nowe lub zmodyfikowane dane w źródle danych.|  
  
### <a name="public-data-members"></a>Publiczne elementy członkowskie danych  
  
|Nazwa|Opis|  
|----------|-----------------|  
|[CDaoRecordset::m_bCheckCacheForDirtyFields](#m_bcheckcachefordirtyfields)|Zawiera nieobsługiwaną flagę wskazującą, czy pola są automatycznie oznaczane jako zmienione.|  
|[CDaoRecordset::m_nFields](#m_nfields)|Zawiera liczbę elementy członkowskie danych pola w klasie zestawu rekordów i liczba kolumn wybranych przez zestaw rekordów ze źródła danych.|  
|[CDaoRecordset::m_nParams](#m_nparams)|Zawiera liczbę elementy członkowskie danych parametru w klasie rekordów — liczba parametrów przekazanych z zapytaniem w zestawie rekordów|  
|[CDaoRecordset::m_pDAORecordset](#m_pdaorecordset)|Wskaźnik do interfejsu DAO podstawowy obiekt zestawu rekordów.|  
|[CDaoRecordset::m_pDatabase](#m_pdatabase)|Ustaw źródłowej bazy danych dla tego wyniku. Zawiera wskaźnik do [CDaoDatabase](../../mfc/reference/cdaodatabase-class.md) obiektu.|  
|[CDaoRecordset::m_strFilter](#m_strfilter)|Zawiera ciąg używany do budowy SQL **gdzie** instrukcji.|  
|[CDaoRecordset::m_strSort](#m_strsort)|Zawiera ciąg używany do budowy SQL **ORDER BY** instrukcji.|  
  
## <a name="remarks"></a>Uwagi  
 Znany jako "zestawy rekordów," `CDaoRecordset` obiekty są dostępne w następujących trzech formularzach:  
  
-   Zestawy rekordów typu tabeli reprezentują tabeli podstawowej, która umożliwia zbadać, dodawania, zmieniania i usuwania rekordów z pojedynczej tabeli bazy danych.  
  
-   Zestawy rekordów dynamicznego są wyników zapytania, które mogą mieć aktualizowalnych rekordy. Te zestawy rekordów są zestawu rekordów, które można zbadać, dodawania, zmieniania i usuwania rekordów z tabeli podstawowej bazy danych lub tabel. Zestawy rekordów dynamicznego mogą zawierać pola z co najmniej jedną tabelę w bazie danych.  
  
-   Zestaw rekordów typu migawka jest statyczną kopię zestawu rekordów, które służy do wyszukiwania danych lub generowania raportów. Te zestawy rekordów mogą zawierać pola z co najmniej jedną tabelę w bazie danych, ale nie można zaktualizować.  
  
 Każdy formularz rekordów reprezentuje zestaw rekordów ustalone w momencie otwarcia zestawu rekordów. Podczas przewijania do rekordu w zestawie rekordów typu tabeli lub dynamicznego zestawu rekordów odzwierciedla zmiany wprowadzone do rekordu po otwarciu zestawu rekordów przez innych użytkowników lub innych zestawów rekordów w aplikacji. (Nie można zaktualizować zestawu rekordów typu migawka.) Można użyć `CDaoRecordset` bezpośrednio lub pochodzi z klasy specyficzne dla aplikacji zestawu rekordów z `CDaoRecordset`. Następnie możesz:  
  
-   Przewijanie rekordów.  
  
-   Indeks i szybko wyszukać rekordów przy użyciu [wyszukiwania](#seek) (tylko zestawy rekordów typ tabeli).  
  
-   Znajdowanie rekordów na podstawie porównania ciągów: "<","\<=", "=" "> =", lub ">" (dynamicznego i zestawów rekordów typu Migawka).  
  
-   Zaktualizuj rekordów i określ tryb blokowania (oprócz zestawów rekordów typu Migawka).  
  
-   Filtrowanie rekordów, aby ograniczyć rekordy, które powoduje wybranie od tych, które są dostępne w źródle danych.  
  
-   Aby posortować zestawu rekordów.  
  
-   Parametryzacja zestawu rekordów, aby dostosować jego zaznaczenie informacje nie są znane do czasu wykonywania.  
  
 Klasa `CDaoRecordset` udostępnia interfejsem podobnym do tej klasy `CRecordset`. Główna różnica polega na tej klasy `CDaoRecordset` uzyskuje dostęp do danych za pośrednictwem obiektu DAO (Data Access) oparte na OLE. Klasa `CRecordset` uzyskuje dostęp do systemu DBMS za pośrednictwem otwarte połączenie bazy danych (ODBC) i sterownik ODBC dla tego systemu DBMS.  
  
> [!NOTE]
>  Klasy baz danych DAO różnią się od klasy baz danych MFC oparte na otwarte połączenie bazy danych (ODBC). Wszystkie nazwy klasy bazy danych DAO mają prefiks "CDao". Możesz nadal dostęp do źródła danych ODBC z klasy DAO; klasy DAO zazwyczaj oferują możliwości wyższego poziomu, ponieważ zależą one od aparatu bazy danych programu Microsoft Jet.  
  
 Można użyć `CDaoRecordset` bezpośrednio lub pochodzić od klasy `CDaoRecordset`. Aby używać klasy zestawu rekordów w obu przypadkach, Otwieranie bazy danych i utworzyć obiekt zestawu rekordów, przekazywanie konstruktora wskaźnik do Twojej `CDaoDatabase` obiektu. Można również utworzyć `CDaoRecordset` obiektu i umożliwić tworzenie tymczasowej MFC `CDaoDatabase` obiekt. Następnie wywołaj zestawu rekordów [Otwórz](#open) funkcji członkowskiej, określając, czy obiekt jest zestaw rekordów typu tabeli dynamicznego zestawu rekordów i rekordów typu migawka. Wywoływanie **Otwórz** wybiera dane z bazy danych i pobiera pierwszy rekord.  
  
 Użyj obiektu elementu członkowskiego funkcji i danych elementów członkowskich do przewijania rekordów i działają na nich. Operacje dostępne są zależne od tego, czy obiekt jest zestaw rekordów typu tabeli dynamicznego zestawu rekordów i rekordów typu migawka, i czy jest można aktualizować tylko do odczytu — zależy od możliwości bazy danych lub Otwórz połączenie bazy danych (ODBC) źródło danych. Aby odświeżyć rekordy, które mogą zostały zmienione lub dodane po **Otwórz** wywołania, należy wywołać obiektu [Requery](#requery) funkcji członkowskiej. Wywołanie obiektu **Zamknij** elementu członkowskiego działać, a obiekt zniszczyć, po zakończeniu pracy z nim.  
  
 `CDaoRecordset` wymiana pól rekordów DAO (DFX) do obsługi odczytywanie i aktualizowanie pól rekordów z użyciem protokołu bezpieczne C++ członkami Twojej `CDaoRecordset` lub `CDaoRecordset`-klasy. Można też wdrożyć dynamiczne powiązanie kolumn w bazie danych, bez użycia za pomocą mechanizmu DFX [GetFieldValue](#getfieldvalue) i [SetFieldValue](#setfieldvalue).  
  
 Powiązane informacje zobacz temat "Zestawu rekordów do obiektu" w pomocy DAO.  
  
## <a name="inheritance-hierarchy"></a>Hierarchia dziedziczenia  
 [CObject](../../mfc/reference/cobject-class.md)  
  
 `CDaoRecordset`  
  
## <a name="requirements"></a>Wymagania  
 **Nagłówek:** afxdao.h  
  
##  <a name="addnew"></a>  CDaoRecordset::AddNew  
 Wywołanie tej funkcji Członkowskich, aby dodać nowy rekord do rekordów typu tabeli lub dynamicznego.  
  
```  
virtual void AddNew();
```  
  
### <a name="remarks"></a>Uwagi  
 Pola rekordu są początkowo wartości Null. (W terminologii bazy danych o wartości Null oznacza, że "o wartości" i nie jest taka sama jak **NULL** w języku C++.) Aby ukończyć operację, należy wywołać [aktualizacji](#update) funkcję elementu członkowskiego. **Aktualizacja** zapisuje zmiany w źródle danych.  
  
> [!CAUTION]
>  Jeśli edytowanie rekordu, a następnie przewiń do innego rekordu bez wywoływania elementu **aktualizacji**, wszystkie zmiany zostaną utracone bez ostrzeżenia.  
  
 Jeśli musisz dodać rekordu do dynamicznego zestawu rekordów przez wywołanie metody [AddNew](#addnew), rekord jest widoczny w zestawie rekordów i uwzględniane w tabeli podstawowej, gdzie staje się niewidoczna dla każdego nowego `CDaoRecordset` obiektów.  
  
 Pozycja nowy rekord zależy od typu zestawu rekordów:  
  
-   Zestaw rekordów, w którym zostanie wstawiony nowy rekord w typu dynamicznego nie jest gwarantowana. To zachowanie jest zmieniony z programu Microsoft Jet 3.0 ze względu na wydajność i współbieżności. Jeśli celem jest zapewnienie nowo dodanego rekordu dla bieżącego rekordu, Pobierz zakładki ostatni rekord zmodyfikowane i przejdź do tej zakładki:  
  
 [!code-cpp[NVC_MFCDatabase#1](../../mfc/codesnippet/cpp/cdaorecordset-class_1.cpp)]  
  
-   W zestawie rekordów typu tabeli, dla której określono indeksu rekordy są zwracane w ich właściwe miejsce w kolejności sortowania. Jeśli nie podano żadnych indeksu, nowe rekordy są zwracane na końcu zestawu rekordów.  
  
 Rekord aktualna, zanim zostanie użyty `AddNew` pozostaje bieżącej. Jeśli chcesz utworzyć nowy rekord bieżący zestaw rekordów obsługuje zakładki, wywołanie [SetBookmark](#setbookmark) do zakładki identyfikowane przez ustawienie właściwości LastModified obiektu podstawowego zestawu rekordów DAO. W ten sposób jest przydatne w przypadku określenia wartości dla licznika (automatycznego przyrostu) pól w rekordzie dodany. Aby uzyskać więcej informacji, zobacz [GetLastModifiedBookmark](#getlastmodifiedbookmark).  
  
 Jeśli bazy danych obsługuje transakcje, możesz wprowadzić Twojej `AddNew` wywołać w ramach transakcji. Aby uzyskać więcej informacji na temat transakcji, zobacz klasy [CDaoWorkspace](../../mfc/reference/cdaoworkspace-class.md). Należy pamiętać, że należy wywołać [CDaoWorkspace::BeginTrans](../../mfc/reference/cdaoworkspace-class.md#begintrans) przed wywołaniem `AddNew`.  
  
 Nie jest dozwolone wywoływanie `AddNew` dla zestawu rekordów których [Otwórz](#open) funkcja członkowska nie została wywołana. A `CDaoException` jest generowany, jeśli wywołujesz `AddNew` dla zestawu rekordów, które nie mogą być dołączane. Można określić, czy zestaw rekordów jest aktualizowalne, wywołując [CanAppend](#canappend).  
  
 Znaczniki framework zmienione elementy członkowskie danych pola, aby upewnić się, że będzie można zapisać rekordu w źródle danych przy użyciu mechanizmu programu exchange (DFX) pól rekordów DAO. Zmiana wartości pola zazwyczaj ustawia pole zanieczyszczone automatycznie, dzięki czemu rzadko trzeba wywołać [SetFieldDirty](#setfielddirty) samodzielnie, ale czasami warto upewnij się, że kolumn zostanie jawnie zaktualizowane lub wstawić niezależnie od tego jakie wartości jest członek pola danych. Mechanizm DFX wykorzystuje również użycie **PSEUDO NULL**. Aby uzyskać więcej informacji, zobacz [CDaoFieldExchange::m_nOperation](../../mfc/reference/cdaofieldexchange-class.md#m_noperation).  
  
 Jeśli nie jest używany mechanizm podwójnego buforowania, następnie zmieniając wartość pola nie automatycznie ustawia pole jako zakłócone. W takim przypadku będzie trzeba jawnie ustaw dla pola zanieczyszczone. Flaga zawarte w [m_bCheckCacheForDirtyFields](#m_bcheckcachefordirtyfields) steruje tym automatyczne sprawdzanie.  
  
> [!NOTE]
>  Jeśli rekordy są podwójnie buforowany (automatyczne sprawdzanie jest włączone), wywoływania `CancelUpdate` spowoduje przywrócenie zmienne Członkowskie wartości miało przed `AddNew` lub **Edytuj** została wywołana.  
  
 Aby uzyskać odpowiednie informacje zobacz tematy "AddNew — metoda", "Metoda CancelUpdate", "LastModified Property" i "EditMode Property" w pomocy DAO.  
  
##  <a name="canappend"></a>  CDaoRecordset::CanAppend  
 Wywołanie tej funkcji Członkowskich, aby ustalić, czy wcześniej otwartych rekordów pozwala na dodawanie nowych rekordów przez wywołanie metody [AddNew](#addnew) funkcję elementu członkowskiego.  
  
```  
BOOL CanAppend() const;  
```  
  
### <a name="return-value"></a>Wartość zwracana  
 Różna od zera, jeśli zestaw rekordów zezwala na dodawanie nowych rekordów; w przeciwnym razie 0. `CanAppend` Zwraca wartość 0, gdy otwarty zestaw rekordów jako tylko do odczytu.  
  
### <a name="remarks"></a>Uwagi  
 Powiązane informacje zobacz temat "Dołącz Method" w pomocy DAO.  
  
##  <a name="canbookmark"></a>  CDaoRecordset::CanBookmark  
 Wywołanie tej funkcji elementu członkowskiego, aby określić, czy wcześniej otwartych rekordów umożliwia indywidualnie oznaczanie rekordów korzystanie z zakładek.  
  
```  
BOOL CanBookmark();
```  
  
### <a name="return-value"></a>Wartość zwracana  
 Różna od zera, jeśli zestaw rekordów obsługuje zakładki, w przeciwnym razie wartość 0.  
  
### <a name="remarks"></a>Uwagi  
 Jeśli korzystasz z zestawów rekordów całkowicie w tabelach aparatu bazy danych programu Microsoft Jet, zakładki może służyć z wyjątkiem na zestawów rekordów typu migawka oznaczony jako tylko do przodu przewijania zestawy rekordów. Inne produkty bazy danych (zewnętrznego źródła danych ODBC) może nie obsługiwać zakładki.  
  
 Powiązane informacje zobacz temat "Bookmarkable Property" w pomocy DAO.  
  
##  <a name="cancelupdate"></a>  CDaoRecordset::CancelUpdate  
 `CancelUpdate` Funkcji członkowskiej anuluje wszystkie oczekujące aktualizacje z powodu [Edytuj](#edit) lub [AddNew](#addnew) operacji.  
  
```  
virtual void CancelUpdate();
```  
  
### <a name="remarks"></a>Uwagi  
 Na przykład, jeśli aplikacja wywołuje **Edytuj** lub `AddNew` funkcji członkowskiej, a nie została wywołana [aktualizacji](#update), `CancelUpdate` Anuluje zmiany wprowadzone po **Edytuj**lub `AddNew` została wywołana.  
  
> [!NOTE]
>  Jeśli rekordy są podwójnie buforowany (automatyczne sprawdzanie jest włączone), wywoływania `CancelUpdate` spowoduje przywrócenie zmienne Członkowskie wartości miało przed `AddNew` lub **Edytuj** została wywołana.  
  
 W przypadku nie **Edytuj** lub `AddNew` operację w toku, `CancelUpdate` powoduje, że MFC do zgłoszenia wyjątku. Wywołanie [GetEditMode](#geteditmode) funkcji członkowskiej, aby określić, czy istnieje oczekująca operacja, która może być anulowane.  
  
 Powiązane informacje zobacz temat "CancelUpdate Method" w pomocy DAO.  
  
##  <a name="canrestart"></a>  CDaoRecordset::CanRestart  
 Wywołanie tej funkcji elementu członkowskiego, aby określić, czy zestaw rekordów zezwala na ponowne uruchomienie jej zapytania (na przykład aby odświeżyć swoje rekordy) przez wywołanie metody **Requery** funkcję elementu członkowskiego.  
  
```  
BOOL CanRestart();
```  
  
### <a name="return-value"></a>Wartość zwracana  
 Jeśli podano niezerowe **Requery** można wywołać w celu uruchomienia zestawu rekordów zapytanie ponownie, w przeciwnym razie wartość 0.  
  
### <a name="remarks"></a>Uwagi  
 Zestawy rekordów typu tabeli nie obsługują **Requery**.  
  
 Jeśli **Requery** jest nieobsługiwane, wywołaj [Zamknij](#close) następnie [Otwórz](#open) odświeżania danych. Możesz wywołać **Requery** można zaktualizować obiektu zestawu rekordów podstawowej parametru zapytania po zmianie wartości parametrów.  
  
 Powiązane informacje zobacz temat "Ponownego uruchamiania Property" w pomocy DAO.  
  
##  <a name="canscroll"></a>  CDaoRecordset::CanScroll  
 Wywołanie tej funkcji Członkowskich, aby ustalić, czy zestaw rekordów umożliwia przewijanie.  
  
```  
BOOL CanScroll() const;  
```  
  
### <a name="return-value"></a>Wartość zwracana  
 Różna od zera, jeśli można przewijać rekordy, w przeciwnym razie wartość 0.  
  
### <a name="remarks"></a>Uwagi  
 Jeśli należy wywołać [Otwórz](#open) z **dbForwardOnly**, zestaw rekordów można tylko przewiń do przodu.  
  
 Powiązane informacje zobacz temat "Pozycjonowanie bieżącego rekordu wskaźnika z DAO" w pomocy DAO.  
  
##  <a name="cantransact"></a>  CDaoRecordset::CanTransact  
 Wywołanie tej funkcji elementu członkowskiego, aby określić, czy zestaw rekordów umożliwia transakcji.  
  
```  
BOOL CanTransact();
```  
  
### <a name="return-value"></a>Wartość zwracana  
 Różna od zera, jeśli źródła danych obsługuje transakcje, w przeciwnym razie wartość 0.  
  
### <a name="remarks"></a>Uwagi  
 Powiązane informacje zobacz temat "Transakcje Property" w pomocy DAO.  
  
##  <a name="canupdate"></a>  CDaoRecordset::CanUpdate  
 Wywołanie tej funkcji elementu członkowskiego, aby określić, czy można zaktualizować zestawu rekordów.  
  
```  
BOOL CanUpdate() const;  
```  
  
### <a name="return-value"></a>Wartość zwracana  
 Różna od zera, jeśli można zaktualizować zestawu rekordów (dodawania, aktualizowania i usuwania rekordów), w przeciwnym razie wartość 0.  
  
### <a name="remarks"></a>Uwagi  
 Zestaw rekordów może być tylko do odczytu, jeśli źródła danych jest tylko do odczytu lub nie określono **dbReadOnly** dla `nOptions` po nazwie [Otwórz](#open) zestawu rekordów.  
  
 Aby uzyskać odpowiednie informacje zobacz tematy "Metody AddNew", "Edytuj metodę", "Metody Delete", "Metody aktualizacji" i "Nadaje się do aktualizacji właściwości" w pomocy DAO.  
  
##  <a name="cdaorecordset"></a>  CDaoRecordset::CDaoRecordset  
 Konstruuje `CDaoRecordset` obiektu.  
  
```  
CDaoRecordset(CDaoDatabase* pDatabase = NULL);
```  
  
### <a name="parameters"></a>Parametry  
 `pDatabase`  
 Zawiera wskaźnik do [CDaoDatabase](../../mfc/reference/cdaodatabase-class.md) obiektu lub wartość **NULL**. Jeśli nie **NULL** i `CDaoDatabase` obiektu **Otwórz** nie została wywołana funkcja członkowska nawiązać źródła danych, próbuje on otwarty przez podczas własny zestaw rekordów [Otwórz ](#open) wywołania. W przypadku przekazania **NULL**, `CDaoDatabase` obiekt jest tworzony i połączone przy użyciu informacje o źródle danych, które zostały określone, jeśli pochodzi z klasy rekordów `CDaoRecordset`.  
  
### <a name="remarks"></a>Uwagi  
 Można użyć `CDaoRecordset` bezpośrednio lub pochodzi z klasy specyficzne dla aplikacji z `CDaoRecordset`. ClassWizard umożliwia pochodzi z klasy zestawu rekordów.  
  
> [!NOTE]
>  Przypadku klasy wyprowadzonej `CDaoRecordset` klasy, z pochodnej klasy podać własne konstruktora. W konstruktorze klasy pochodnej, wywołanie konstruktora `CDaoRecordset::CDaoRecordset`, przekazywanie do niego odpowiednie parametry wzdłuż.  
  
 Przekaż **wartości NULL** Twojego Konstruktora zestawu rekordów mają `CDaoDatabase` obiekt utworzone i połączone można automatycznie. Jest to przydatny skrót, który nie wymaga do utworzenia i połączenia `CDaoDatabase` obiektu przed konstruowania zestawu rekordów. Jeśli `CDaoDatabase` obiektu nie jest otwarty, [CDaoWorkspace](../../mfc/reference/cdaoworkspace-class.md) dla Ciebie, która używa domyślny obszar roboczy zostanie również utworzony obiekt. Aby uzyskać więcej informacji, zobacz [CDaoDatabase::CDaoDatabase](../../mfc/reference/cdaodatabase-class.md#cdaodatabase).  
  
##  <a name="close"></a>  CDaoRecordset::Close  
 Zamykanie `CDaoRecordset` obiektu usuwa go z kolekcji otwieranie zestawów rekordów w skojarzonej bazie danych.  
  
```  
virtual void Close();
```  
  
### <a name="remarks"></a>Uwagi  
 Ponieważ **Zamknij** nie niszczy `CDaoRecordset` obiektu, można użyć ponownie obiektu przez wywołanie metody **Otwórz** na tym samym źródle danych lub innego źródła danych.  
  
 Wszystkie oczekujące [AddNew](#addnew) lub [Edytuj](#edit) instrukcje są anulowane, a wszystkie oczekujące transakcje są wycofywane. Jeśli chcesz zachować oczekujące dodatków lub zmian, wywołanie [aktualizacji](#update) przed wywołaniem **Zamknij** dla każdego zestawu rekordów.  
  
 Możesz wywołać **Otwórz** ponownie po wywołaniu **Zamknij**. Dzięki temu można użyć ponownie obiektu zestawu rekordów. Lepszym jest wywołanie [Requery](#requery), jeśli to możliwe.  
  
 Powiązane informacje zobacz temat "Metody Close" w pomocy DAO.  
  
##  <a name="delete"></a>  CDaoRecordset::Delete  
 Wywołanie tej funkcji elementu członkowskiego, aby usunąć rekord bieżący w otwarty obiekt zestawu rekordów dynamicznego lub typ tabeli.  
  
```  
virtual void Delete();
```  
  
### <a name="remarks"></a>Uwagi  
 Po pomyślnym usunięciu, elementy członkowskie danych pola w zestawie rekordów są ustawione na wartość Null i musi jawnie wywołać jednej z funkcji Członkowskich nawigacji zestawu rekordów ( [Przenieś](#move), [wyszukiwania](#seek), [ SetBookmark](#setbookmark)i tak dalej), aby opuścić usunięty rekord. Podczas usuwania rekordów z zestawu rekordów, musi istnieć rekord bieżący w zestawie rekordów przed wywołaniem **usunąć**; w przeciwnym razie MFC zgłasza wyjątek.  
  
 **Usuń** spowoduje usunięcie bieżącego rekordu i ułatwia niedostępny. Mimo że nie można edytować ani przy użyciu usuniętego rekordu, pozostaje bieżącej. Po przejściu do innego rekordu, jednak nie można wprowadzić usunięty rekord bieżący ponownie.  
  
> [!CAUTION]
>  Zestaw rekordów musi zezwalać na aktualizacje, a musi być prawidłowy rekord bieżący w zestawie rekordów podczas wywoływania **usunąć**. Na przykład usunąć rekord, ale nie przewiń do nowego rekordu przed wywołaniem **usunąć** ponownie, **usunąć** zgłasza [CDaoException](../../mfc/reference/cdaoexception-class.md).  
  
 Jeśli używasz transakcji i wywołania można cofnąć usunięcie rekordu [CDaoWorkspace::Rollback](../../mfc/reference/cdaoworkspace-class.md#rollback) funkcję elementu członkowskiego. Jeśli tabela podstawowa jest tabela podstawowa w kaskadowego. Usuń relację, usunięcie bieżącego rekordu może również usunięcie jednego lub więcej rekordów w tabeli obcej. Aby uzyskać więcej informacji Zobacz definicji "cascade Usuń" w pomocy DAO.  
  
 W odróżnieniu od `AddNew` i **Edytuj**, wywołanie **usunąć** nie następuje wywołanie **aktualizacji**.  
  
 Aby uzyskać odpowiednie informacje zobacz tematy "Metody AddNew", "Edytuj metodę", "Metody Delete", "Metody aktualizacji" i "Nadaje się do aktualizacji właściwości" w pomocy DAO.  
  
##  <a name="dofieldexchange"></a>  CDaoRecordset::DoFieldExchange  
 Struktura wywołuje funkcji członkowskiej do automatycznie wymiany danych między elementy członkowskie danych pola obiektu zestawu rekordów i odpowiednie kolumny bieżącego rekordu w źródle danych.  
  
```  
virtual void DoFieldExchange(CDaoFieldExchange* pFX);
```  
  
### <a name="parameters"></a>Parametry  
 `pFX`  
 Zawiera wskaźnik do `CDaoFieldExchange` obiektu. Platformę będzie już skonfigurowano tego obiektu do określenia kontekstu dla operacji wymiana pola.  
  
### <a name="remarks"></a>Uwagi  
 Wiąże również użytkownika elementy członkowskie danych parametru, jeśli parametr zastępcze w ciągu instrukcji SQL dla zaznaczenia w zestawie rekordów. Pola danych, nazywane wymiana pól rekordów DAO (DFX) programu exchange działa w obu kierunkach: elementy członkowskie danych pola obiektu zestawu rekordów w polach rekordu w źródle danych oraz rekordu w źródle danych do obiektu zestawu rekordów. Jeśli dynamicznie powiązanie kolumn nie są wymagane wdrożenie `DoFieldExchange`.  
  
 Jedyną akcją, zazwyczaj należy wykonać, aby zaimplementować `DoFieldExchange` dla pochodnego zestawu rekordów klasy ma utworzyć klasę z ClassWizard i określić nazwy i typy danych elementy członkowskie danych pola. Można również dodać kod w ClassWizard zapisuje określone elementy członkowskie danych parametru. Jeśli wszystkie pola mają być dynamicznie powiązane, tej funkcji będą nieaktywne, chyba że Określ elementy członkowskie danych parametru.  
  
 Deklaracja klasy pochodnej rekordów z ClassWizard kreator zapisuje zastępująca `DoFieldExchange` , który podobnego do następującego:  
  
 [!code-cpp[NVC_MFCDatabase#2](../../mfc/codesnippet/cpp/cdaorecordset-class_2.cpp)]  
  
##  <a name="edit"></a>  CDaoRecordset::Edit  
 Wywołanie tej funkcji Członkowskich do umożliwienia wprowadzania zmian dla bieżącego rekordu.  
  
```  
virtual void Edit();
```  
  
### <a name="remarks"></a>Uwagi  
 Po wywołaniu **Edytuj** funkcji członkowskiej, zmiany wprowadzone do bieżącego rekordu pól są kopiowane do buforu kopiowania. Po wprowadzeniu żądane zmiany z rekordem wywołać **aktualizacji** Aby zapisać zmiany. **Edytuj** zapisuje wartości elementów członkowskich danych w zestawie rekordów. Wywołanie **Edytuj**, wprowadzić zmiany, następnie wywołaj **Edytuj** ponownie, wartości rekordu zostaną przywrócone były przed pierwszym **Edytuj** wywołania.  
  
> [!CAUTION]
>  Jeśli edytowanie rekordu, a następnie wykonać żadnej operacji przenoszenia do innego rekordu bez wywoływania pierwszego elementu **aktualizacji**, wszystkie zmiany zostaną utracone bez ostrzeżenia. Ponadto jeśli zamkniesz zestawu rekordów lub nadrzędnej bazy danych edytowanego rekordu jest odrzucany bez ostrzeżenia.  
  
 W niektórych przypadkach można zaktualizować kolumny czyniąc ją (bez danych zawierający) o wartości Null. Aby to zrobić, należy wywołać `SetFieldNull` z parametrem **TRUE** do oznaczania pola wartość Null; powoduje również kolumny, która ma zostać zaktualizowany. Jeśli pole ma zapisywane do źródła danych, mimo że nie zmieniono jego wartość, należy wywołać `SetFieldDirty` z parametrem **TRUE**. To działanie, nawet jeśli pole ma wartość Null.  
  
 Znaczniki framework zmienione elementy członkowskie danych pola, aby upewnić się, że będzie można zapisać rekordu w źródle danych przy użyciu mechanizmu programu exchange (DFX) pól rekordów DAO. Zmiana wartości pola zazwyczaj ustawia pole zanieczyszczone automatycznie, dzięki czemu rzadko trzeba wywołać [SetFieldDirty](#setfielddirty) samodzielnie, ale czasami warto upewnij się, że kolumn zostanie jawnie zaktualizowane lub wstawić niezależnie od tego jakie wartości jest członek pola danych. Mechanizm DFX wykorzystuje również użycie **PSEUDO NULL**. Aby uzyskać więcej informacji, zobacz [CDaoFieldExchange::m_nOperation](../../mfc/reference/cdaofieldexchange-class.md#m_noperation).  
  
 Jeśli nie jest używany mechanizm podwójnego buforowania, następnie zmieniając wartość pola nie automatycznie ustawia pole jako zakłócone. W takim przypadku będzie trzeba jawnie ustaw dla pola zanieczyszczone. Flaga zawarte w [m_bCheckCacheForDirtyFields](#m_bcheckcachefordirtyfields) steruje tym automatyczne sprawdzanie.  
  
 Gdy obiekt zestawu rekordów pessimistically jest zablokowana w środowisku wielodostępnym, rekord jest zablokowany od czasu **Edytuj** służy do zakończenia uaktualnienia. Jeśli zestaw rekordów według optymistycznych jest zablokowana, rekord jest zablokowana i tylko zanim zostaną one zaktualizowane w bazie danych w porównaniu z wstępnie edytowanego rekordu. Jeśli rekord został zmieniony, ponieważ wywołana **Edytuj**, **aktualizacji** operacja kończy się niepowodzeniem i MFC zgłasza wyjątek. Można zmienić tryb blokowania z `SetLockingMode`.  
  
> [!NOTE]
>  Optymistyczne blokowanie zawsze jest używany na formatów zewnętrznej bazy danych, takich jak ODBC i zainstalowania ISAM.  
  
 Rekord bieżący pozostaje bieżącego po wywołaniu metody **Edytuj**. Aby wywołać **Edytuj**, musi być bieżącego rekordu. Jeśli nie istnieje bieżący rekord lub zestaw rekordów nie odwołuje się do typu otwartego tabeli lub obiektu zestawu rekordów dynamicznego, wystąpi wyjątek. Wywoływanie **Edytuj** powoduje, że `CDaoException` zostanie wygenerowany w następujących warunkach:  
  
-   Brak bieżącego rekordu.  
  
-   Baza danych lub zestawu rekordów jest tylko do odczytu.  
  
-   Nie są aktualizowalne żadne pola w rekordzie.  
  
-   Bazy danych lub zestawu rekordów została otwarta do wyłącznego użytku przez innego użytkownika.  
  
-   Inny użytkownik zablokował strona zawierająca rekordu.  
  
 Jeśli źródło danych obsługuje transakcje, możesz wprowadzić **Edytuj** wywołać w ramach transakcji. Należy pamiętać, że należy wywołać `CDaoWorkspace::BeginTrans` przed wywołaniem **Edytuj** i po otwarciu zestawu rekordów. Należy również zauważyć, że wywołania `CDaoWorkspace::CommitTrans` nie jest zamiast wywoływania **aktualizacji** do ukończenia **Edytuj** operacji. Aby uzyskać więcej informacji na temat transakcji, zobacz klasy `CDaoWorkspace`.  
  
 Aby uzyskać odpowiednie informacje zobacz tematy "Metody AddNew", "Edytuj metodę", "Metody Delete", "Metody aktualizacji" i "Nadaje się do aktualizacji właściwości" w pomocy DAO.  
  
##  <a name="fillcache"></a>  CDaoRecordset::FillCache  
 Wywołanie tej funkcji Członkowskich w pamięci podręcznej przez określoną liczbę rekordów w zestawie.  
  
```  
void FillCache(
    long* pSize = NULL,  
    COleVariant* pBookmark = NULL);
```  
  
### <a name="parameters"></a>Parametry  
 `pSize`  
 Określa liczbę wierszy do wypełnienia pamięci podręcznej. Jeśli ten parametr zostanie pominięty, wartość jest określana przez ustawienie właściwości CacheSize obiekt DAO.  
  
 `pBookmark`  
 A [COleVariant](../../mfc/reference/colevariant-class.md) określenie zakładki. Pamięć podręczna jest wypełniony, zaczynając od rekordu wskazywanym przez tę zakładkę. Jeśli ten parametr zostanie pominięty, pamięci podręcznej jest wypełniony, zaczynając od rekordu wskazywanym przez właściwość CacheStart obiekt DAO.  
  
### <a name="remarks"></a>Uwagi  
 Buforowanie poprawia wydajność aplikacji, która pobiera, lub pobiera dane z serwera zdalnego. Pamięć podręczna jest miejsca w lokalnej pamięci, która przechowuje dane ostatnio pobrane z serwera przy założeniu, że dane będą prawdopodobnie można żądać jej ponownie gdy aplikacja jest uruchomiona. Po zażądaniu danych aparatu bazy danych programu Microsoft Jet w pamięci podręcznej danych najpierw sprawdza zamiast pobierania go z serwera, który zajmuje więcej czasu. Przy użyciu danych buforowanie na innych niż ODBC — źródła danych nie ma znaczenia jak dane nie są zapisywane w pamięci podręcznej.  
  
 Przed wysłaniem ich do pamięci podręcznej, aby być wypełnione rekordów, ponieważ są one pobierane, można jawnie wypełnienie pamięci podręcznej w dowolnym momencie przez wywołanie metody `FillCache` funkcję elementu członkowskiego. Jest to sposób wypełnienia pamięci podręcznej, ponieważ `FillCache` pobiera kilka rekordów jednocześnie zamiast pojedynczo. Przykładowo, podczas każdego screenful rekordów jest wyświetlany, jeśli masz wywołania aplikacji `FillCache` do pobrania następnej screenful rekordów.  
  
 Wszystkie dostępne z obiektami rekordów bazy danych ODBC może mieć lokalnej pamięci podręcznej. Aby utworzyć pamięci podręcznej, otwórz obiekty zestawów rekordów ze zdalnego źródła danych, a następnie wywołaj `SetCacheSize` i `SetCacheStart` funkcji elementów członkowskich zestawu rekordów. Jeśli `lSize` i *lBookmark* utworzyć zakres, który jest częściowo lub całkowicie poza zakres określony przez `SetCacheSize` i `SetCacheStart`, część zestawu rekordów poza tym zakresem jest ignorowany i nie jest ładowany do pamięci podręcznej. Jeśli `FillCache` żądań więcej rekordów niż pozostają w zdalne źródło danych, są pobierane tylko pozostałych rekordów i nie jest wyjątek.  
  
 Rejestruje pobranych z pamięci podręcznej nie uwzględniają zmiany wprowadzone współbieżnie źródła danych przez innych użytkowników.  
  
 `FillCache` pobiera tylko te rekordy, które nie są już w pamięci podręcznej. Aby wymusić aktualizację wszystkie buforowane dane, należy wywołać `SetCacheSize` funkcji członkowskiej z `lSize` parametru równa 0, wywołanie `SetCacheSize` ponownie, podając `lSize` parametru taki sam rozmiar pamięci podręcznej można początkowo żądana, a następnie wywołać `FillCache`.  
  
 Powiązane informacje zobacz temat "FillCache Method" w pomocy DAO.  
  
##  <a name="find"></a>  CDaoRecordset::Find  
 Wywołanie tej funkcji członkowskich można znaleźć określony ciąg w zestawie rekordów typu dynamicznego lub migawek przy użyciu operatora porównania.  
  
```  
virtual BOOL Find(
    long lFindType,  
    LPCTSTR lpszFilter);
```  
  
### <a name="parameters"></a>Parametry  
 *lFindType*  
 Wartość wskazująca typ żądaną operację wyszukiwania. Możliwe wartości to:  
  
- **AFX_DAO_NEXT** znaleźć następnej lokalizacji odpowiedni ciąg.  
  
- **AFX_DAO_PREV** poprzedniej lokalizacji dopasowania ciągu wyszukiwania.  
  
- **AFX_DAO_FIRST** pierwszy lokalizacji dopasowania ciągu wyszukiwania.  
  
- **AFX_DAO_LAST** ostatnich lokalizacji dopasowania ciągu wyszukiwania.  
  
 `lpszFilter`  
 Wyrażenia ciągu (takich jak **gdzie** klauzuli w instrukcji SQL bez wyrazu **gdzie**) używane do lokalizowania rekordu. Na przykład:  
  
 [!code-cpp[NVC_MFCDatabase#3](../../mfc/codesnippet/cpp/cdaorecordset-class_3.cpp)]  
  
### <a name="return-value"></a>Wartość zwracana  
 Różna od zera, jeśli rekordy zostaną znalezione, w przeciwnym razie 0.  
  
### <a name="remarks"></a>Uwagi  
 Można znaleźć najpierw następne wystąpienie poprzedniego lub ostatniego ciągu. **Znajdź** jest funkcją wirtualną, aby można było ją zastąpić i dodać własną implementację. `FindFirst`, `FindLast`, `FindNext`, I `FindPrev` wywołanie funkcji Członkowskich **znaleźć** funkcji członkowskiej, dzięki czemu można używać **znaleźć** do sterowania zachowaniem wszystkich operacji wyszukiwania .  
  
 Aby zlokalizować rekordu do zestawu rekordów typu tabeli, należy wywołać [wyszukiwania](#seek) funkcję elementu członkowskiego.  
  
> [!TIP]
>  Mniejszy zestaw rekordów, musisz mieć bardziej skuteczna **znaleźć** będzie. W ogólności, a szczególnie w przypadku danych ODBC warto utworzyć nowe zapytanie, które są pobierane tylko rekordy, które mają.  
  
 Powiązane informacje zobacz temat "FindNext FindFirst, FindLast, metody FindPrevious" w pomocy DAO.  
  
##  <a name="findfirst"></a>  CDaoRecordset::FindFirst  
 Wywołanie tej funkcji członkowskich można znaleźć pierwszy rekord, który pasuje określonego warunku.  
  
```  
BOOL FindFirst(LPCTSTR lpszFilter);
```  
  
### <a name="parameters"></a>Parametry  
 `lpszFilter`  
 Wyrażenia ciągu (takich jak **gdzie** klauzuli w instrukcji SQL bez wyrazu **gdzie**) używane do lokalizowania rekordu.  
  
### <a name="return-value"></a>Wartość zwracana  
 Różna od zera, jeśli rekordy zostaną znalezione, w przeciwnym razie 0.  
  
### <a name="remarks"></a>Uwagi  
 `FindFirst` Funkcji członkowskiej rozpocznie się wyszukiwanie od początku zestawu rekordów i wyszukiwania w celu zestawu rekordów.  
  
 Jeśli chcesz uwzględnić wszystkie rekordy w wyszukiwania (nie tylko te, które spełniają określony warunek) Aby użyć jednej z operacji przenoszenia przechodzenia z rekordami. Aby zlokalizować rekordu do zestawu rekordów typu tabeli, należy wywołać `Seek` funkcję elementu członkowskiego.  
  
 Jeśli rekord spełniających kryteria nie znajduje się, bieżący wskaźnik rekordu jest nieokreślona, i `FindFirst` zwraca zero. Jeśli zestaw rekordów zawiera więcej niż jeden rekord, który spełnia kryteria, `FindFirst` znajduje pierwsze wystąpienie `FindNext` znajduje następne wystąpienie i tak dalej.  
  
> [!CAUTION]
>  Jeśli edytujesz bieżącego rekordu, pamiętaj zapisać zmiany wywołując **aktualizacji** funkcji członkowskiej przed przejściem do innego rekordu. Jeśli przeniesienie do innego rekordu bez aktualizowania Twoje zmiany zostaną utracone bez ostrzeżenia.  
  
 **Znaleźć** funkcje Członkowskie przeszukiwać z lokalizacji i kierunek określony w poniższej tabeli:  
  
|Operacji wyszukiwania|Rozpocznij|Kierunek wyszukiwania|  
|---------------------|-----------|----------------------|  
|`FindFirst`|Początek zestawu rekordów|Koniec zestawu rekordów|  
|`FindLast`|Koniec zestawu rekordów|Początek zestawu rekordów|  
|`FindNext`|Bieżącego rekordu|Koniec zestawu rekordów|  
|**FindPrevious**|Bieżącego rekordu|Początek zestawu rekordów|  
  
> [!NOTE]
>  Podczas wywoływania `FindLast`, aparat bazy danych programu Microsoft Jet pełni wypełnia zestawu rekordów przed rozpoczęciem wyszukiwania, jeśli to nie ma jeszcze wykonane. Pierwszy wyszukiwania może trwać dłużej niż kolejnych operacji wyszukiwania.  
  
 Przy użyciu jednej z operacji wyszukiwania nie jest taka sama, co wywołanie **MoveFirst** lub `MoveNext`, jednak co po prostu czyni pierwszy lub następny rekord bieżący bez określania warunku. Można wykonać operacji wyszukiwania z operacji przenoszenia.  
  
 Przy użyciu operacji wyszukiwania, należy pamiętać o następujących:  
  
-   Jeśli **znaleźć** zwraca różną od zera, bieżący rekord nie jest zdefiniowany. W takim przypadku należy umieścić wskaźnik bieżącego rekordu wstecz do rekordu prawidłowe.  
  
-   Nie można używać operacji wyszukiwania przewijania typu migawka rekordów.  
  
-   Powinien mieć format daty Stanów Zjednoczonych (dzień miesiąc rok) podczas wyszukiwania dla pól zawierających daty, nawet jeśli nie używasz wersji US aparatu bazy danych programu Microsoft Jet; w przeciwnym razie pasujących rekordów nie można znaleźć.  
  
-   Podczas pracy z bazy danych ODBC i dużych zestawów dynamicznych, użytkownik może stwierdzić, że za pomocą operacji wyszukiwania jest powolne, szczególnie w przypadku pracy z dużych zestawów rekordów. Może poprawić wydajność przy użyciu zapytania SQL z dostosowane **ORDERBY** lub **gdzie** klauzule, parametr zapytania, lub **CDaoQuerydef** obiektów, które pobrać określonych indeksowane rekordów.  
  
 Powiązane informacje zobacz temat "FindNext FindFirst, FindLast, metody FindPrevious" w pomocy DAO.  
  
##  <a name="findlast"></a>  CDaoRecordset::FindLast  
 Wywołanie tej funkcji członkowskich można znaleźć ostatni rekord, który pasuje określonego warunku.  
  
```  
BOOL FindLast(LPCTSTR lpszFilter);
```  
  
### <a name="parameters"></a>Parametry  
 `lpszFilter`  
 Wyrażenia ciągu (takich jak **gdzie** klauzuli w instrukcji SQL bez wyrazu **gdzie**) używane do lokalizowania rekordu.  
  
### <a name="return-value"></a>Wartość zwracana  
 Różna od zera, jeśli rekordy zostaną znalezione, w przeciwnym razie 0.  
  
### <a name="remarks"></a>Uwagi  
 `FindLast` Funkcji członkowskiej rozpocznie się wyszukiwanie na końcu zestawu rekordów i wyszukiwania do tyłu na początku zestawu rekordów.  
  
 Jeśli chcesz uwzględnić wszystkie rekordy w wyszukiwania (nie tylko te, które spełniają określony warunek) Aby użyć jednej z operacji przenoszenia przechodzenia z rekordami. Aby zlokalizować rekordu do zestawu rekordów typu tabeli, należy wywołać `Seek` funkcję elementu członkowskiego.  
  
 Jeśli rekord spełniających kryteria nie znajduje się, bieżący wskaźnik rekordu jest nieokreślona, i `FindLast` zwraca zero. Jeśli zestaw rekordów zawiera więcej niż jeden rekord, który spełnia kryteria, `FindFirst` znajduje pierwsze wystąpienie `FindNext` znajduje następne wystąpienie po pierwszym wystąpieniu i tak dalej.  
  
> [!CAUTION]
>  Edytuj bieżącego rekordu, należy zapisać zmiany wywołując **aktualizacji** funkcji członkowskiej przed przejściem do innego rekordu. Jeśli przeniesienie do innego rekordu bez aktualizowania Twoje zmiany zostaną utracone bez ostrzeżenia.  
  
 Przy użyciu jednej z operacji wyszukiwania nie jest taka sama, co wywołanie **MoveFirst** lub `MoveNext`, jednak co po prostu czyni pierwszy lub następny rekord bieżący bez określania warunku. Można wykonać operacji wyszukiwania z operacji przenoszenia.  
  
 Przy użyciu operacji wyszukiwania, należy pamiętać o następujących:  
  
-   Jeśli **znaleźć** zwraca różną od zera, bieżący rekord nie jest zdefiniowany. W takim przypadku należy umieścić wskaźnik bieżącego rekordu wstecz do rekordu prawidłowe.  
  
-   Nie można używać operacji wyszukiwania przewijania typu migawka rekordów.  
  
-   Powinien mieć format daty Stanów Zjednoczonych (dzień miesiąc rok) podczas wyszukiwania dla pól zawierających daty, nawet jeśli nie używasz wersji US aparatu bazy danych programu Microsoft Jet; w przeciwnym razie pasujących rekordów nie można znaleźć.  
  
-   Podczas pracy z bazy danych ODBC i dużych zestawów dynamicznych, użytkownik może stwierdzić, że za pomocą operacji wyszukiwania jest powolne, szczególnie w przypadku pracy z dużych zestawów rekordów. Może poprawić wydajność przy użyciu zapytania SQL z dostosowane **ORDERBY** lub **gdzie** klauzule, parametr zapytania, lub **CDaoQuerydef** obiektów, które pobrać określonych indeksowane rekordów.  
  
 Powiązane informacje zobacz temat "FindNext FindFirst, FindLast, metody FindPrevious" w pomocy DAO.  
  
##  <a name="findnext"></a>  CDaoRecordset::FindNext  
 Wywołanie tej funkcji członkowskich można znaleźć dalej rekord, który pasuje określonego warunku.  
  
```  
BOOL FindNext(LPCTSTR lpszFilter);
```  
  
### <a name="parameters"></a>Parametry  
 `lpszFilter`  
 Wyrażenia ciągu (takich jak **gdzie** klauzuli w instrukcji SQL bez wyrazu **gdzie**) używane do lokalizowania rekordu.  
  
### <a name="return-value"></a>Wartość zwracana  
 Różna od zera, jeśli rekordy zostaną znalezione, w przeciwnym razie 0.  
  
### <a name="remarks"></a>Uwagi  
 `FindNext` Funkcji członkowskiej rozpoczyna się wyszukiwanie od bieżącego rekordu i wyszukuje na końcu zestawu rekordów.  
  
 Jeśli chcesz uwzględnić wszystkie rekordy w wyszukiwania (nie tylko te, które spełniają określony warunek) Aby użyć jednej z operacji przenoszenia przechodzenia z rekordami. Aby zlokalizować rekordu do zestawu rekordów typu tabeli, należy wywołać `Seek` funkcję elementu członkowskiego.  
  
 Jeśli rekord spełniających kryteria nie znajduje się, bieżący wskaźnik rekordu jest nieokreślona, i `FindNext` zwraca zero. Jeśli zestaw rekordów zawiera więcej niż jeden rekord, który spełnia kryteria, `FindFirst` znajduje pierwsze wystąpienie `FindNext` znajduje następne wystąpienie i tak dalej.  
  
> [!CAUTION]
>  Edytuj bieżącego rekordu, należy zapisać zmiany wywołując **aktualizacji** funkcji członkowskiej przed przejściem do innego rekordu. Jeśli przeniesienie do innego rekordu bez aktualizowania Twoje zmiany zostaną utracone bez ostrzeżenia.  
  
 Przy użyciu jednej z operacji wyszukiwania nie jest taka sama, co wywołanie **MoveFirst** lub `MoveNext`, jednak co po prostu czyni pierwszy lub następny rekord bieżący bez określania warunku. Można wykonać operacji wyszukiwania z operacji przenoszenia.  
  
 Przy użyciu operacji wyszukiwania, należy pamiętać o następujących:  
  
-   Jeśli **znaleźć** zwraca różną od zera, bieżący rekord nie jest zdefiniowany. W takim przypadku należy umieścić wskaźnik bieżącego rekordu wstecz do rekordu prawidłowe.  
  
-   Nie można używać operacji wyszukiwania przewijania typu migawka rekordów.  
  
-   Powinien mieć format daty Stanów Zjednoczonych (dzień miesiąc rok) podczas wyszukiwania dla pól zawierających daty, nawet jeśli nie używasz wersji US aparatu bazy danych programu Microsoft Jet; w przeciwnym razie pasujących rekordów nie można znaleźć.  
  
-   Podczas pracy z bazy danych ODBC i dużych zestawów dynamicznych, użytkownik może stwierdzić, że za pomocą operacji wyszukiwania jest powolne, szczególnie w przypadku pracy z dużych zestawów rekordów. Może poprawić wydajność przy użyciu zapytania SQL z dostosowane **ORDERBY** lub **gdzie** klauzule, parametr zapytania, lub **CDaoQuerydef** obiektów, które pobrać określonych indeksowane rekordów.  
  
 Powiązane informacje zobacz temat "FindNext FindFirst, FindLast, metody FindPrevious" w pomocy DAO.  
  
##  <a name="findprev"></a>  CDaoRecordset::FindPrev  
 Wywołanie tej funkcji członkowskich można odnaleźć poprzedniego rekordu odpowiadającego określonego warunku.  
  
```  
BOOL FindPrev(LPCTSTR lpszFilter);
```  
  
### <a name="parameters"></a>Parametry  
 `lpszFilter`  
 Wyrażenia ciągu (takich jak **gdzie** klauzuli w instrukcji SQL bez wyrazu **gdzie**) używane do lokalizowania rekordu.  
  
### <a name="return-value"></a>Wartość zwracana  
 Różna od zera, jeśli rekordy zostaną znalezione, w przeciwnym razie 0.  
  
### <a name="remarks"></a>Uwagi  
 `FindPrev` Funkcji członkowskiej rozpoczyna się wyszukiwanie od bieżącego rekordu i wyszukiwania do tyłu na początku zestawu rekordów.  
  
 Jeśli chcesz uwzględnić wszystkie rekordy w wyszukiwania (nie tylko te, które spełniają określony warunek) Aby użyć jednej z operacji przenoszenia przechodzenia z rekordami. Aby zlokalizować rekordu do zestawu rekordów typu tabeli, należy wywołać `Seek` funkcję elementu członkowskiego.  
  
 Jeśli rekord spełniających kryteria nie znajduje się, bieżący wskaźnik rekordu jest nieokreślona, i `FindPrev` zwraca zero. Jeśli zestaw rekordów zawiera więcej niż jeden rekord, który spełnia kryteria, `FindFirst` znajduje pierwsze wystąpienie `FindNext` znajduje następne wystąpienie i tak dalej.  
  
> [!CAUTION]
>  Edytuj bieżącego rekordu, należy zapisać zmiany wywołując **aktualizacji** funkcji członkowskiej przed przejściem do innego rekordu. Jeśli przeniesienie do innego rekordu bez aktualizowania Twoje zmiany zostaną utracone bez ostrzeżenia.  
  
 Przy użyciu jednej z operacji wyszukiwania nie jest taka sama, co wywołanie **MoveFirst** lub `MoveNext`, jednak co po prostu czyni pierwszy lub następny rekord bieżący bez określania warunku. Można wykonać operacji wyszukiwania z operacji przenoszenia.  
  
 Przy użyciu operacji wyszukiwania, należy pamiętać o następujących:  
  
-   Jeśli **znaleźć** zwraca różną od zera, bieżący rekord nie jest zdefiniowany. W takim przypadku należy umieścić wskaźnik bieżącego rekordu wstecz do rekordu prawidłowe.  
  
-   Nie można używać operacji wyszukiwania przewijania typu migawka rekordów.  
  
-   Powinien mieć format daty Stanów Zjednoczonych (dzień miesiąc rok) podczas wyszukiwania dla pól zawierających daty, nawet jeśli nie używasz wersji US aparatu bazy danych programu Microsoft Jet; w przeciwnym razie pasujących rekordów nie można znaleźć.  
  
-   Podczas pracy z bazy danych ODBC i dużych zestawów dynamicznych, użytkownik może stwierdzić, że za pomocą operacji wyszukiwania jest powolne, szczególnie w przypadku pracy z dużych zestawów rekordów. Może poprawić wydajność przy użyciu zapytania SQL z dostosowane **ORDERBY** lub **gdzie** klauzule, parametr zapytania, lub **CDaoQuerydef** obiektów, które pobrać określonych indeksowane rekordów.  
  
 Powiązane informacje zobacz temat "FindNext FindFirst, FindLast, metody FindPrevious" w pomocy DAO.  
  
##  <a name="getabsoluteposition"></a>  CDaoRecordset::GetAbsolutePosition  
 Zwraca numer bieżącego rekordu obiektu zestawu rekordów.  
  
```  
long GetAbsolutePosition();
```  
  
### <a name="return-value"></a>Wartość zwracana  
 Liczba całkowita z przedziału od 0 do liczby rekordów w zestawie rekordów. Odpowiada numerem porządkowym bieżącego rekordu w zestawie rekordów.  
  
### <a name="remarks"></a>Uwagi  
 Wartość właściwości AbsolutePosition obiekt DAO jest liczony od zera; wartość 0 oznacza pierwszy rekord w zestawie rekordów. Można określić liczbę wypełnione rekordy w zestawie rekordów przez wywołanie metody [GetRecordCount](#getrecordcount). Wywoływanie `GetRecordCount` może zająć trochę czasu, ponieważ muszą uzyskać dostęp do wszystkich rekordów, aby określić wartość licznika.  
  
 Jeśli nie istnieje bieżący rekord, jako gdy nie ma żadnych rekordów w zestawie rekordów, - 1, jest zwracany. Usunięcie bieżącego rekordu AbsolutePosition wartość właściwości nie została zdefiniowana, a MFC zgłasza wyjątek, jeśli odwołuje się do. Dla zestawów rekordów dynamicznego nowe rekordy są dodawane na końcu sekwencji.  
  
> [!NOTE]
>  Ta właściwość nie jest przeznaczony do użycia jako numer rekordu dwuskładnikowego. Zakładki są nadal zalecany sposób zachowania i zwracany do określonej pozycji i są jedynym sposobem na pozycji wszystkich typów rekordów obiekty dla bieżącego rekordu. W szczególności pozycja danego rekordu zostanie zmieniona podczas usuwania rekordów przed nim. Ponadto nie jest rekord ma to samo położenie bezwzględne Jeśli zestaw rekordów jest utworzony ponownie, ponieważ nie jest gwarantowana kolejność poszczególnych rekordów w zestawie rekordów, chyba że jest tworzony z instrukcji SQL przy użyciu  **ORDERBY** klauzuli.  
  
> [!NOTE]
>  Ta funkcja członkowska jest prawidłowy tylko w przypadku dynamicznego i zestawów rekordów typu migawka.  
  
 Powiązane informacje zobacz temat "AbsolutePosition Property" w pomocy DAO.  
  
##  <a name="getbookmark"></a>  CDaoRecordset::GetBookmark  
 Wywołanie tej funkcji Członkowskich do uzyskania wartości zakładkę do określonego rekordu.  
  
```  
COleVariant GetBookmark();
```  
  
### <a name="return-value"></a>Wartość zwracana  
 Zwraca wartość reprezentującą zakładki bieżącego rekordu.  
  
### <a name="remarks"></a>Uwagi  
 Podczas tworzenia lub otworzyć obiektu zestawu rekordów, każdego z jego rekordami ma już unikatowe zakładki jeśli je obsługuje. Wywołanie `CanBookmark` do ustalenia, czy zestaw rekordów obsługuje zakładki.  
  
 Można zapisać zakładki dla bieżącego rekordu, przypisując wartość zakładkę do `COleVariant` obiektu. Aby szybko powrócić do tego rekordu w dowolnym momencie po przeniesieniu do innego rekordu, należy wywołać `SetBookmark` z odpowiadającą wartości tego parametru `COleVariant` obiektu.  
  
> [!NOTE]
>  Wywoływanie [Requery](#requery) zmienia DAO zakładki.  
  
 Powiązane informacje zobacz temat "Właściwość zakładki" w pomocy DAO.  
  
##  <a name="getcachesize"></a>  CDaoRecordset::GetCacheSize  
 Wywołanie tej funkcji elementu członkowskiego w celu uzyskania liczby rekordów w pamięci podręcznej.  
  
```  
long GetCacheSize();
```  
  
### <a name="return-value"></a>Wartość zwracana  
 Wartość, która określa liczbę rekordów w zestawie rekordów dynamicznego zawierający dane lokalnie pamięci podręcznej ze źródła danych ODBC.  
  
### <a name="remarks"></a>Uwagi  
 Buforowanie danych zwiększa wydajność aplikacji, która pobiera dane z serwera zdalnego za pomocą dynamicznego zestawu rekordów obiektów. Pamięć podręczna jest spacja w lokalnej pamięci, która przechowuje dane ostatnio pobrana z serwera w przypadku, gdy dane będzie wymagane ponownie, gdy aplikacja jest uruchomiona. Po zażądaniu danych aparatu bazy danych programu Microsoft Jet pamięci podręcznej dla żądanych danych najpierw sprawdza zamiast pobierania jej z serwera, który zajmuje więcej czasu. Dane, które nie pochodzą ze źródła danych ODBC nie są zapisywane w pamięci podręcznej.  
  
 Wszystkie źródła danych ODBC, takich jak dołączonej tabeli może mieć lokalnej pamięci podręcznej.  
  
 Powiązane informacje zobacz temat "CacheSize właściwości CacheStart" w pomocy DAO.  
  
##  <a name="getcachestart"></a>  CDaoRecordset::GetCacheStart  
 Wywołanie tej funkcji Członkowskich do uzyskania wartości zakładki pierwszy rekord w zestawie rekordów w pamięci podręcznej.  
  
```  
COleVariant GetCacheStart();
```  
  
### <a name="return-value"></a>Wartość zwracana  
 A `COleVariant` określający zakładki pierwszy rekord w zestawie rekordów w pamięci podręcznej.  
  
### <a name="remarks"></a>Uwagi  
 Aparat bazy danych programu Microsoft Jet żądań rekordów w zakresie pamięci podręcznej z pamięci podręcznej i żądania rekordy poza zakresem pamięci podręcznej z serwera.  
  
> [!NOTE]
>  Rekordów pobieranych z pamięci podręcznej nie uwzględniają zmiany wprowadzone współbieżnie źródła danych przez innych użytkowników.  
  
 Powiązane informacje zobacz temat "CacheSize właściwości CacheStart" w pomocy DAO.  
  
##  <a name="getcurrentindex"></a>  CDaoRecordset::GetCurrentIndex  
 Wywołanie tej funkcji elementu członkowskiego, aby określić indeks aktualnie w użyciu indeksowanej tabeli `CDaoRecordset` obiektu.  
  
```  
CString GetCurrentIndex();
```  
  
### <a name="return-value"></a>Wartość zwracana  
 A `CString` zawierający nazwę indeksu obecnie w użyciu zestaw rekordów typu tabeli. Zwraca pusty ciąg, jeżeli nie ustawiono żadnych indeksu.  
  
### <a name="remarks"></a>Uwagi  
 Ten indeks stanowi podstawę do ustalania kolejności rekordy w zestawie rekordów typu tabeli i jest używany przez [wyszukiwania](#seek) funkcji członkowskiej można zlokalizować rekordów.  
  
 A `CDaoRecordset` obiekt może mieć więcej niż jednego indeksu, ale w danej chwili można używać tylko jeden indeks (mimo że [CDaoTableDef](../../mfc/reference/cdaotabledef-class.md) obiekt może mieć kilka indeksów zdefiniowanej).  
  
 Powiązane informacje zobacz temat "Indeksu obiektu", jak i definicja "bieżącego indeksu" w pomocy DAO.  
  
##  <a name="getdatecreated"></a>  CDaoRecordset::GetDateCreated  
 Wywołaj tę funkcję elementu członkowskiego, aby pobrać datę i godzinę utworzenia tabeli podstawowej.  
  
```  
COleDateTime GetDateCreated();
```  
  
### <a name="return-value"></a>Wartość zwracana  
 A [COleDateTime](../../atl-mfc-shared/reference/coledatetime-class.md) obiekt zawierający Data i godzina utworzenia tabeli podstawowej.  
  
### <a name="remarks"></a>Uwagi  
 Ustawienia daty i godziny są uzyskiwane z komputera, na którym utworzono tabeli podstawowej.  
  
 Powiązane informacje zobacz temat "DateCreated właściwości LastUpdated" w pomocy DAO.  
  
##  <a name="getdatelastupdated"></a>  CDaoRecordset::GetDateLastUpdated  
 Wywołanie tej funkcji Członkowskich pobrać datę i godzinę ostatniej aktualizacji schematu.  
  
```  
COleDateTime GetDateLastUpdated();
```  
  
### <a name="return-value"></a>Wartość zwracana  
 A [COleDateTime](../../atl-mfc-shared/reference/coledatetime-class.md) obiekt zawierający Data i godzina ostatniej aktualizacji tabeli podstawowej struktury (schemat).  
  
### <a name="remarks"></a>Uwagi  
 Ustawienia daty i godziny są uzyskiwane z komputera ostatniej aktualizacji tabeli podstawowej struktury (schemat).  
  
 Powiązane informacje zobacz temat "DateCreated właściwości LastUpdated" w pomocy DAO.  
  
##  <a name="getdefaultdbname"></a>  CDaoRecordset::GetDefaultDBName  
 Wywołanie tej funkcji członkowskich można określić nazwy bazy danych dla tego zestawu rekordów.  
  
```  
virtual CString GetDefaultDBName();
```  
  
### <a name="return-value"></a>Wartość zwracana  
 A `CString` zawiera ścieżkę i nazwę bazy danych, z którego pochodzi ten zestaw rekordów.  
  
### <a name="remarks"></a>Uwagi  
 Jeśli zestaw rekordów jest utworzony bez wskaźnik do [CDaoDatabase](../../mfc/reference/cdaodatabase-class.md), a następnie ta ścieżka jest używana przez zestaw rekordów, aby otworzyć domyślnej bazy danych. Domyślnie ta funkcja zwraca pusty ciąg. Gdy ClassWizard pochodzi nowy zestaw rekordów z `CDaoRecordset`, ta funkcja zostanie utworzony automatycznie.  
  
 Poniższy przykład przedstawia użycie podwójny ukośnik odwrotny (\\\\) w ciągu, w jakim są wymagane dla ciągu były prawidłowo interpretowane.  
  
 [!code-cpp[NVC_MFCDatabase#4](../../mfc/codesnippet/cpp/cdaorecordset-class_4.cpp)]  
  
##  <a name="getdefaultsql"></a>  CDaoRecordset::GetDefaultSQL  
 Struktura wywołuje tę funkcję elementu członkowskiego, aby pobrać domyślną instrukcję SQL, na której oparto zestawu rekordów.  
  
```  
virtual CString GetDefaultSQL();
```  
  
### <a name="return-value"></a>Wartość zwracana  
 A `CString` zawiera domyślną instrukcję SQL.  
  
### <a name="remarks"></a>Uwagi  
 Może to być nazwa tabeli lub SQL **wybierz** instrukcji.  
  
 Pośrednio zdefiniować domyślną instrukcję SQL od zadeklarowania klasy rekordów z ClassWizard i ClassWizard wykonuje to zadanie.  
  
 W przypadku przekazania pusty ciąg SQL do [Otwórz](#open), a następnie ta funkcja jest wywoływana w celu określenia nazwy tabeli lub SQL dla zestawu rekordów.  
  
##  <a name="geteditmode"></a>  CDaoRecordset::GetEditMode  
 Wywołanie funkcji członkowskiej można określić stanu elementu edycji, które jest jednym z następujących wartości:  
  
```  
short GetEditMode();
```  
  
### <a name="return-value"></a>Wartość zwracana  
 Zwraca wartość, która wskazuje stan edycji dla bieżącego rekordu.  
  
### <a name="remarks"></a>Uwagi  
  
|Wartość|Opis|  
|-----------|-----------------|  
|**dbEditNone**|Nie edycji jest operacja w toku.|  
|**dbEditInProgress**|**Edytuj** została wywołana.|  
|**dbEditAdd**|`AddNew` została wywołana.|  
  
 Powiązane informacje zobacz temat "EditMode Property" w pomocy DAO.  
  
##  <a name="getfieldcount"></a>  CDaoRecordset::GetFieldCount  
 Wywołaj tę funkcję elementu członkowskiego, aby pobrać liczbę pola (kolumny) zdefiniowane w zestawie rekordów.  
  
```  
short GetFieldCount();
```  
  
### <a name="return-value"></a>Wartość zwracana  
 Liczba pól w zestawie rekordów.  
  
### <a name="remarks"></a>Uwagi  
 Powiązane informacje zobacz temat "Właściwość Count" w pomocy DAO.  
  
##  <a name="getfieldinfo"></a>  CDaoRecordset::GetFieldInfo  
 Wywołanie tej funkcji członkowskich można uzyskać informacji o polach w zestawie rekordów.  
  
```  
void GetFieldInfo(
    int nIndex,  
    CDaoFieldInfo& fieldinfo,  
    DWORD dwInfoOptions = AFX_DAO_PRIMARY_INFO);

 
void GetFieldInfo(
    LPCTSTR lpszName,  
    CDaoFieldInfo& fieldinfo,  
    DWORD dwInfoOptions = AFX_DAO_PRIMARY_INFO);
```  
  
### <a name="parameters"></a>Parametry  
 `nIndex`  
 Liczony od zera indeks wstępnie zdefiniowanego pola w kolekcji pól zestawu rekordów, wyszukiwanie według indeksu.  
  
 `fieldinfo`  
 Odwołanie do [cdaofieldinfo —](../../mfc/reference/cdaofieldinfo-structure.md) struktury.  
  
 `dwInfoOptions`  
 Opcje, które określają, które informacje dotyczące rekordów do pobrania. Dostępne opcje są wyświetlane tutaj wraz z co spowodują one funkcji do zwrócenia. Aby uzyskać najlepszą wydajność należy pobrać tylko poziom potrzebne informacje:  
  
- `AFX_DAO_PRIMARY_INFO` (Ustawienie domyślne) Nazwa, typ, rozmiar, atrybuty  
  
- `AFX_DAO_SECONDARY_INFO` Podstawowe informacje plus: numer pozycji, wymagane, Zezwalaj tabeli źródłowej zerowej długości, kolejność sortowania, obcego Nazwa pola źródła  
  
- `AFX_DAO_ALL_INFO` Informacje o podstawowych i pomocniczych, plus: tekst sprawdzania poprawności domyślna wartość reguły walidacji  
  
 `lpszName`  
 Nazwa pola.  
  
### <a name="remarks"></a>Uwagi  
 Jedna wersja funkcji umożliwia pole wyszukiwania według indeksu. Druga wersja umożliwia wyszukiwania według nazwy pola.  
  
 Aby uzyskać opis zwracanych informacji, zobacz [cdaofieldinfo —](../../mfc/reference/cdaofieldinfo-structure.md) struktury. Ta struktura ma elementów członkowskich, które odpowiadają informacje wymienione powyżej w opisie `dwInfoOptions`. Gdy użytkownik żąda informacji o jeden poziom, można pobrać informacji o żadnych poprzednich poziomach.  
  
 Powiązane informacje zobacz temat "Właściwość Attributes" w pomocy DAO.  
  
##  <a name="getfieldvalue"></a>  CDaoRecordset::GetFieldValue  
 Wywołanie tej funkcji Członkowskich do pobierania danych w zestawie rekordów.  
  
```  
virtual void GetFieldValue(
    LPCTSTR lpszName,  
    COleVariant& varValue);

 
virtual void GetFieldValue(
    int nIndex,  
    COleVariant& varValue);
 
virtual COleVariant GetFieldValue(LPCTSTR lpszName); 
virtual COleVariant GetFieldValue(int nIndex);
```  
  
### <a name="parameters"></a>Parametry  
 `lpszName`  
 Wskaźnik do ciąg znaków zawierający nazwę pola.  
  
 `varValue`  
 Odwołanie do `COleVariant` obiektu, w którym będą przechowywane wartości pola.  
  
 `nIndex`  
 Liczony od zera indeks pola w kolekcji pól zestawu rekordów, wyszukiwanie według indeksu.  
  
### <a name="return-value"></a>Wartość zwracana  
 Dwie wersje `GetFieldValue` , które zwracają wartość zwracany [COleVariant](../../mfc/reference/colevariant-class.md) obiekt, który zawiera wartości pola.  
  
### <a name="remarks"></a>Uwagi  
 Pola można wyszukiwać według nazwy lub porządkowym.  
  
> [!NOTE]
>  Jest bardziej wydajne do wywołania, jeden z tej funkcji elementu członkowskiego, który przyjmuje `COleVariant` obiekt odwołania jako parametru, zamiast wywoływania wersji, która zwraca `COleVariant` obiektu. Ostatnie wersje tej funkcji są przechowywane dla zgodności z poprzednimi wersjami.  
  
 Użyj `GetFieldValue` i [SetFieldValue](#setfieldvalue) dynamicznie powiązać pola w czasie wykonywania, a nie statycznie powiązanie kolumn za pomocą [DoFieldExchange](#dofieldexchange) mechanizmu.  
  
 `GetFieldValue` i `DoFieldExchange` mechanizmu można łączyć, aby zwiększyć wydajność. Na przykład użyć `GetFieldValue` do pobierania wartości, które są potrzebne tylko na żądanie i przypisz tego wywołania na przycisk "Więcej informacji" w interfejsie.  
  
 Powiązane informacje zobacz tematy "Pola obiektu" i "Wartość właściwości" w pomocy DAO.  
  
##  <a name="getindexcount"></a>  CDaoRecordset::GetIndexCount  
 Wywołanie tej funkcji Członkowskich, aby określić liczbę indeksów dostępne w zestawie rekordów typu tabeli.  
  
```  
short GetIndexCount();
```  
  
### <a name="return-value"></a>Wartość zwracana  
 Liczba indeksów w zestawie rekordów typu tabeli.  
  
### <a name="remarks"></a>Uwagi  
 `GetIndexCount` jest przydatne w przypadku wszystkich indeksów w zestawie rekordów w pętli. W tym celu użyj `GetIndexCount` w połączeniu z [GetIndexInfo](#getindexinfo). Wywołanie funkcji członkowskiej na dynamicznego lub zestawów rekordów typu migawka, MFC zgłasza wyjątek.  
  
 Powiązane informacje zobacz temat "Właściwość Attributes" w pomocy DAO.  
  
##  <a name="getindexinfo"></a>  CDaoRecordset::GetIndexInfo  
 Wywołanie tej funkcji Członkowskich uzyskać różne rodzaje informacji na temat indeksu zdefiniowany w tabeli bazowej podstawowy zestaw rekordów.  
  
```  
void GetIndexInfo(
    int nIndex,  
    CDaoIndexInfo& indexinfo,  
    DWORD dwInfoOptions = AFX_DAO_PRIMARY_INFO);

 
void GetIndexInfo(
    LPCTSTR lpszName,  
    CDaoIndexInfo& indexinfo,  
    DWORD dwInfoOptions = AFX_DAO_PRIMARY_INFO);
```  
  
### <a name="parameters"></a>Parametry  
 `nIndex`  
 Liczony od zera indeks w kolekcji indeksów tabeli, wyszukiwanie według położenia wartości liczbowych.  
  
 `indexinfo`  
 Odwołanie do [cdaoindexinfo —](../../mfc/reference/cdaoindexinfo-structure.md) struktury.  
  
 `dwInfoOptions`  
 Opcje, które określają, które informacje o indeksie do pobrania. Dostępne opcje są wyświetlane tutaj wraz z co spowodują one funkcji do zwrócenia. Aby uzyskać najlepszą wydajność należy pobrać tylko poziom potrzebne informacje:  
  
- `AFX_DAO_PRIMARY_INFO` (Ustawienie domyślne) Pola Nazwa pola informacji,  
  
- `AFX_DAO_SECONDARY_INFO` Podstawowe informacje plus: podstawowej, Unique, klastra, IgnoreNulls wymagane, obcy  
  
- `AFX_DAO_ALL_INFO` Informacje o podstawowych i pomocniczych plus: liczności unikatowych wartości  
  
 `lpszName`  
 Wskaźnik na nazwę obiektu indeksu wyszukiwania według nazwy.  
  
### <a name="remarks"></a>Uwagi  
 Jedna wersja funkcji umożliwia wyszukiwanie indeksu za pomocą jego pozycji w kolekcji. Druga wersja pozwala indeksu wyszukiwania według nazwy.  
  
 Aby uzyskać opis zwracanych informacji, zobacz [cdaoindexinfo —](../../mfc/reference/cdaoindexinfo-structure.md) struktury. Ta struktura ma elementów członkowskich, które odpowiadają informacje wymienione powyżej w opisie `dwInfoOptions`. Gdy użytkownik żąda informacji o jeden poziom, można pobrać informacji o żadnych poprzednich poziomach.  
  
 Powiązane informacje zobacz temat "Właściwość Attributes" w pomocy DAO.  
  
##  <a name="getlastmodifiedbookmark"></a>  CDaoRecordset::GetLastModifiedBookmark  
 Wywołanie tej funkcji Członkowskich pobrać zakładki rekordu najbardziej ostatnio dodane lub zaktualizowane.  
  
```  
COleVariant GetLastModifiedBookmark();
```  
  
### <a name="return-value"></a>Wartość zwracana  
 A `COleVariant` zawierające zakładki, która wskazuje ostatnio dodane lub zmienione rekordu.  
  
### <a name="remarks"></a>Uwagi  
 Podczas tworzenia lub otworzyć obiektu zestawu rekordów, każdego z jego rekordami ma już unikatowe zakładki jeśli je obsługuje. Wywołanie [GetBookmark](#getbookmark) do określenia, czy zestaw rekordów obsługuje zakładki. Jeśli zestaw rekordów obsługuje zakładki, `CDaoException` jest generowany.  
  
 Po dodaniu rekordu pojawia się na końcu zestawu rekordów, a nie jest bieżącego rekordu. Aby wprowadzić nowy rekord bieżący, należy wywołać `GetLastModifiedBookmark` , a następnie wywołać `SetBookmark` aby powrócić do nowo dodanego rekordu.  
  
 Powiązane informacje zobacz temat "LastModified Property" w pomocy DAO.  
  
##  <a name="getlockingmode"></a>  CDaoRecordset::GetLockingMode  
 Wywołanie tej funkcji Członkowskich w celu określenia typu w celu blokowania zestawu rekordów.  
  
```  
BOOL GetLockingMode();
```  
  
### <a name="return-value"></a>Wartość zwracana  
 Różna od zera, jeśli typ blokowania jest pesymistyczne, w przeciwnym razie 0 dla rekordu optymistyczne blokowanie.  
  
### <a name="remarks"></a>Uwagi  
 Gdy pesymistyczne blokowanie jest aktywna, strony danych zawierającego rekord edytujesz jest zablokowany, jak należy wywołać [Edytuj](#edit) funkcję elementu członkowskiego. Strona jest odblokowany, podczas wywoływania [aktualizacji](#update) lub [Zamknij](#close) funkcji członkowskiej lub dowolnych operacji przenoszenia lub Znajdź.  
  
 Gdy optymistyczne blokowanie jest włączona, strona danych zawierająca rekord jest zablokowany tylko wtedy, gdy rekord jest aktualizowany przy użyciu **aktualizacji** funkcję elementu członkowskiego.  
  
 Podczas pracy ze źródłami danych ODBC, tryb blokowania jest zawsze optymistycznej.  
  
 Aby uzyskać odpowiednie informacje zobacz tematy "LockEdits Property" i "Blokowania zachowanie w wielodostępnego aplikacji" w pomocy DAO.  
  
##  <a name="getname"></a>  CDaoRecordset::GetName  
 Wywołanie tej funkcji Członkowskich pobrać nazwy zestawu rekordów.  
  
```  
CString GetName();
```  
  
### <a name="return-value"></a>Wartość zwracana  
 A `CString` zawierającą nazwę zestawu rekordów.  
  
### <a name="remarks"></a>Uwagi  
 Nazwa zestawu rekordów musi rozpoczynać się od litery i może zawierać maksymalnie 40 znaków. Może zawierać cyfry i znaki podkreślenia, ale nie może zawierać znaków interpunkcyjnych i spacji.  
  
 Aby uzyskać odpowiednie informacje zobacz temat "Właściwości Name" w pomocy DAO.  
  
##  <a name="getparamvalue"></a>  CDaoRecordset::GetParamValue  
 Wywołanie tej funkcji Członkowskich pobrać bieżącą wartość określony parametr przechowywane w obiekcie źródłowym zostały DAOParameter.  
  
```  
virtual COleVariant GetParamValue(int nIndex);  
virtual COleVariant GetParamValue(LPCTSTR lpszName);
```  
  
### <a name="parameters"></a>Parametry  
 `nIndex`  
 Numeryczne pozycja parametru DAOParameter obiektu źródłowego.  
  
 `lpszName`  
 Nazwa parametru, którego wartość ma.  
  
### <a name="return-value"></a>Wartość zwracana  
 Obiekt klasy [COleVariant](../../mfc/reference/colevariant-class.md) zawierający wartości parametru.  
  
### <a name="remarks"></a>Uwagi  
 Według nazwy lub jej numeryczny pozycji w kolekcji można uzyskać dostępu do parametru.  
  
 Powiązane informacje zobacz temat "Obiektu Parameter" w pomocy DAO.  
  
##  <a name="getpercentposition"></a>  CDaoRecordset::GetPercentPosition  
 Podczas pracy z dynamicznego lub zestaw rekordów typu migawka, jeśli wywołujesz `GetPercentPosition` przed pełni wypełnianie zestawu rekordów, wielkość ruchu jest określana względem to liczba rekordów dostęp do określonych przez wywołanie metody [GetRecordCount](#getrecordcount).  
  
```  
float GetPercentPosition();
```  
  
### <a name="return-value"></a>Wartość zwracana  
 Liczbą z zakresu od 0 do 100, która wskazuje przybliżonej lokalizacji bieżącego rekordu w obiekcie rekordów procentem rekordy w zestawie rekordów.  
  
### <a name="remarks"></a>Uwagi  
 Można przenieść do ostatniego rekordu przez wywołanie metody [MoveLast](#movelast) do pełnej populacji wszystkie zestawy rekordów, ale może zająć dużo czasu.  
  
 Możesz wywołać `GetPercentPosition` na wszystkie trzy typy obiektów zestawu rekordów, w tym tabel bez indeksów. Jednak nie można wywołać `GetPercentPosition` tylko do przodu migawki przewijania lub zestawu rekordów otwarty z przekazujący zapytanie zewnętrznej bazy danych. Jeśli nie istnieje bieżący rekord lub he bieżący rekord został usunięty, `CDaoException` jest generowany.  
  
 Powiązane informacje zobacz temat "PercentPosition Property" w pomocy DAO.  
  
##  <a name="getrecordcount"></a>  CDaoRecordset::GetRecordCount  
 Wywołanie tej funkcji członkowskiej, aby dowiedzieć się, uzyskiwały ile rekordy w zestawie rekordów.  
  
```  
long GetRecordCount();
```  
  
### <a name="return-value"></a>Wartość zwracana  
 Zwraca liczbę rekordów dostępne w obiekcie zestawu rekordów.  
  
### <a name="remarks"></a>Uwagi  
 `GetRecordCount` wskazuje liczbę rekordów są zawarte w dynamicznego lub zestaw rekordów typu migawka, dopóki dostęp do wszystkich rekordów. To wywołanie funkcji Członkowskich może zająć dużo czasu.  
  
 Po uzyskaniu ostatniego rekordu wartości zwracanej wskazuje całkowita liczba rekordów cofnąć usunięcia w zestawie rekordów. Aby wymusić ostatni rekord, aby można było uzyskać dostęp, należy wywołać `MoveLast` lub `FindLast` funkcji członkowskiej zestawu rekordów. Liczba SQL umożliwia również określić przybliżoną liczbę rekordów, które zwraca zapytanie.  
  
 Jak aplikacja usuwa rekordy w zestawie rekordów dynamicznego, zwracana wartość `GetRecordCount` zmniejsza. Jednak rekordy zostały usunięte przez innych użytkowników nie są uwzględniane przy `GetRecordCount` aż do bieżącego rekordu znajduje się na usunięty rekord. Jeśli wykonaj transakcję, która wpływa na liczbę rekordów, a następnie Wycofaj tę transakcję `GetRecordCount` nie zostaną one zastosowane rzeczywista liczba pozostałych rekordów.  
  
 Wartość `GetRecordCount` z zestawu rekordów typu migawka nie ma wpływu na zmiany w tabeli.  
  
 Wartość `GetRecordCount` z typem tabeli zestaw rekordów odzwierciedla przybliżoną liczbę rekordów w tabeli i ma to wpływ na natychmiast wraz z dodawaniem i usunąć rekordy tabeli.  
  
 Zestaw rekordów o żadne rekordy nie zwraca wartość 0. Podczas pracy z dołączonymi tabelami lub baz danych ODBC `GetRecordCount` zawsze zwraca wartość - 1. Wywoływanie **Requery** funkcji członkowskiej w zestawie rekordów resetuje wartości `GetRecordCount` tak, jakby były ponowne wykonanie kwerendy.  
  
 Powiązane informacje zobacz temat "RecordCount Property" w pomocy DAO.  
  
##  <a name="getsql"></a>  CDaoRecordset::GetSQL  
 Wywołanie tej funkcji Członkowskich uzyskanie instrukcji SQL, którego użyto do wybierania rekordów w zestawie rekordów, gdy została otwarta.  
  
```  
CString GetSQL() const;  
```  
  
### <a name="return-value"></a>Wartość zwracana  
 A `CString` zawiera instrukcję SQL.  
  
### <a name="remarks"></a>Uwagi  
 Są to zazwyczaj SQL **wybierz** instrukcji.  
  
 Długość ciągu zwróconego przez `GetSQL` zwykle różni się od dowolnego ciągu może przekazano do zestawu rekordów w `lpszSQL` parametr [Otwórz](#open) funkcję elementu członkowskiego. Jest to spowodowane zestawu rekordów tworzy pełną instrukcję SQL oparte na przekazany do **Otwórz**określona z ClassWizard i co określono w [m_strFilter](#m_strfilter) i [m_strSort](#m_strsort) elementy członkowskie danych.  
  
> [!NOTE]
>  Wywołanie tej funkcji Członkowskich tylko po wywołaniu **Otwórz**.  
  
 Powiązane informacje zobacz temat "SQL Property" w pomocy DAO.  
  
##  <a name="gettype"></a>  CDaoRecordset::GetType  
 Wywołanie tej funkcji Członkowskich po otwarciu zestawu rekordów, można określić typu obiektu zestawu rekordów.  
  
```  
short GetType();
```  
  
### <a name="return-value"></a>Wartość zwracana  
 Jedna z następujących wartości, które wskazuje typ zestaw rekordów:  
  
- **dbOpenTable** zestaw rekordów typu tabeli  
  
- **dbOpenDynaset** dynamicznego zestawu rekordów  
  
- **dbOpenSnapshot** zestaw rekordów typu migawka  
  
### <a name="remarks"></a>Uwagi  
 Powiązane informacje zobacz temat "Właściwość Type" w pomocy DAO.  
  
##  <a name="getvalidationrule"></a>  CDaoRecordset::GetValidationRule  
 Wywołanie tej funkcji Członkowskich, aby ustalić reguły używane do sprawdzania poprawności danych.  
  
```  
CString GetValidationRule();
```  
  
### <a name="return-value"></a>Wartość zwracana  
 A `CString` obiektu zawierającego wartość, która sprawdza poprawność danych rekordu, ponieważ jest zmienione lub dodane do tabeli.  
  
### <a name="remarks"></a>Uwagi  
 Ta zasada jest oparta na tekst i jest stosowany na każdym razem, gdy zostanie zmieniona w tabeli podstawowej. Jeśli dane jest niedozwolona, MFC zgłasza wyjątek. Komunikat zwrócony kod błędu jest tekst pola obiektu podstawowego, jeśli określona właściwość komunikat lub tekst wyrażenia określonego przez właściwość ValidationRule obiektu podstawowego pola. Możesz wywołać [GetValidationText](#getvalidationtext) uzyskać tekst komunikatu o błędzie.  
  
 Na przykład pola w rekordzie wymaga dzień miesiąca może istnieć reguła sprawdzania poprawności takich jak "BETWEEN dnia 1 do 31."  
  
 Powiązane informacje zobacz temat "ValidationRule Property" w pomocy DAO.  
  
##  <a name="getvalidationtext"></a>  CDaoRecordset::GetValidationText  
 Wywołanie tej funkcji Członkowskich pobrać tekst właściwości komunikat obiektu podstawowego pola.  
  
```  
CString GetValidationText();
```  
  
### <a name="return-value"></a>Wartość zwracana  
 A `CString` obiekt zawierający tekst wiadomości, która jest wyświetlana, jeśli wartość pola nie spełnia warunków reguły sprawdzania poprawności obiektu podstawowego pola.  
  
### <a name="remarks"></a>Uwagi  
 Powiązane informacje zobacz temat "Komunikat Property" w pomocy DAO.  
  
##  <a name="isbof"></a>  CDaoRecordset::IsBOF  
 Wywołanie funkcji członkowskiej przed przewiń z rekordu do rekordu, aby dowiedzieć się czy przeszły przed pierwszy rekord zestawu rekordów.  
  
```  
BOOL IsBOF() const;  
```  
  
### <a name="return-value"></a>Wartość zwracana  
 Różna od zera, jeśli zestaw nie zawiera żadnych rekordów lub jeśli były przewijane wstecz przed pierwszy rekord. w przeciwnym razie 0.  
  
### <a name="remarks"></a>Uwagi  
 Możesz także wywołać `IsBOF` wraz z programem `IsEOF` czy zestaw rekordów zawiera rekordy, czy jest pusta. Natychmiast po wywołaniu metody **Otwórz**, jeśli zestaw nie zawiera żadnych rekordów `IsBOF` zwraca różną od zera. Po otwarciu rekordów, który ma co najmniej jeden rekord pierwszy rekord jest bieżącego rekordu i `IsBOF` zwraca wartość 0.  
  
 Jeśli pierwszy rekord jest bieżącego rekordu i wywołania `MovePrev`, `IsBOF` następnie zwróci różną od zera. Jeśli `IsBOF` zwraca różną od zera i można wywołać `MovePrev`, jest zgłaszany wyjątek. Jeśli `IsBOF` zwraca różną od zera, bieżący rekord jest niezdefiniowany i dowolną akcję, która wymaga bieżącego rekordu, spowodują wyjątek.  
  
 Efekt określonych metod `IsBOF` i `IsEOF` ustawienia:  
  
-   Wywoływanie **Otwórz** wewnętrznie sprawia, że pierwszy rekord w zestawie rekordów bieżącego rekordu przez wywołanie metody **MoveFirst**. W związku z tym wywołaniem **Otwórz** na pusty zestaw rekordów przyczyny `IsBOF` i `IsEOF` do zwrócenia różną od zera. (Zobacz poniższą tabelę dla zachowania nieudanej **MoveFirst** lub `MoveLast` wywołań.)  
  
-   Wszystkie operacje przenoszenia, które pomyślnie Zlokalizuj rekord spowodować zarówno `IsBOF` i `IsEOF` do zwrócenia 0.  
  
-   `AddNew` Następuje wywołanie **aktualizacji** spowoduje wywołanie, które pomyślnie Wstawia nowy rekord `IsBOF` do zwrócenia 0, ale tylko wtedy, gdy `IsEOF` już jest różna od zera. Stan `IsEOF` zawsze pozostają bez zmian. Zdefiniowane przez aparat bazy danych programu Microsoft Jet bieżący wskaźnik rekord pusty zestaw rekordów jest na końcu pliku, tak po bieżącego rekordu dodaje żadnych nowych rekordów.  
  
-   Wszelkie **usunąć** wywołanie, nawet jeśli spowoduje usunięcie tylko pozostałych rekordów z zestawu rekordów, nie zmieni wartość `IsBOF` lub `IsEOF`.  
  
 W poniższej tabeli przedstawiono operacje przenoszenia dozwolone z różną kombinacją możliwości `IsBOF` /  `IsEOF`.  
  
||MoveFirst, MoveLast|MovePrev,<br /><br /> Przenieś < 0|Przenieś 0|MoveNext,<br /><br /> Przenieś > 0.|  
|------|-------------------------|-----------------------------|------------|-----------------------------|  
|`IsBOF`= różną od zera,<br /><br /> `IsEOF`=0|Dozwolone|Wyjątek|Wyjątek|Dozwolone|  
|`IsBOF`=0,<br /><br /> `IsEOF`= różną od zera|Dozwolone|Dozwolone|Wyjątek|Wyjątek|  
|Zarówno różną od zera|Wyjątek|Wyjątek|Wyjątek|Wyjątek|  
|Zarówno 0|Dozwolone|Dozwolone|Dozwolone|Dozwolone|  
  
 Stosowanie operacji przenoszenia nie oznacza operacji pomyślnie zlokalizuje rekordu. Wskazuje on jedynie, że próba wykonania określonej operacji przenoszenia jest dozwolone i nie zostanie wygenerowany wyjątek. Wartość `IsBOF` i `IsEOF` funkcje Członkowskie mogą ulec zmianie w wyniku próby przeniesienia.  
  
 Wpływ operacji przenoszenia, których nie można odnaleźć rekordu na wartość `IsBOF` i `IsEOF` ustawienia przedstawiono w poniższej tabeli.  
  
||IsBOF|IsEOF|  
|------|-----------|-----------|  
|**MoveFirst**, `MoveLast`|Różna od zera|Różna od zera|  
|**Przenieś** 0|Brak zmian|Brak zmian|  
|`MovePrev`, **Przenieś** < 0|Różna od zera|Brak zmian|  
|`MoveNext`, **Przenieś** > 0.|Brak zmian|Różna od zera|  
  
 Aby uzyskać odpowiednie informacje, zobacz temat "BOF, właściwości EOF" w pomocy DAO.  
  
##  <a name="isdeleted"></a>  CDaoRecordset::IsDeleted  
 Wywołanie tej funkcji Członkowskich, aby określić, czy bieżący rekord został usunięty.  
  
```  
BOOL IsDeleted() const;  
```  
  
### <a name="return-value"></a>Wartość zwracana  
 Różna od zera, jeśli zestaw rekordów jest ustawiony na usunięty rekord; w przeciwnym razie 0.  
  
### <a name="remarks"></a>Uwagi  
 Jeśli przewiń do rekordu i `IsDeleted` zwraca **TRUE** (niezerowej), następnie należy przewijania do innego rekordu przed wykonaniem innych operacji w zestawie rekordów.  
  
> [!NOTE]
>  Nie trzeba sprawdzić stan usunięte rekordy w zestawie rekordów migawki lub typ tabeli. Ponieważ nie można usunąć rekordów z migawki, nie jest konieczne do wywołania `IsDeleted`. Dla zestawów rekordów typu tabeli usuniętych rekordów faktycznie są usuwane z tego zestawu rekordów. Gdy rekord został usunięty, przez Ciebie innego użytkownika lub w innym rekordów nie przewiń do tego rekordu. W związku z tym nie istnieje potrzeba do wywołania `IsDeleted`.  
  
 Podczas usuwania rekordu z dynamiczny, zostanie ono usunięte z tego zestawu rekordów, a nie przewiń do rekordu. Jeśli rekord w dynamiczny jest usunięte przez innego użytkownika lub innego zestawu rekordów w oparciu o tej samej tabeli `IsDeleted` zwróci **TRUE** po później przewijania do tego rekordu.  
  
 Aby uzyskać odpowiednie informacje zobacz tematy "Metody Delete", "LastModified Property" i "EditMode Property" w pomocy DAO.  
  
##  <a name="iseof"></a>  CDaoRecordset::IsEOF  
 Wywołanie funkcji członkowskiej przewijania z rekordu do rekordu, aby dowiedzieć się czy przeszły poza ostatni rekord zestawu rekordów.  
  
```  
BOOL IsEOF() const;  
```  
  
### <a name="return-value"></a>Wartość zwracana  
 Różna od zera, jeśli zestaw nie zawiera żadnych rekordów lub jeśli były przewijane poza ostatni rekord; w przeciwnym razie 0.  
  
### <a name="remarks"></a>Uwagi  
 Możesz także wywołać `IsEOF` czy zestaw rekordów zawiera rekordy, czy jest pusta. Natychmiast po wywołaniu metody **Otwórz**, jeśli zestaw nie zawiera żadnych rekordów `IsEOF` zwraca różną od zera. Po otwarciu rekordów, który ma co najmniej jeden rekord pierwszy rekord jest bieżącego rekordu i `IsEOF` zwraca wartość 0.  
  
 Jeśli ostatni rekord jest bieżącego rekordu podczas wywoływania `MoveNext`, `IsEOF` następnie zwróci różną od zera. Jeśli `IsEOF` zwraca różną od zera i można wywołać `MoveNext`, jest zgłaszany wyjątek. Jeśli `IsEOF` zwraca różną od zera, bieżący rekord jest niezdefiniowany i dowolną akcję, która wymaga bieżącego rekordu, spowodują wyjątek.  
  
 Efekt określonych metod `IsBOF` i `IsEOF` ustawienia:  
  
-   Wywoływanie **Otwórz** wewnętrznie sprawia, że pierwszy rekord w zestawie rekordów bieżącego rekordu przez wywołanie metody **MoveFirst**. W związku z tym wywołaniem **Otwórz** na pusty zestaw rekordów przyczyny `IsBOF` i `IsEOF` do zwrócenia różną od zera. (Zobacz poniższą tabelę dla zachowania nieudanej **MoveFirst** wywołań.)  
  
-   Wszystkie operacje przenoszenia, które pomyślnie Zlokalizuj rekord spowodować zarówno `IsBOF` i `IsEOF` do zwrócenia 0.  
  
-   `AddNew` Następuje wywołanie **aktualizacji** spowoduje wywołanie, które pomyślnie Wstawia nowy rekord `IsBOF` do zwrócenia 0, ale tylko wtedy, gdy `IsEOF` już jest różna od zera. Stan `IsEOF` zawsze pozostają bez zmian. Zdefiniowane przez aparat bazy danych programu Microsoft Jet bieżący wskaźnik rekord pusty zestaw rekordów jest na końcu pliku, tak po bieżącego rekordu dodaje żadnych nowych rekordów.  
  
-   Wszelkie **usunąć** wywołanie, nawet jeśli spowoduje usunięcie tylko pozostałych rekordów z zestawu rekordów, nie zmieni wartość `IsBOF` lub `IsEOF`.  
  
 W poniższej tabeli przedstawiono operacje przenoszenia dozwolone z różną kombinacją możliwości `IsBOF` /  `IsEOF`.  
  
||MoveFirst, MoveLast|MovePrev,<br /><br /> Przenieś < 0|Przenieś 0|MoveNext,<br /><br /> Przenieś > 0.|  
|------|-------------------------|-----------------------------|------------|-----------------------------|  
|`IsBOF`= różną od zera,<br /><br /> `IsEOF`=0|Dozwolone|Wyjątek|Wyjątek|Dozwolone|  
|`IsBOF`=0,<br /><br /> `IsEOF`= różną od zera|Dozwolone|Dozwolone|Wyjątek|Wyjątek|  
|Zarówno różną od zera|Wyjątek|Wyjątek|Wyjątek|Wyjątek|  
|Zarówno 0|Dozwolone|Dozwolone|Dozwolone|Dozwolone|  
  
 Stosowanie operacji przenoszenia nie oznacza operacji pomyślnie zlokalizuje rekordu. Wskazuje on jedynie, że próba wykonania określonej operacji przenoszenia jest dozwolone i nie zostanie wygenerowany wyjątek. Wartość `IsBOF` i `IsEOF` funkcje Członkowskie mogą ulec zmianie w wyniku próby przeniesienia.  
  
 Wpływ operacji przenoszenia, których nie można odnaleźć rekordu na wartość `IsBOF` i `IsEOF` ustawienia przedstawiono w poniższej tabeli.  
  
||IsBOF|IsEOF|  
|------|-----------|-----------|  
|**MoveFirst**, `MoveLast`|Różna od zera|Różna od zera|  
|**Przenieś** 0|Brak zmian|Brak zmian|  
|`MovePrev`, **Przenieś** < 0|Różna od zera|Brak zmian|  
|`MoveNext`, **Przenieś** > 0.|Brak zmian|Różna od zera|  
  
 Aby uzyskać odpowiednie informacje, zobacz temat "BOF, właściwości EOF" w pomocy DAO.  
  
##  <a name="isfielddirty"></a>  CDaoRecordset::IsFieldDirty  
 Wywołanie tej funkcji elementu członkowskiego, aby określić, czy element członkowski danych określonego pola z dynamicznego zostały oznaczone jako "zakłóconych" (zmienić).  
  
```  
BOOL IsFieldDirty(void* pv);
```  
  
### <a name="parameters"></a>Parametry  
 `pv`  
 Wskaźnik do elementu danych pola, których stan chcesz sprawdzić, lub **NULL** ustalenie, czy dowolna z pól jest zanieczyszczony.  
  
### <a name="return-value"></a>Wartość zwracana  
 Różna od zera, jeśli element członkowski danych określone pole jest oznaczony jako zakłócone; w przeciwnym razie 0.  
  
### <a name="remarks"></a>Uwagi  
 Dane w wszystkie elementy członkowskie danych pola z zanieczyszczeniu zostanie przeniesiona do rekordu w źródle danych podczas aktualizacji przez wywołanie do bieżącego rekordu **aktualizacji** funkcji członkowskiej klasy `CDaoRecordset` (po wywołaniu **Edytuj**lub `AddNew`). Z tym wiedzy, możesz wykonać dalsze czynności, takie jak unflagging element członkowski danych pola, aby oznaczyć kolumny, więc nie można zapisać w źródle danych.  
  
 `IsFieldDirty` jest implementowane za pośrednictwem `DoFieldExchange`.  
  
##  <a name="isfieldnull"></a>  CDaoRecordset::IsFieldNull  
 Wywołanie tej funkcji elementu członkowskiego, aby określić, czy element członkowski danych określonego pola rekordów zostały oznaczone jako wartość Null.  
  
```  
BOOL IsFieldNull(void* pv);
```  
  
### <a name="parameters"></a>Parametry  
 `pv`  
 Wskaźnik do elementu danych pola, których stan chcesz sprawdzić, lub **NULL** ustalenie, czy dowolna z pola jest Null.  
  
### <a name="return-value"></a>Wartość zwracana  
 Różna od zera, jeśli element członkowski danych określone pole jest oznaczony jako wartość Null; w przeciwnym razie 0.  
  
### <a name="remarks"></a>Uwagi  
 (W terminologii bazy danych o wartości Null oznacza, że "o wartości" i nie jest taka sama jak **NULL** w języku C++.) Element członkowski danych pola jest oznaczony jako wartość Null, jest interpretowany jako kolumnę bieżącego rekordu, dla którego nie ma żadnej wartości.  
  
> [!NOTE]
>  W niektórych sytuacjach przy użyciu `IsFieldNull` może być mało wydajne, jak pokazano w poniższym przykładzie:  
  
 [!code-cpp[NVC_MFCDatabase#5](../../mfc/codesnippet/cpp/cdaorecordset-class_5.cpp)]  
  
> [!NOTE]
>  Jeśli używasz rekordów wiązania dynamicznego bez pochodny `CDaoRecordset`, należy użyć **VT_NULL** jak pokazano w przykładzie.  
  
##  <a name="isfieldnullable"></a>  CDaoRecordset::IsFieldNullable  
 Wywołanie tej funkcji Członkowskich, aby ustalić, czy element członkowski danych określone pole "nullable" (może być ustawiony na wartość Null; C++ **NULL** nie jest taka sama jak wartość Null, co w terminologii bazy danych, oznacza to "o wartości").  
  
```  
BOOL IsFieldNullable(void* pv);
```  
  
### <a name="parameters"></a>Parametry  
 `pv`  
 Wskaźnik do elementu danych pola, których stan chcesz sprawdzić, lub **NULL** ustalenie, czy dowolna z pola jest Null.  
  
### <a name="return-value"></a>Wartość zwracana  
 Różna od zera, jeśli element członkowski danych określonego pola można wprowadzić wartość Null; w przeciwnym razie 0.  
  
### <a name="remarks"></a>Uwagi  
 Pola, które nie może mieć wartości Null, musi mieć wartość. Jeśli spróbujesz ustawić na wartość Null, podczas dodawania lub aktualizowania rekordu takiego pola źródła danych odrzuca dodawania lub aktualizacji, i **aktualizacji** spowoduje zgłoszenie wyjątku. Wyjątek występuje po wywołaniu **aktualizacji**, nie w przypadku wywołania `SetFieldNull`.  
  
##  <a name="isopen"></a>  CDaoRecordset::IsOpen  
 Wywołanie tej funkcji Członkowskich, aby ustalić, czy zestaw rekordów jest otwarty.  
  
```  
BOOL IsOpen() const;  
```  
  
### <a name="return-value"></a>Wartość zwracana  
 Jeśli podano niezerowe obiekty zestawów rekordów **Otwórz** lub **Requery** wcześniej została wywołana funkcja elementu członkowskiego i nie została zamknięta zestawu rekordów; w przeciwnym razie wartość 0.  
  
### <a name="remarks"></a>Uwagi  
  
##  <a name="m_bcheckcachefordirtyfields"></a>  CDaoRecordset::m_bCheckCacheForDirtyFields  
 Flaga wskazująca, czy pola pamięci podręcznej zostaną automatycznie oznaczone jako dirty (zmienione) zawiera i Null.  
  
### <a name="remarks"></a>Uwagi  
 Domyślnie flaga **TRUE**. Ustawienie tego elementu członkowskiego danych określa całą mechanizmu podwójnego buforowania. Jeśli ustawiono flagę **TRUE**, można wyłączyć buforowanie na podstawie przez pole przy użyciu mechanizmu DFX. Jeśli ustawiono flagę **FALSE**, należy wywołać `SetFieldDirty` i `SetFieldNull` samodzielnie.  
  
 Ustaw ten element członkowski danych przed wywołaniem **Otwórz**. Ten mechanizm jest przeznaczone głównie dla łatwość użycia. Wydajność może być niższa z powodu podwójnego buforowania pól, ponieważ zmiany zostały wprowadzone.  
  
##  <a name="m_nfields"></a>  CDaoRecordset::m_nFields  
 Zawiera liczbę elementy członkowskie danych pola w klasie zestawu rekordów i liczba kolumn wybranych przez zestaw rekordów ze źródła danych.  
  
### <a name="remarks"></a>Uwagi  
 Konstruktor dla klasy rekordów musi inicjować `m_nFields` z poprawną liczbę pól statycznie powiązanej. ClassWizard zapisuje ten inicjowania dla Ciebie można użyć do zadeklarowania klasy zestawu rekordów. Można również napisać go ręcznie.  
  
 Platformę używa tego numeru do zarządzania interakcji między elementy członkowskie danych pola i odpowiednie kolumny bieżącego rekordu w źródle danych.  
  
> [!NOTE]
>  Ta liczba musi odpowiadać liczbę zarejestrowanych w kolumnach wyjściowych `DoFieldExchange` po wywołaniu `SetFieldType` z parametrem **CDaoFieldExchange::outputColumn**.  
  
 Można powiązać kolumny dynamicznie przez zasadzie `CDaoRecordset::GetFieldValue` i `CDaoRecordset::SetFieldValue`. Jeśli tak zrobisz, nie trzeba zwiększyć liczby w `m_nFields` do uwzględnienia liczba funkcji DFX wywołań Twojej `DoFieldExchange` funkcji członkowskiej.  
  
##  <a name="m_nparams"></a>  CDaoRecordset::m_nParams  
 Zawiera liczbę elementy członkowskie danych parametru w klasie rekordów — liczba parametrów przekazanych z zapytaniem w zestawie rekordów.  
  
### <a name="remarks"></a>Uwagi  
 Jeśli klasa zestaw rekordów zawiera wszystkie elementy członkowskie danych parametru, Konstruktor klasy musi inicjować `m_nParams` z prawidłową liczbą. Wartość `m_nParams` wartość domyślna to 0. Jeśli dodasz elementy członkowskie danych parametru — co należy zrobić ręcznie — musisz również ręcznie dodać inicjowania w konstruktorze klasy w celu odzwierciedlenia liczba parametrów (musi być przynajmniej tak duże jak liczba '' symbole zastępcze w Twojej **m_strFilter**  lub `m_strSort` ciągu).  
  
 Platformę używa tego numeru przy jego parameterizes zapytania w zestawie rekordów.  
  
> [!NOTE]
>  Ten numer musi odpowiadać numerowi "params" zarejestrowany w `DoFieldExchange` po wywołaniu `SetFieldType` z parametrem **CFieldExchange::param**.  
  
 Powiązane informacje zobacz temat "Obiektu Parameter" w pomocy DAO.  
  
##  <a name="m_pdaorecordset"></a>  CDaoRecordset::m_pDAORecordset  
 Zawiera wskaźnik do interfejsu OLE dla podstawowego obiektu zestawu rekordów DAO `CDaoRecordset` obiektu.  
  
### <a name="remarks"></a>Uwagi  
 Jeśli potrzebujesz dostępu interfejsu DAO bezpośrednio za pomocą tego wskaźnika.  
  
 Powiązane informacje zobacz temat "Zestawu rekordów do obiektu" w pomocy DAO.  
  
##  <a name="m_pdatabase"></a>  CDaoRecordset::m_pDatabase  
 Zawiera wskaźnik do `CDaoDatabase` obiektu za pomocą których zestaw rekordów jest połączony ze źródłem danych.  
  
### <a name="remarks"></a>Uwagi  
 Ta zmienna jest ustawiona na dwa sposoby. Zazwyczaj przekazać wskaźnik do już otwartych `CDaoDatabase` obiektu podczas konstruowania obiektu zestawu rekordów. W przypadku przekazania **NULL** zamiast **cdaorecordset —** tworzy `CDaoDatabase` obiekt i otwarcie go. W obu przypadkach `CDaoRecordset` przechowuje wskaźnika w tej zmiennej.  
  
 Zwykle nie bezpośrednio należy używać wskaźnika przechowywane w **m_pDatabase**. Jeśli piszesz własnych rozszerzeń `CDaoRecordset`, jednak czasami trzeba używać wskaźnika. Na przykład może być potrzebny wskaźnik generowanie własnego `CDaoException`(s).  
  
 Powiązane informacje zobacz temat "Obiektu bazy danych" w pomocy DAO.  
  
##  <a name="m_strfilter"></a>  CDaoRecordset::m_strFilter  
 Zawiera ciąg, który jest używany do tworzenia **gdzie** klauzuli instrukcji SQL.  
  
### <a name="remarks"></a>Uwagi  
 Nie zawiera słowo zastrzeżone **gdzie** do filtrowania zestawu rekordów. Użycie tego elementu członkowskiego danych nie ma zastosowania do zestawów rekordów typu tabeli. Korzystanie z **m_strFilter** nie obowiązuje, podczas otwierania rekordów przy użyciu `CDaoQueryDef` wskaźnika.  
  
 Użyj formatu daty Stanów Zjednoczonych (dzień miesiąc rok) podczas filtrowania pól zawierających daty, nawet jeśli nie używasz wersji US aparatu bazy danych programu Microsoft Jet; w przeciwnym razie dane nie mogą być filtrowane, zgodnie z oczekiwaniami.  
  
 Powiązane informacje zobacz temat "Filtr właściwości" w pomocy DAO.  
  
##  <a name="m_strsort"></a>  CDaoRecordset::m_strSort  
 Zawiera ciąg zawierający **ORDERBY** klauzuli instrukcji SQL bez słów zastrzeżonych **ORDERBY**.  
  
### <a name="remarks"></a>Uwagi  
 Można sortować w obiektach zestaw rekordów typu dynamicznego i migawki.  
  
 Nie można sortować obiektów zestaw rekordów typu tabeli. Aby określić kolejność sortowania zestaw rekordów typu tabeli, należy wywołać [SetCurrentIndex](#setcurrentindex).  
  
 Korzystanie z `m_strSort` nie obowiązuje, podczas otwierania rekordów przy użyciu `CDaoQueryDef` wskaźnika.  
  
 Powiązane informacje zobacz temat "Właściwości sortowania" w pomocy DAO.  
  
##  <a name="move"></a>  CDaoRecordset::Move  
 Wywołanie tej funkcji Członkowskich, aby umieścić zestaw rekordów `lRows` rekordów z bieżącego rekordu.  
  
```  
virtual void Move(long lRows);
```  
  
### <a name="parameters"></a>Parametry  
 `lRows`  
 Liczba rekordów do przeniesienia do przodu i do tyłu. Wartości dodatnie do przodu, Przenieś stronę końca zestawu rekordów. Wartości ujemne Wstecz, Przenieś stronę początku.  
  
### <a name="remarks"></a>Uwagi  
 Możesz przejść do przodu i do tyłu. `Move( 1 )` jest odpowiednikiem `MoveNext`, i `Move( -1 )` jest odpowiednikiem `MovePrev`.  
  
> [!CAUTION]
>  Wywoływanie poszczególnych **Przenieś** funkcje zgłasza wyjątek, jeśli zestaw nie zawiera żadnych rekordów. Ogólnie rzecz biorąc, wywołać metodę `IsBOF` i `IsEOF` przed operacji przenoszenia w celu określenia, czy zestaw rekordów zawiera rekordy. Po wywołaniu metody **Otwórz** lub **Requery**, albo wywoływać `IsBOF` lub `IsEOF`.  
  
> [!NOTE]
>  Jeśli były przewijane upłynął na początku lub na końcu zestawu rekordów ( `IsBOF` lub `IsEOF` zwraca różną od zera), wywołanie **Przenieś** zgłasza `CDaoException`.  
  
> [!NOTE]
>  Jeśli należy wywołać dowolną z **Przenieś** funkcji podczas bieżącego rekordu zaktualizowane lub dodane aktualizacje zostaną utracone bez ostrzeżenia.  
  
 Podczas wywoływania **Przenieś** na tylko do przodu migawki przewijania, `lRows` parametr musi być dodatnią liczbą całkowitą i zakładki nie są dozwolone, więc możesz przejść do przodu tylko.  
  
 Aby imię, nazwisko, następnej lub poprzedniej rekordów w zestawie rekordów bieżącego rekordu, wywołania **MoveFirst**, `MoveLast`, `MoveNext`, lub `MovePrev` funkcję elementu członkowskiego.  
  
 Powiązane informacje, zobacz tematy "Metody Move" i "MoveNext MoveFirst, MoveLast, metody MovePrevious" w pomocy DAO.  
  
##  <a name="movefirst"></a>  CDaoRecordset::MoveFirst  
 Wywołanie tej funkcji Członkowskich, aby pierwszy rekord w zestawie rekordów (jeśli istnieją) bieżącego rekordu.  
  
```  
void MoveFirst();
```  
  
### <a name="remarks"></a>Uwagi  
 Nie trzeba wywołać **MoveFirst** bezpośrednio po otwarciu zestawu rekordów. W tym czasie pierwszy rekord (jeśli istnieje) jest automatycznie bieżącego rekordu.  
  
> [!CAUTION]
>  Wywoływanie poszczególnych **Przenieś** funkcje zgłasza wyjątek, jeśli zestaw nie zawiera żadnych rekordów. Ogólnie rzecz biorąc, wywołać metodę `IsBOF` i `IsEOF` przed operacji przenoszenia w celu określenia, czy zestaw rekordów zawiera rekordy. Po wywołaniu metody **Otwórz** lub **Requery**, albo wywoływać `IsBOF` lub `IsEOF`.  
  
> [!NOTE]
>  Jeśli należy wywołać dowolną z **Przenieś** funkcji podczas bieżącego rekordu zaktualizowane lub dodane aktualizacje zostaną utracone bez ostrzeżenia.  
  
 Użyj **Przenieś** funkcji przenoszenia między rekordami bez zastosowania warunku. Użyj operacji wyszukiwania można zlokalizować rekordów w dynamicznego lub obiekt zestaw rekordów typu migawka spełnienia określonego warunku. Aby zlokalizować rekord w obiekcie zestaw rekordów typu tabeli, należy wywołać `Seek`.  
  
 Jeśli zestaw rekordów odwołuje się do zestawu rekordów typu tabeli, przenoszenie następuje bieżącego indeksu tabeli. Można ustawić bieżącego indeksu przy użyciu właściwości indeksu obiekt DAO. Jeśli bieżący indeks nie jest ustawiona, kolejność zwróconych rekordów jest niezdefiniowany.  
  
 Jeśli należy wywołać `MoveLast` na obiekt zestawu rekordów, na podstawie zapytania SQL lub querydef, zapytanie będzie zmuszony do ukończenia i obiekty zestawów rekordów jest całkowicie wypełnione.  
  
 Nie można wywołać **MoveFirst** lub `MovePrev` funkcji członkowskiej z przewijania migawki tylko do przodu.  
  
 Aby przenieść pozycja bieżący rekord w obiekcie zestawu rekordów określonej liczby rekordów do przodu lub do tyłu, należy wywołać **Przenieś**.  
  
 Powiązane informacje, zobacz tematy "Metody Move" i "MoveNext MoveFirst, MoveLast, metody MovePrevious" w pomocy DAO.  
  
##  <a name="movelast"></a>  CDaoRecordset::MoveLast  
 Wywołanie tej funkcji Członkowskich, aby ostatniego rekordu (jeśli istnieją) w zestawie rekordów bieżącego rekordu.  
  
```  
void MoveLast();
```  
  
### <a name="remarks"></a>Uwagi  
  
> [!CAUTION]
>  Wywoływanie poszczególnych **Przenieś** funkcje zgłasza wyjątek, jeśli zestaw nie zawiera żadnych rekordów. Ogólnie rzecz biorąc, wywołać metodę `IsBOF` i `IsEOF` przed operacji przenoszenia w celu określenia, czy zestaw rekordów zawiera rekordy. Po wywołaniu metody **Otwórz** lub **Requery**, albo wywoływać `IsBOF` lub `IsEOF`.  
  
> [!NOTE]
>  Jeśli należy wywołać dowolną z **Przenieś** funkcji podczas bieżącego rekordu zaktualizowane lub dodane aktualizacje zostaną utracone bez ostrzeżenia.  
  
 Użyj **Przenieś** funkcji przenoszenia między rekordami bez zastosowania warunku. Użyj operacji wyszukiwania można zlokalizować rekordów w dynamicznego lub obiekt zestaw rekordów typu migawka spełnienia określonego warunku. Aby zlokalizować rekord w obiekcie zestaw rekordów typu tabeli, należy wywołać `Seek`.  
  
 Jeśli zestaw rekordów odwołuje się do zestawu rekordów typu tabeli, przenoszenie następuje bieżącego indeksu tabeli. Można ustawić bieżącego indeksu przy użyciu właściwości indeksu obiekt DAO. Jeśli bieżący indeks nie jest ustawiona, kolejność zwróconych rekordów jest niezdefiniowany.  
  
 Jeśli należy wywołać `MoveLast` na obiekt zestawu rekordów, na podstawie zapytania SQL lub querydef, zapytanie będzie zmuszony do ukończenia i obiekty zestawów rekordów jest całkowicie wypełnione.  
  
 Aby przenieść pozycja bieżący rekord w obiekcie zestawu rekordów określonej liczby rekordów do przodu lub do tyłu, należy wywołać **Przenieś**.  
  
 Powiązane informacje, zobacz tematy "Metody Move" i "MoveNext MoveFirst, MoveLast, metody MovePrevious" w pomocy DAO.  
  
##  <a name="movenext"></a>  CDaoRecordset::MoveNext  
 Wywołanie tej funkcji Członkowskich dokonanie następnego rekordu w zestawie rekordów bieżącego rekordu.  
  
```  
void MoveNext();
```  
  
### <a name="remarks"></a>Uwagi  
 Zalecane jest telefoniczne skontaktowanie się z `IsBOF` przed przystąpieniem do przeniesienia do poprzedniego rekordu. Wywołanie `MovePrev` zgłosi `CDaoException` Jeśli `IsBOF` zwraca różną od zera, wskazujący, że żadne rekordy nie zostały wybrane przez zestaw rekordów albo które były już przewijane przed pierwszy rekord.  
  
> [!CAUTION]
>  Wywoływanie poszczególnych **Przenieś** funkcje zgłasza wyjątek, jeśli zestaw nie zawiera żadnych rekordów. Ogólnie rzecz biorąc, wywołać metodę `IsBOF` i `IsEOF` przed operacji przenoszenia w celu określenia, czy zestaw rekordów zawiera rekordy. Po wywołaniu metody **Otwórz** lub **Requery**, albo wywoływać `IsBOF` lub `IsEOF`.  
  
> [!NOTE]
>  Jeśli należy wywołać dowolną z **Przenieś** funkcji podczas bieżącego rekordu zaktualizowane lub dodane aktualizacje zostaną utracone bez ostrzeżenia.  
  
 Użyj **Przenieś** funkcji przenoszenia między rekordami bez zastosowania warunku. Użyj operacji wyszukiwania można zlokalizować rekordów w dynamicznego lub obiekt zestaw rekordów typu migawka spełnienia określonego warunku. Aby zlokalizować rekord w obiekcie zestaw rekordów typu tabeli, należy wywołać `Seek`.  
  
 Jeśli zestaw rekordów odwołuje się do zestawu rekordów typu tabeli, przenoszenie następuje bieżącego indeksu tabeli. Można ustawić bieżącego indeksu przy użyciu właściwości indeksu obiekt DAO. Jeśli bieżący indeks nie jest ustawiona, kolejność zwróconych rekordów jest niezdefiniowany.  
  
 Aby przenieść pozycja bieżący rekord w obiekcie zestawu rekordów określonej liczby rekordów do przodu lub do tyłu, należy wywołać **Przenieś**.  
  
 Powiązane informacje, zobacz tematy "Metody Move" i "MoveNext MoveFirst, MoveLast, metody MovePrevious" w pomocy DAO.  
  
##  <a name="moveprev"></a>  CDaoRecordset::MovePrev  
 Wywołanie tej funkcji Członkowskich dokonanie poprzedniego rekordu w zestawie rekordów bieżącego rekordu.  
  
```  
void MovePrev();
```  
  
### <a name="remarks"></a>Uwagi  
 Zalecane jest telefoniczne skontaktowanie się z `IsBOF` przed przystąpieniem do przeniesienia do poprzedniego rekordu. Wywołanie `MovePrev` zgłosi `CDaoException` Jeśli `IsBOF` zwraca różną od zera, wskazujący, że żadne rekordy nie zostały wybrane przez zestaw rekordów albo które były już przewijane przed pierwszy rekord.  
  
> [!CAUTION]
>  Wywoływanie poszczególnych **Przenieś** funkcje zgłasza wyjątek, jeśli zestaw nie zawiera żadnych rekordów. Ogólnie rzecz biorąc, wywołać metodę `IsBOF` i `IsEOF` przed operacji przenoszenia w celu określenia, czy zestaw rekordów zawiera rekordy. Po wywołaniu metody **Otwórz** lub **Requery**, albo wywoływać `IsBOF` lub `IsEOF`.  
  
> [!NOTE]
>  Jeśli należy wywołać dowolną z **Przenieś** funkcji podczas bieżącego rekordu zaktualizowane lub dodane aktualizacje zostaną utracone bez ostrzeżenia.  
  
 Użyj **Przenieś** funkcji przenoszenia między rekordami bez zastosowania warunku. Użyj operacji wyszukiwania można zlokalizować rekordów w dynamicznego lub obiekt zestaw rekordów typu migawka spełnienia określonego warunku. Aby zlokalizować rekord w obiekcie zestaw rekordów typu tabeli, należy wywołać `Seek`.  
  
 Jeśli zestaw rekordów odwołuje się do zestawu rekordów typu tabeli, przenoszenie następuje bieżącego indeksu tabeli. Można ustawić bieżącego indeksu przy użyciu właściwości indeksu obiekt DAO. Jeśli bieżący indeks nie jest ustawiona, kolejność zwróconych rekordów jest niezdefiniowany.  
  
 Nie można wywołać **MoveFirst** lub `MovePrev` funkcji członkowskiej z przewijania migawki tylko do przodu.  
  
 Aby przenieść pozycja bieżący rekord w obiekcie zestawu rekordów określonej liczby rekordów do przodu lub do tyłu, należy wywołać **Przenieś**.  
  
 Powiązane informacje, zobacz tematy "Metody Move" i "MoveNext MoveFirst, MoveLast, metody MovePrevious" w pomocy DAO.  
  
##  <a name="open"></a>  CDaoRecordset::Open  
 Wywołaj tę funkcję elementu członkowskiego, aby pobrać rekordy zestawu rekordów.  
  
```  
virtual void Open(
    int nOpenType = AFX_DAO_USE_DEFAULT_TYPE,  
    LPCTSTR lpszSQL = NULL,  
    int nOptions = 0);

 
virtual void Open(
    CDaoTableDef* pTableDef,  
    int nOpenType = dbOpenTable,  
    int nOptions = 0);

 
virtual void Open(
    CDaoQueryDef* pQueryDef,  
    int nOpenType = dbOpenDynaset,  
    int nOptions = 0);
```  
  
### <a name="parameters"></a>Parametry  
 `nOpenType`  
 Jedna z następujących wartości:  
  
- **dbOpenDynaset** dynamicznego zestawu rekordów z przewijanie dwukierunkowego. Domyślnie włączone.  
  
- **dbOpenTable** zestaw rekordów typu tabeli z przewijanie dwukierunkowego.  
  
- **dbOpenSnapshot** zestaw rekordów typu migawka z przewijanie dwukierunkowego.  
  
 `lpszSQL`  
 Wskaźnik ciągu zawierający jedną z następujących czynności:  
  
-   A **NULL** wskaźnika.  
  
-   Nazwa tabledefs — lub querydefs — (rozdzielone przecinkami).  
  
-   SQL **wybierz** instrukcji (opcjonalnie z SQL **gdzie** lub **ORDERBY** klauzuli).  
  
-   Zapytania przekazującego.  
  
 `nOptions`  
 Co najmniej jednego z poniższych opcji. Wartość domyślna to 0. Dopuszczalne są następujące wartości:  
  
- **dbAppendOnly** można dodać tylko nowe rekordy (tylko w przypadku rekordów dynamicznego). Ta opcja oznacza dosłownie rekordów tylko mogą być dołączane. Klasy baz danych MFC ODBC mają tylko Dołącz opcja umożliwiająca rekordów mają być pobierane i dołączona.  
  
- **dbForwardOnly** zestaw rekordów jest tylko do przodu migawki przewijania.  
  
- **dbSeeChanges** wygeneruje wyjątek, jeśli inny użytkownik zmienia edytowania danych.  
  
- **dbDenyWrite** innych użytkowników nie można zmodyfikować ani dodać rekordy.  
  
- **dbDenyRead** innych użytkowników nie można wyświetlić rekordy (tylko zestaw rekordów typu tabeli).  
  
- **dbReadOnly** rekordy można wyświetlać tylko; można je modyfikować przez innych użytkowników.  
  
- **dbInconsistent** niespójne aktualizacje są dozwolone (tylko w przypadku rekordów dynamicznego).  
  
- **dbConsistent** tylko spójna aktualizacje są dozwolone (dynamicznego zestawu rekordów tylko).  
  
> [!NOTE]
>  Stałe **dbConsistent** i **dbInconsistent** wykluczają się wzajemnie. Można użyć jednej lub drugiej, ale nie oba w podanym wystąpieniu **Otwórz**.  
  
 *pTableDef*  
 Wskaźnik do [CDaoTableDef](../../mfc/reference/cdaotabledef-class.md) obiektu. Ta wersja jest prawidłowa tylko dla zestawów rekordów typu tabeli. Korzystając z tej opcji `CDaoDatabase` wskaźnik został użyty do utworzenia `CDaoRecordset` nie jest używany; zamiast bazy danych, w której znajduje się tabledef jest używany.  
  
 *pQueryDef*  
 Wskaźnik do [CDaoQueryDef](../../mfc/reference/cdaoquerydef-class.md) obiektu. Ta wersja jest prawidłowy tylko w przypadku dynamicznego i zestawy rekordów typu migawka. Korzystając z tej opcji `CDaoDatabase` wskaźnik został użyty do utworzenia `CDaoRecordset` nie jest używany; zamiast służy bazy danych, w której znajduje się querydef.  
  
### <a name="remarks"></a>Uwagi  
 Przed wywołaniem **Otwórz**, należy utworzyć obiekt zestawu rekordów. Istnieje kilka sposobów, aby to zrobić:  
  
-   Podczas konstruowania obiektu zestawu rekordów, Przekaż wskaźnik do `CDaoDatabase` obiektu, który jest już otwarty.  
  
-   Podczas konstruowania obiektu zestawu rekordów, Przekaż wskaźnik do `CDaoDatabase` obiektu, który nie jest otwarty. Zestaw rekordów otwiera `CDaoDatabase` obiekt, ale nie zostanie on zamknięty, po zamknięciu obiekt zestawu rekordów.  
  
-   Podczas konstruowania obiektu zestawu rekordów, Przekaż **NULL** wskaźnika. Zestaw rekordów wywołania obiektu `GetDefaultDBName` można pobrać nazwy programu Microsoft Access. Plik MDB, aby otworzyć. Otwarcie zestawu rekordów `CDaoDatabase` obiektu i przechowuje ją otworzyć tak długo, jak zestaw rekordów jest otwarty. Podczas wywoływania **Zamknij** w zestawie rekordów, `CDaoDatabase` obiekt również jest zamknięty.  
  
    > [!NOTE]
    >  Po otwarciu zestawu rekordów `CDaoDatabase` obiektu, zostanie otwarty z wyłącznego dostępu do źródła danych.  
  
 Dla wersji **Otwórz** używającą `lpszSQL` parametru po otwarciu zestawu rekordów można pobrać rekordów w jednym z kilku sposobów. Pierwsza opcja ma funkcje DFX Twojej `DoFieldExchange`. Drugą opcją jest użycie wiązania dynamicznego wywołując `GetFieldValue` funkcję elementu członkowskiego. Te opcje można zaimplementować osobno lub razem. Jeśli są połączone, trzeba będzie przekazać w instrukcji SQL samodzielnie w wywołaniu **Otwórz**.  
  
 Jeśli używasz druga wersja **Otwórz** gdy przekazujesz w `CDaoTableDef` obiekt wynikowy kolumn będzie można powiązać za pośrednictwem `DoFieldExchange` i DFX mechanizmu i/lub powiązanego dynamicznie za pośrednictwem `GetFieldValue`.  
  
> [!NOTE]
>  Można wywołać tylko **Otwórz** przy użyciu `CDaoTableDef` obiektu dla zestawów rekordów typu tabeli.  
  
 Jeśli używasz trzeciej wersji aplikacji **Otwórz** gdy przekazujesz w `CDaoQueryDef` obiektu, że kwerenda zostanie wykonana, a wynikowy kolumn będzie można powiązać za pośrednictwem `DoFieldExchange` i mechanizmu DFX i/lub powiązać dynamicznie za pomocą `GetFieldValue`.  
  
> [!NOTE]
>  Można wywołać tylko **Otwórz** przy użyciu `CDaoQueryDef` obiektu dynamicznego i zestawów rekordów typu migawka.  
  
 Dla pierwszej wersji **Otwórz** używającą `lpszSQL` parametru rekordy są wybrane na podstawie kryteria, pokazano w poniższej tabeli.  
  
|Wartość `lpszSQL` parametru|Wybrane rekordy są określane przez|Przykład|  
|--------------------------------------|----------------------------------------|-------------|  
|**NULL**|Długość ciągu zwróconego przez `GetDefaultSQL`.||  
|Rozdzielana przecinkami lista tabledefs — co najmniej jeden i/lub querydef nazwy.|Wszystkie kolumny reprezentowane w `DoFieldExchange`.|`"Customer"`|  
|**Wybierz** listy kolumn **FROM** listę tabel|Określonych kolumn z określonym tabledef(s) i/lub querydef(s).|`"SELECT CustId, CustName`<br /><br /> `FROM Customer"`|  
  
 Zwykle procedura służy do przekazywania **NULL** do **Otwórz**; w takim przypadku **Otwórz** wywołania `GetDefaultSQL`, funkcji członkowskiej możliwym do zastąpienia, która generuje ClassWizard podczas tworzenia `CDaoRecordset`-klasy. Ta wartość zapewnia tabledef(s) i/lub querydef nazwy określonej w ClassWizard. Zamiast tego można określić inne informacje w `lpszSQL` parametru.  
  
 Niezależnie od przypadku przekazania, **Otwórz** tworzy ostatni ciąg SQL dla zapytania (ciąg może zawierać SQL **gdzie** i **ORDERBY** klauzule dołączany do `lpszSQL` ciągu można Przekroczono), a następnie wykonuje zapytanie. Należy zbadać skonstruowane ciąg przez wywołanie metody `GetSQL` po wywołaniu **Otwórz**.  
  
 Elementy członkowskie danych pola klasy zestawu rekordów, które są powiązane kolumny wybranych danych. Jeśli żadne rekordy nie zostały zwrócone, pierwszy rekord staje się bieżącego rekordu.  
  
 Jeśli chcesz ustawić opcje dla zestawu rekordów, takich jak filtr lub sortowanie, ustaw `m_strSort` lub **m_strFilter** po konstruowania obiektu zestawu rekordów, ale przed wywołaniem **Otwórz**. Jeśli chcesz odświeżyć rekordy w zestawie rekordów po zestaw rekordów jest już otwarty, należy wywołać **Requery**.  
  
 Jeśli należy wywołać **Otwórz** dynamicznego lub zestaw rekordów typu migawka, lub jeśli źródło danych odwołuje się do instrukcji SQL lub tabledef, który reprezentuje dołączonej tabeli, nie można użyć **dbOpenTable** dla typu argument; Jeśli to zrobisz, MFC zgłasza wyjątek. Aby ustalić, czy obiekt tabledef reprezentuje dołączonej tabeli, należy utworzyć [CDaoTableDef](../../mfc/reference/cdaotabledef-class.md) obiekt i wywołanie jego [GetConnect](../../mfc/reference/cdaotabledef-class.md#getconnect) funkcję elementu członkowskiego.  
  
 Użyj **dbSeeChanges** Oznacz flagą, aby zmiany wprowadzone przez innego użytkownika lub inny program na komputer podczas edytowania i usuwania ten sam rekord pułapki. Na przykład, jeśli dwóch użytkowników edytowana ten sam rekord pierwszy użytkownik, aby wywołać **aktualizacji** funkcji członkowskiej zakończy się pomyślnie. Gdy **aktualizacji** jest wywoływana przez drugiego użytkownika `CDaoException` jest generowany. Podobnie jeśli drugi użytkownik podejmie próbę wywołania **usunąć** można usunąć rekord który już został zmieniony przez pierwszego użytkownika `CDaoException` występuje.  
  
 Zwykle jeśli użytkownik pobiera to `CDaoException` podczas aktualizowania, kod należy odświeżyć zawartość pól i pobrać zmodyfikowane wartości. Jeśli wystąpi wyjątek w trakcie usuwania, kodu można wyświetlić nowych rekordów danych użytkownika i komunikat informujący, że dane ostatnio zmieniła się. W tym momencie kodu mogą poprosić o potwierdzenie, że użytkownik chce nadal można usunąć rekordu.  
  
> [!TIP]
>  Opcja tylko do przodu przewijania ( **dbForwardOnly**) aby zwiększyć wydajność, gdy aplikacja przesyła pojedynczego przekazywania zestaw rekordów została otwarta ze źródła danych ODBC.  
  
 Powiązane informacje zobacz temat "OpenRecordset Method" w pomocy DAO.  
  
##  <a name="requery"></a>  CDaoRecordset::Requery  
 Wywołanie tej funkcji Członkowskich odbudować (odświeżanie) zestawu rekordów.  
  
```  
virtual void Requery();
```  
  
### <a name="remarks"></a>Uwagi  
 Jeśli żadne rekordy nie zostały zwrócone, pierwszy rekord staje się bieżącego rekordu.  
  
 Aby zestaw rekordów odzwierciedla dodawania i usuwania, które wykonują źródła danych, należy ponownie zbudować zestawu rekordów przez wywołanie metody **Requery**. Jeśli zestaw rekordów jest dynamiczny, automatycznie odzwierciedla aktualizacje, które użytkownicy dokonać jego istniejące rekordy (ale nie dodatków). Jeśli zestaw rekordów jest migawką, należy wywołać **Requery** uwzględnienie zmian przez innych użytkowników, a także dodawania i usuwania.  
  
 Zestaw dynamiczny lub migawki, należy wywołać **Requery** dowolnej chwili, aby odbudować rekordów przy użyciu wartości parametrów. Ustaw nowe filtrowania lub sortowania przez ustawienie [m_strFilter](#m_strfilter) i [m_strSort](#m_strsort) przed wywołaniem **Requery**. Ustaw nowe parametry przez przypisanie wartości nowe elementy członkowskie danych parametru przed wywołaniem **Requery**.  
  
 Jeśli próba odbudować zestaw rekordów nie powiedzie się, zestaw rekordów jest zamknięty. Przed wywołaniem **Requery**, można określić, czy zestaw rekordów można ponowieniu wywołując [CanRestart](#canrestart) funkcję elementu członkowskiego. `CanRestart` nie gwarantuje, że **Requery** powiedzie się.  
  
> [!CAUTION]
>  Wywołanie **Requery** tylko po wywołaniu **Otwórz**.  
  
> [!NOTE]
>  Wywoływanie [Requery](#requery) zmienia DAO zakładki.  
  
 Nie można wywołać **Requery** dynamicznego lub zestaw rekordów typu migawka, jeśli wywołanie `CanRestart` zwraca wartość 0, nie można użyć go na zestaw rekordów typu tabeli.  
  
 Jeśli oba `IsBOF` i `IsEOF` zwracać niezerowy po wywołaniu metody **Requery**, kwerenda nie zwróciła żadnych rekordów i rekordów zostanie nie zawierają danych.  
  
 Powiązane informacje zobacz temat "Requery Method" w pomocy DAO.  
  
##  <a name="seek"></a>  CDaoRecordset::Seek  
 Wywołanie tej funkcji Członkowskich do zlokalizowania w obiekcie zestaw rekordów typu indeksowanej tabeli spełniającego określone kryteria dla bieżącego indeksu i upewnij, że rekord dla bieżącego rekordu rekordu.  
  
```  
BOOL Seek(
    LPCTSTR lpszComparison,  
    COleVariant* pKey1,  
    COleVariant* pKey2 = NULL,  
    COleVariant* pKey3 = NULL);

 
BOOL Seek(
    LPCTSTR lpszComparison,  
    COleVariant* pKeyArray,  
    WORD nKeys);
```  
  
### <a name="parameters"></a>Parametry  
 `lpszComparison`  
 Jedno z wyrażeń następujący ciąg: "<","\<=", "=" "> =", lub ">".  
  
 `pKey1`  
 Wskaźnik do [COleVariant](../../mfc/reference/colevariant-class.md) którego wartość odpowiada pierwszego pola w indeksie. Wymagana.  
  
 *pKey2*  
 Wskaźnik do `COleVariant` którego wartość odpowiada drugiego pola w indeksie, jeśli istnieje. Domyślnie **NULL**.  
  
 *pKey3*  
 Wskaźnik do `COleVariant` którego wartość odpowiada trzecie pole w indeksie, jeśli istnieje. Domyślnie **NULL**.  
  
 *pKeyArray*  
 Wskaźnik do tablicy typu Variant. Rozmiar tablicy odpowiada liczbę pól w indeksie.  
  
 *nKeys*  
 Integer odpowiadającego rozmiar tablicy, która jest liczba pól w indeksie.  
  
> [!NOTE]
>  W kluczach nie należy określać symboli wieloznacznych. Symbole wieloznaczne spowoduje, że `Seek` do zwrócenia ma pasujących rekordów.  
  
### <a name="return-value"></a>Wartość zwracana  
 Różna od zera, jeśli rekordy zostaną znalezione, w przeciwnym razie 0.  
  
### <a name="remarks"></a>Uwagi  
 Przy użyciu drugiej wersji (tablica) `Seek` indeksy pól cztery lub więcej.  
  
 `Seek` Umożliwia wyszukiwanie zestawów rekordów typu tabeli indeksu wysokiej wydajności. Należy ustawić bieżącego indeksu przez wywołanie metody `SetCurrentIndex` przed wywołaniem `Seek`. Jeśli indeks identyfikuje nieunikatowy lub pól klucza, `Seek` lokalizuje pierwszy rekord, który spełnia kryteria. Jeśli indeks nie jest ustawiona, jest zwracany wyjątek.  
  
 Należy pamiętać, że jeśli nie utworzysz zestaw rekordów UNICODE, `COleVariant` obiekty muszą być jawnie deklarować ANSI. Można to zrobić za pomocą [COleVariant::COleVariant](../../mfc/reference/colevariant-class.md#colevariant)**(** `lpszSrc` **,** `vtSrc` **)** formę — Konstruktor z `vtSrc` ustawioną `VT_BSTRT` (ANSI) lub za pomocą **COleVariant** funkcja [SetString](../../mfc/reference/colevariant-class.md#setstring)**(** `lpszSrc` **,** `vtSrc` **)** z `vtSrc` ustawioną `VT_BSTRT`.  
  
 Podczas wywoływania `Seek`, należy przekazać co najmniej jednej wartości klucza i operatora porównania ("<","\<=", "=" "> =", lub ">"). `Seek` przeszukanie określone pola klucza i lokalizuje pierwszy rekord, który spełnia kryteria określone przez `lpszComparison` i `pKey1`. Znaleziono jeden raz, `Seek` zwraca różną od zera co oznacza, że ten rekord bieżący. Jeśli `Seek` nie uda się znaleźć dopasowania, `Seek` zwraca zero, a bieżący rekord jest niezdefiniowany. Korzystając z obiektów DAO bezpośrednio, należy jawnie Sprawdź właściwość NoMatch.  
  
 Jeśli `lpszComparison` to "=" "> =", lub ">", `Seek` rozpoczyna się od początku indeksu. Jeśli `lpszComparison` jest "<" lub "< =", `Seek` rozpoczyna się na końcu indeksu i wyszukuje Wstecz, o ile nie ma indeksu zduplikowanych wpisów na końcu. W takim przypadku `Seek` rozpoczyna się od dowolnego wpis między indeksu zduplikowane wpisy na końcu indeksu.  
  
 Brak nie musi być bieżącego rekordu w przypadku używania `Seek`.  
  
 Aby zlokalizować rekord dynamicznego lub zestaw rekordów typu migawka, która spełnia określony warunek, użyj operacji wyszukiwania. Aby uwzględnić wszystkie rekordy, nie tylko te, które spełniają określony warunek, użyj operacji przenoszenia do przechodzenia między rekordu.  
  
 Nie można wywołać `Seek` na dołączonej tabeli dowolnego typu, ponieważ tabele dołączonych muszą być otwarte jako dynamicznego lub zestawów rekordów typu migawka. Jednak jeśli wywołujesz `CDaoDatabase::Open` bezpośrednio otworzyć instalowalnych ISAM bazy danych, należy wywołać `Seek` w tabelach w tej bazie danych, mimo że wydajność może być wolne.  
  
 Powiązane informacje zobacz temat "Wyszukiwanie Method" w pomocy DAO.  
  
##  <a name="setabsoluteposition"></a>  CDaoRecordset::SetAbsolutePosition  
 Ustawia względną numer bieżącego rekordu obiektu zestawu rekordów.  
  
```  
void SetAbsolutePosition(long lPosition);
```  
  
### <a name="parameters"></a>Parametry  
 *lPosition*  
 Odpowiada numerem porządkowym bieżącego rekordu w zestawie rekordów.  
  
### <a name="remarks"></a>Uwagi  
 Wywoływanie `SetAbsolutePosition` umożliwia umieść wskaźnik bieżącego rekordu określony rekord na podstawie jego liczby porządkowej pozycji w dynamicznego lub zestaw rekordów typu migawka. Należy także określić numer bieżącego rekordu, wywołując [GetAbsolutePosition](#getabsoluteposition).  
  
> [!NOTE]
>  Ta funkcja członkowska jest prawidłowy tylko w przypadku dynamicznego i zestawów rekordów typu migawka.  
  
 Wartość właściwości AbsolutePosition obiekt DAO jest liczony od zera; wartość 0 oznacza pierwszy rekord w zestawie rekordów. Ustawienie wartości jest większa niż liczba rekordów wypełnione przyczyny MFC do zgłoszenia wyjątku. Można określić liczbę wypełnione rekordy w zestawie rekordów przez wywołanie metody `GetRecordCount` funkcję elementu członkowskiego.  
  
 Usunięcie bieżącego rekordu AbsolutePosition wartość właściwości nie została zdefiniowana, a MFC zgłasza wyjątek, jeśli odwołuje się do. Nowe rekordy są dodawane na końcu sekwencji.  
  
> [!NOTE]
>  Ta właściwość nie jest przeznaczony do użycia jako numer rekordu dwuskładnikowego. Zakładki są nadal zalecany sposób zachowania i zwracany do określonej pozycji i są jedynym sposobem na pozycji wszystkich typów obiektów zestawu rekordów, które obsługują zakładki dla bieżącego rekordu. W szczególności pozycja danego rekordu zostanie zmieniona podczas usuwania rekordów przed nim. Ponadto nie jest rekord ma to samo położenie bezwzględne Jeśli zestaw rekordów jest utworzony ponownie, ponieważ nie jest gwarantowana kolejność poszczególnych rekordów w zestawie rekordów, chyba że jest tworzony z instrukcji SQL przy użyciu  **ORDERBY** klauzuli.  
  
 Powiązane informacje zobacz temat "AbsolutePosition Property" w pomocy DAO.  
  
##  <a name="setbookmark"></a>  CDaoRecordset::SetBookmark  
 Wywołanie tej funkcji Członkowskich, aby umieścić zestaw rekordów na rekord zawierający zakładką.  
  
```  
void SetBookmark(COleVariant varBookmark);
```  
  
### <a name="parameters"></a>Parametry  
 `varBookmark`  
 A [COleVariant](../../mfc/reference/colevariant-class.md) obiekt zawierający wartości zakładki dla określonego rekordu.  
  
### <a name="remarks"></a>Uwagi  
 Podczas tworzenia lub otworzyć obiektu zestawu rekordów, każda rekordy już ma unikatowe zakładki. Możesz pobrać zakładki dla bieżącego rekordu przez wywołanie metody `GetBookmark` i zapisywanie wartość `COleVariant` obiektu. Później można było powrócić do tego rekordu przez wywołanie metody `SetBookmark` przy użyciu wartości zapisane zakładki.  
  
> [!NOTE]
>  Wywoływanie [Requery](#requery) zmienia DAO zakładki.  
  
 Należy pamiętać, że jeśli nie utworzysz zestaw rekordów UNICODE, `COleVariant` obiektu musi być jawnie deklarować ANSI. Można to zrobić za pomocą [COleVariant::COleVariant](../../mfc/reference/colevariant-class.md#colevariant)**(** `lpszSrc` **,** `vtSrc` **)** formę — Konstruktor z `vtSrc` ustawioną `VT_BSTRT` (ANSI) lub za pomocą **COleVariant** funkcja [SetString](../../mfc/reference/colevariant-class.md#setstring)**(** `lpszSrc` **,** `vtSrc` **)** z `vtSrc` ustawioną `VT_BSTRT`.  
  
 Powiązane informacje zobacz tematy "Właściwość zakładki" i Bookmarkable"w pomocy DAO.  
  
##  <a name="setcachesize"></a>  CDaoRecordset::SetCacheSize  
 Wywołanie tej funkcji członkowskich można ustawić liczby rekordów w pamięci podręcznej.  
  
```  
void SetCacheSize(long lSize);
```  
  
### <a name="parameters"></a>Parametry  
 `lSize`  
 Określa liczbę rekordów. Typowe wartości to 100. Wartość 0 powoduje wyłączenie buforowania. Ustawienie musi należeć do zakresu od 5 i 1200 rekordów. Pamięć podręczna może używać znaczną ilość pamięci.  
  
### <a name="remarks"></a>Uwagi  
 Pamięć podręczna jest spacja w lokalnej pamięci, która przechowuje dane ostatnio pobrana z serwera w przypadku, gdy dane będzie wymagane ponownie, gdy aplikacja jest uruchomiona. Buforowanie danych zwiększa wydajność aplikacji, która pobiera dane z serwera zdalnego za pomocą dynamicznego zestawu rekordów obiektów. Po zażądaniu danych aparatu bazy danych programu Microsoft Jet pamięci podręcznej dla żądanych danych najpierw sprawdza zamiast pobierania jej z serwera, który zajmuje więcej czasu. Dane, które nie pochodzą ze źródła danych ODBC nie są zapisywane w pamięci podręcznej.  
  
 Wszystkie źródła danych ODBC, takich jak dołączonej tabeli może mieć lokalnej pamięci podręcznej. Aby utworzyć pamięci podręcznej, otwórz obiekty zestawów rekordów ze źródła danych zdalnych, wywołanie `SetCacheSize` i `SetCacheStart` funkcji elementów członkowskich, a następnie wywołania `FillCache` funkcji członkowskiej lub krok rekordy przy użyciu jednej z operacji przenoszenia. `lSize` Parametr `SetCacheSize` funkcji członkowskiej może opierać się na to liczba rekordów aplikacji razem w tym samym czasie. Na przykład, jeśli używasz zestaw rekordów jako źródło danych do wyświetlenia na ekranie, można przekazać `SetCacheSize` `lSize` parametr jako 20 do wyświetlenia w tym samym czasie 20 rekordów.  
  
 Powiązane informacje zobacz temat "CacheSize właściwości CacheStart" w pomocy DAO.  
  
##  <a name="setcachestart"></a>  CDaoRecordset::SetCacheStart  
 Wywołanie tej funkcji elementu członkowskiego, aby określić zakładki pierwszy rekord w zestawie rekordów w pamięci podręcznej.  
  
```  
void SetCacheStart(COleVariant varBookmark);
```  
  
### <a name="parameters"></a>Parametry  
 `varBookmark`  
 A [COleVariant](../../mfc/reference/colevariant-class.md) określający zakładki pierwszy rekord w zestawie rekordów w pamięci podręcznej.  
  
### <a name="remarks"></a>Uwagi  
 Możesz użyć wartości zakładki dowolnego rekordu dla `varBookmark` parametr `SetCacheStart` funkcję elementu członkowskiego. Rekord, aby uruchomić pamięć podręczną z bieżącym rekordem, ustanowić zakładki dla tego rekordu za pomocą [SetBookmark](#setbookmark)i przekazać wartość zakładki jako parametr `SetCacheStart` funkcję elementu członkowskiego.  
  
 Aparat bazy danych programu Microsoft Jet żądań rekordów w zakresie pamięci podręcznej z pamięci podręcznej i żądania rekordy poza zakresem pamięci podręcznej z serwera.  
  
 Rekordów pobieranych z pamięci podręcznej nie uwzględniają zmiany wprowadzone współbieżnie źródła danych przez innych użytkowników.  
  
 Aby wymusić aktualizację wszystkie buforowane dane, należy przekazać `lSize` parametr `SetCacheSize` jako 0, należy wywołać `SetCacheSize` ponownie z rozmiarem pamięci podręcznej można początkowo żądana, a następnie wywołać `FillCache` funkcję elementu członkowskiego.  
  
 Należy pamiętać, że jeśli nie utworzysz zestaw rekordów UNICODE, `COleVariant` obiektu musi być jawnie deklarować ANSI. Można to zrobić za pomocą [COleVariant::COleVariant](../../mfc/reference/colevariant-class.md#colevariant)**(** `lpszSrc` **,** `vtSrc` **)** formę — Konstruktor z `vtSrc` ustawioną `VT_BSTRT` (ANSI) lub za pomocą **COleVariant** funkcja [SetString](../../mfc/reference/colevariant-class.md#setstring)**(** `lpszSrc` **,** `vtSrc` **)** z `vtSrc` ustawioną `VT_BSTRT`.  
  
 Powiązane informacje zobacz temat CacheSize, właściwości CacheStart"w pomocy DAO.  
  
##  <a name="setcurrentindex"></a>  CDaoRecordset::SetCurrentIndex  
 Wywołanie tej funkcji Członkowskich ustawić indeksu na zestaw rekordów typu tabeli.  
  
```  
void SetCurrentIndex(LPCTSTR lpszIndex);
```  
  
### <a name="parameters"></a>Parametry  
 `lpszIndex`  
 Wskaźnik zawierający nazwę indeksu, który ma zostać ustawiona.  
  
### <a name="remarks"></a>Uwagi  
 Rekordy w tabel podstawowych nie są przechowywane w określonej kolejności. Indeks ustawień zmienia kolejność rekordów zwróconych z bazy danych, ale nie ma wpływu na kolejność, w którym są przechowywane rekordy. Określony indeks musi być już zdefiniowana. Jeśli spróbujesz użyć indeksu obiektu, który nie istnieje lub indeks nie jest ustawiany w przypadku wywołania [wyszukiwania](#seek), MFC zgłasza wyjątek.  
  
 Można utworzyć nowego indeksu dla tabeli, wywołując [CDaoTableDef::CreateIndex](../../mfc/reference/cdaotabledef-class.md#createindex) i dodanie nowego indeksu do kolekcji indeksów tabledef podstawowej przez wywołanie metody [CDaoTableDef::Append](../../mfc/reference/cdaotabledef-class.md#append), i następnie przeglądarkę zestawu rekordów.  
  
 Rekordów zwróconych z zestawu rekordów typu tabeli może zostać określona tylko przez zdefiniowane dla podstawowej tabledef indeksy. Aby posortować rekordy w niektórych innych kolejności, można otworzyć dynamicznego lub zestaw rekordów typu migawka przy użyciu programu SQL **ORDERBY** klauzuli przechowywane w [CDaoRecordset::m_strSort](#m_strsort).  
  
 Powiązane informacje zobacz temat "Indeksu obiektu", jak i definicja "bieżącego indeksu" w pomocy DAO.  
  
##  <a name="setfielddirty"></a>  CDaoRecordset::SetFieldDirty  
 Wywołanie tej funkcji Członkowskich do flagi element członkowski danych pól rekordów jako zmieniony lub jako bez zmian.  
  
```  
void SetFieldDirty(
    void* pv,  
    BOOL bDirty = TRUE);
```  
  
### <a name="parameters"></a>Parametry  
 `pv`  
 Zawiera adres elementu członkowskiego danych pole w zestawie rekordów lub **NULL**. Jeśli **NULL**, oflagowane wszystkie elementy członkowskie danych pola w zestawie rekordów. (C++ **NULL** nie jest taka sama jak wartość Null w terminologii bazy danych, co oznacza, że "o wartości".)  
  
 `bDirty`  
 **Wartość TRUE,** element członkowski danych pola jest zostanie oznaczony jako "zakłóconych" (zmienione). W przeciwnym razie **FALSE** element członkowski danych pola jest zostanie oznaczony jako "clean" (bez zmian).  
  
### <a name="remarks"></a>Uwagi  
 Oznaczanie pola jako niezmienione gwarantuje, że pole nie zostanie zaktualizowane.  
  
 Znaczniki framework zmienione elementy członkowskie danych pola, aby upewnić się, że będzie można zapisać rekordu w źródle danych przy użyciu mechanizmu programu exchange (DFX) pól rekordów DAO. Zmiana wartości pola zazwyczaj ustawia pole zanieczyszczone automatycznie, dzięki czemu rzadko trzeba wywołać `SetFieldDirty` samodzielnie, ale czasami warto upewnij się, że kolumn zostanie jawnie zaktualizowane lub wstawić niezależnie od tego, jakie wartości w polu danych element członkowski. Mechanizm DFX wykorzystuje również użycie **PSEUDONULL**. Aby uzyskać więcej informacji, zobacz [CDaoFieldExchange::m_nOperation](../../mfc/reference/cdaofieldexchange-class.md#m_noperation).  
  
 Jeśli nie jest używany mechanizm podwójnego buforowania, następnie zmieniając wartość pola nie automatycznie ustawia pole jako zakłócone. W takim przypadku będzie trzeba jawnie ustaw dla pola jako zakłócone. Flaga zawarte w [m_bCheckCacheForDirtyFields](#m_bcheckcachefordirtyfields) steruje tym automatyczne sprawdzanie.  
  
> [!NOTE]
>  Wywołanie funkcji członkowskiej tylko po wywołaniu [Edytuj](#edit) lub [AddNew](#addnew).  
  
 Przy użyciu **NULL** dla pierwszy argument funkcji obowiązuje funkcję we wszystkich **outputColumn** pól nie **param** pól w `CDaoFieldExchange`. Na przykład wywołanie  
  
 [!code-cpp[NVC_MFCDatabase#6](../../mfc/codesnippet/cpp/cdaorecordset-class_6.cpp)]  
  
 zostanie ustawiona tylko **outputColumn** pól do **NULL**; **param** pól będzie to miało wpływu.  
  
 Do pracy nad **param**, należy podać rzeczywiste adres poszczególne **param** chcesz pracować, takich jak:  
  
 [!code-cpp[NVC_MFCDatabase#7](../../mfc/codesnippet/cpp/cdaorecordset-class_7.cpp)]  
  
 Oznacza to, nie można ustawić wszystkie **param** pól do **NULL**, jak w przypadku **outputColumn** pól.  
  
 `SetFieldDirty` jest implementowane za pośrednictwem `DoFieldExchange`.  
  
##  <a name="setfieldnull"></a>  CDaoRecordset::SetFieldNull  
 Wywołanie tej funkcji Członkowskich do flagi element członkowski danych pól rekordów jako wartości Null (o specjalnie żadna wartość) lub inną niż Null.  
  
```  
void SetFieldNull(
    void* pv,  
    BOOL bNull = TRUE);
```  
  
### <a name="parameters"></a>Parametry  
 `pv`  
 Zawiera adres elementu członkowskiego danych pole w zestawie rekordów lub **NULL**. Jeśli **NULL**, oflagowane wszystkie elementy członkowskie danych pola w zestawie rekordów. (C++ **NULL** nie jest taka sama jak wartość Null w terminologii bazy danych, co oznacza, że "o wartości".)  
  
 `bNull`  
 Różna od zera, jeśli element członkowski danych pole ma być oznaczone jako mający żadna wartość (Null). W przeciwnym razie równa 0, jeśli element członkowski danych pola być oznaczony jako inną niż Null.  
  
### <a name="remarks"></a>Uwagi  
 `SetFieldNull` Służy do pola powiązane w `DoFieldExchange` mechanizmu.  
  
 Podczas dodawania nowego rekordu do zestawu rekordów, wszystkie elementy członkowskie danych pola są początkowo ustawiona na wartość Null i oznaczone jako "zakłóconych" (zmienione). Gdy można pobrać rekordu ze źródła danych, jej kolumn już mieć wartości albo mają wartość Null. Jeśli nie jest dokonanie pola wartość Null, [CDaoException](../../mfc/reference/cdaoexception-class.md) jest generowany.  
  
 Jeśli używasz mechanizmu podwójnego buforowania, na przykład, jeśli chcesz wyznaczyć pole bieżącego rekordu nie ma wartości, wywołaj specjalnie `SetFieldNull` z `bNull` ustawioną **TRUE** do flagi go jako wartość Null. Jeśli chcesz nadać mu wartość pola została wcześniej oznaczona wartość Null, po prostu ustawić jego nowej wartości. Nie trzeba usunąć flagę Null z `SetFieldNull`. Aby ustalić, czy pole może mieć wartości Null, należy wywołać [IsFieldNullable](#isfieldnullable).  
  
 Jeśli nie używasz mechanizmu podwójnego buforowania, następnie zmieniając wartość pola nie automatycznie ustawia pole jako zakłócone i inną niż Null. W szczególności należy ustawić pola zanieczyszczone i inną niż Null. Flaga zawarte w [m_bCheckCacheForDirtyFields](#m_bcheckcachefordirtyfields) steruje tym automatyczne sprawdzanie.  
  
 Korzystanie z wykorzystuje mechanizm DFX **PSEUDONULL**. Aby uzyskać więcej informacji, zobacz [CDaoFieldExchange::m_nOperation](../../mfc/reference/cdaofieldexchange-class.md#m_noperation).  
  
> [!NOTE]
>  Wywołanie funkcji członkowskiej tylko po wywołaniu [Edytuj](#edit) lub [AddNew](#addnew).  
  
 Przy użyciu **NULL** dla pierwszy argument funkcji będą stosowane tylko do funkcji **outputColumn** pól nie **param** pól w `CDaoFieldExchange`. Na przykład wywołanie  
  
 [!code-cpp[NVC_MFCDatabase#8](../../mfc/codesnippet/cpp/cdaorecordset-class_8.cpp)]  
  
 zostanie ustawiona tylko **outputColumn** pól do **NULL**; **param** pól będzie to miało wpływu.  
  
##  <a name="setfieldvalue"></a>  CDaoRecordset::SetFieldValue  
 Wywołanie tej funkcji członkowskich można ustawić wartości pola, według liczby porządkowej pozycji lub zmieniając wartość ciągu.  
  
```  
virtual void SetFieldValue(
    LPCTSTR lpszName,  
    const COleVariant& varValue);

 
virtual void SetFieldValue(
    int nIndex,  
    const COleVariant& varValue);

 
void SetFieldValue(
    LPCTSTR lpszName,  
    LPCTSTR lpszValue);

 
void SetFieldValue(
    int nIndex,  
    LPCTSTR lpszValue);
```  
  
### <a name="parameters"></a>Parametry  
 `lpszName`  
 Wskaźnik do ciąg zawierający nazwę pola.  
  
 `varValue`  
 Odwołanie do [COleVariant](../../mfc/reference/colevariant-class.md) obiekt zawierający wartości pola.  
  
 `nIndex`  
 Liczba całkowita, która reprezentuje numerem porządkowym pola w kolekcji pól w zestawie rekordów (liczony od zera).  
  
 `lpszValue`  
 Wskaźnik do ciąg zawierający wartość pola zawartość.  
  
### <a name="remarks"></a>Uwagi  
 Użyj `SetFieldValue` i [GetFieldValue](#getfieldvalue) dynamicznie powiązać pola w czasie wykonywania, a nie statycznie powiązanie kolumn za pomocą [DoFieldExchange](#dofieldexchange) mechanizmu.  
  
 Należy pamiętać, że jeśli nie utworzysz rekordów UNICODE, należy użyć formularza `SetFieldValue` niezawierające `COleVariant` parametru lub `COleVariant` obiektu musi być jawnie deklarować ANSI. Można to zrobić za pomocą [COleVariant::COleVariant](../../mfc/reference/colevariant-class.md#colevariant)**(** `lpszSrc` **,** `vtSrc` **)** formę — Konstruktor z `vtSrc` ustawioną `VT_BSTRT` (ANSI) lub za pomocą **COleVariant** funkcja [SetString](../../mfc/reference/colevariant-class.md#setstring)**(** `lpszSrc` **,** `vtSrc` **)** z `vtSrc` ustawioną `VT_BSTRT`.  
  
 Powiązane informacje zobacz tematy "Pola obiektu" i "Wartość właściwości" w pomocy DAO.  
  
##  <a name="setfieldvaluenull"></a>  CDaoRecordset::SetFieldValueNull  
 Wywołanie tej funkcji członkowskich można ustawić pola na wartość Null.  
  
```  
void SetFieldValueNull(int nIndex);  
void SetFieldValueNull(LPCTSTR lpszName);
```  
  
### <a name="parameters"></a>Parametry  
 `nIndex`  
 Indeks pole w zestawie rekordów do wyszukiwania przez liczony od zera indeks.  
  
 `lpszName`  
 Nazwa pola w zestawie rekordów do wyszukiwania według nazwy.  
  
### <a name="remarks"></a>Uwagi  
 C++ **NULL** nie jest taka sama jak wartość Null, co w terminologii bazy danych, oznacza to "o wartości".  
  
 Powiązane informacje zobacz tematy "Pola obiektu" i "Wartość właściwości" w pomocy DAO.  
  
##  <a name="setlockingmode"></a>  CDaoRecordset::SetLockingMode  
 Wywołanie tej funkcji Członkowskich, aby ustawić typ blokady dla zestawu rekordów.  
  
```  
void SetLockingMode(BOOL bPessimistic);
```  
  
### <a name="parameters"></a>Parametry  
 *bPessimistic*  
 Flaga wskazująca typ blokowania.  
  
### <a name="remarks"></a>Uwagi  
 Gdy pesymistyczne blokowanie jest włączona, strona 2K zawierająca edytowania rekordu jest zablokowany, jak należy wywołać **Edytuj** funkcję elementu członkowskiego. Strona jest odblokowany, podczas wywoływania **aktualizacji** lub **Zamknij** funkcji członkowskiej lub dowolnych operacji przenoszenia lub Znajdź.  
  
 Gdy optymistyczne blokowanie jest włączona, strona 2K zawierająca rekord jest zablokowany, tylko wtedy, gdy rekord jest aktualizowany przy użyciu **aktualizacji** funkcję elementu członkowskiego.  
  
 Jeśli strona jest zablokowana, żaden inny użytkownik może edytować rekordy na tej samej stronie. Jeśli należy wywołać `SetLockingMode` i przekaż wartość niezerową i inny użytkownik ma już strony zablokowany, jest zgłaszany wyjątek podczas wywoływania **Edytuj**. Inni użytkownicy mogą odczytywać dane z zablokowanych stron.  
  
 Wywołanie `SetLockingMode` z wartością zero lub nowszym należy wywołać **aktualizacji** podczas, gdy strona jest zablokowany przez innego użytkownika, wystąpi wyjątek. Aby obejrzeć zmiany wprowadzone do rekordu przez innego użytkownika (i utracić zmiany), należy wywołać `SetBookmark` funkcja elementu członkowskiego o wartości zakładki bieżącego rekordu.  
  
 Podczas pracy ze źródłami danych ODBC, tryb blokowania jest zawsze optymistycznej.  
  
##  <a name="setparamvalue"></a>  CDaoRecordset::SetParamValue  
 Wywołanie tej funkcji członkowskich można ustawić wartości parametru w zestawie rekordów w czasie wykonywania.  
  
```  
virtual void SetParamValue(
    int nIndex,  
    const COleVariant& varValue);

 
virtual void SetParamValue(
    LPCTSTR lpszName,  
    const COleVariant& varValue);
```  
  
### <a name="parameters"></a>Parametry  
 `nIndex`  
 Numeryczne pozycja parametru w kolekcji Parameters querydef.  
  
 `var`  
 Wartość do ustawienia; Zobacz uwagi.  
  
 `lpszName`  
 Nazwa parametru, którego chcesz ustawić wartość.  
  
### <a name="remarks"></a>Uwagi  
 Parametr musi już zostały określone jako część ciągu SQL zestawu rekordów. Według nazwy lub jej indeks w kolekcji można uzyskać dostępu do parametru.  
  
 Określ wartość do ustawienia jako `COleVariant` obiektu. Informacje o ustawianiu na żądaną wartość i wpisz Twojej `COleVariant` obiektów, zobacz klasę [COleVariant](../../mfc/reference/colevariant-class.md). Należy pamiętać, że jeśli nie utworzysz zestaw rekordów UNICODE, `COleVariant` obiektu musi być jawnie deklarować ANSI. Można to zrobić za pomocą [COleVariant::COleVariant](../../mfc/reference/colevariant-class.md#colevariant)**(** `lpszSrc` **,** `vtSrc` **)** formę — Konstruktor z `vtSrc` ustawioną `VT_BSTRT` (ANSI) lub za pomocą **COleVariant** funkcja [SetString](../../mfc/reference/colevariant-class.md#setstring)**(** `lpszSrc` **,** `vtSrc` **)** z `vtSrc` ustawioną `VT_BSTRT`.  
  
##  <a name="setparamvaluenull"></a>  CDaoRecordset::SetParamValueNull  
 Wywołanie tej funkcji Członkowskich, aby ustawić parametr na wartość Null.  
  
```  
void SetParamValueNull(int nIndex);  
void SetParamValueNull(LPCTSTR lpszName);
```  
  
### <a name="parameters"></a>Parametry  
 `nIndex`  
 Indeks pole w zestawie rekordów do wyszukiwania przez liczony od zera indeks.  
  
 `lpszName`  
 Nazwa pola w zestawie rekordów do wyszukiwania według nazwy.  
  
### <a name="remarks"></a>Uwagi  
 C++ **NULL** nie jest taka sama jak wartość Null, co w terminologii bazy danych, oznacza to "o wartości".  
  
##  <a name="setpercentposition"></a>  CDaoRecordset::SetPercentPosition  
 Wywołanie tej funkcji Członkowskich, aby ustawić wartość, która zmienia przybliżonej lokalizacji bieżącego rekordu w obiekcie rekordów procentem rekordy w zestawie rekordów.  
  
```  
void SetPercentPosition(float fPosition);
```  
  
### <a name="parameters"></a>Parametry  
 *fPosition*  
 Liczbą z zakresu od 0 do 100.  
  
### <a name="remarks"></a>Uwagi  
 Podczas pracy z dynamicznego lub zestaw rekordów typu migawka, przenosząc do ostatniego rekordu przed wywołaniem najpierw wypełnić zestaw rekordów `SetPercentPosition`. Jeśli należy wywołać `SetPercentPosition` przed pełni wypełnianie zestawu rekordów, wielkość ruchu jest określana względem to liczba rekordów dostęp do określonych przez wartość [GetRecordCount](#getrecordcount). Można przenieść do ostatniego rekordu przez wywołanie metody `MoveLast`.  
  
 Po wywołaniu `SetPercentPosition`, bieżącym staje się rekord w pozycji przybliżonej odpowiadający tej wartości.  
  
> [!NOTE]
>  Wywoływanie `SetPercentPosition` można przenieść bieżącego rekordu do określonego rekordu w zestawie rekordów nie jest zalecane. Wywołanie [SetBookmark](#setbookmark) zamiast funkcji członkowskiej.  
  
 Powiązane informacje zobacz temat "PercentPosition Property" w pomocy DAO.  
  
##  <a name="update"></a>  CDaoRecordset::Update  
 Wywołanie tej funkcji Członkowskich po wywołaniu `AddNew` lub **Edytuj** funkcję elementu członkowskiego.  
  
```  
virtual void Update();
```  
  
### <a name="remarks"></a>Uwagi  
 To wywołanie jest wymagane do ukończenia `AddNew` lub **Edytuj** operacji.  
  
 Zarówno `AddNew` i **Edytuj** przygotowanie buforu edycji, w której znajduje się dodane lub zmodyfikowane dane do zapisu w źródle danych. **Aktualizacja** zapisuje dane. Tylko te pola oznaczone lub wykryte jako zmienione zostały zaktualizowane.  
  
 Jeśli źródło danych obsługuje transakcje, możesz wprowadzić **aktualizacji** wywołania (oraz odpowiednie `AddNew` lub **Edytuj** wywołać) częścią transakcji.  
  
> [!CAUTION]
>  Jeśli należy wywołać **aktualizacji** bez uprzedniego wywołania `AddNew` lub **Edytuj**, **aktualizacji** zgłasza `CDaoException`. Jeśli należy wywołać `AddNew` lub **Edytuj**, należy wywołać **aktualizacji** przed wywołaniem [MoveNext](#movenext) lub zamknąć połączenie ze źródłem danych albo zestawu rekordów. W przeciwnym razie wprowadzone zmiany zostaną utracone bez powiadomienia.  
  
 Gdy obiekt zestawu rekordów pessimistically jest zablokowana w środowisku wielodostępnym, rekord jest zablokowany od czasu **Edytuj** służy do zakończenia uaktualnienia. Jeśli zestaw rekordów według optymistycznych jest zablokowana, rekord jest zablokowana i tylko zanim zostaną one zaktualizowane w bazie danych w porównaniu z wstępnie edytowanego rekordu. Jeśli rekord został zmieniony, ponieważ wywołana **Edytuj**, **aktualizacji** operacja kończy się niepowodzeniem i MFC zgłasza wyjątek. Można zmienić tryb blokowania z `SetLockingMode`.  
  
> [!NOTE]
>  Optymistyczne blokowanie zawsze jest używany na formatów zewnętrznej bazy danych, takich jak ODBC i zainstalowania ISAM.  
  
 Aby uzyskać odpowiednie informacje zobacz tematy "AddNew — metoda", "CancelUpdate metoda", "Metody Delete", "LastModified Property", "Metody aktualizacji" i "EditMode Property" w pomocy DAO.  
  
## <a name="see-also"></a>Zobacz też  
 [CObject — klasa](../../mfc/reference/cobject-class.md)   
 [Diagram hierarchii](../../mfc/hierarchy-chart.md)   
 [Klasa CDaoTableDef](../../mfc/reference/cdaotabledef-class.md)   
 [Klasa CDaoWorkspace](../../mfc/reference/cdaoworkspace-class.md)   
 [Klasa CDaoDatabase](../../mfc/reference/cdaodatabase-class.md)   
 [Klasa CDaoQueryDef](../../mfc/reference/cdaoquerydef-class.md)

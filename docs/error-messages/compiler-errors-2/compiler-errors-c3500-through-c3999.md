---
title: Błędy kompilatora od C3500 do C3999 | Dokumentacja firmy Microsoft
ms.date: 11/17/2017
ms.technology:
- cpp-diagnostics
ms.topic: error-reference
f1_keywords:
- C3502
- C3503
- C3504
- C3511
- C3512
- C3513
- C3514
- C3515
- C3516
- C3517
- C3518
- C3520
- C3521
- C3522
- C3523
- C3524
- C3525
- C3526
- C3527
- C3528
- C3529
- C3534
- C3542
- C3543
- C3544
- C3545
- C3546
- C3547
- C3548
- C3549
- C3557
- C3558
- C3559
- C3560
- C3561
- C3562
- C3563
- C3564
- C3565
- C3566
- C3567
- C3568
- C3569
- C3570
- C3571
- C3572
- C3573
- C3574
- C3575
- C3576
- C3577
- C3578
- C3579
- C3580
- C3581
- C3582
- C3583
- C3584
- C3585
- C3586
- C3587
- C3588
- C3589
- C3590
- C3591
- C3592
- C3593
- C3594
- C3595
- C3596
- C3597
- C3598
- C3599
- C3600
- C3601
- C3602
- C3604
- C3605
- C3613
- C3614
- C3616
- C3620
- C3621
- C3635
- C3636
- C3649
- C3658
- C3659
- C3660
- C3663
- C3664
- C3667
- C3674
- C3676
- C3677
- C3678
- C3679
- C3680
- C3681
- C3682
- C3683
- C3684
- C3685
- C3686
- C3687
- C3688
- C3689
- C3690
- C3691
- C3696
- C3716
- C3720
- C3725
- C3726
- C3729
- C3730
- C3735
- C3742
- C3746
- C3750
- C3751
- C3756
- C3757
- C3758
- C3759
- C3760
- C3770
- C3773
- C3774
- C3775
- C3776
- C3777
- C3778
- C3779
- C3780
- C3781
- C3782
- C3783
- C3784
- C3785
- C3786
- C3787
- C3801
- C3802
- C3806
- C3811
- C3814
- C3819
- C3822
- C3823
- C3826
- C3827
- C3829
- C3837
- C3840
- C3841
- C3843
- C3844
- C3845
- C3863
- C3870
- C3871
- C3875
- C3879
- C3881
- C3882
- C3884
- C3885
- C3897
- C3905
- C3906
- C3916
- C3921
- C3924
- C3925
- C3926
- C3927
- C3928
- C3930
- C3931
- C3932
- C3933
- C3934
- C3935
- C3936
- C3937
- C3938
- C3939
- C3940
- C3941
- C3945
- C3946
- C3947
- C3948
- C3949
- C3950
- C3951
- C3952
- C3953
- C3954
- C3955
- C3956
- C3957
- C3958
- C3959
- C3960
- C3961
- C3962
- C3963
- C3964
- C3965
- C3966
- C3967
- C3968
- C3969
- C3970
- C3971
- C3972
- C3975
- C3976
- C3977
- C3978
- C3979
- C3980
- C3981
- C3982
- C3983
- C3984
- C3985
- C3986
- C3987
- C3988
- C3989
- C3990
- C3991
- C3992
- C3993
- C3994
- C3995
- C3996
- C3997
- C3998
- C3999
dev_langs:
- C++
ms.assetid: bd6f23ad-b300-4e07-8e35-9661cab1585f
author: corob-msft
ms.author: corob
ms.workload:
- cplusplus
ms.openlocfilehash: d1a157bcd3ecdce16a25d5bb6523ed6962a94a18
ms.sourcegitcommit: e9ce38decc9f986edab5543de3464b11ebccb123
ms.translationtype: MT
ms.contentlocale: pl-PL
ms.lasthandoff: 08/13/2018
ms.locfileid: "42465132"
---
# <a name="compiler-errors-c3500-through-c3999"></a>Błędy kompilatora od C3500 do C3999

Artykuły w tej sekcji dokumentacji wyjaśniają podzbiór komunikaty o błędach, które są generowane przez kompilator.

[!INCLUDE[error-boilerplate](../../error-messages/includes/error-boilerplate.md)]

## <a name="error-messages"></a>Komunikaty o błędach

|Błąd|Komunikat|
|-----------|-------------|
|[Błąd kompilatora C3500](compiler-error-c3500.md)|Nieprawidłowy ProgID "*progid*"|
|[Błąd kompilatora C3501](compiler-error-c3501.md)|ma żadnych zarejestrowanych typelib dla identyfikatora ProgID "*progid*"|
|C3502 błąd kompilatora|Nie można uzyskać identyfikatora LIBID dla ProgID "*progid*"|
|C3503 błąd kompilatora|znak "0 x*wartość*" nie jest dozwolona w nieprzetworzonego ciągu literału|
|C3504 błąd kompilatora|Nie można utworzyć identyfikatora GUID z ciągu "*ciąg*"|
|[Błąd kompilatora C3505](compiler-error-c3505.md)|Nie można załadować biblioteki typów '*biblioteki*"|
|[Błąd kompilatora C3506](compiler-error-c3506.md)|ma żadnych zarejestrowanych typelib dla identyfikatora LIBID "*biblioteki*"|
|[Błąd kompilatora C3507](compiler-error-c3507.md)|Identyfikator ProgID może zawierać nie więcej niż 39 znaków*progid*"; ani zawierać jakichkolwiek znaków interpunkcyjnych z wyjątkiem". "; ani rozpoczynających się od cyfry|
|[Błąd kompilatora C3508](compiler-error-c3508.md)|"*typu*": nie jest prawidłowym typem automatyzacji|
|[Błąd kompilatora C3509](compiler-error-c3509.md)|"*typu*": nieprawidłowy zwracany typ automatyzacji; gdy parametr jest oznaczony jako "retval", zwracanym typem musi być "void", "HRESULT" lub "SCODE"|
|[Błąd kompilatora C3510](compiler-error-c3510.md)|Nie można zlokalizować biblioteki typów zależnych *biblioteki*|
|C3511 błąd kompilatora|"*identyfikator*": wywołanie konstruktora delegującego powinny być jedyną inicjacją składowej|
|C3512 błąd kompilatora|ograniczająca sekwencja znaków dla literału nieprzetworzonego ciągu powinna mieć nie więcej niż 16 znaków|
|C3513 błąd kompilatora|"*ciąg*": nieobsługiwany znak ograniczający literał nieprzetworzonego ciągu|
|C3514 błąd kompilatora|"*znak*" (*wartość*): nieobsługiwany znak ograniczający literał nieprzetworzonego ciągu|
|C3515 błąd kompilatora|Jeśli argument częściowej specjalizacji szablonu klasy jest rozwinięciem pakietu powinien być ostatnim argumentem|
|C3516 błąd kompilatora|Nieoczekiwany koniec pliku znalezione podczas przetwarzania literału; nieprzetworzonego ciągu Sekwencja ogranicznika "*ciąg*" nie został dopasowany.|
|C3517 błąd kompilatora|"*identyfikator*" Deklaracja aliasu nie może mieć typu zawierającego "auto"|
|C3518 błąd kompilatora|"*identyfikator*": w kontekście bezpośredniego Inicjalizacja listy Typ dla "*typu*" można określić tylko na podstawie pojedynczego wyrażenia inicjatora|
|[Błąd kompilatora C3519](compiler-error-c3519.md)|"*parametr*": nieprawidłowy parametr dla atrybutu embedded_idl|
|C3520 błąd kompilatora|"*identyfikator*": pakiet parametrów musi być rozwinięty w tym kontekście|
|C3521 błąd kompilatora|"*identyfikator*" nie jest pakietem parametrów|
|C3522 błąd kompilatora|"*typu*": pakiet parametrów nie może być rozwinięty w tym kontekście|
|C3523 błąd kompilatora|"sizeof..." wymaga jako argument nierozwiniętego pakietu parametrów|
|C3524 błąd kompilatora|"*identyfikator*": "sizeof" nie można zastosować do pakietu parametrów. Czy zamierzałeś użyć "sizeof..."?|
|C3525 błąd kompilatora|"*parametr*": Jeśli szablon klasy ma pakiet parametrów szablonu, musi znajdować się na końcu listy parametrów szablonu|
|C3526 błąd kompilatora|"..." nie można zastosować do "this"|
|C3527 błąd kompilatora|"*identyfikator*" nie jest prawidłowym argumentem operacji "sizeof...". Czy zamierzałeś użyć "sizeof"?|
|C3528 błąd kompilatora|"*identifier1*": liczba elementów w tym rozwinięciu pakietu jest niezgodna z liczbą elementów w "*identifier2*"|
|C3529 błąd kompilatora|"*parametr*": pakiet parametrów szablonu nie może mieć argumentu domyślnego|
|[Błąd kompilatora C3530](compiler-error-c3530.md)|"*typu*" nie można łączyć z jakimkolwiek innym specyfikatorem typu|
|[Błąd kompilatora C3531](compiler-error-c3531.md)|"*identyfikator*": symbol, którego typ zawiera "*typu*" musi mieć inicjator|
|[Błąd kompilatora C3532](compiler-error-c3532.md)|Typ elementu tablicy nie może być typem zawierającym "*typu*"|
|[Błąd kompilatora C3533](compiler-error-c3533.md)|Parametr nie może mieć typu zawierającego "*typu*"|
|C3534 błąd kompilatora|Nieaktualne.|
|[Błąd kompilatora C3535](compiler-error-c3535.md)|Nie można ustalić typu "*type1*"from"*type2*"|
|[Błąd kompilatora C3536](compiler-error-c3536.md)|"*identyfikator*": nie można użyć, zanim zostanie zainicjowany|
|[Błąd kompilatora C3537](compiler-error-c3537.md)|Nie można rzutować na typ, który zawiera "*typu*"|
|[Błąd kompilatora C3538](compiler-error-c3538.md)|na liście deklaratorów "*typu*" należy zawsze ustalać do tego samego typu|
|[Błąd kompilatora C3539](compiler-error-c3539.md)|argument szablonu nie może być typem zawierającym "*typu*"|
|[Błąd kompilatora C3540](compiler-error-c3540.md)|Nie można zastosować operatora sizeof do typu, który zawiera "*typu*"|
|[Błąd kompilatora C3541](compiler-error-c3541.md)|TypeID, nie można zastosować do typu zawierającego "*typu*"|
|C3542 błąd kompilatora|"*identyfikator*": funkcja wirtualna elementu członkowskiego nie posiada zwracany typ, który zawiera "*typu*"|
|C3543 błąd kompilatora|"*typu*": nie zawiera pakietu parametrów|
|C3544 błąd kompilatora|"*parametr*": pakiet parametrów oczekuje argumentu szablonu typu|
|C3545 błąd kompilatora|"*parametr*": pakiet parametrów oczekuje argumentu szablonu bez typu|
|C3546 błąd kompilatora|"...": Brak pakietów parametrów dostępnych do rozwinięcia|
|C3547 błąd kompilatora|Parametr szablonu "*parametru*"nie można użyć, ponieważ następuje po pakiecie parametrów szablonu i nie można wywnioskować z parametrów funkcji"*funkcja*"|
|C3548 błąd kompilatora|"*identyfikator*": pakiet parametrów nie można używać w tym kontekście|
|C3549 błąd kompilatora|"*wartość*": pakiet parametrów funkcji nie może mieć argumentu domyślnego|
|[Błąd kompilatora C3550](compiler-error-c3550.md)|tylko zwykły elementu "decltype(auto)" jest dozwolony w tym kontekście|
|[Błąd kompilatora C3551](compiler-error-c3551.md)|Jeśli jest używane w końcowym typem zwracanym, a następnie typ zwracany jest pojedynczym specyfikatorem typu "auto" (nie "*typu*")|
|[Błąd kompilatora C3552](compiler-error-c3552.md)|Oczekiwano elementu "decltype(auto)"|
|[Błąd kompilatora C3553](compiler-error-c3553.md)|decltype oczekuje wyrażenia nie typu|
|[Błąd kompilatora C3554](compiler-error-c3554.md)|"*typu*" nie można łączyć z jakimkolwiek innym specyfikatorem typu|
|[Błąd kompilatora C3555](compiler-error-c3555.md)|Nieprawidłowy argument dla "decltype"|
|[Błąd kompilatora C3556](compiler-error-c3556.md)|"*wyrażenie*": nieprawidłowy argument dla "decltype"|
|C3557 błąd kompilatora|Nieaktualne.|
|C3558 błąd kompilatora|Nieaktualne.|
|C3559 błąd kompilatora|Wywołanie rekurencyjne dla "*funkcja*": rekursja została wykryta podczas kompilacji wykresu wywołań dla concurrency::parallel_for_each: "*funkcja*"|
|C3560 błąd kompilatora|"*funkcja*": IL jest niedostępne podczas kompilacji wykresu wywołań dla concurrency::parallel_for_each: "*funkcja*"|
|C3561 błąd kompilatora|znaleziono w przepływie sterowania, który nie jest różniącym podczas kompilacji wykresu wywołań dla concurrency::parallel_for_each operację bariery sąsiedniego: "*funkcja*"|
|C3562 błąd kompilatora|funkcja wewnętrzna "*funkcja*" jest ograniczona do nie mają więcej niż *numer* parametrów|
|C3563 błąd kompilatora|Wykryto nieskończoną pętlę podczas kompilacji wykresu wywołań dla concurrency::parallel_for_each: "*funkcja*"|
|C3564 błąd kompilatora|czytanie niezainicjalizowanej wartości podczas kompilacji wykresu wywołań dla concurrency::parallel_for_each: "*funkcja*"|
|C3565 błąd kompilatora|Całkowita ilość pamięci sąsiadująco rozmieszczonej statycznie (*numer* bajtów) przekracza limit wynoszący *numer* bajtów podczas kompilacji wykresu wywołań dla concurrency::parallel_for_each|
|C3566 błąd kompilatora|bloki z efektami ubocznymi zagnieżdżone zbyt głęboko podczas kompilacji wykresu wywołań dla concurrency::parallel_for_each: "*funkcja*"|
|C3567 błąd kompilatora|Dzielenie lub dzielenie modulo przez zero wykryta podczas kompilacji wykresu wywołań dla concurrency::parallel_for_each: "*funkcja*"|
|C3568 błąd kompilatora|Suma rejestrów przekracza limit wynoszący *numer* podczas kompilacji wykresu wywołań dla concurrency::parallel_for_each. Uprość program|
|C3569 błąd kompilatora|Wykryto podczas kompilacji wykresu wywołań dla concurrency::parallel_for_each sytuację wyścigu: "*funkcja*"|
|C3570 błąd kompilatora|niedozwolone użycie amp ograniczony zakres podczas kompilowania z/CLR|
|C3571 błąd kompilatora|"*typu*": niedozwolony argument domeny obliczeń; nie jest typem klasy|
|C3572 błąd kompilatora|"*typu*": niedozwolony argument domeny obliczeń; brak publicznej składowej: "static const int rank" lub wartość rankingowa jest Niedodatnia|
|C3573 błąd kompilatora|Liczba wystąpień concurrency::graphics::sampler przekazanych do concurrency::parallel_for_each nie może przekroczyć *numer*|
|C3574 błąd kompilatora|"*typu*": niedozwolone zakresy sąsiadujące: musi być dodatnia i (1) Z < = *numer*; (2) Z*Y*X < = *numer*|
|C3575 błąd kompilatora|"*typu*": niedozwolony argument domeny obliczeń; brak publicznej składowej: "concurrency::index <*numer*> _map_index (const concurrency::index <*numer*> &) restrict(amp) "|
|C3576 błąd kompilatora|"*typu*": concurrency::details::_Parallel_for_each argument #*numer* ma nieobsługiwany typ|
|C3577 błąd kompilatora|argument jądra CONCURRENCY::parallel_for_each jest niedozwolony: nie można rozwiązać wywołania do składowej "void operator() (*typu*) restrict(amp)"|
|C3578 błąd kompilatora|Rozmiar obiektu funkcji, przekazanych do concurrency::parallel_for_each nie może przekraczać *numer* bajtów|
|C3579 błąd kompilatora|Liczba wystąpień tylko do odczytu concurrency::array oraz CONCURRENCY::Graphics:: Texture przekazanych do concurrency::parallel_for_each nie może przekroczyć *numer*|
|C3580 błąd kompilatora|Liczba wystąpień do zapisu concurrency::array oraz CONCURRENCY::Graphics:: Texture przekazanych do concurrency::parallel_for_each nie może przekroczyć *numer*|
|C3581 błąd kompilatora|"*typu*": nieobsługiwany typ w amp z ograniczeniami kodu|
|C3582 błąd kompilatora|Nieaktualne.|
|C3583 błąd kompilatora|"*identyfikator*": rozmiar zmiennej (*numer* bajtów) jest większy niż maksymalny rozmiar (*numer* bajtów) są obsługiwane w kodzie amp z ograniczeniami|
|C3584 błąd kompilatora|nieobsługiwane użycie tile_static na "*identyfikator*"|
|C3585 błąd kompilatora|"*identyfikator*" klasy magazynu w amp ograniczył kodu|
|C3586 błąd kompilatora|"*identyfikator*": przy użyciu globalnych lub statycznych zmiennych jest nieobsługiwane w ograniczonym kodzie amp|
|C3587 błąd kompilatora|dynamic_cast jest nieobsługiwane w ograniczonym kodzie amp|
|C3588 błąd kompilatora|Rzutowanie z "*type1*"to"*type2*" jest nieobsługiwana w ograniczonym kodzie amp|
|C3589 błąd kompilatora|"*ciąg*": nieobsługiwane użycie literałów ciągów w amp z ograniczeniami kodu|
|C3590 błąd kompilatora|"*tokenu*": Przechwytywanie przez odwołanie lub przechwytywania "this" jest nieobsługiwane, jeżeli wyrażenie lambda jest ograniczone przez amp|
|C3591 błąd kompilatora|TypeID operator jest nieobsługiwany w ograniczonym kodzie amp|
|C3592 błąd kompilatora|Wbudowany natywny zestaw (__asm) jest nieobsługiwana w ograniczonym kodzie amp|
|C3593 błąd kompilatora|Instrukcja "goto" jest nieobsługiwana w ograniczonym kodzie amp|
|C3594 błąd kompilatora|Obsługa (try, catch, throw itp.) wyjątków jest nieobsługiwana w ograniczonym kodzie amp|
|C3595 błąd kompilatora|wartość stała jest poza obsługiwanym zakresem w ograniczonym kodzie amp|
|C3596 błąd kompilatora|"*parametru*" ("*typu*"): zmienna przechwycona przez lambda ma nieobsługiwany typ w ograniczonym kodzie amp|
|C3597 błąd kompilatora|"*parametru*": "*identyfikator*" nie może być przechwytywane przez wartość, jeśli wyrażenie lambda jest ograniczone przez amp|
|C3598 błąd kompilatora|Etykieta instrukcji jest nieobsługiwana w ograniczonym kodzie amp|
|C3599 błąd kompilatora|"*operator*": nie można wykonać arytmetyki wskaźnika na wskaźniku do wartości logicznej, w ograniczonym kodzie amp|
|C3600 błąd kompilatora|"*funkcji*": Użyj kafelka\_pamięci statycznej wykryta podczas kompilacji wykresu wywołań dla concurrency::parallel niekafelkowanego\_for_each na: "*funkcja*"|
|C3601 błąd kompilatora|"*typu*": jest nieprawidłowym typem argumentu dla diagnostycznej funkcji amp "*funkcja*"|
|C3602 błąd kompilatora|Wykryto podczas kompilacji wykresu wywołań dla concurrency::parallel_for_each nieobsługiwany przepływ sterowania: "*funkcja*"|
|[Błąd kompilatora C3603](compiler-error-c3603.md)|"*symbol*": typ "*typu*" nie jest jeszcze obsługiwany|
|C3604 błąd kompilatora|"*identyfikator*": tylko można utworzyć obiekt zarządzany na stercie gc|
|C3605 błąd kompilatora|Całkowita liczba próbników (*numer* przechwytywane i *numer* wstępnie zdefiniowanych) przekracza *numer* podczas kompilacji wykresu wywołań dla concurrency::parallel_for_each: " *Funkcja*"|
|C3606 błąd kompilatora|Nieaktualne.|
|C3607 błąd kompilatora|Nieaktualne.|
|C3608 błąd kompilatora|Nieaktualne.|
|[Błąd kompilatora C3609](compiler-error-c3609.md)|"*identyfikator*": funkcja "zapieczętowany/final" musi być funkcją wirtualną|
|[Błąd kompilatora C3610](compiler-error-c3610.md)|"*identyfikator*": typ wartościowy musi być "boxed" przed metodą "*metoda*" może być wywoływany|
|[Błąd kompilatora C3611](compiler-error-c3611.md)|"*identyfikator*": funkcja zapieczętowana nie może mieć czystego specyfikatora|
|[Błąd kompilatora C3612](compiler-error-c3612.md)|"*identyfikator*": Klasa zapieczętowana nie może mieć żadnych czystych metod wirtualnych|
|C3613 błąd kompilatora|Brak typu zwracanego po "->" ("zakładany jest int")|
|C3614 błąd kompilatora|Różne wartości rozmiaru pakietu w tej samej klasie; poprzedniej została "*wartość*", nowa wartość to"*wartość*"|
|[Błąd kompilatora C3615](compiler-error-c3615.md)|Funkcja constexpr "*funkcja*" nie może być wyrażeniem stałym|
|C3616 błąd kompilatora|Nieaktualne.|
|C3617 błąd kompilatora|Nieaktualne.|
|[Błąd kompilatora C3618](compiler-error-c3618.md)|"*deklaracji*": nie można zdefiniować metody oznaczonej jako DllImport|
|[Błąd kompilatora C3619](compiler-error-c3619.md)|Nie można deklarować szablonu w ramach typu zarządzanego WinRT|
|C3620 błąd kompilatora|"*typu*": ustawienie wyrównania jest niedozwolone dla typów WinRT|
|C3621 błąd kompilatora|"*typu*": tylko domyślna wartość pakowania (*numer*) jest dozwolona dla typów WinRT|
|[Błąd kompilatora C3622](compiler-error-c3622.md)|*Typ*": klasy zadeklarowanej jako"*— słowo kluczowe*"nie można utworzyć wystąpienia|
|[Błąd kompilatora C3623](compiler-error-c3623.md)|"*identyfikator*": pola bitowe nie są obsługiwane w typach zarządzanych/WinRT|
|[Błąd kompilatora C3624](compiler-error-c3624.md)|"*typu*": stosowanie tego typu wymaga odwołania do zestawu/modułu "*identyfikator*"|
|[Błąd kompilatora C3625](compiler-error-c3625.md)|"*klasy*": typ natywny nie może pochodzić od typu zarządzanego WinRT "*typu*"|
|[Błąd kompilatora C3626](compiler-error-c3626.md)|"*identyfikator*": "*— słowo kluczowe*" — słowo kluczowe należy używać tylko na interfejsów COM, funkcji składowych i składowych danych, które są wskaźnikami do delegatów|
|[Błąd kompilatora C3627](compiler-error-c3627.md)|Można go opakować typ wartości|
|[Błąd kompilatora C3628](compiler-error-c3628.md)|"*klasy*': klas zarządzanych/WinRT obsługują tylko publiczne dziedziczenie|
|C3629 błąd kompilatora|"*tokenu*": wartość domyślna przechwytywania może wystąpić tylko na początku listy przechwytywania lambda|
|[Błąd kompilatora C3630](compiler-error-c3630.md)|Wystąpił błąd podczas przetwarzania tokenu "*tokenu*"|
|[Błąd kompilatora C3631](compiler-error-c3631.md)|"*zdarzeń*": nie można przeciążyć zdarzeń zarządzanych/WinRT|
|[Błąd kompilatora C3632](compiler-error-c3632.md)|"*zdarzeń*": niedozwolony styl zdarzenia dla *konstruowania*|
|[Błąd kompilatora C3633](compiler-error-c3633.md)|Nie można zdefiniować "*identyfikator*"as "zarządzane przez członkiem*klasy*"|
|[Błąd kompilatora C3634](compiler-error-c3634.md)|"*elementu członkowskiego*": nie można definiować metody abstrakcyjnej klasy zarządzane/WinRT|
|C3635 błąd kompilatora|"*identyfikator*": nie można zastosować do klasy zarządzane WinRT (Użyj "*identyfikator*" zamiast)|
|C3636 błąd kompilatora|"*identyfikator*": nie można zastosować do tego typu|
|[Błąd kompilatora C3637](compiler-error-c3637.md)|"*funkcja*": definicja funkcji zaprzyjaźnionej nie może być specjalizacją szablonu funkcji/ogólne|
|[Błąd kompilatora C3638](compiler-error-c3638.md)|"*operator*": nie można przedefiniować standardowej konwersji boxing i operatory konwersji rozpakowującej|
|C3639 błąd kompilatora|Nieaktualne.|
|[Błąd kompilatora C3640](compiler-error-c3640.md)|"*elementu członkowskiego*": odwołanie lub wirtualna składowa lokalnej klasy musi być zdefiniowany.|
|[Błąd kompilatora C3641](compiler-error-c3641.md)|"*funkcja*": Nieprawidłowa konwencja wywoływania '*Konwencji*"dla funkcji kompilowanych z/CLR: pure lub/CLR: Safe|
|[Błąd kompilatora C3642](compiler-error-c3642.md)|"*funkcja*": nie można wywołać funkcji w Konwencji wywołania __clrcall z natywnego kodu|
|C3643 błąd kompilatora|Nieaktualne.|
|[Błąd kompilatora C3644](compiler-error-c3644.md)|"*funkcja*": nie można skompilować funkcji do generowania kodu zarządzanego|
|[Błąd kompilatora C3645](compiler-error-c3645.md)|"*funkcja*": __clrcall nie można używać w funkcjach skompilowanych do natywnego kodu|
|[Błąd kompilatora C3646](compiler-error-c3646.md)|"*identyfikator*": nieznany specyfikator przesłonięcia|
|C3647 błąd kompilatora|Nieaktualne.|
|[Błąd kompilatora C3648](compiler-error-c3648.md)|Ta składnia jawnego przesłaniania nie jest obsługiwana w typach zarządzanych|
|C3649 błąd kompilatora|Ta składnia jawnego przesłaniania nie jest dozwolona z /ZW|
|[Błąd kompilatora C3650](compiler-error-c3650.md)|"*elementu członkowskiego*": nie można użyć jako jawnego przesłaniania, musi być wirtualną składową klasy bazowej|
|[Błąd kompilatora C3651](compiler-error-c3651.md)|"*elementu członkowskiego*": nie można użyć jako jawnego przesłaniania, musi należeć do klasy bazowej|
|[Błąd kompilatora C3652](compiler-error-c3652.md)|"*elementu członkowskiego*": funkcja, która jawnie przesłania, musi być wirtualna|
|[Błąd kompilatora C3653](compiler-error-c3653.md)|"*identyfikator*": nie można użyć jako nazwanego przesłaniania: przesłaniana funkcja nie znaleziona; czy pamiętasz o nadaj funkcji nazwę jawnie, przy użyciu: operator?|
|[Błąd kompilatora C3654](compiler-error-c3654.md)|"*tokenu*": błąd składni w jawnym przesłanianiu|
|[Błąd kompilatora C3655](compiler-error-c3655.md)|"*elementu członkowskiego*": funkcja została już jawnie przesłonięta|
|[Błąd kompilatora C3656](compiler-error-c3656.md)|"*— słowo kluczowe*": Zastąp specyfikator nie może powtarzać się|
|[Błąd kompilatora C3657](compiler-error-c3657.md)|destruktor/finalizator nie można jawnie przesłonić lub być jawnie przesłonięte|
|C3658 błąd kompilatora|Nieaktualne.|
|C3659 błąd kompilatora|"*elementu członkowskiego*": specyfikator override "*— słowo kluczowe*" nie jest obsługiwana|
|C3660 błąd kompilatora|"*Członek1*": ukrywa dziedziczoną składową "*członek2*"|
|[Błąd kompilatora C3661](compiler-error-c3661.md)|Lista jawnego przesłaniania nie znalazła żadnych metod aby je przesłonić|
|[Błąd kompilatora C3662](compiler-error-c3662.md)|"*elementu członkowskiego*": specyfikator override "*— słowo kluczowe*" dozwolone tylko dla funkcji składowych klas zarządzanych/WinRT|
|C3663 błąd kompilatora|Nieaktualne.|
|C3664 błąd kompilatora|"*elementu członkowskiego*": nie można użyć jako jawnego przesłaniania, musi mieć dostępność "public" lub "protected"|
|[Błąd kompilatora C3665](compiler-error-c3665.md)|"*elementu członkowskiego*": specyfikator override "*— słowo kluczowe*" nie jest dozwolone na destruktora/finalizatorze|
|[Błąd kompilatora C3666](compiler-error-c3666.md)|"*Konstruktor*": specyfikator override "*— słowo kluczowe*" nie jest dozwolony na konstruktorze|
|C3667 błąd kompilatora|"*atrybut*": atrybut nie obsługuje rozwinięcia pakietu|
|[Błąd kompilatora C3668](compiler-error-c3668.md)|"*elementu członkowskiego*": metoda ze specyfikatorem przesłonięcia "override" nie przesłania żadnej metody klasy bazowej|
|[Błąd kompilatora C3669](compiler-error-c3669.md)|"*elementu członkowskiego*": specyfikator override nie "override" dozwolony dla funkcji statycznych składowych lub konstruktory|
|[Błąd kompilatora C3670](compiler-error-c3670.md)|"*elementu członkowskiego*": nie można przesłonić metody niedostępnej klasy bazowej "*elementu członkowskiego*"|
|[Błąd kompilatora C3671](compiler-error-c3671.md)|"*elementu członkowskiego*": funkcja nie przesłania "*elementu członkowskiego*"|
|[Błąd kompilatora C3672](compiler-error-c3672.md)|wyrażenie pseudo-destruktora może służyć jedynie jako część wywołania funkcji|
|[Błąd kompilatora C3673](compiler-error-c3673.md)|"*klasy*": klasa nie ma konstruktora kopiującego|
|C3674 błąd kompilatora|Nie można odnaleźć modułu biblioteki standardowej "*modułu*"|
|[Błąd kompilatora C3675](compiler-error-c3675.md)|"*funkcja*": jest zarezerwowana, ponieważ "*właściwość*" jest zdefiniowana|
|C3676 błąd kompilatora|"*klasy*": klasa ref i klasa bazowa mają niezgodne atrybuty "[*atrybut*]"|
|C3677 błąd kompilatora|literał ciągu po 'operator' nie może mieć prefiksu kodowania|
|C3678 błąd kompilatora|literał ciągu po 'operator' musi być ciągiem pustym "" "" "|
|C3679 błąd kompilatora|Oczekiwano identyfikatora sufiksu literału po "operator" "" "|
|C3680 błąd kompilatora|Nie można połączyć Literały ciągu zdefiniowany przez użytkownika z niezgodnymi identyfikatorami sufiksów literałów|
|C3681 błąd kompilatora|"fallthrough": atrybut może występować tylko w otaczającej instrukcji switch|
|C3682 błąd kompilatora|"operator *identyfikator*": szablon operatora literału operator/literału nie może być zadeklarowana w zapewnienie "Powiązanie C"|
|C3683 błąd kompilatora|Nie można zdefiniować nieprzetworzonego operatora literału i szablonu operatora literału z tym samym identyfikatorem sufiksu literału|
|C3684 błąd kompilatora|"operator *identyfikator*": deklaracja operatora literału ma nieprawidłową listę parametrów|
|C3685 błąd kompilatora|"operator *identyfikator*": szablon operatora literału nie może mieć parametrów funkcji|
|C3686 błąd kompilatora|"operator *identyfikator*": szablon operatora literału musi mieć dokładnie jeden parametr szablonu będący pakietem parametrów|
|C3687 błąd kompilatora|"operator *identyfikator*": szablon operatora literału musi mieć parametr szablonu bez typu o typie "char"|
|C3688 błąd kompilatora|Nieprawidłowy sufiks literału "*sufiks*"; literał operatora lub szablon operatora literału "operator *identyfikator*" nie znaleziono|
|C3689 błąd kompilatora|"operator *identyfikator*": szablon operatora literału operator/literału musi być w zakresie globalnym lub przestrzeni nazw|
|C3690 błąd kompilatora|Oczekiwano literału ciągu, ale znaleziono ciągiem zdefiniowanym przez użytkownika literałów|
|C3691 błąd kompilatora|Nieprawidłowy prefiks literału "*prefiks*"|
|C3692 błąd kompilatora|Nieaktualne.|
|C3693 błąd kompilatora|Nieaktualne.|
|C3694 błąd kompilatora|Nieaktualne.|
|C3695 błąd kompilatora|Nieaktualne.|
|C3696 błąd kompilatora|"*— słowo kluczowe*": nie można użyć tego kwalifikatora na "%"|
|[Błąd kompilatora C3697](compiler-error-c3697.md)|"*— słowo kluczowe*": nie można użyć tego kwalifikatora na "^"|
|[Błąd kompilatora C3698](compiler-error-c3698.md)|"*typu*": nie można użyć tego typu jako argumentu "*operator*"|
|[Błąd kompilatora C3699](compiler-error-c3699.md)|"*operator*": nie można użyć tego operatora pośredniego na typie "*typu*"|
|C3700 błąd kompilatora|Nieaktualne.|
|[Błąd kompilatora C3701](compiler-error-c3701.md)|"*funkcja*": źródło zdarzeń nie ma żadnych zdarzeń|
|[Błąd kompilatora C3702](compiler-error-c3702.md)|ATL jest wymagany dla zdarzeń COM|
|[Błąd kompilatora C3703](compiler-error-c3703.md)|"*event_handler*": metoda obsługi zdarzeń musi mieć tą samą klasę magazynu jako źródło "*zdarzeń*"|
|[Błąd kompilatora C3704](compiler-error-c3704.md)|"*elementu członkowskiego*": metoda vararg nie może wyzwalać zdarzeń|
|[Błąd kompilatora C3705](compiler-error-c3705.md)|"*funkcja*": nie można odnaleźć interfejsu zdarzeń|
|[Błąd kompilatora C3706](compiler-error-c3706.md)|"*funkcja*": musi być interfejsem COM żeby wyzwalać zdarzenia COM|
|[Błąd kompilatora C3707](compiler-error-c3707.md)|"*elementu członkowskiego*": metoda dispinterface musi posiadać identyfikator dispid|
|[Błąd kompilatora C3708](compiler-error-c3708.md)|"*funkcja*": nieprawidłowe użycie "*— słowo kluczowe*"; musi należeć do zgodnego źródła zdarzeń|
|[Błąd kompilatora C3709](compiler-error-c3709.md)|"*funkcja*": Niewłaściwa składnia określająca zdarzenie w __hook/__unhook|
|[Błąd kompilatora C3710](compiler-error-c3710.md)|"*funkcja*": Niewłaściwa składnia określająca obsługę zdarzeń w __hook/__unhook|
|[Błąd kompilatora C3711](compiler-error-c3711.md)|"*zdarzeń*": metoda źródła zdarzeń niezarządzany musi zwrócić void lub typ całkowity|
|[Błąd kompilatora C3712](compiler-error-c3712.md)|"*event_handler*": metoda obsługi zdarzeń musi zwracać taki sam typ jak źródło "*zdarzeń*"|
|[Błąd kompilatora C3713](compiler-error-c3713.md)|"*event_handler*": metoda obsługi zdarzeń musi mieć te same parametry funkcji jako źródło "*zdarzeń*"|
|[Błąd kompilatora C3714](compiler-error-c3714.md)|"*event_handler*": metoda obsługi zdarzeń musi mieć tą samą konwencję wywołania jako źródło "*zdarzeń*"|
|[Błąd kompilatora C3715](compiler-error-c3715.md)|"*wskaźnik*": musi być wskaźnikiem do "*typu*"|
|C3716 błąd kompilatora|Nieaktualne.|
|[Błąd kompilatora C3717](compiler-error-c3717.md)|"*elementu członkowskiego*": metoda wyzwalająca zdarzenia nie może być zdefiniowana|
|[Błąd kompilatora C3718](compiler-error-c3718.md)|można tylko wywołania "__*— słowo kluczowe*" w kontekście funkcji składowej klasy odbiorczej|
|[Błąd kompilatora C3719](compiler-error-c3719.md)|"*elementu członkowskiego*": źródło zdarzeń bazujące na interfejsie należy używać tylko dla zdarzeń COM|
|C3720 błąd kompilatora|"*typu*": można tylko zaimplementować interfejs IDispatch podwójnie lub dispinterface|
|[Błąd kompilatora C3721](compiler-error-c3721.md)|"*podpisu*": niezgodny podpis dla zdarzenia|
|[Błąd kompilatora C3722](compiler-error-c3722.md)|Zdarzenie generyczne nie jest dozwolone.|
|[Błąd kompilatora C3723](compiler-error-c3723.md)|"*funkcja*": nie można rozpoznać zdarzenia|
|[Błąd kompilatora C3724](compiler-error-c3724.md)|należy #include < windows.h > Aby użyć wielowątkowości ze zdarzeniami|
|C3725 błąd kompilatora|Nieaktualne.|
|C3726 błąd kompilatora|Nieaktualne.|
|[Błąd kompilatora C3727](compiler-error-c3727.md)|"*zdarzeń*": zdarzenie zarządzane musi być funkcją składową lub składową danych będącą wskaźnikiem do delegata|
|[Błąd kompilatora C3728](compiler-error-c3728.md)|"*zdarzeń*": zdarzenie nie posiada metody wzrostu|
|C3729 błąd kompilatora|Nieaktualne.|
|C3730 błąd kompilatora|Nieaktualne.|
|[Błąd kompilatora C3731](compiler-error-c3731.md)|niezgodne zdarzenie "*zdarzeń*"i procedury obsługi"*event_handler*"; źródło zdarzeń i program obsługi zdarzeń musi mieć ten sam typ zdarzenia|
|[Błąd kompilatora C3732](compiler-error-c3732.md)|"*interfejsu*": niestandardowy interfejs wyzwalający zdarzenia COM nie można dziedziczyć interfejsu IDispatch|
|[Błąd kompilatora C3733](compiler-error-c3733.md)|"*zdarzeń*": Niewłaściwa składnia określająca zdarzenie COM; czy pamiętasz o "__interface"?|
|[Błąd kompilatora C3734](compiler-error-c3734.md)|"*klasy*": klasa zarządzana WinRT nie może być klasą coclass|
|C3735 błąd kompilatora|Nieaktualne.|
|[Błąd kompilatora C3736](compiler-error-c3736.md)|"*elementu członkowskiego*": musi być metodą lub, w przypadku zarządzanych zdarzeń, opcjonalnie składową danych|
|[Błąd kompilatora C3737](compiler-error-c3737.md)|"*identyfikator*": Delegat może nie mieć jawnej konwencji wywoływania|
|[Błąd kompilatora C3738](compiler-error-c3738.md)|"*Konwencji*": Konwencja wywołania jawnego utworzenia wystąpienia musi być zgodna z szablonu wystąpienia|
|[Błąd kompilatora C3739](compiler-error-c3739.md)|"*klasy*": składnia jest tylko obsługiwane w przypadku "układ\_zależnego" parametr od event_receiver ma wartość true|
|[Błąd kompilatora C3740](compiler-error-c3740.md)|"*szablonu*": szablony nie źródła lub odbieranie zdarzeń|
|[Błąd kompilatora C3741](compiler-error-c3741.md)|"*klasy*": musi być klasą coclass gdy "układ\_zależnego" parametr od event_receiver ma wartość true|
|C3742 błąd kompilatora|"*token1*": nieprawidłowo ustawiona sekwencja tokenów w argumencie atrybutu "*atrybut*", oczekiwano"*token2*"|
|[Błąd kompilatora C3743](compiler-error-c3743.md)|można tylko zaczepić/odczepić cały interfejs podczas parametr "layout_dependent" od event_receiver ma wartość true|
|[Błąd kompilatora C3744](compiler-error-c3744.md)|__unhook musi mieć co najmniej 3 argumenty dla zdarzeń zarządzanych|
|[Błąd kompilatora C3745](compiler-error-c3745.md)|"*funkcja*": tylko zdarzenie może być "raised"|
|C3746 błąd kompilatora|Atrybut standardowy "*identyfikator*" może występować co najwyżej raz na liście atrybutów|
|[Błąd kompilatora C3747](compiler-error-c3747.md)|Brak domyślnego parametru szablonu/ogólne: parametr *numer*|
|[Błąd kompilatora C3748](compiler-error-c3748.md)|"*interfejsu*": interfejsy niezarządzane nie mogą wyzwalać zdarzeń|
|[Błąd kompilatora C3749](compiler-error-c3749.md)|"*atrybut*": atrybut niestandardowy nie można używać wewnątrz funkcji|
|C3750 błąd kompilatora|"*tokenu*": nieoczekiwany token na liście atrybutów|
|C3751 błąd kompilatora|"*identyfikator*": nieoczekiwany identyfikator na liście atrybutów|
|[Błąd kompilatora C3752](compiler-error-c3752.md)|"*atrybut*": nie można sklasyfikować atrybutu; "*— słowo kluczowe*" nie powinny być używane w tym kontekście|
|[Błąd kompilatora C3753](compiler-error-c3753.md)|Właściwość generyczna nie jest dozwolona.|
|[Błąd kompilatora C3754](compiler-error-c3754.md)|Konstruktor delegata: funkcja składowa "*elementu członkowskiego*"nie można wywołać dla wystąpienia typu"*typu*"|
|[Błąd kompilatora C3755](compiler-error-c3755.md)|"*identyfikator*": Delegat może nie być zdefiniowana.|
|C3756 błąd kompilatora|Nieaktualne.|
|C3757 błąd kompilatora|"*typu*": typ nie jest dozwolony dla funkcji "constexpr"|
|C3758 błąd kompilatora|"*elementu członkowskiego*": funkcja wirtualna nie można zadeklarować jako "constexpr"|
|C3759 błąd kompilatora|"*elementu członkowskiego*": funkcja składowa typu innego niż literał nie można zadeklarować jako "constexpr"|
|C3760 błąd kompilatora|Użyj słowa kluczowego __property Aby zadeklarować właściwość w zarządzanych/WinRT "*klasy*"|
|[Błąd kompilatora C3761](compiler-error-c3761.md)|"*funkcja*": "retval" może wystąpić tylko jako ostatni argument funkcji|
|[Błąd kompilatora C3762](compiler-error-c3762.md)|Nie można przetworzyć atrybutu "*atrybut*"|
|[Błąd kompilatora C3763](compiler-error-c3763.md)|"*typu*": "retval" i "out" może występować tylko w typie wskaźnikowych danych|
|[Błąd kompilatora C3764](compiler-error-c3764.md)|"*elementu członkowskiego*": nie można przesłonić metody klasy bazowej "*elementu członkowskiego*"|
|[Błąd kompilatora C3765](compiler-error-c3765.md)|"*zdarzeń*": nie można zdefiniować określone zdarzenie w klasie/strukturze "*typu*" oznaczonej jako event_receiver|
|[Błąd kompilatora C3766](compiler-error-c3766.md)|"*typu*"musi dostarczyć implementację metody interfejsu"*funkcja*"|
|[Błąd kompilatora C3767](compiler-error-c3767.md)|"*funkcja*": kandydujące nie jest dostępny|
|[Błąd kompilatora C3768](compiler-error-c3768.md)|Nie można przyjąć adresu wirtualnej funkcji vararg w czystym kodzie zarządzanym|
|[Błąd kompilatora C3769](compiler-error-c3769.md)|"*identyfikator*": zagnieżdżona klasa nie może mieć taką samą nazwę jako natychmiastowo otaczającą klasę|
|C3770 błąd kompilatora|"*typu*": nie jest prawidłową klasę podstawową|
|[Błąd kompilatora C3771](compiler-error-c3771.md)|"*identyfikator*": deklaracja zaprzyjaźniona nie można znaleźć w najbliższym zakresie przestrzeni nazw|
|[Błąd kompilatora C3772](compiler-error-c3772.md)|"*identyfikator*": Nieprawidłowa deklaracja szablonu zaprzyjaźnionego|
|C3773 błąd kompilatora|należy użyć przełącznika kompilatora / await w celu włączenia procedur wspólnych|
|C3774 błąd kompilatora|Nie można odnaleźć '*zakres*::*identyfikator*": Dołącz *nagłówka* nagłówka|
|C3775 błąd kompilatora|zwracany typ "*funkcja*"nie powinien być"*typu*"|
|C3776 błąd kompilatora|Nie można zwrócić, wyrażenie typu void w koprocedury za pomocą ostatecznej zwracany typ inny niż void|
|C3777 błąd kompilatora|"*funkcja*": procedura wspólna nie może mieć zmiennej listy argumentów|
|C3778 błąd kompilatora|alloca: nie można używać w procedurze wspólnej|
|C3779 błąd kompilatora|"*funkcja*": funkcja, która zwraca "*typu*" nie można użyć, zanim zostanie on zdefiniowany|
|C3780 błąd kompilatora|"*funkcja*": funkcja konwersji, która zwraca*typu*"nie można użyć, zanim zostanie on zdefiniowany|
|C3781 błąd kompilatora|"*— słowo kluczowe*": nie może być używane jako procedura wspólna typu "*typu*". Albo *— słowo kluczowe* lub *— słowo kluczowe* w skojarzonych promise_type musi znajdować się|
|C3782 błąd kompilatora|*Typ*: procedura wspólna nie może zawierać zarówno *— słowo kluczowe* i *— słowo kluczowe*|
|C3783 błąd kompilatora|"*identyfikator*": nie może być koprocedurą|
|C3784 błąd kompilatora|*słowo kluczowe* wyrażenia nie może występować w tym kontekście|
|C3785 błąd kompilatora|pierwszy argument szablonu dla elementu "STD::integer_sequence" musi być typu całkowitego|
|C3786 błąd kompilatora|drugi argument szablonu "std::make_integer_sequence" musi być stała liczba całkowita większa lub równa zero|
|C3787 błąd kompilatora|Nie można wywnioskować zwracanego typu tej współprocedury|
|C3788 błąd kompilatora|Nieaktualne.|
|C3789 błąd kompilatora|Nieaktualne.|
|C3790 błąd kompilatora|Nieaktualne.|
|C3791 błąd kompilatora|Nieaktualne.|
|C3792 błąd kompilatora|Nieaktualne.|
|C3793 błąd kompilatora|Nieaktualne.|
|C3794 błąd kompilatora|Nieaktualne.|
|C3795 błąd kompilatora|Nieaktualne.|
|C3796 błąd kompilatora|Nieaktualne.|
|[Błąd kompilatora C3797](compiler-error-c3797.md)|"*— słowo kluczowe*": deklaracja zdarzenia nie może posiadać specyfikatora przesłonięcia (powinna być umieszczona dla metod dodawania/usuwania/podbicia zdarzeń zamiast)|
|[Błąd kompilatora C3798](compiler-error-c3798.md)|"*— słowo kluczowe*": deklaracja właściwości nie może posiadać specyfikatora przesłonięcia (powinna być umieszczona dla właściwości get/set metody zamiast)|
|[Błąd kompilatora C3799](compiler-error-c3799.md)|indeksowana właściwość nie może mieć pustą listę parametrów|
|[Błąd kompilatora C3800](compiler-error-c3800.md)|"*deklaracji*": nie można mieszać właściwości i zdarzenia|
|C3801 błąd kompilatora|"*atrybut*": atrybut nie może mieć klauzuli argumentu|
|C3802 błąd kompilatora|Nieaktualne.|
|[Błąd kompilatora C3803](compiler-error-c3803.md)|"*właściwość*": właściwość ma typ, który jest niezgodny z jednym z jego metod dostępu*akcesor*"|
|[Błąd kompilatora C3804](compiler-error-c3804.md)|"*elementu członkowskiego*": metody dostępu dla właściwości muszą albo być wszystkie statyczne albo wszystkie Niestatyczne|
|[Błąd kompilatora C3805](compiler-error-c3805.md)|"*tokenu*": nieoczekiwany token, oczekiwano albo "}"lub ","|
|C3806 błąd kompilatora|"*tokenu*": nieoczekiwany token, oczekiwano albo "{" lub inicjator składowej|
|[Błąd kompilatora C3807](compiler-error-c3807.md)|"*typu*": klasa z atrybutem ComImport nie może pochodzić od "*typu*", tylko implementacja interfejsu jest dozwolona|
|[Błąd kompilatora C3808](compiler-error-c3808.md)|"*typu*": klasa z atrybutem ComImport nie może definiować składowej "*elementu członkowskiego*", tylko abstrakcyjne lub dllimport funkcje są dozwolone|
|[Błąd kompilatora C3809](compiler-error-c3809.md)|"*typu*": typ zarządzany WinRT nie może mieć żadnych friend funkcji/klas/interfejsów|
|C3810 błąd kompilatora|Nieaktualne.|
|C3811 błąd kompilatora|Nieaktualne.|
|[Błąd kompilatora C3812](compiler-error-c3812.md)|"__property" musi być pierwszym tokenem w deklaracji właściwości|
|[Błąd kompilatora C3813](compiler-error-c3813.md)|Deklaracja właściwości może wystąpić tylko wewnątrz definicji typu zarządzanego WinRT|
|C3814 błąd kompilatora|Nieaktualne.|
|[Błąd kompilatora C3815](compiler-error-c3815.md)|zwracany typ metody "*elementu członkowskiego*" musi odpowiadać typowi ostatniego parametru metody ustawiającej|
|[Błąd kompilatora C3816](compiler-error-c3816.md)|"klasie/strukturze *elementu członkowskiego*" poprzednio zadeklarowany lub zdefiniowany za pomocą innego modyfikatora managed WinRT|
|[Błąd kompilatora C3817](compiler-error-c3817.md)|"*deklaracji*": właściwość może zostać zastosowana tylko do funkcji|
|[Błąd kompilatora C3818](compiler-error-c3818.md)|Deklaracja właściwości tablicy "*właściwość*"nie powinny przeciążać właściwości indeksu"*właściwość*"|
|C3819 błąd kompilatora|Nieaktualne.|
|[Błąd kompilatora C3820](compiler-error-c3820.md)|"*identyfikator*": inicjatory muszą być zarządzane|
|[Błąd kompilatora C3821](compiler-error-c3821.md)|"*funkcja*": typ zarządzany lub funkcja nie można używać w funkcji niezarządzanej|
|C3822 błąd kompilatora|Nieaktualne.|
|C3823 błąd kompilatora|Nieaktualne.|
|[Błąd kompilatora C3824](compiler-error-c3824.md)|"*typu*": ten typ nie może występować w tym kontekście (parametr funkcji, zwracany typ lub składową statyczną)|
|[Błąd kompilatora C3825](compiler-error-c3825.md)|"*typu*": klasa zarządzana WinRT może obsługiwać tylko zdarzenia managed WinRT|
|C3826 błąd kompilatora|Nieaktualne.|
|C3827 błąd kompilatora|Atrybut standardowy "deprecated" może mieć żadnych argumentów lub jeden literał ciągu opisujący przyczynę|
|[Błąd kompilatora C3828](compiler-error-c3828.md)|Nie można określić argumentów położenia "*— słowo kluczowe*"wyrażenie typu"*typu*"|
|C3829 błąd kompilatora|Atrybut standardowy "noreturn" można stosować tylko do funkcji|
|[Błąd kompilatora C3830](compiler-error-c3830.md)|"*type1*": nie może dziedziczyć po "*type2*", typy wartości może dziedziczyć tylko z klas interfejsów|
|[Błąd kompilatora C3831](compiler-error-c3831.md)|"*identyfikator*": "*typu*" nie może mieć przypiętej składowej danych lub funkcji składowej zwracającej przypięty wskaźnik|
|[Błąd kompilatora C3832](compiler-error-c3832.md)|"*typelib*": typ Biblioteka wygląda tak, jakby został zbudowany dla 32-bitowych wskaźników; Zmień kwalifikator "ptrsize"|
|[Błąd kompilatora C3833](compiler-error-c3833.md)|"*typu*": nieprawidłowy typ docelowy dla *identyfikator*|
|[Błąd kompilatora C3834](compiler-error-c3834.md)|niedozwolone jawne rzutowanie do przypiętego wskaźnika; Zamiast tego użyj przypiętej zmiennej lokalnej|
|C3835 błąd kompilatora|Nieaktualne.|
|[Błąd kompilatora C3836](compiler-error-c3836.md)|Konstruktor statyczny nie może mieć listy inicjatorów składowej|
|C3837 błąd kompilatora|w tym kontekście atrybuty są niedozwolone.|
|[Błąd kompilatora C3838](compiler-error-c3838.md)|nie może dziedziczyć po "*typu*"|
|[Błąd kompilatora C3839](compiler-error-c3839.md)|Nie można zmienić wyrównania w typie zarządzane/WinRT|
|C3840 błąd kompilatora|Nieaktualne.|
|C3841 błąd kompilatora|Nieaktualne.|
|[Błąd kompilatora C3842](compiler-error-c3842.md)|"*identyfikator*": kwalifikatory "const" i "volatile" dla funkcji składowych typów zarządzanych/WinRT nie są obsługiwane.|
|C3843 błąd kompilatora|"*identyfikator*": kwalifikatory ref w funkcjach składowych typów zarządzanych/WinRT nie są obsługiwane.|
|C3844 błąd kompilatora|"*identyfikator*": nie można zaimportować symbolu z "*źródła*": jako*identyfikator*"już istnieje w bieżącym zakresie|
|C3845 błąd kompilatora|Nieaktualne.|
|[Błąd kompilatora C3846](compiler-error-c3846.md)|"*identyfikator*": nie można zaimportować symbolu z "*źródła*": jako*identyfikator*"został już zaimportowany z innego zestawu"*zestawu*'|
|C3847 błąd kompilatora|Nieaktualne.|
|[Błąd kompilatora C3848](compiler-error-c3848.md)|Wyrażenie typu "*typu*"spowoduje utratę niektórych kwalifikatorów const-volatile w celu wywołania"*identyfikator*"|
|[Błąd kompilatora C3849](compiler-error-c3849.md)|Wywołanie w stylu funkcji na wyrażeniu typu "*typu*" spowoduje utratę kwalifikatorów const i/lub volatile dla wszystkich *numer* dostępnych przeciążeń operatora|
|[Błąd kompilatora C3850](compiler-error-c3850.md)|"*tokenu*": universal-character-name Określa nieprawidłowy znak|
|[Błąd kompilatora C3851](compiler-error-c3851.md)|"*tokenu*": universal-character-name nie może wyznaczyć znaku w podstawowym zestawie znaków|
|[Błąd kompilatora C3852](compiler-error-c3852.md)|"*elementu członkowskiego*"o typie"*typu*": inicjowanie agregacji nie może zainicjować tej składowej|
|[Błąd kompilatora C3853](compiler-error-c3853.md)|"=": ponowna inicjalizacja odwołania lub przypisania poprzez odwołanie do funkcji jest niedozwolone|
|[Błąd kompilatora C3854](compiler-error-c3854.md)|Wyrażenie po lewej stronie "=" daje w wyniku funkcji. Nie można przypisać do funkcji (funkcja nie jest wartością l)|
|[Błąd kompilatora C3855](compiler-error-c3855.md)|"*funkcja*": parametr szablonu/ogólne "*identyfikator*" jest niezgodny z deklaracją|
|[Błąd kompilatora C3856](compiler-error-c3856.md)|"*klasy*": klasa nie jest ogólny/szablonu klasy|
|[Błąd kompilatora C3857](compiler-error-c3857.md)|"*szablonu*": wiele list parametrów szablonu/ogólne nie są dozwolone.|
|[Błąd kompilatora C3858](compiler-error-c3858.md)|"*identyfikator*": nie można ponownie zadeklarować w bieżącym zakresie|
|[Błąd kompilatora C3859](compiler-error-c3859.md)|zakres pamięci wirtualnej dla PCH przekroczona; należy ponownie skompilować przy użyciu opcji wiersza polecenia "-Zm*numer*" lub nowszej|
|[Błąd kompilatora C3860](compiler-error-c3860.md)|Lista argumentów szablonu/ogólne po nazwie szablonu/ogólne klasy musi katalogować parametry w kolejności użytej w liście parametrów szablonu/ogólne|
|[Błąd kompilatora C3861](compiler-error-c3861.md)|"*identyfikator*": nie odnaleziono identyfikatora|
|[Błąd kompilatora C3862](compiler-error-c3862.md)|"*funkcja*": nie można kompilować niezarządzanej funkcji z/CLR: pure lub/CLR: Safe|
|C3863 błąd kompilatora|typu tablicy "*typu*" nie jest możliwy do przypisania|
|C3864 błąd kompilatora|Nieaktualne.|
|[Błąd kompilatora C3865](compiler-error-c3865.md)|"*— słowo kluczowe*": należy używać tylko w natywnych funkcjach składowych|
|[Błąd kompilatora C3866](compiler-error-c3866.md)|wywołanie destruktora/finalizator brakuje listy argumentów|
|[Błąd kompilatora C3867](compiler-error-c3867.md)|"*funkcja*": niestandardowa składnia; Użyj "&", aby utworzyć wskaźnik do składowej|
|[Błąd kompilatora C3868](compiler-error-c3868.md)|"*typu*": ograniczenia na parametry generyczne "*parametr*" różnią się od tych w deklaracji|
|[Błąd kompilatora C3869](compiler-error-c3869.md)|w ograniczeniu gcnew brakuje listy parametrów empty "()"|
|C3870 błąd kompilatora|"*parametru*": "__declspec (*specyfikator*)" może być stosowany tylko do parametrów typu całkowitego|
|C3871 błąd kompilatora|"*parametr*": "__declspec(guard(overflow))" jest obsługiwany tylko w pierwszych 64 parametrach funkcji|
|[Błąd kompilatora C3872](compiler-error-c3872.md)|"0 x*wartość*": ten znak nie jest dozwolony w identyfikatorze|
|[Błąd kompilatora C3873](compiler-error-c3873.md)|"0 x*wartość*": ten znak nie jest dozwolona jako pierwszy znak identyfikatora|
|[Błąd kompilatora C3874](compiler-error-c3874.md)|zwracany typ "*identyfikator*powinien być*type1*"zamiast z"*type2*"|
|C3875 błąd kompilatora|Wywołanie funkcji niestatycznego elementu członkowskiego, Brak listy argumentów|
|C3876 błąd kompilatora|Nieaktualne.|
|C3877 błąd kompilatora|Nieaktualne.|
|C3878 błąd kompilatora|Nieaktualne.|
|C3879 błąd kompilatora|"*elementu członkowskiego*": nie może być składową danych initonly|
|[Błąd kompilatora C3880](compiler-error-c3880.md)|"*elementu członkowskiego*": nie może być literał składowej danych|
|C3881 błąd kompilatora|może dziedziczyć Konstruktor tylko z bezpośredniej klasy podstawowej|
|C3882 błąd kompilatora|"*klasy*": konstruktor został już odziedziczony z "*klasy*"|
|Błąd kompilatora C3883|"*elementu członkowskiego*": statyczna składowa danych initonly musi zostać zainicjowany|
|C3884 błąd kompilatora|"*typu*": tablica o nieznanym rozmiarze nie może być inicjowany przez wartość|
|C3885 błąd kompilatora|"*typu*": nie można zainicjować tablicy o nieznanym rozmiarze przy użyciu pustej listy inicjatora|
|[Błąd kompilatora C3886](compiler-error-c3886.md)|"*elementu członkowskiego*": literał składowej danych musi zostać zainicjowany|
|[Błąd kompilatora C3887](compiler-error-c3887.md)|"*elementu członkowskiego*": Inicjator literału składowej danych musi być wyrażeniem stałym|
|[Błąd kompilatora C3888](compiler-error-c3888.md)|"*elementu członkowskiego*": wyrażenie const powiązane z tym literałem składowej danych nie jest obsługiwana przez C + +/ CLI|
|C3889 błąd kompilatora|Nieaktualne.|
|[Błąd kompilatora C3890](compiler-error-c3890.md)|"*elementu członkowskiego*": nie można przyjąć adresu literału składowej danych|
|[Błąd kompilatora C3891](compiler-error-c3891.md)|"*elementu członkowskiego*": literał składowej danych nie można użyć jako wartościowanie lewostronne|
|[Błąd kompilatora C3892](compiler-error-c3892.md)|"*zmiennej*": nie można przypisać do zmiennej, która jest stałą|
|[Błąd kompilatora C3893](compiler-error-c3893.md)|"*elementu członkowskiego*": wykorzystanie wartości l składowej danych initonly jest dozwolone tylko w konstruktorze wystąpienia klasy*klasy*"|
|[Błąd kompilatora C3894](compiler-error-c3894.md)|"*elementu członkowskiego*": wykorzystanie wartości l składowej danych initonly jest dozwolone tylko w konstruktorze wystąpienia klasy*klasy*"|
|[Błąd kompilatora C3895](compiler-error-c3895.md)|"*elementu członkowskiego*": *typu* składowe danych nie może być "volatile"|
|[Błąd kompilatora C3896](compiler-error-c3896.md)|"*elementu członkowskiego*": niewłaściwy inicjator: ten literał składowej danych może być inicjowane tylko z "nullptr"|
|C3897 błąd kompilatora|Nieaktualne.|
|[Błąd kompilatora C3898](compiler-error-c3898.md)|"*elementu członkowskiego*": *typu* składowych danych mogą być tylko składowymi typów zarządzanych|
|[Błąd kompilatora C3899](compiler-error-c3899.md)|"*elementu członkowskiego*": wykorzystanie wartości l składowej danych initonly nie jest dozwolona bezpośrednio w ramach równoległego regionu w klasie*klasy*"|
|[Błąd kompilatora C3900](compiler-error-c3900.md)|"*elementu członkowskiego*": niedozwolona w bieżącym zakresie|
|[Błąd kompilatora C3901](compiler-error-c3901.md)|"*funkcja*": musi mieć typ zwracany "*typu*"|
|[Błąd kompilatora C3902](compiler-error-c3902.md)|"*funkcja*": Typ ostatniego parametru musi być "*typu*"|
|[Błąd kompilatora C3903](compiler-error-c3903.md)|"*właściwość*": jest nie zostały ustawione lub get, metoda|
|[Błąd kompilatora C3904](compiler-error-c3904.md)|"*właściwość*": należy określić *numer* następującą liczbą parametrów:|
|C3905 błąd kompilatora|niewyrównane dostępy nie są obsługiwane dla wewnętrznego typu "*typu*"|
|C3906 błąd kompilatora|wewnętrznego typu "*typu*" nie jest obsługiwane zwracanym lub typem argumentu dla funkcji vararg lub funkcji nieprototypowanych|
|C3907 błąd kompilatora|Nieaktualne.|
|[Błąd kompilatora C3908](compiler-error-c3908.md)|mniej restrykcyjny niż poziom dostępu "*identyfikator*"|
|[Błąd kompilatora C3909](compiler-error-c3909.md)|Deklaracja zdarzenia zarządzane WinRT musi wystąpić w typie managed WinRT|
|[Błąd kompilatora C3910](compiler-error-c3910.md)|"*zdarzeń*": należy zdefiniować składową "*elementu członkowskiego*"|
|[Błąd kompilatora C3911](compiler-error-c3911.md)|"*elementu członkowskiego*": funkcja musi być typu "*typu*"|
|[Błąd kompilatora C3912](compiler-error-c3912.md)|"*zdarzeń*": typ zdarzenia musi być typem delegowanym|
|[Błąd kompilatora C3913](compiler-error-c3913.md)|Domyślna właściwość musi być indeksowana|
|[Błąd kompilatora C3914](compiler-error-c3914.md)|Domyślna właściwość nie może być statyczna|
|[Błąd kompilatora C3915](compiler-error-c3915.md)|"*identyfikator*" ma nie właściwość domyślnie indeksowana (klasa indeksatora)|
|C3916 błąd kompilatora|Nieaktualne.|
|[Błąd kompilatora C3917](compiler-error-c3917.md)|"*tokenu*": przestarzały *konstruowania* styl deklaracji (czy zamierzałeś użyć "[" "]" zamiast niego?)|
|[Błąd kompilatora C3918](compiler-error-c3918.md)|użycie wymaga "*identyfikator*" jako element członkowski danych|
|[Błąd kompilatora C3919](compiler-error-c3919.md)|"*funkcja*": funkcja musi być typu "*Typ_wyniku* (*typu*)"|
|[Błąd kompilatora C3920](compiler-error-c3920.md)|"*operator*": nie można definiować przyrostkowego inkrementacyjnego/dekrementacyjnego operatora CLR/WinRT wywołanie przyrostkowego operatora CLR/WinRT wywoła odpowiedni prefiks CLR/WinRT (op_Increment/op_Decrement), ale operator przyrostka Semantyka|
|C3921 błąd kompilatora|Nieaktualne.|
|C3922 błąd kompilatora|Nieaktualne.|
|[Błąd kompilatora C3923](compiler-error-c3923.md)|"*elementu członkowskiego*": lokalnej klasy, struktury lub Unii definicje są niedozwolone w funkcji składowej klasy zarządzane/WinRT|
|C3924 błąd kompilatora|Błąd w argumencie #*numer* wywołania konstruktora delegata "*Konstruktor*":|
|C3925 błąd kompilatora|Oczekiwano pętli (for, while lub) następujących "*dyrektywy*" — dyrektywa|
|C3926 błąd kompilatora|Nieprawidłowa stała w dyrektywie "parallel"|
|C3927 błąd kompilatora|"->": końcowym typem zwracanym nie jest dozwolona po deklaratorze niebędącym funkcją|
|C3928 błąd kompilatora|"->": końcowym typem zwracanym nie jest dozwolona po deklaratorze w nawiasach okrągłych|
|C3929 błąd kompilatora|Nieaktualne.|
|C3930 błąd kompilatora|"*funkcja*": Brak funkcji przeciążonej posiadającej specyfikatory ograniczeń, które są zgodne z otaczającym kontekstem "*kontekstu*"|
|C3931 błąd kompilatora|"*typu*": nie można wywołać funkcję, która ma specyfikatory ograniczeń, które są niezgodne z otaczającym kontekstem|
|C3932 błąd kompilatora|Nieaktualne.|
|C3933 błąd kompilatora|"*klasy*": specyfikatory ograniczenia destruktora muszą obejmować związek ograniczeń na wszystkie konstruktory|
|C3934 błąd kompilatora|Funkcja, która jest w jakimkolwiek formularzu "main" nie może mieć specyfikatorów ograniczenia innych niż restrict(cpu)|
|C3935 błąd kompilatora|"*identyfikator*": zmiana definicji; specyfikatory ograniczenia nakładają się|
|C3936 błąd kompilatora|"*identyfikator*": nierozpoznany specyfikator ograniczenia|
|C3937 błąd kompilatora|pusty specyfikator ograniczenia nie jest dozwolone.|
|C3938 błąd kompilatora|"*identyfikator*": wielokrotne specyfikatory ograniczenia są nieobsługiwane w funkcji \042C\042 extern|
|C3939 błąd kompilatora|"*identyfikator*": wskaźnik do funkcji składowych, wskaźniki funkcji, odwołania do funkcji ze specyfikatorem ograniczenia "amp" są niedozwolone|
|C3940 błąd kompilatora|"*identyfikator*": nie odnaleziono identyfikatora - możliwa niezgodność kompilatora i wersje biblioteki. Sprawdź, czy dopasowanie vccorlib.h/.lib, vccorlib120.dll i c1xx.dll sobie|
|C3941 błąd kompilatora|"*warunek*": wymaga "/ clr" opcja wiersza polecenia|
|C3942 błąd kompilatora|Nieaktualne.|
|C3943 błąd kompilatora|Nieaktualne.|
|C3944 błąd kompilatora|Nieaktualne.|
|C3945 błąd kompilatora|"*typu*": nie można zgłosić lub przechwycić obiektu winrt, który nie pochodzi od Platform::Exception|
|C3946 błąd kompilatora|"*typu*": typeid nie można zastosować do tego typu|
|C3947 błąd kompilatora|"*typeid*": typeid nie można zastosować do rozwinięcia pakietu|
|C3948 błąd kompilatora|"*— słowo kluczowe*": rozwinięcie pakietu nie może występować w tym kontekście|
|C3949 błąd kompilatora|rozwinięcie pakietu, '...', nie może występować w abstrakcyjnym deklaratorze ujęty w nawiasy|
|C3950 błąd kompilatora|Nieaktualne.|
|C3951 błąd kompilatora|Nie można użyć wskaźników do elementów członkowskich w przewidywanego typu WinRT "*typu*". Zamiast tego użyj delegata.|
|C3952 błąd kompilatora|"*typu*": WinRT nie obsługuje tablic "in/out". Użyj "const tablicy<T>^" dla "in" i "WriteOnlyArray<T>" lub "tablica<T>^ *" dla "out" w publicznych interfejsach API|
|C3953 błąd kompilatora|Nie można użyć zarządzanej klasy*typu*"w WinRT module.|
|C3954 błąd kompilatora|"*typu*": tablica zwrócona z opublikowanej metody typu WinRT musi używać formy "Array<T>^"|
|C3955 błąd kompilatora|"*typu*": konstruktor publiczny nie może zawierać parametru "out" lub "WriteOnlyArray<T>"|
|C3956 błąd kompilatora|"*typu*": typ jest oznaczony jako wyłączny dla "*typu*"i nie może służyć jako podstawa"*derived_type*"|
|C3957 błąd kompilatora|"*typu*": nie można użyć typu "new" dla WinRT; Użyj zamiast tego "ref new"|
|C3958 błąd kompilatora|"*typu*": nie można Użyj "gcnew" na WinRT typu; Użyj zamiast tego "ref new"|
|C3959 błąd kompilatora|"ref new" może używać tylko do utworzenia obiektu z typem WinRT|
|C3960 błąd kompilatora|Nieaktualne.|
|C3961 błąd kompilatora|Konstruktor statyczny nie jest obsługiwane.|
|C3962 błąd kompilatora|Klasa generyczna nie jest obsługiwane.|
|C3963 błąd kompilatora|Wielowymiarowe tablice nie jest obsługiwana.|
|C3964 błąd kompilatora|Tablica nieregularna nie jest obsługiwana.|
|C3965 błąd kompilatora|Tablica parametrów nie jest obsługiwana.|
|C3966 błąd kompilatora|"*funkcja*": funkcja ogólna nie jest obsługiwana.|
|C3967 błąd kompilatora|Błąd importowania "*identyfikator*"z modułu"*modułu*"|
|C3968 błąd kompilatora|token "*tokenu*" jest nieprawidłowy jako separator nazwy modułu; użyj kropki (".") zamiast tego|
|C3969 błąd kompilatora|Niespójne nazwy modułów: "*module1*"i"*module1*"|
|C3970 błąd kompilatora|"*identyfikator*": "*— słowo kluczowe*" można stosować tylko do "ref class" lub "ref struct" w zakresie globalnym lub zakresie przestrzeni nazw|
|C3971 błąd kompilatora|"*typu*": częściowa definicja nie może występować po pełnej definicji|
|C3972 błąd kompilatora|"*typu*": "partial" może być stosowane tylko do deklaracji lub definicji klasy|
|C3973 błąd kompilatora|Nieaktualne.|
|C3974 błąd kompilatora|Nieaktualne.|
|C3975 błąd kompilatora|"klasie/strukturze *identyfikator*" poprzednio zadeklarowany lub zdefiniowany za pomocą innego modyfikatora|
|C3976 błąd kompilatora|"*identifier1*"musi być zadeklarowany jako "public" Aby można było używać"*identifier2*"|
|C3977 błąd kompilatora|Użycie wymaga odwołania do zestawu, który definiuje "*identyfikator*"|
|C3978 błąd kompilatora|"*identyfikator*": właściwość statyczna nie może być elementem członkowskim typu interfejsu, lub wartość WinRT|
|C3979 błąd kompilatora|"*typu*": Użyj atrybutu "*atrybut*"zamiast z"*wartość*"|
|C3980 błąd kompilatora|"*typu*" nie może być wydane do metadanych|
|C3981 błąd kompilatora|"*typu*": typ wartościowy nie może mieć żadnych statycznych składowych danych*identyfikator*"|
|C3982 błąd kompilatora|"*typu*": typ wartościowy nie może mieć żadnych składowych danych niepublicznych*identyfikator*"|
|C3983 błąd kompilatora|"*typu*": typ wartościowy nie może mieć żadnych publicznych składowych innych niż danych*identyfikator*"|
|C3984 błąd kompilatora|"*typu*": typ inny niż wartości nie może mieć żadnych publicznych składowych danych*identyfikator*"|
|C3985 błąd kompilatora|"*identyfikator*": sygnatura publicznej składowej zawiera typ prywatny "*elementu członkowskiego*"|
|C3986 błąd kompilatora|"*identyfikator*": sygnatura publicznej składowej zawiera typ natywny "*elementu członkowskiego*"|
|C3987 błąd kompilatora|"*identyfikator*": sygnatura publicznej składowej zawiera typ natywny "*typu*"|
|C3988 błąd kompilatora|"*typu*": typ natywny nie może być publiczny|
|C3989 błąd kompilatora|"*typu*': Zagnieżdżony typ nie może być publiczny|
|C3990 błąd kompilatora|"*typu*": atrybut "*atrybut*" nie może być prywatny ani zagnieżdżony|
|C3991 błąd kompilatora|"*typu*": nie można zaimplementować niepublicznego lub zagnieżdżonego interfejsu "*interfejsu*"|
|C3992 błąd kompilatora|"*identyfikator*": sygnatura publicznej składowej zawiera nieprawidłowy typ "*typu*"|
|C3993 błąd kompilatora|"*typu*": typ wartościowy musi zawierać co najmniej jedno pole publiczne|
|C3994 błąd kompilatora|"*typu*": typ wartościowy nie może implementować interfejsów lub mieć funkcji wirtualnych|
|C3995 błąd kompilatora|"*typu*": typ wartościowy nie może mieć żadnych składowych zdarzenia*identyfikator*"|
|C3996 błąd kompilatora|Nieaktualne.|
|C3998 błąd kompilatora|"c ++*wersji*": nieobsługiwana wersja języka C++; przyjęto wartość domyślną "c ++*wersji*"|
|C3999 błąd kompilatora|Nieznany błąd, wybierz polecenie Pomoc techniczna w Visual C++ menu Pomoc lub Otwórz plik pomocy technicznej, aby uzyskać więcej informacji|

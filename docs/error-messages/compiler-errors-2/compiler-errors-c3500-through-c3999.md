---
description: 'Dowiedz się więcej o: Błędy kompilatora C3500 przez C3999'
title: Błędy kompilatora — od C3500 do C3999
ms.date: 04/21/2019
f1_keywords:
- C3502
- C3503
- C3504
- C3511
- C3512
- C3513
- C3514
- C3515
- C3516
- C3517
- C3518
- C3520
- C3521
- C3522
- C3523
- C3524
- C3525
- C3526
- C3527
- C3528
- C3529
- C3534
- C3542
- C3543
- C3544
- C3545
- C3546
- C3547
- C3548
- C3549
- C3557
- C3558
- C3559
- C3560
- C3561
- C3562
- C3563
- C3564
- C3565
- C3566
- C3567
- C3568
- C3569
- C3570
- C3571
- C3572
- C3573
- C3574
- C3575
- C3576
- C3577
- C3578
- C3579
- C3580
- C3581
- C3582
- C3583
- C3584
- C3585
- C3586
- C3587
- C3588
- C3589
- C3590
- C3591
- C3592
- C3593
- C3594
- C3595
- C3596
- C3597
- C3598
- C3599
- C3600
- C3601
- C3602
- C3604
- C3605
- C3613
- C3614
- C3616
- C3620
- C3621
- C3635
- C3636
- C3649
- C3658
- C3659
- C3660
- C3663
- C3664
- C3667
- C3674
- C3676
- C3677
- C3678
- C3679
- C3680
- C3681
- C3682
- C3683
- C3684
- C3685
- C3686
- C3687
- C3688
- C3689
- C3690
- C3691
- C3696
- C3716
- C3720
- C3725
- C3726
- C3729
- C3730
- C3735
- C3742
- C3746
- C3750
- C3751
- C3756
- C3757
- C3758
- C3759
- C3760
- C3770
- C3773
- C3774
- C3775
- C3776
- C3777
- C3778
- C3779
- C3780
- C3781
- C3782
- C3783
- C3784
- C3785
- C3786
- C3787
- C3801
- C3802
- C3806
- C3811
- C3814
- C3819
- C3822
- C3823
- C3826
- C3827
- C3829
- C3837
- C3840
- C3841
- C3843
- C3844
- C3845
- C3863
- C3870
- C3871
- C3875
- C3879
- C3881
- C3882
- C3884
- C3885
- C3897
- C3905
- C3906
- C3916
- C3921
- C3924
- C3925
- C3926
- C3927
- C3928
- C3930
- C3931
- C3932
- C3933
- C3934
- C3935
- C3936
- C3937
- C3938
- C3939
- C3940
- C3941
- C3945
- C3946
- C3947
- C3948
- C3949
- C3950
- C3951
- C3952
- C3953
- C3954
- C3955
- C3956
- C3957
- C3958
- C3959
- C3960
- C3961
- C3962
- C3963
- C3964
- C3965
- C3966
- C3967
- C3968
- C3969
- C3970
- C3971
- C3972
- C3975
- C3976
- C3977
- C3978
- C3979
- C3980
- C3981
- C3982
- C3983
- C3984
- C3985
- C3986
- C3987
- C3988
- C3989
- C3990
- C3991
- C3992
- C3993
- C3994
- C3995
- C3996
- C3997
- C3998
- C3999
ms.assetid: bd6f23ad-b300-4e07-8e35-9661cab1585f
ms.openlocfilehash: bf0075e9064b7e03c0b733119300ee90d77884fc
ms.sourcegitcommit: d6af41e42699628c3e2e6063ec7b03931a49a098
ms.translationtype: MT
ms.contentlocale: pl-PL
ms.lasthandoff: 12/11/2020
ms.locfileid: "97238573"
---
# <a name="compiler-errors-c3500-through-c3999"></a>Błędy kompilatora — od C3500 do C3999

W artykułach w tej sekcji dokumentacji wyjaśniono podzestaw komunikatów o błędach generowanych przez kompilator.

[!INCLUDE[error-boilerplate](../../error-messages/includes/error-boilerplate.md)]

## <a name="error-messages"></a>Komunikaty o błędach

|Błąd|Wiadomość|
|-----------|-------------|
|[Błąd kompilatora C3500](compiler-error-c3500.md)|nieprawidłowy atrybut ProgID "*ProgID*"|
|[Błąd kompilatora C3501](compiler-error-c3501.md)|Brak zarejestrowanych TypeLib dla identyfikatora ProgID "*ProgID*"|
|Błąd kompilatora C3502|nie można uzyskać identyfikatora LIBID dla identyfikatora ProgID "*ProgID*"|
|Błąd kompilatora C3503|znak "0x *Value*" jest niedozwolony w literale nieprzetworzonego ciągu|
|Błąd kompilatora C3504|nie można utworzyć identyfikatora GUID z ciągu "*String*"|
|[Błąd kompilatora C3505](compiler-error-c3505.md)|nie można załadować biblioteki typów "*Library*"|
|[Błąd kompilatora C3506](compiler-error-c3506.md)|Brak zarejestrowanej biblioteki typów dla identyfikatora LIBID *'*|
|[Błąd kompilatora C3507](compiler-error-c3507.md)|Identyfikator ProgID może zawierać nie więcej niż 39 znaków "*ProgID*"; ani nie zawierać żadnych znaków interpunkcyjnych z wyjątkiem "."; ani Rozpocznij od cyfry|
|[Błąd kompilatora C3508](compiler-error-c3508.md)|"*Type*": nie jest prawidłowym typem automatyzacji|
|[Błąd kompilatora C3509](compiler-error-c3509.md)|"*Type*": nieprawidłowy zwracany typ automatyzacji; gdy parametr jest oznaczony jako "retval", typem zwracanym musi być "void", "HRESULT" lub "SCODE"|
|[Błąd kompilatora C3510](compiler-error-c3510.md)|nie można zlokalizować *biblioteki* zależnej biblioteki typów|
|Błąd kompilatora C3511|"*Identyfikator*": wywołanie konstruktora delegowanego jest jedynym inicjatorem składowej|
|Błąd kompilatora C3512|ograniczająca sekwencja znaków dla literału nieprzetworzonego ciągu powinna mieć nie więcej niż 16 znaków|
|Błąd kompilatora C3513|"*String*": nieobsługiwany znak ograniczający literał nieprzetworzonego ciągu|
|Błąd kompilatora C3514|"*Character*" (*wartość*): nieobsługiwany znak ograniczający literał nieprzetworzonego ciągu|
|Błąd kompilatora C3515|Jeśli argument częściowej specjalizacji szablonu klasy jest rozwinięciem pakietu, powinien być ostatnim argumentem|
|Błąd kompilatora C3516|napotkano nieoczekiwany koniec pliku podczas przetwarzania literału nieprzetworzonego ciągu; Sekwencja ogranicznika "*String*" nie została dopasowana|
|Błąd kompilatora C3517|"*Identyfikator*" Deklaracja aliasu nie może mieć typu zawierającego element "Auto"|
|Błąd kompilatora C3518|"*Identyfikator*": w kontekście bezpośredniego inicjowania listy Typ dla elementu "*Type*" można określić tylko na podstawie pojedynczego wyrażenia inicjatora|
|[Błąd kompilatora C3519](compiler-error-c3519.md)|"*Parameter*": nieprawidłowy parametr embedded_idl atrybutu|
|Błąd kompilatora C3520|"*Identyfikator*": pakiet parametrów musi być rozwinięty w tym kontekście|
|Błąd kompilatora C3521|"*Identyfikator*" nie jest pakietem parametrów|
|Błąd kompilatora C3522|"*Type*": pakiet parametrów nie może być rozwinięty w tym kontekście|
|Błąd kompilatora C3523|"sizeof..." wymaga jako argument nierozwiniętego pakietu parametrów|
|Błąd kompilatora C3524|nie można zastosować elementu "*Identifier*": "sizeof" do pakietu parametrów. Czy chodziło o użycie "sizeof..."?|
|Błąd kompilatora C3525|"*Parameter*": Jeśli szablon klasy ma pakiet parametrów szablonu, musi pojawić się na końcu listy parametrów szablonu|
|Błąd kompilatora C3526|'...' nie można zastosować do "This"|
|Błąd kompilatora C3527|element "*Identifier*" nie jest prawidłowym argumentem operacji "sizeof...". Czy chodziło o użycie operatora "sizeof"?|
|Błąd kompilatora C3528|"*Identifier1*": liczba elementów w tym rozwinięciu pakietu nie pasuje do liczby elementów w elemencie "*identifier2*"|
|Błąd kompilatora C3529|"*Parameter*": pakiet parametrów szablonu nie może mieć argumentu domyślnego|
|[Błąd kompilatora C3530](compiler-error-c3530.md)|nie można łączyć instrukcji "*Type*" z jakimkolwiek innym specyfikatorem typu|
|[Błąd kompilatora C3531](compiler-error-c3531.md)|"*Identyfikator*": symbol, którego typ zawiera "*Type*", musi mieć inicjator|
|[Błąd kompilatora C3532](compiler-error-c3532.md)|Typ elementu tablicy nie może być typem zawierającym wartość "*Type*".|
|[Błąd kompilatora C3533](compiler-error-c3533.md)|parametr nie może mieć typu zawierającego element "*Type*"|
|Błąd kompilatora C3534|Nieaktualne.|
|[Błąd kompilatora C3535](compiler-error-c3535.md)|nie można wywnioskować typu dla elementu "*Type1*" z elementu "*Type2*"|
|[Błąd kompilatora C3536](compiler-error-c3536.md)|"*Identyfikator*": nie można użyć przed zainicjowaniem|
|[Błąd kompilatora C3537](compiler-error-c3537.md)|nie można rzutować na typ, który zawiera wartość "*Type*".|
|[Błąd kompilatora C3538](compiler-error-c3538.md)|w elemencie deklarator-list "*Type*" musi zawsze zostać wywnioskowany dla tego samego typu|
|[Błąd kompilatora C3539](compiler-error-c3539.md)|argument szablonu nie może być typem zawierającym wartość "*Type*"|
|[Błąd kompilatora C3540](compiler-error-c3540.md)|nie można zastosować operatora sizeof do typu, który zawiera element "*Type*"|
|[Błąd kompilatora C3541](compiler-error-c3541.md)|nie można zastosować elementu typeid do typu, który zawiera element "*Type*".|
|Błąd kompilatora C3542|"*Identyfikator*": wirtualna funkcja członkowska nie powinna mieć zwracanego typu zawierającego element "*Type*"|
|Błąd kompilatora C3543|"*Type*": nie zawiera pakietu parametrów|
|Błąd kompilatora C3544|"*Parameter*": pakiet parametrów oczekuje argumentu szablonu typu|
|Błąd kompilatora C3545|"*Parameter*": pakiet parametrów oczekuje argumentu szablonu bez typu|
|Błąd kompilatora C3546|"...": nie ma pakietów parametrów dostępnych do rozwinięcia|
|Błąd kompilatora C3547|nie można użyć parametru szablonu "*Parameter*", ponieważ następuje po pakiecie parametrów szablonu i nie można go wywnioskować z parametrów funkcji "*Function*"|
|Błąd kompilatora C3548|"*Identyfikator*": pakiet parametrów nie może zostać użyty w tym kontekście|
|Błąd kompilatora C3549|"*Value*": pakiet parametrów funkcji nie może mieć argumentu domyślnego|
|[Błąd kompilatora C3550](compiler-error-c3550.md)|w tym kontekście jest dozwolony tylko zwykły element "decltype (Auto)"|
|[Błąd kompilatora C3551](compiler-error-c3551.md)|Jeśli zostanie użyty końcowy typ zwracany, wiodący typ zwracany powinien być pojedynczym specyfikatorem typu "Auto" (nie "*Type*")|
|[Błąd kompilatora C3552](compiler-error-c3552.md)|Oczekiwano elementu "decltype (Auto)"|
|[Błąd kompilatora C3553](compiler-error-c3553.md)|decltype oczekuje wyrażenia, a nie typu|
|[Błąd kompilatora C3554](compiler-error-c3554.md)|nie można łączyć instrukcji "*Type*" z jakimkolwiek innym specyfikatorem typu|
|[Błąd kompilatora C3555](compiler-error-c3555.md)|Nieprawidłowy argument dla "decltype"|
|[Błąd kompilatora C3556](compiler-error-c3556.md)|"*Expression*": nieprawidłowy argument dla "decltype"|
|Błąd kompilatora C3557|Nieaktualne.|
|Błąd kompilatora C3558|Nieaktualne.|
|Błąd kompilatora C3559|cykliczne wywołanie *funkcji*: rekursja została wykryta podczas kompilowania grafu wywołań dla concurrency::p arallel_for_each w: "*Function*"|
|Błąd kompilatora C3560|"*Function*": Il nie jest dostępna podczas kompilowania grafu wywołań dla concurrency::p arallel_for_each w: "*Function*"|
|Błąd kompilatora C3561|znaleziono operację bariery kafelka w przepływie sterowania, która nie jest jednolite, podczas kompilowania grafu wywołań dla concurrency::p arallel_for_each w: "*Function*"|
|Błąd kompilatora C3562|Funkcja wewnętrzna "*Function*" nie może mieć więcej niż parametrów *liczbowych*|
|Błąd kompilatora C3563|Wykryto nieskończoną pętlę podczas kompilowania grafu wywołań dla concurrency::p arallel_for_each w: "*Function*"|
|Błąd kompilatora C3564|Odczytywanie niezainicjowanej wartości podczas kompilowania grafu wywołań dla concurrency::p arallel_for_each w: "*Function*"|
|Błąd kompilatora C3565|Całkowita ilość tile_static pamięci (*Liczba* bajtów) przekracza limit *liczby* bajtów podczas kompilowania grafu wywołań dla concurrency::p arallel_for_each|
|Błąd kompilatora C3566|bloki z efektami ubocznymi zagnieżdżone zbyt głęboko podczas kompilowania grafu wywołań dla concurrency::p arallel_for_each w: "*Function*"|
|Błąd kompilatora C3567|Wykryto dzielenie lub dzielenie modulo przez zero podczas kompilowania grafu wywołań dla concurrency::p arallel_for_each w: "*Function*"|
|Błąd kompilatora C3568|suma rejestrów przekracza limit *liczby* podczas kompilowania grafu wywołań dla arallel_for_each współbieżności::p. Uprość program|
|Błąd kompilatora C3569|Wykryto sytuację wyścigu podczas kompilowania grafu wywołań dla concurrency::p arallel_for_each w: "*Function*"|
|Błąd kompilatora C3570|niedozwolone użycie zakresu amp z ograniczeniami podczas kompilacji z/CLR|
|Błąd kompilatora C3571|"*Type*": niedozwolony argument domeny obliczeń; to nie jest typ klasy|
|Błąd kompilatora C3572|"*Type*": niedozwolony argument domeny obliczeń; Brak publicznej składowej: "static const int rangi" lub wartość rangi jest Niedodatnia|
|Błąd kompilatora C3573|Liczba wystąpień elementu concurrency:: Graphics:: Próbnik przeniesiona do concurrency::p arallel_for_each nie może przekraczać *liczby*|
|Błąd kompilatora C3574|"*Type*": niedozwolone zakresy kafelków: musi być dodatnia i (1) Z <= *Number*; (2) Z *Y* X <= *Liczba*|
|Błąd kompilatora C3575|"*Type*": niedozwolony argument domeny obliczeń; Brak publicznej składowej: "concurrency:: index<*number*> _map_index (const concurrency:: index<*Number*>&) Ogranicz (amp)"|
|Błąd kompilatora C3576|"*Type*": concurrency::d etails:: _Parallel_for_each argument #*Number* ma nieobsługiwany typ|
|Błąd kompilatora C3577|Typ concurrency::p arallel_for_each jądra jest niedozwolony: nie można rozwiązać wywołania do składowej "void operator () (*Typ*) ograniczenia (amp)"|
|Błąd kompilatora C3578|Rozmiar obiektu funkcji, który przeszedł do concurrency::p arallel_for_each nie może przekroczyć *liczby* bajtów|
|Błąd kompilatora C3579|Liczba wystąpień tylko do odczytu elementów concurrency:: Array i concurrency:: Graphics:: Texture przeniesiona do concurrency::p arallel_for_each nie może przekraczać *liczby*|
|Błąd kompilatora C3580|Liczba zapisywalnych wystąpień concurrency:: Array i concurrency:: Graphics:: Texture przeniesiona do concurrency::p arallel_for_each nie może przekraczać *liczby*|
|Błąd kompilatora C3581|"*Type*": nieobsługiwany typ w ograniczonym kodzie amp|
|Błąd kompilatora C3582|Nieaktualne.|
|Błąd kompilatora C3583|"*Identyfikator*": rozmiar zmiennej (*Liczba* bajtów) jest większy niż maksymalny *rozmiar (w* bajtach) obsługiwany w ograniczonym kodzie amp|
|Błąd kompilatora C3584|nieobsługiwane użycie tile_static w "*identyfikatorze*"|
|Błąd kompilatora C3585|element "*Identifier*" ma nieobsługiwaną klasę magazynu w ograniczonym kodzie amp|
|Błąd kompilatora C3586|"*Identyfikator*": użycie globalnych lub statycznych zmiennych jest nieobsługiwane w ograniczonym kodzie amp|
|Błąd kompilatora C3587|dynamic_cast jest nieobsługiwane w ograniczonym kodzie amp|
|Błąd kompilatora C3588|Rzutowanie z "*Type1*" na "*Type2*" jest nieobsługiwane w ograniczonym kodzie amp|
|Błąd kompilatora C3589|"*String*": nieobsługiwane użycie literałów ciągu w ograniczonym kodzie amp|
|Błąd kompilatora C3590|"*token*": przechwycenie przez odwołanie lub przechwycenie "This" jest nieobsługiwane, jeśli wyrażenie lambda jest ograniczone przez amp|
|Błąd kompilatora C3591|Operator typeid jest nieobsługiwany w ograniczonym kodzie amp|
|Błąd kompilatora C3592|Wbudowany zestaw natywny ("__asm") nie jest obsługiwany w ograniczonym kodzie amp|
|Błąd kompilatora C3593|Instrukcja "goto" jest nieobsługiwana w ograniczonym kodzie amp|
|Błąd kompilatora C3594|Obsługa wyjątków (try, catch, throw itp.) jest nieobsługiwana w ograniczonym kodzie amp|
|Błąd kompilatora C3595|wartość stała jest poza obsługiwanym zakresem w ograniczonym kodzie amp|
|Błąd kompilatora C3596|"*Parameter*" ("*Type*"): zmienna przechwycona przez wyrażenie lambda ma nieobsługiwany typ w ograniczonym kodzie amp|
|Błąd kompilatora C3597|"*Parameter*": element "*Identifier*" nie może być przechwytywany przez wartość, jeśli wyrażenie lambda jest ograniczone przez amp|
|Błąd kompilatora C3598|Etykieta instrukcji jest nieobsługiwana w ograniczonym kodzie amp|
|Błąd kompilatora C3599|"*operator*": nie można wykonać arytmetyki wskaźnika na wskaźniku do wartości logicznej w ograniczonym kodzie amp|
|Błąd kompilatora C3600|"*Function*": \_ wykryto użycie pamięci statycznej kafelka podczas kompilowania grafu wywołań dla współbieżności bez fragmentacji::p arallel \_ for_each w: "*Function*"|
|Błąd kompilatora C3601|"*Type*": jest nieprawidłowym typem argumentu dla funkcji diagnostyki amp "*Function*"|
|Błąd kompilatora C3602|Wykryto nieobsługiwany przepływ sterowania podczas kompilowania grafu wywołań dla concurrency::p arallel_for_each w: "*Function*"|
|[Błąd kompilatora C3603](compiler-error-c3603.md)|"*symbol*": typ "*Type*" nie jest jeszcze obsługiwany|
|Błąd kompilatora C3604|"*Identyfikator*": można utworzyć tylko obiekt zarządzany na stercie GC|
|Błąd kompilatora C3605|Całkowita liczba próbników (*Liczba* przechwyconych i *Liczba* wstępnie zdefiniowana) przekracza *liczbę* podczas kompilowania grafu wywołań dla concurrency::p arallel_for_each w: "*Function*"|
|Błąd kompilatora C3606|Nieaktualne.|
|Błąd kompilatora C3607|Nieaktualne.|
|Błąd kompilatora C3608|Nieaktualne.|
|[Błąd kompilatora C3609](compiler-error-c3609.md)|"*Identyfikator*": funkcja "Sealed/Final" musi być wirtualna|
|[Błąd kompilatora C3610](compiler-error-c3610.md)|"*Identyfikator*": typ wartości musi być "opakowany" przed wywołaniem metody "*Method*"|
|[Błąd kompilatora C3611](compiler-error-c3611.md)|"*Identyfikator*": funkcja zapieczętowana nie może mieć czystego specyfikatora|
|[Błąd kompilatora C3612](compiler-error-c3612.md)|"*Identyfikator*": Klasa zapieczętowana nie może mieć żadnych czystych metod wirtualnych|
|Błąd kompilatora C3613|Brak typu zwracanego po "->" (przyjęto "int")|
|Błąd kompilatora C3614|Różne wartości rozmiaru pakietu w tej samej klasie; Poprzedni element to "*Value*", Nowa wartość to "*Value*"|
|[Błąd kompilatora C3615](compiler-error-c3615.md)|Funkcja constexpr "*Function*" nie może skutkować wyrażeniem stałym|
|Błąd kompilatora C3616|Nieaktualne.|
|Błąd kompilatora C3617|Nieaktualne.|
|[Błąd kompilatora C3618](compiler-error-c3618.md)|"*Deklaracja*": nie można zdefiniować metody oznaczonej jako dllimport|
|[Błąd kompilatora C3619](compiler-error-c3619.md)|szablon nie może być zadeklarowany w obrębie typu zarządzanego/WinRT|
|Błąd kompilatora C3620|"*Type*": ustawienie wyrównania jest niedozwolone dla typów WinRT|
|Błąd kompilatora C3621|"*Type*": tylko domyślna wartość pakowania (*Number*) jest dozwolona dla typów WinRT|
|[Błąd kompilatora C3622](compiler-error-c3622.md)|*Typ*": nie można utworzyć wystąpienia klasy zadeklarowanej jako"*słowo kluczowe*"|
|[Błąd kompilatora C3623](compiler-error-c3623.md)|"*Identyfikator*": pola bitowe nie są obsługiwane w typach zarządzanych/WinRT|
|[Błąd kompilatora C3624](compiler-error-c3624.md)|"*Type*": użycie tego typu wymaga odwołania do zestawu/modułu "*Identyfikator*"|
|[Błąd kompilatora C3625](compiler-error-c3625.md)|"*Class*": typ natywny nie może pochodzić od typu zarządzanego/WinRT "*Type*"|
|[Błąd kompilatora C3626](compiler-error-c3626.md)|"*Identifier*": słowo kluczowe "*Keyword*" może być używane tylko dla interfejsów COM, funkcji składowych i składowych danych, które są wskaźnikami do delegatów|
|[Błąd kompilatora C3627](compiler-error-c3627.md)|Tylko typ wartości może być opakowany|
|[Błąd kompilatora C3628](compiler-error-c3628.md)|"*Class*": klasy zarządzane/WinRT obsługują tylko publiczne dziedziczenie|
|Błąd kompilatora C3629|"*token*": wartość domyślna przechwytywania może występować tylko na początku listy przechwytywania lambda|
|[Błąd kompilatora C3630](compiler-error-c3630.md)|błąd podczas przetwarzania tokenu "*token*"|
|[Błąd kompilatora C3631](compiler-error-c3631.md)|"*Event*": nie można przeciążyć zdarzeń zarządzanych/WinRT|
|[Błąd kompilatora C3632](compiler-error-c3632.md)|"*Event*": niedozwolony styl zdarzenia dla *konstrukcji*|
|[Błąd kompilatora C3633](compiler-error-c3633.md)|nie można zdefiniować elementu "*Identifier*" jako składowej zarządzanej "*Class*"|
|[Błąd kompilatora C3634](compiler-error-c3634.md)|"*member*": nie można zdefiniować metody abstrakcyjnej klasy Managed/WinRT|
|Błąd kompilatora C3635|"*Identyfikator*": nie można zastosować do klasy zarządzanej/WinRT (Użyj zamiast tego "*Identifier*")|
|Błąd kompilatora C3636|"*Identyfikator*": nie można zastosować do tego typu|
|[Błąd kompilatora C3637](compiler-error-c3637.md)|"*Function*": definicja funkcji zaprzyjaźnionej nie może być specjalizacją szablonu funkcji/generycznego|
|[Błąd kompilatora C3638](compiler-error-c3638.md)|"*operator*": nie można ponownie zdefiniować odpakowania standardowego i rozpakowywania operatorów konwersji|
|Błąd kompilatora C3639|Nieaktualne.|
|[Błąd kompilatora C3640](compiler-error-c3640.md)|"*member*": odwołanie lub wirtualna funkcja członkowska klasy lokalnej musi być zdefiniowana|
|[Błąd kompilatora C3641](compiler-error-c3641.md)|"*Function*": nieprawidłowa Konwencja wywoływania "*Konwencja*" dla funkcji kompilowanych z/CLR: Pure lub/CLR: Safe|
|[Błąd kompilatora C3642](compiler-error-c3642.md)|"*Function*": nie można wywołać funkcji z __clrcall konwencją wywoływania z kodu natywnego|
|Błąd kompilatora C3643|Nieaktualne.|
|[Błąd kompilatora C3644](compiler-error-c3644.md)|"*Function*": nie można skompilować funkcji w celu wygenerowania kodu zarządzanego|
|[Błąd kompilatora C3645](compiler-error-c3645.md)|"*Function*": __clrcall nie może być używana w funkcjach skompilowanych do kodu natywnego|
|[Błąd kompilatora C3646](compiler-error-c3646.md)|"*Identyfikator*": nieznany specyfikator przesłonięcia|
|Błąd kompilatora C3647|Nieaktualne.|
|[Błąd kompilatora C3648](compiler-error-c3648.md)|Ta składnia jawnego przesłaniania nie jest obsługiwana w przypadku typów zarządzanych|
|Błąd kompilatora C3649|Ta składnia jawnego przesłaniania nie jest dozwolona w przypadku/ZW|
|[Błąd kompilatora C3650](compiler-error-c3650.md)|"*member*": nie można użyć jako jawnego przesłaniania, musi być wirtualną funkcją członkowską klasy bazowej|
|[Błąd kompilatora C3651](compiler-error-c3651.md)|"*member*": nie można użyć jako jawnego przesłaniania, musi być składową klasy bazowej|
|[Błąd kompilatora C3652](compiler-error-c3652.md)|"*member*": funkcja, która jawnie przesłania, musi być wirtualna|
|[Błąd kompilatora C3653](compiler-error-c3653.md)|"*Identyfikator*": nie można użyć jako nazwanego przesłonięcia: nie można odnaleźć przesłanianej funkcji; Czy pamiętasz o nazwie funkcji jawnie, przy użyciu operatora::?|
|[Błąd kompilatora C3654](compiler-error-c3654.md)|"*token*": błąd składniowy w jawnym przesłonięciu|
|[Błąd kompilatora C3655](compiler-error-c3655.md)|"*member*": funkcja została już jawnie przesłonięta|
|[Błąd kompilatora C3656](compiler-error-c3656.md)|"*słowo kluczowe*": specyfikator przesłonięcia nie może być powtórzony|
|[Błąd kompilatora C3657](compiler-error-c3657.md)|destruktor/finalizator nie może jawnie przesłonić lub być jawnie przesłonięty|
|Błąd kompilatora C3658|Nieaktualne.|
|Błąd kompilatora C3659|"*member*": specyfikator przesłonięcia "*słowo kluczowe*" nie jest obsługiwany|
|Błąd kompilatora C3660|"*member1*": ukrywa dziedziczoną składową "*member2*"|
|[Błąd kompilatora C3661](compiler-error-c3661.md)|Lista jawnego przesłaniania nie znalazła żadnych metod do przesłonięcia|
|[Błąd kompilatora C3662](compiler-error-c3662.md)|"*member*": specyfikator przesłonięcia "*Keyword*" dozwolony tylko dla funkcji składowych klas zarządzanych/WinRT|
|Błąd kompilatora C3663|Nieaktualne.|
|Błąd kompilatora C3664|"*member*": nie można użyć jako jawnego przesłaniania, musi mieć ułatwienia dostępu "Public" lub "Protected"|
|[Błąd kompilatora C3665](compiler-error-c3665.md)|"*member*": specyfikator przesłonięcia "*słowo kluczowe*" jest niedozwolony w destruktorze/finalizatorze|
|[Błąd kompilatora C3666](compiler-error-c3666.md)|"*Konstruktor*": specyfikator przesłonięcia "*słowo kluczowe*" jest niedozwolony w konstruktorze|
|Błąd kompilatora C3667|"*Attribute*": atrybut nie obsługuje rozwinięcia pakietu|
|[Błąd kompilatora C3668](compiler-error-c3668.md)|"*member*": Metoda ze specyfikatorem przesłonięcia "override" nie przesłania żadnych metod klasy bazowej|
|[Błąd kompilatora C3669](compiler-error-c3669.md)|"*member*": specyfikator przesłonięcia "override" nie jest dozwolony na statycznych funkcjach składowych lub konstruktorach|
|[Błąd kompilatora C3670](compiler-error-c3670.md)|"*member*": nie można przesłonić metody "*member*" niedostępnej klasy bazowej|
|[Błąd kompilatora C3671](compiler-error-c3671.md)|"*member*": funkcja nie przesłania elementu "*member*"|
|[Błąd kompilatora C3672](compiler-error-c3672.md)|wyrażenie pseudo-destruktora może być używane tylko jako część wywołania funkcji|
|[Błąd kompilatora C3673](compiler-error-c3673.md)|"*Class*": Klasa nie posiada konstruktora kopiującego|
|Błąd kompilatora C3674|nie można znaleźć modułu standardowej biblioteki "*module*"|
|[Błąd kompilatora C3675](compiler-error-c3675.md)|"*Function*": jest zarezerwowana, ponieważ zdefiniowano *Właściwość "Property*"|
|Błąd kompilatora C3676|"*Class*": Klasa ref i Klasa bazowa mają niezgodne atrybuty "[*Attribute*]"|
|Błąd kompilatora C3677|literał ciągu po słowie "operator" nie może mieć prefiksu kodowania|
|Błąd kompilatora C3678|literał ciągu po elemencie "operator" musi być pustym ciągiem "" "" "|
|Błąd kompilatora C3679|Oczekiwano identyfikatora sufiksu literału po "operator" "" ""|
|Błąd kompilatora C3680|nie można połączyć zdefiniowanych przez użytkownika literałów ciągu z niezgodnymi identyfikatorami sufiksów literałów|
|Błąd kompilatora C3681|"fallthrough": atrybut może występować tylko w otaczającej instrukcji switch|
|Błąd kompilatora C3682|" *Identyfikator* operatora": szablon operatora literału/literału nie może być zadeklarowany jako mający powiązanie "C"|
|Błąd kompilatora C3683|nie można zdefiniować zarówno operatora nieprzetworzonego literału, jak i szablonu operatora literału z tym samym identyfikatorem sufiksu literału|
|Błąd kompilatora C3684|" *Identyfikator* operatora": Deklaracja operatora literału ma nieprawidłową listę parametrów|
|Błąd kompilatora C3685|" *Identyfikator* operatora": szablon operatora literału nie może mieć parametrów funkcji|
|Błąd kompilatora C3686|" *Identyfikator* operatora": szablon operatora literału musi mieć dokładnie jeden parametr szablonu, który jest pakietem parametrów|
|Błąd kompilatora C3687|" *Identyfikator* operatora": szablon operatora literału nie może mieć parametru szablonu typu "char"|
|Błąd kompilatora C3688|nieprawidłowy sufiks literału "*sufiks*"; nie znaleziono operatora literału lub szablonu operatora literału " *Identyfikator* operatora"|
|Błąd kompilatora C3689|" *Identyfikator* operatora": szablon operatora literału/literału musi znajdować się w zakresie globalnym lub przestrzeni nazw|
|Błąd kompilatora C3690|Oczekiwano literału ciągu, ale zamiast niego znaleziono literał ciągu zdefiniowany przez użytkownika|
|Błąd kompilatora C3691|Nieprawidłowy prefiks literału "*prefix*"|
|Błąd kompilatora C3692|Nieaktualne.|
|Błąd kompilatora C3693|Nieaktualne.|
|Błąd kompilatora C3694|Nieaktualne.|
|Błąd kompilatora C3695|Nieaktualne.|
|Błąd kompilatora C3696|"*słowo kluczowe*": nie można użyć tego kwalifikatora dla "%"|
|[Błąd kompilatora C3697](compiler-error-c3697.md)|"*słowo kluczowe*": nie można użyć tego kwalifikatora na "^"|
|[Błąd kompilatora C3698](compiler-error-c3698.md)|"*Type*": nie można użyć tego typu jako argumentu "*operator*"|
|[Błąd kompilatora C3699](compiler-error-c3699.md)|"*operator*": nie można użyć tego operatora pośredniego dla typu "*Type*"|
|Błąd kompilatora C3700|Nieaktualne.|
|[Błąd kompilatora C3701](compiler-error-c3701.md)|"*Function*": Źródło zdarzenia nie ma zdarzeń|
|[Błąd kompilatora C3702](compiler-error-c3702.md)|Dla zdarzeń COM wymagany jest ATL|
|[Błąd kompilatora C3703](compiler-error-c3703.md)|"*event_handler*": metoda obsługi zdarzeń musi mieć tę samą klasę magazynu co Źródło "*Event*"|
|[Błąd kompilatora C3704](compiler-error-c3704.md)|"*member*": Metoda vararg nie może wyzwalać zdarzeń|
|[Błąd kompilatora C3705](compiler-error-c3705.md)|"*Function*": nie można odnaleźć interfejsu zdarzeń|
|[Błąd kompilatora C3706](compiler-error-c3706.md)|"*Function*": musi być INTERFEJSem com, aby uruchamiać zdarzenia com|
|[Błąd kompilatora C3707](compiler-error-c3707.md)|"*member*": Metoda dispinterface musi mieć identyfikator DISPID|
|[Błąd kompilatora C3708](compiler-error-c3708.md)|"*Function*": niewłaściwe użycie *słowa kluczowego "Keyword*"; musi być składową zgodnego źródła zdarzeń|
|[Błąd kompilatora C3709](compiler-error-c3709.md)|"*Function*": Niewłaściwa składnia określająca zdarzenie w __hook/__unhook|
|[Błąd kompilatora C3710](compiler-error-c3710.md)|"*Function*": Niewłaściwa składnia określająca obsługę zdarzeń w __hook/__unhook|
|[Błąd kompilatora C3711](compiler-error-c3711.md)|"*Event*": Metoda niezarządzanego źródła zdarzeń musi zwracać typ void lub całkowity|
|[Błąd kompilatora C3712](compiler-error-c3712.md)|"*event_handler*": metoda obsługi zdarzeń musi zwracać ten sam typ co Źródło "*Event*"|
|[Błąd kompilatora C3713](compiler-error-c3713.md)|"*event_handler*": metoda obsługi zdarzeń musi mieć te same parametry funkcji co Źródło "*Event*"|
|[Błąd kompilatora C3714](compiler-error-c3714.md)|"*event_handler*": metoda obsługi zdarzeń musi mieć taką samą konwencję wywołania jak Źródło "*Event*"|
|[Błąd kompilatora C3715](compiler-error-c3715.md)|"*wskaźnik*": musi być wskaźnikiem do "*Type*"|
|Błąd kompilatora C3716|Nieaktualne.|
|[Błąd kompilatora C3717](compiler-error-c3717.md)|"*member*": metoda, która wyzwala zdarzenia nie może być zdefiniowana|
|[Błąd kompilatora C3718](compiler-error-c3718.md)|można wywołać tylko "__ *słowo kluczowe*" w kontekście funkcji składowej klasy odbiorczej|
|[Błąd kompilatora C3719](compiler-error-c3719.md)|"*member*": Źródło zdarzeń bazujące na interfejsie może być używane tylko dla zdarzeń com|
|Błąd kompilatora C3720|"*Type*": można zaimplementować tylko element IDispatch na podwójnym lub dispinterface|
|[Błąd kompilatora C3721](compiler-error-c3721.md)|"*Signature*": niezgodny podpis dla zdarzenia|
|[Błąd kompilatora C3722](compiler-error-c3722.md)|zdarzenie generyczne nie jest dozwolone|
|[Błąd kompilatora C3723](compiler-error-c3723.md)|"*Function*": nie można rozpoznać zdarzenia|
|[Błąd kompilatora C3724](compiler-error-c3724.md)|musi #include \<windows.h> używać wielowątkowości ze zdarzeniami|
|Błąd kompilatora C3725|Nieaktualne.|
|Błąd kompilatora C3726|Nieaktualne.|
|[Błąd kompilatora C3727](compiler-error-c3727.md)|"*Event*": zdarzenie zarządzane musi być funkcją członkowską lub składową danych będącą wskaźnikiem do delegata|
|[Błąd kompilatora C3728](compiler-error-c3728.md)|"*zdarzenie*": zdarzenie nie ma metody podniesienia|
|Błąd kompilatora C3729|Nieaktualne.|
|Błąd kompilatora C3730|Nieaktualne.|
|[Błąd kompilatora C3731](compiler-error-c3731.md)|niezgodne zdarzenie "*Event*" i obsługa "*event_handler*"; Źródło zdarzeń i program obsługi zdarzeń muszą mieć ten sam typ zdarzenia|
|[Błąd kompilatora C3732](compiler-error-c3732.md)|"*Interface*": niestandardowy interfejs wyzwalający zdarzenia com nie może dziedziczyć z IDispatch|
|[Błąd kompilatora C3733](compiler-error-c3733.md)|"*Event*": Niewłaściwa składnia określająca zdarzenie com; Czy pamiętasz "__interface"?|
|[Błąd kompilatora C3734](compiler-error-c3734.md)|"*Class*": Klasa Managed/WinRT nie może być klasą coclass|
|Błąd kompilatora C3735|Nieaktualne.|
|[Błąd kompilatora C3736](compiler-error-c3736.md)|"*member*": musi być metodą lub, w przypadku zarządzanych zdarzeń, opcjonalnie składową danych|
|[Błąd kompilatora C3737](compiler-error-c3737.md)|"*Identyfikator*": delegat może nie mieć jawnej konwencji wywoływania|
|[Błąd kompilatora C3738](compiler-error-c3738.md)|"*Konwencja*": Konwencja wywołania jawnego tworzenia wystąpienia musi być zgodna z szablonem, którego wystąpienie jest tworzone|
|[Błąd kompilatora C3739](compiler-error-c3739.md)|"*Class*": składnia jest obsługiwana tylko wtedy, gdy \_ parametr "zależny od układu" event_receiver ma wartość true|
|[Błąd kompilatora C3740](compiler-error-c3740.md)|"*Template*": szablony nie mogą być źródłem ani odbierać zdarzeń|
|[Błąd kompilatora C3741](compiler-error-c3741.md)|"*Class*": musi być klasą coclass, gdy parametr " \_ zależny od układu" event_receiver ma wartość true|
|Błąd kompilatora C3742|"*token1*": niezrównoważona sekwencja tokenów w argumencie atrybutu *atrybutu "Attribute*", oczekiwano "*token2*"|
|[Błąd kompilatora C3743](compiler-error-c3743.md)|można tylko podpiąć/odpiąć cały interfejs, gdy parametr "layout_dependent" event_receiver ma wartość true|
|[Błąd kompilatora C3744](compiler-error-c3744.md)|__unhook musi mieć co najmniej 3 argumenty dla zdarzeń zarządzanych|
|[Błąd kompilatora C3745](compiler-error-c3745.md)|"*Function*": tylko zdarzenie może być "wywoływane"|
|Błąd kompilatora C3746|atrybut standardowy "*Identifier*" może występować co najwyżej raz na liście atrybutów|
|[Błąd kompilatora C3747](compiler-error-c3747.md)|Brak domyślnego szablonu/parametru generycznego: *numer* parametru|
|[Błąd kompilatora C3748](compiler-error-c3748.md)|"*Interface*": interfejsy niezarządzane nie mogą wyzwalać zdarzeń|
|[Błąd kompilatora C3749](compiler-error-c3749.md)|"*Attribute*": atrybut niestandardowy nie może być użyty wewnątrz funkcji|
|Błąd kompilatora C3750|"*token*": Nieoczekiwany token na liście atrybutów|
|Błąd kompilatora C3751|"*Identyfikator*": nieoczekiwany identyfikator na liście atrybutów|
|[Błąd kompilatora C3752](compiler-error-c3752.md)|"*Attribute*": nie można sklasyfikować atrybutu; *słowo kluczowe "Keyword*" nie powinno być używane w tym kontekście|
|[Błąd kompilatora C3753](compiler-error-c3753.md)|Właściwość generyczna jest niedozwolona|
|[Błąd kompilatora C3754](compiler-error-c3754.md)|Konstruktor delegata: funkcja członkowska "*member*" nie może być wywołana w wystąpieniu typu "*Type*"|
|[Błąd kompilatora C3755](compiler-error-c3755.md)|"*Identyfikator*": delegat nie może być zdefiniowany|
|Błąd kompilatora C3756|Nieaktualne.|
|Błąd kompilatora C3757|"*Type*": typ nie jest dozwolony dla funkcji "constexpr"|
|Błąd kompilatora C3758|"*member*": funkcja wirtualna nie może być zadeklarowana jako "constexpr"|
|Błąd kompilatora C3759|"*member*": funkcja członkowska typu innego niż Literal nie może być zadeklarowana jako "constexpr"|
|Błąd kompilatora C3760|Użyj słowa kluczowego __property, aby zadeklarować właściwość w *klasie* Managed/WinRT|
|[Błąd kompilatora C3761](compiler-error-c3761.md)|"*Function*": "retval" może występować tylko na ostatnim argumencie funkcji|
|[Błąd kompilatora C3762](compiler-error-c3762.md)|nie można przetworzyć atrybutu "*Attribute*"|
|[Błąd kompilatora C3763](compiler-error-c3763.md)|"*Type*": "retval" i "out" może występować tylko w typie wskaźnika danych|
|[Błąd kompilatora C3764](compiler-error-c3764.md)|"*member*": nie można przesłonić metody "*member*" klasy bazowej|
|[Błąd kompilatora C3765](compiler-error-c3765.md)|"*Event*": nie można zdefiniować zdarzenia w *typie* klasy/struktury "oznaczonej jako event_receiver|
|[Błąd kompilatora C3766](compiler-error-c3766.md)|element "*Type*" musi dostarczyć implementację metody interfejsu "*Function*"|
|[Błąd kompilatora C3767](compiler-error-c3767.md)|"*Function*": funkcje kandydujące nie są dostępne|
|[Błąd kompilatora C3768](compiler-error-c3768.md)|nie można przyjąć adresu wirtualnej funkcji vararg w czystym kodzie zarządzanym|
|[Błąd kompilatora C3769](compiler-error-c3769.md)|"*Identyfikator*": zagnieżdżona Klasa nie może mieć takiej samej nazwy, jak bezpośrednio otaczająca Klasa|
|Błąd kompilatora C3770|"*Type*": nie jest prawidłową klasą bazową|
|[Błąd kompilatora C3771](compiler-error-c3771.md)|"*Identyfikator*": Deklaracja zaprzyjaźniona nie może zostać znaleziona w najbliższym zakresie przestrzeni nazw|
|[Błąd kompilatora C3772](compiler-error-c3772.md)|"*Identyfikator*": nieprawidłowa deklaracja szablonu zaprzyjaźnionego|
|Błąd kompilatora C3773|Użyj przełącznika kompilatora/await w celu włączenia procedur wspólnych|
|Błąd kompilatora C3774|nie można znaleźć "*SCOPE*::*Identifier*": Dołącz nagłówek *nagłówka*|
|Błąd kompilatora C3775|zwracany typ funkcji "*Function*" nie może być *typem "Type*"|
|Błąd kompilatora C3776|nie można zwrócić wyrażenie typu "void" w procedurze wspólnej z zwracanym typem innym niż void|
|Błąd kompilatora C3777|"*Function*": procedura wspólna nie może pobrać listy argumentów zmiennych|
|Błąd kompilatora C3778|alloca: nie można używać w procedurze wspólnej|
|Błąd kompilatora C3779|"*Function*": funkcja zwracająca wartość "*Type*" nie może zostać użyta przed zdefiniowaniem|
|Błąd kompilatora C3780|"*Function*": funkcja konwersji zwracająca wartość "*Type*" nie może zostać użyta przed zdefiniowaniem|
|Błąd kompilatora C3781|*słowo kluczowe*": nie może być użyte w procedurze wspólnej typu"*Type*". W skojarzonym promise_type musi znajdować się *słowo kluczowe* lub *słowo kluczowe*|
|Błąd kompilatora C3782|*Typ*: obietnica procedury wspólnej nie może zawierać *słowa kluczowego* i słowa *kluczowego*|
|Błąd kompilatora C3783|"*Identyfikator*": nie może być procedurą wspólną|
|Błąd kompilatora C3784|wyrażenie *słowa kluczowego* nie może pojawić się w tym kontekście|
|Błąd kompilatora C3785|pierwszy argument szablonu dla elementu "std:: integer_sequence" musi być typu Integer|
|Błąd kompilatora C3786|drugi argument szablonu dla elementu "std:: make_integer_sequence" musi być stałą liczbą całkowitą większą lub równą zero|
|Błąd kompilatora C3787|nie można wywnioskować zwracanego typu tej współprocedury|
|Błąd kompilatora C3788|Nieaktualne.|
|Błąd kompilatora C3789|Nieaktualne.|
|Błąd kompilatora C3790|Nieaktualne.|
|Błąd kompilatora C3791|Nieaktualne.|
|Błąd kompilatora C3792|Nieaktualne.|
|Błąd kompilatora C3793|Nieaktualne.|
|Błąd kompilatora C3794|Nieaktualne.|
|Błąd kompilatora C3795|Nieaktualne.|
|Błąd kompilatora C3796|Nieaktualne.|
|[Błąd kompilatora C3797](compiler-error-c3797.md)|"*słowo kluczowe*": Deklaracja zdarzenia nie może posiadać specyfikatora przesłonięcia (powinna być umieszczona dla zdarzenia Dodaj/Usuń/Zgłoś zamiast niego)|
|[Błąd kompilatora C3798](compiler-error-c3798.md)|"*słowo kluczowe*": Deklaracja właściwości nie może posiadać specyfikatora przesłonięcia (powinna być umieszczona we właściwościach metod get/set)|
|[Błąd kompilatora C3799](compiler-error-c3799.md)|indeksowana właściwość nie może mieć pustej listy parametrów|
|[Błąd kompilatora C3800](compiler-error-c3800.md)|"*Deklaracja*": nie można mieszać właściwości i zdarzeń|
|Błąd kompilatora C3801|"*Attribute*": atrybut nie może mieć klauzuli argumentu|
|Błąd kompilatora C3802|Nieaktualne.|
|[Błąd kompilatora C3803](compiler-error-c3803.md)|Właściwość "*Property*": właściwość ma typ, który jest niezgodny z jednym z *metod* dostępu "|
|[Błąd kompilatora C3804](compiler-error-c3804.md)|"*member*": metody dostępu dla właściwości muszą być wszystkie statyczne lub wszystkie niestatyczne|
|[Błąd kompilatora C3805](compiler-error-c3805.md)|"*token*": Nieoczekiwany token, oczekiwano znaku "}" lub ","|
|Błąd kompilatora C3806|"*token*": Nieoczekiwany token, oczekiwano "{" lub inicjatora składowej|
|[Błąd kompilatora C3807](compiler-error-c3807.md)|"*Type*": Klasa o atrybucie atrybutem ComImport nie może pochodzić od "*Type*", tylko implementacja interfejsu jest dozwolona|
|[Błąd kompilatora C3808](compiler-error-c3808.md)|"*Type*": Klasa o atrybucie atrybutem ComImport nie może definiować składowej "*member*", dozwolone są tylko funkcje abstrakcyjne lub dllimport|
|[Błąd kompilatora C3809](compiler-error-c3809.md)|"*Type*": typ zarządzany/WinRT nie może mieć żadnych zaprzyjaźnionych funkcji/klas/interfejsów|
|Błąd kompilatora C3810|Nieaktualne.|
|Błąd kompilatora C3811|Nieaktualne.|
|[Błąd kompilatora C3812](compiler-error-c3812.md)|element "__property" musi być pierwszym tokenem w deklaracji właściwości|
|[Błąd kompilatora C3813](compiler-error-c3813.md)|Deklaracja właściwości może wystąpić tylko w definicji typu zarządzanego/WinRT|
|Błąd kompilatora C3814|Nieaktualne.|
|[Błąd kompilatora C3815](compiler-error-c3815.md)|zwracany typ metody "*member*" musi być zgodny z typem ostatniego parametru metody ustawiającej|
|[Błąd kompilatora C3816](compiler-error-c3816.md)|*element członkowski*"Class/struct" został poprzednio zadeklarowany lub zdefiniowany za pomocą innego modyfikatora Managed/WinRT|
|[Błąd kompilatora C3817](compiler-error-c3817.md)|"*Deklaracja*": Właściwość może być stosowana tylko do funkcji|
|[Błąd kompilatora C3818](compiler-error-c3818.md)|Deklaracja właściwości tablicy "*Property*" nie powinna przeciążać właściwości indeksu "*Property*"|
|Błąd kompilatora C3819|Nieaktualne.|
|[Błąd kompilatora C3820](compiler-error-c3820.md)|"*Identyfikator*": inicjatory muszą być zarządzane|
|[Błąd kompilatora C3821](compiler-error-c3821.md)|"*Function*": typ zarządzany lub funkcja nie może być użyta w funkcji niezarządzanej|
|Błąd kompilatora C3822|Nieaktualne.|
|Błąd kompilatora C3823|Nieaktualne.|
|[Błąd kompilatora C3824](compiler-error-c3824.md)|"*Type*": ten typ nie może pojawić się w tym kontekście (parametr funkcji, zwracany typ lub statyczny element członkowski)|
|[Błąd kompilatora C3825](compiler-error-c3825.md)|"*Type*": Klasa Managed/WinRT może obsługiwać tylko zdarzenia zarządzane/WinRT|
|Błąd kompilatora C3826|Nieaktualne.|
|Błąd kompilatora C3827|atrybut standardowy "przestarzały" może nie mieć argumentów ani jednego literału ciągu opisującego przyczynę|
|[Błąd kompilatora C3828](compiler-error-c3828.md)|nie można określić argumentów położenia dla wyrażenia "*Keyword*" dla typu "*Type*"|
|Błąd kompilatora C3829|atrybut standardowy "noreturn" może być stosowany tylko do funkcji|
|[Błąd kompilatora C3830](compiler-error-c3830.md)|"*Type1*": nie można dziedziczyć po elemencie "*Type2*", typy wartości mogą dziedziczyć tylko z klas interfejsu|
|[Błąd kompilatora C3831](compiler-error-c3831.md)|"*Identyfikator*": element "*Type*" nie może mieć przypiętej składowej danych lub funkcji składowej zwracającej przypinany wskaźnik|
|[Błąd kompilatora C3832](compiler-error-c3832.md)|"*TypeLib*": Biblioteka typów wygląda tak, jakby była skompilowana dla wskaźników 32-bitowych; Zmień kwalifikator "ptrsize"|
|[Błąd kompilatora C3833](compiler-error-c3833.md)|"*Type*": nieprawidłowy typ docelowy dla *identyfikatora*|
|[Błąd kompilatora C3834](compiler-error-c3834.md)|niedozwolone jawne rzutowanie do przypiętego wskaźnika; Zamiast tego użyj przypiętej zmiennej lokalnej|
|Błąd kompilatora C3835|Nieaktualne.|
|[Błąd kompilatora C3836](compiler-error-c3836.md)|Konstruktor statyczny nie może mieć listy inicjatorów składowych|
|Błąd kompilatora C3837|atrybuty są niedozwolone w tym kontekście|
|[Błąd kompilatora C3838](compiler-error-c3838.md)|nie można dziedziczyć po elemencie "*Type*"|
|[Błąd kompilatora C3839](compiler-error-c3839.md)|nie można zmienić wyrównania w typie zarządzanym/WinRT|
|Błąd kompilatora C3840|Nieaktualne.|
|Błąd kompilatora C3841|Nieaktualne.|
|[Błąd kompilatora C3842](compiler-error-c3842.md)|"*Identyfikator*": kwalifikatory "const" i "volatile" dla funkcji składowych typów zarządzanych/WinRT nie są obsługiwane|
|Błąd kompilatora C3843|"*Identyfikator*": kwalifikatory ref w funkcjach składowych typów zarządzanych/WinRT nie są obsługiwane|
|Błąd kompilatora C3844|"*Identyfikator*": nie można zaimportować symbolu ze *źródła*: ponieważ element "*Identifier*" istnieje już w bieżącym zakresie|
|Błąd kompilatora C3845|Nieaktualne.|
|[Błąd kompilatora C3846](compiler-error-c3846.md)|"*Identyfikator*": nie można zaimportować symbolu ze *źródła*: ponieważ element "*Identifier*" został już zaimportowany z innego zestawu "*Assembly*"|
|Błąd kompilatora C3847|Nieaktualne.|
|[Błąd kompilatora C3848](compiler-error-c3848.md)|wyrażenie typu "*Type*" spowoduje utratę niektórych kwalifikatorów const-volatile w celu wywołania "*Identifier*"|
|[Błąd kompilatora C3849](compiler-error-c3849.md)|Wywołanie w stylu funkcji na wyrażeniu typu "*Type*" spowoduje utratę kwalifikatorów const i/lub volatile dla wszystkich dostępnych przeciążeń operatora *liczbowego*|
|[Błąd kompilatora C3850](compiler-error-c3850.md)|"*token*": nazwa typu uniwersalnego określa nieprawidłowy znak|
|[Błąd kompilatora C3851](compiler-error-c3851.md)|"*token*": Universal-Character-Name nie może wyznaczyć znaku w podstawowym zestawie znaków|
|[Błąd kompilatora C3852](compiler-error-c3852.md)|*Typ*"*member*" typu ": inicjalizacja agregująca nie może zainicjować tego elementu członkowskiego|
|[Błąd kompilatora C3853](compiler-error-c3853.md)|"=": Ponowna inicjalizacja odwołania lub przypisania za pomocą odwołania do funkcji jest niedozwolona|
|[Błąd kompilatora C3854](compiler-error-c3854.md)|wyrażenie po lewej stronie "=" daje w wyniku funkcję. Nie można przypisać do funkcji (funkcja nie jest l-wartością)|
|[Błąd kompilatora C3855](compiler-error-c3855.md)|"*Function*": szablon/parametr ogólny "*Identifier*" jest niezgodny z deklaracją|
|[Błąd kompilatora C3856](compiler-error-c3856.md)|"*Class*": Klasa nie jest szablonem/rodzajem klasy|
|[Błąd kompilatora C3857](compiler-error-c3857.md)|"*Template*": wiele list parametrów szablonu/generycznych jest niedozwolonych|
|[Błąd kompilatora C3858](compiler-error-c3858.md)|"*Identyfikator*": nie można ponownie zadeklarować w bieżącym zakresie|
|[Błąd kompilatora C3859](compiler-error-c3859.md)|Przekroczono zakres pamięci wirtualnej dla PCH; Skompiluj ponownie z opcją wiersza polecenia "-zm *Number*" lub nowszym|
|[Błąd kompilatora C3860](compiler-error-c3860.md)|szablon/lista argumentów ogólnych następujący szablon klasy/nazwa ogólna musi być listą parametrów w kolejności używanej na liście parametrów szablonu/generycznego|
|[Błąd kompilatora C3861](compiler-error-c3861.md)|"*Identyfikator*": nie znaleziono identyfikatora|
|[Błąd kompilatora C3862](compiler-error-c3862.md)|"*Function*": nie można skompilować niezarządzanej funkcji z/CLR: Pure lub/CLR: Safe|
|Błąd kompilatora C3863|nie można przypisać typu tablicy "*Type*"|
|Błąd kompilatora C3864|Nieaktualne.|
|[Błąd kompilatora C3865](compiler-error-c3865.md)|*słowo kluczowe*": może być używane tylko w natywnych funkcjach składowych|
|[Błąd kompilatora C3866](compiler-error-c3866.md)|wywołanie destruktora/finalizatora nie ma listy argumentów|
|[Błąd kompilatora C3867](compiler-error-c3867.md)|"*Function*": niestandardowa składnia; Użyj "&", aby utworzyć wskaźnik do składowej|
|[Błąd kompilatora C3868](compiler-error-c3868.md)|"*Type*": ograniczenia dotyczące parametru generycznego "*Parameter*" różnią się od tych w deklaracji|
|[Błąd kompilatora C3869](compiler-error-c3869.md)|w ograniczeniu gcnew brakuje pustej listy parametrów "()"|
|Błąd kompilatora C3870|"*Parameter*": "__declspec (*specyfikator*)" można stosować tylko do parametrów typu całkowitego|
|Błąd kompilatora C3871|"*Parameter*": "__declspec (Guard (overflow))" jest obsługiwane tylko dla pierwszych 64 parametrów funkcji|
|[Błąd kompilatora C3872](compiler-error-c3872.md)|"0x *Value*": ten znak nie jest dozwolony w identyfikatorze|
|[Błąd kompilatora C3873](compiler-error-c3873.md)|"0x *Value*": ten znak nie jest dozwolony jako pierwszy znak identyfikatora|
|[Błąd kompilatora C3874](compiler-error-c3874.md)|zwracanym typem elementu "*Identifier*" powinien być "*Type1*", a nie "*Type2*"|
|Błąd kompilatora C3875|Brak listy argumentów w wywołaniu niestatycznej funkcji członkowskiej|
|Błąd kompilatora C3876|Nieaktualne.|
|Błąd kompilatora C3877|Nieaktualne.|
|Błąd kompilatora C3878|Nieaktualne.|
|Błąd kompilatora C3879|"*member*": nie może być składową danych initonly|
|[Błąd kompilatora C3880](compiler-error-c3880.md)|"*member*": nie może być literałem składowej danych|
|Błąd kompilatora C3881|może dziedziczyć Konstruktor tylko z bezpośredniej bazy|
|Błąd kompilatora C3882|"*Class*": Konstruktor został już odziedziczony z "*Class*"|
|Błąd kompilatora C3883|"*member*": statyczna składowa danych initonly musi być zainicjowana|
|Błąd kompilatora C3884|"*Type*": tablica o nieznanym rozmiarze nie może być inicjowana przez wartość|
|Błąd kompilatora C3885|"*Type*": tablica o nieznanym rozmiarze nie może zostać zainicjowana przy użyciu pustej listy inicjatora|
|[Błąd kompilatora C3886](compiler-error-c3886.md)|"*member*": literał składowej danych musi być zainicjowany|
|[Błąd kompilatora C3887](compiler-error-c3887.md)|"*member*": inicjator literału składowej danych musi być wyrażeniem stałym|
|[Błąd kompilatora C3888](compiler-error-c3888.md)|"*member*": wyrażenie const skojarzone z tym literałem składowej danych nie jest obsługiwane przez C++/CLI|
|Błąd kompilatora C3889|Nieaktualne.|
|[Błąd kompilatora C3890](compiler-error-c3890.md)|"*member*": nie można przyjąć adresu literału składowej danych|
|[Błąd kompilatora C3891](compiler-error-c3891.md)|"*member*": literał składowej danych nie może być używany jako wartość l|
|[Błąd kompilatora C3892](compiler-error-c3892.md)|"*zmienna*": nie można przypisać do zmiennej, która jest stałą|
|[Błąd kompilatora C3893](compiler-error-c3893.md)|"*member*": wykorzystanie wartości l składowej danych initonly jest dozwolone tylko w konstruktorze wystąpienia klasy "*Class*"|
|[Błąd kompilatora C3894](compiler-error-c3894.md)|"*member*": wykorzystanie wartości l statycznej składowej danych initonly jest dozwolone tylko w konstruktorze klasy klasy "*Class*"|
|[Błąd kompilatora C3895](compiler-error-c3895.md)|"*member*": składowe danych *typu* nie mogą być "volatile"|
|[Błąd kompilatora C3896](compiler-error-c3896.md)|"*member*": niewłaściwy inicjator: ten literał składowej danych może być zainicjowany tylko przy użyciu elementu "nullptr"|
|Błąd kompilatora C3897|Nieaktualne.|
|[Błąd kompilatora C3898](compiler-error-c3898.md)|"*member*": *typy* składowe danych mogą być tylko składowymi typów zarządzanych|
|[Błąd kompilatora C3899](compiler-error-c3899.md)|"*member*": wykorzystanie wartości l składowej danych initonly nie jest dozwolone bezpośrednio w ramach równoległego regionu w klasie "*Class*"|
|[Błąd kompilatora C3900](compiler-error-c3900.md)|"*member*": niedozwolone w bieżącym zakresie|
|[Błąd kompilatora C3901](compiler-error-c3901.md)|"*Function*": musi mieć typ zwracany "*Type*"|
|[Błąd kompilatora C3902](compiler-error-c3902.md)|"*Function*": typ ostatniego parametru musi być typu "*Type*"|
|[Błąd kompilatora C3903](compiler-error-c3903.md)|"*Property*": nie ma metody Set lub Get|
|[Błąd kompilatora C3904](compiler-error-c3904.md)|"*Property*": należy określić *liczbę* parametrów|
|Błąd kompilatora C3905|niewyrównane dostępy nie są obsługiwane dla typu wewnętrznego "*Type*"|
|Błąd kompilatora C3906|Typ wewnętrzny "*Type*" nie jest obsługiwanym zwracanym typem argumentu dla funkcji vararg lub bez prototypów|
|Błąd kompilatora C3907|Nieaktualne.|
|[Błąd kompilatora C3908](compiler-error-c3908.md)|poziom dostępu mniej restrykcyjny niż "*Identyfikator*"|
|[Błąd kompilatora C3909](compiler-error-c3909.md)|Deklaracja zdarzenia zarządzanego/WinRT musi wystąpić w typie zarządzanym/WinRT|
|[Błąd kompilatora C3910](compiler-error-c3910.md)|"*zdarzenie*": należy zdefiniować składową "*member*"|
|[Błąd kompilatora C3911](compiler-error-c3911.md)|"*member*": funkcja musi być typu "*Type*"|
|[Błąd kompilatora C3912](compiler-error-c3912.md)|"*Event*": typ zdarzenia musi być typem delegata|
|[Błąd kompilatora C3913](compiler-error-c3913.md)|domyślna właściwość musi być indeksowana|
|[Błąd kompilatora C3914](compiler-error-c3914.md)|domyślna właściwość nie może być statyczna|
|[Błąd kompilatora C3915](compiler-error-c3915.md)|element "*Identifier*" nie ma domyślnej właściwości indeksowanej (indeksator klasy)|
|Błąd kompilatora C3916|Nieaktualne.|
|[Błąd kompilatora C3917](compiler-error-c3917.md)|"*token*": przestarzały styl deklaracji *konstrukcji* (Czy chodziło o użycie "[" "]" zamiast niego?)|
|[Błąd kompilatora C3918](compiler-error-c3918.md)|Użycie wymaga "*Identifier*" jako elementu członkowskiego danych|
|[Błąd kompilatora C3919](compiler-error-c3919.md)|"*Function*": funkcja musi być typu "*return_type* (*Typ*)"|
|[Błąd kompilatora C3920](compiler-error-c3920.md)|"*operator*": nie można zdefiniować przyrostkowego przyrostu/zmniejszania operatora CLR/WinRT wywołanie przyrostkowego operatora CLR/WinRT spowoduje wywołanie odpowiadającego operatora CLR/winrt (op_Increment/op_Decrement), ale z semantyką przyrostkową|
|Błąd kompilatora C3921|Nieaktualne.|
|Błąd kompilatora C3922|Nieaktualne.|
|[Błąd kompilatora C3923](compiler-error-c3923.md)|"*member*": lokalne definicje klasy, struktury lub Unii są niedozwolone w funkcji składowej klasy zarządzanej/WinRT|
|Błąd kompilatora C3924|błąd w argumencie #*numer* wywołania konstruktora delegata "*Konstruktor*":|
|Błąd kompilatora C3925|Oczekiwano pętli (for, while lub do) następującej po dyrektywie "*dyrektywy*"|
|Błąd kompilatora C3926|Nieprawidłowa stała w dyrektywie "Parallel"|
|Błąd kompilatora C3927|"->": końcowy typ zwracany nie jest dozwolony po deklarator poza funkcją|
|Błąd kompilatora C3928|"->": końcowy typ zwracany jest niedozwolony po deklarator w nawiasie|
|Błąd kompilatora C3929|Nieaktualne.|
|Błąd kompilatora C3930|"*Function*": żadna przeciążona funkcja ma specyfikatory ograniczenia, które są zgodne z otaczającym kontekstem "*Context*"|
|Błąd kompilatora C3931|"*Type*": nie można wywołać funkcji, która ma specyfikatory ograniczenia, które są niezgodne z otaczającym kontekstem|
|Błąd kompilatora C3932|Nieaktualne.|
|Błąd kompilatora C3933|"*Class*": specyfikatory ograniczenia destruktora muszą obejmować związek ograniczeń na wszystkich konstruktorach|
|Błąd kompilatora C3934|Funkcja, która jest w dowolnej postaci elementu "Main", nie może mieć specyfikatorów ograniczenia innych niż ograniczanie (CPU)|
|Błąd kompilatora C3935|"*Identyfikator*": zmiana definicji; nakładające się specyfikatory ograniczeń|
|Błąd kompilatora C3936|"*Identyfikator*": nierozpoznany specyfikator ograniczenia|
|Błąd kompilatora C3937|pusty specyfikator ograniczenia nie jest dozwolony|
|Błąd kompilatora C3938|"*Identyfikator*": wiele specyfikatorów ograniczenia nie są obsługiwane w zewnętrznych funkcjach \042C\042|
|Błąd kompilatora C3939|"*Identyfikator*": wskaźnik do funkcji składowych, wskaźniki funkcji, odwołania do funkcji ze specyfikatorem ograniczenia "amp" są niedozwolone|
|Błąd kompilatora C3940|"*Identyfikator*": nie znaleziono identyfikatora — możliwa niezgodność między wersjami kompilatora i biblioteki. Upewnij się, że vccorlib. h/. lib, vccorlib120.dll i c1xx.dll|
|Błąd kompilatora C3941|*warunek "Condition*": wymaga opcji wiersza polecenia "/CLR"|
|Błąd kompilatora C3942|Nieaktualne.|
|Błąd kompilatora C3943|Nieaktualne.|
|Błąd kompilatora C3944|Nieaktualne.|
|Błąd kompilatora C3945|"*Type*": nie można zgłosić lub przechwycić obiektu WinRT, który nie pochodzi od platformy:: Exception|
|Błąd kompilatora C3946|"*Type*": nie można zastosować identyfikatora typeid do tego typu|
|Błąd kompilatora C3947|"*typeid*": nie można zastosować identyfikatora typeid do rozwinięcia pakietu|
|Błąd kompilatora C3948|"*słowo kluczowe*": rozwinięcie pakietu nie może pojawić się w tym kontekście|
|Błąd kompilatora C3949|rozwinięcie pakietu "..." nie może pojawić się w nawiasach abstrakcyjnych deklarator|
|Błąd kompilatora C3950|Nieaktualne.|
|Błąd kompilatora C3951|Nie można użyć wskaźnika do składowej w rzutowanym typie WinRT "*Type*". Zamiast tego użyj delegata.|
|Błąd kompilatora C3952|"*Type*": WinRT nie obsługuje tablic "in/out". Użyj "const Array \<T> ^" dla "in" i "WriteOnlyArray \<T> " lub "Array \<T> ^ *" dla "out" w publicznych interfejsach API|
|Błąd kompilatora C3953|Nie można użyć zarządzanej klasy "*Type*" w module WinRT.|
|Błąd kompilatora C3954|"*Type*": tablica zwrócona z opublikowanej metody typu WinRT musi używać formy "Array \<T> ^"|
|Błąd kompilatora C3955|"*Type*": Konstruktor publiczny nie może zawierać parametru "out" ani "WriteOnlyArray \<T> "|
|Błąd kompilatora C3956|"*Type*": typ jest oznaczony jako wyłączny dla elementu "*Type*" i nie może być używany jako podstawa "*derived_type*"|
|Błąd kompilatora C3957|"*Type*": nie można użyć "New" dla typu WinRT; Użyj zamiast tego "ref New"|
|Błąd kompilatora C3958|"*Type*": nie można użyć "gcnew" dla typu WinRT; Użyj zamiast tego "ref New"|
|Błąd kompilatora C3959|"ref New" może być użyty tylko do utworzenia obiektu z typem WinRT|
|Błąd kompilatora C3960|Nieaktualne.|
|Błąd kompilatora C3961|statyczny Konstruktor nie jest obsługiwany|
|Błąd kompilatora C3962|Klasa generyczna nie jest obsługiwana|
|Błąd kompilatora C3963|Tablica wielowymiarowa nie jest obsługiwana|
|Błąd kompilatora C3964|Tablica nieregularna nie jest obsługiwana|
|Błąd kompilatora C3965|Tablica parametrów nie jest obsługiwana|
|Błąd kompilatora C3966|"*Function*": funkcja generyczna nie jest obsługiwana|
|Błąd kompilatora C3967|Wystąpił błąd podczas importowania elementu "*Identifier*" z *modułu "module"*|
|Błąd kompilatora C3968|token "*token*" jest nieprawidłowy jako separator nazwy modułu; Zamiast tego użyj kropki (".")|
|Błąd kompilatora C3969|niespójne nazwy modułów: "*Module1*" i "*Module1*"|
|Błąd kompilatora C3970|"*Identifier*":*słowo kluczowe*"Only" może być stosowane tylko do "ref class" lub "ref struct" w zakresie globalnym lub zakresie przestrzeni nazw|
|Błąd kompilatora C3971|"*Type*": częściowa definicja nie może pojawić się po pełnej definicji|
|Błąd kompilatora C3972|"*Type*": "częściowe" może być stosowane tylko do deklaracji lub definicji klasy|
|Błąd kompilatora C3973|Nieaktualne.|
|Błąd kompilatora C3974|Nieaktualne.|
|Błąd kompilatora C3975|*Identyfikator* klasy/struktury został poprzednio zadeklarowany lub zdefiniowany za pomocą innego modyfikatora|
|Błąd kompilatora C3976|element "*Identifier1*" musi być zadeklarowany jako "Public", aby można było użyć "*identifier2*"|
|Błąd kompilatora C3977|Użycie wymaga odwołania do zestawu, który definiuje element "*Identifier*"|
|Błąd kompilatora C3978|"*Identyfikator*": właściwość statyczna jest niedozwolona jako składowa interfejsu WinRT lub typu wartościowego|
|Błąd kompilatora C3979|"*Type*": Użyj atrybutu "*Attribute*" zamiast "*Value*"|
|Błąd kompilatora C3980|nie można wyemitować *typu "Type*" do metadanych|
|Błąd kompilatora C3981|"*Type*": typ wartości nie może mieć żadnych statycznych składowych danych "*Identifier*"|
|Błąd kompilatora C3982|"*Type*": typ wartości nie może mieć żadnych niepublicznych składowych danych "*Identifier*"|
|Błąd kompilatora C3983|"*Type*": typ wartości nie może mieć żadnych publicznych elementów członkowskich, które nienależą do danych|
|Błąd kompilatora C3984|"*Type*": typ inny niż wartość nie może mieć żadnych publicznych składowych danych "*Identifier*"|
|Błąd kompilatora C3985|"*Identyfikator*": Sygnatura publicznej składowej zawiera typ prywatny "*member*"|
|Błąd kompilatora C3986|"*Identyfikator*": Sygnatura publicznej składowej zawiera typ natywny "*member*"|
|Błąd kompilatora C3987|"*Identyfikator*": Sygnatura publicznej składowej zawiera typ natywny "*Type*"|
|Błąd kompilatora C3988|"*Type*": typ natywny nie może być publiczny|
|Błąd kompilatora C3989|"*Type*": zagnieżdżony typ nie może być publiczny|
|Błąd kompilatora C3990|"*Type*": atrybut "*Attribute*" nie może być prywatny ani zagnieżdżony|
|Błąd kompilatora C3991|"*Type*": nie można zaimplementować interfejsu "*Interface*", który nie jest publiczny lub zagnieżdżony|
|Błąd kompilatora C3992|"*Identyfikator*": Sygnatura publicznej składowej zawiera nieprawidłowy typ "*Type*"|
|Błąd kompilatora C3993|"*Type*": typ wartości musi zawierać co najmniej jedno pole publiczne|
|Błąd kompilatora C3994|"*Type*": typ wartości nie może implementować interfejsów lub mieć funkcji wirtualnych|
|Błąd kompilatora C3995|"*Type*": typ wartości nie może mieć żadnych składowych zdarzenia "*Identifier*"|
|Błąd kompilatora C3996|Nieaktualne.|
|Błąd kompilatora C3998|"*wersja* c++": nieobsługiwana wersja języka c++; Domyślna *wersja* języka c++|
|Błąd kompilatora C3999|NIEZNANY błąd. Wybierz polecenie Pomoc techniczna w menu Pomoc Visual C++ lub Otwórz plik pomocy technicznej, aby uzyskać więcej informacji|

## <a name="see-also"></a>Zobacz też

[Błędy i ostrzeżenia dotyczące kompilatora i narzędzi kompilacji C/C++](../compiler-errors-1/c-cpp-build-errors.md) \
[Błędy kompilatora C2000–C3999](../compiler-errors-1/compiler-errors-c2000-c3999.md)
